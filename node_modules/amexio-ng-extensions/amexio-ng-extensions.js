import { APP_BASE_HREF, CommonModule, DOCUMENT, HashLocationStrategy, LOCATION_INITIALIZED, Location, LocationStrategy, PathLocationStrategy, PlatformLocation, ViewportScroller, isPlatformBrowser, ɵparseCookieValue } from '@angular/common';
import { ANALYZE_FOR_ENTRY_COMPONENTS, APP_BOOTSTRAP_LISTENER, APP_INITIALIZER, ApplicationRef, Attribute, ChangeDetectionStrategy, ChangeDetectorRef, Compiler, Component, ComponentFactoryResolver, ContentChild, ContentChildren, Directive, ElementRef, EventEmitter, Host, HostBinding, HostListener, Inject, Injectable, InjectionToken, Injector, Input, IterableDiffers, NgModule, NgModuleFactory, NgModuleFactoryLoader, NgModuleRef, NgProbeToken, NgZone, Optional, Output, PLATFORM_ID, Pipe, QueryList, Renderer2, SkipSelf, SystemJsNgModuleLoader, TemplateRef, Version, ViewChild, ViewChildren, ViewContainerRef, ViewEncapsulation, defineInjectable, forwardRef, isDevMode, ɵConsole, ɵisObservable, ɵisPromise } from '@angular/core';
import { DomSanitizer, Meta, ɵgetDOM } from '@angular/platform-browser';
import { FormBuilder, FormsModule, NG_VALIDATORS, NG_VALUE_ACCESSOR, NgControl, NgForm, NgModel, ReactiveFormsModule } from '@angular/forms';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};



function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}







function __values(o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function isFunction(x) {
    return typeof x === 'function';
}

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var _enable_super_gross_mode_that_will_cause_bad_things = false;
var config = {
    Promise: undefined,
    set useDeprecatedSynchronousErrorHandling(value) {
        if (value) {
            var error = /*@__PURE__*/ new Error();
            /*@__PURE__*/ console.warn('DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n' + error.stack);
        }
        else if (_enable_super_gross_mode_that_will_cause_bad_things) {
            /*@__PURE__*/ console.log('RxJS: Back to a better error behavior. Thank you. <3');
        }
        _enable_super_gross_mode_that_will_cause_bad_things = value;
    },
    get useDeprecatedSynchronousErrorHandling() {
        return _enable_super_gross_mode_that_will_cause_bad_things;
    },
};

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function hostReportError(err) {
    setTimeout(function () { throw err; }, 0);
}

/** PURE_IMPORTS_START _config,_util_hostReportError PURE_IMPORTS_END */
var empty = {
    closed: true,
    next: function (value) { },
    error: function (err) {
        if (config.useDeprecatedSynchronousErrorHandling) {
            throw err;
        }
        else {
            hostReportError(err);
        }
    },
    complete: function () { }
};

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var isArray = /*@__PURE__*/ (function () { return Array.isArray || (function (x) { return x && typeof x.length === 'number'; }); })();

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function isObject(x) {
    return x !== null && typeof x === 'object';
}

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var UnsubscriptionErrorImpl = /*@__PURE__*/ (function () {
    function UnsubscriptionErrorImpl(errors) {
        Error.call(this);
        this.message = errors ?
            errors.length + " errors occurred during unsubscription:\n" + errors.map(function (err, i) { return i + 1 + ") " + err.toString(); }).join('\n  ') : '';
        this.name = 'UnsubscriptionError';
        this.errors = errors;
        return this;
    }
    UnsubscriptionErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);
    return UnsubscriptionErrorImpl;
})();
var UnsubscriptionError = UnsubscriptionErrorImpl;

/** PURE_IMPORTS_START _util_isArray,_util_isObject,_util_isFunction,_util_UnsubscriptionError PURE_IMPORTS_END */
var Subscription = /*@__PURE__*/ (function () {
    function Subscription(unsubscribe) {
        this.closed = false;
        this._parentOrParents = null;
        this._subscriptions = null;
        if (unsubscribe) {
            this._unsubscribe = unsubscribe;
        }
    }
    Subscription.prototype.unsubscribe = function () {
        var errors;
        if (this.closed) {
            return;
        }
        var _a = this, _parentOrParents = _a._parentOrParents, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
        this.closed = true;
        this._parentOrParents = null;
        this._subscriptions = null;
        if (_parentOrParents instanceof Subscription) {
            _parentOrParents.remove(this);
        }
        else if (_parentOrParents !== null) {
            for (var index = 0; index < _parentOrParents.length; ++index) {
                var parent_1 = _parentOrParents[index];
                parent_1.remove(this);
            }
        }
        if (isFunction(_unsubscribe)) {
            try {
                _unsubscribe.call(this);
            }
            catch (e) {
                errors = e instanceof UnsubscriptionError ? flattenUnsubscriptionErrors(e.errors) : [e];
            }
        }
        if (isArray(_subscriptions)) {
            var index = -1;
            var len = _subscriptions.length;
            while (++index < len) {
                var sub = _subscriptions[index];
                if (isObject(sub)) {
                    try {
                        sub.unsubscribe();
                    }
                    catch (e) {
                        errors = errors || [];
                        if (e instanceof UnsubscriptionError) {
                            errors = errors.concat(flattenUnsubscriptionErrors(e.errors));
                        }
                        else {
                            errors.push(e);
                        }
                    }
                }
            }
        }
        if (errors) {
            throw new UnsubscriptionError(errors);
        }
    };
    Subscription.prototype.add = function (teardown) {
        var subscription = teardown;
        if (!teardown) {
            return Subscription.EMPTY;
        }
        switch (typeof teardown) {
            case 'function':
                subscription = new Subscription(teardown);
            case 'object':
                if (subscription === this || subscription.closed || typeof subscription.unsubscribe !== 'function') {
                    return subscription;
                }
                else if (this.closed) {
                    subscription.unsubscribe();
                    return subscription;
                }
                else if (!(subscription instanceof Subscription)) {
                    var tmp = subscription;
                    subscription = new Subscription();
                    subscription._subscriptions = [tmp];
                }
                break;
            default: {
                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
            }
        }
        var _parentOrParents = subscription._parentOrParents;
        if (_parentOrParents === null) {
            subscription._parentOrParents = this;
        }
        else if (_parentOrParents instanceof Subscription) {
            if (_parentOrParents === this) {
                return subscription;
            }
            subscription._parentOrParents = [_parentOrParents, this];
        }
        else if (_parentOrParents.indexOf(this) === -1) {
            _parentOrParents.push(this);
        }
        else {
            return subscription;
        }
        var subscriptions = this._subscriptions;
        if (subscriptions === null) {
            this._subscriptions = [subscription];
        }
        else {
            subscriptions.push(subscription);
        }
        return subscription;
    };
    Subscription.prototype.remove = function (subscription) {
        var subscriptions = this._subscriptions;
        if (subscriptions) {
            var subscriptionIndex = subscriptions.indexOf(subscription);
            if (subscriptionIndex !== -1) {
                subscriptions.splice(subscriptionIndex, 1);
            }
        }
    };
    Subscription.EMPTY = (function (empty) {
        empty.closed = true;
        return empty;
    }(new Subscription()));
    return Subscription;
}());
function flattenUnsubscriptionErrors(errors) {
    return errors.reduce(function (errs, err) { return errs.concat((err instanceof UnsubscriptionError) ? err.errors : err); }, []);
}

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var rxSubscriber = /*@__PURE__*/ (function () {
    return typeof Symbol === 'function'
        ? /*@__PURE__*/ Symbol('rxSubscriber')
        : '@@rxSubscriber_' + /*@__PURE__*/ Math.random();
})();

/** PURE_IMPORTS_START tslib,_util_isFunction,_Observer,_Subscription,_internal_symbol_rxSubscriber,_config,_util_hostReportError PURE_IMPORTS_END */
var Subscriber = /*@__PURE__*/ (function (_super) {
    __extends(Subscriber, _super);
    function Subscriber(destinationOrNext, error, complete) {
        var _this = _super.call(this) || this;
        _this.syncErrorValue = null;
        _this.syncErrorThrown = false;
        _this.syncErrorThrowable = false;
        _this.isStopped = false;
        switch (arguments.length) {
            case 0:
                _this.destination = empty;
                break;
            case 1:
                if (!destinationOrNext) {
                    _this.destination = empty;
                    break;
                }
                if (typeof destinationOrNext === 'object') {
                    if (destinationOrNext instanceof Subscriber) {
                        _this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;
                        _this.destination = destinationOrNext;
                        destinationOrNext.add(_this);
                    }
                    else {
                        _this.syncErrorThrowable = true;
                        _this.destination = new SafeSubscriber(_this, destinationOrNext);
                    }
                    break;
                }
            default:
                _this.syncErrorThrowable = true;
                _this.destination = new SafeSubscriber(_this, destinationOrNext, error, complete);
                break;
        }
        return _this;
    }
    Subscriber.prototype[rxSubscriber] = function () { return this; };
    Subscriber.create = function (next, error, complete) {
        var subscriber = new Subscriber(next, error, complete);
        subscriber.syncErrorThrowable = false;
        return subscriber;
    };
    Subscriber.prototype.next = function (value) {
        if (!this.isStopped) {
            this._next(value);
        }
    };
    Subscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            this.isStopped = true;
            this._error(err);
        }
    };
    Subscriber.prototype.complete = function () {
        if (!this.isStopped) {
            this.isStopped = true;
            this._complete();
        }
    };
    Subscriber.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
    };
    Subscriber.prototype._next = function (value) {
        this.destination.next(value);
    };
    Subscriber.prototype._error = function (err) {
        this.destination.error(err);
        this.unsubscribe();
    };
    Subscriber.prototype._complete = function () {
        this.destination.complete();
        this.unsubscribe();
    };
    Subscriber.prototype._unsubscribeAndRecycle = function () {
        var _parentOrParents = this._parentOrParents;
        this._parentOrParents = null;
        this.unsubscribe();
        this.closed = false;
        this.isStopped = false;
        this._parentOrParents = _parentOrParents;
        return this;
    };
    return Subscriber;
}(Subscription));
var SafeSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(SafeSubscriber, _super);
    function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
        var _this = _super.call(this) || this;
        _this._parentSubscriber = _parentSubscriber;
        var next;
        var context = _this;
        if (isFunction(observerOrNext)) {
            next = observerOrNext;
        }
        else if (observerOrNext) {
            next = observerOrNext.next;
            error = observerOrNext.error;
            complete = observerOrNext.complete;
            if (observerOrNext !== empty) {
                context = Object.create(observerOrNext);
                if (isFunction(context.unsubscribe)) {
                    _this.add(context.unsubscribe.bind(context));
                }
                context.unsubscribe = _this.unsubscribe.bind(_this);
            }
        }
        _this._context = context;
        _this._next = next;
        _this._error = error;
        _this._complete = complete;
        return _this;
    }
    SafeSubscriber.prototype.next = function (value) {
        if (!this.isStopped && this._next) {
            var _parentSubscriber = this._parentSubscriber;
            if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                this.__tryOrUnsub(this._next, value);
            }
            else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            var useDeprecatedSynchronousErrorHandling = config.useDeprecatedSynchronousErrorHandling;
            if (this._error) {
                if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(this._error, err);
                    this.unsubscribe();
                }
                else {
                    this.__tryOrSetError(_parentSubscriber, this._error, err);
                    this.unsubscribe();
                }
            }
            else if (!_parentSubscriber.syncErrorThrowable) {
                this.unsubscribe();
                if (useDeprecatedSynchronousErrorHandling) {
                    throw err;
                }
                hostReportError(err);
            }
            else {
                if (useDeprecatedSynchronousErrorHandling) {
                    _parentSubscriber.syncErrorValue = err;
                    _parentSubscriber.syncErrorThrown = true;
                }
                else {
                    hostReportError(err);
                }
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.complete = function () {
        var _this = this;
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            if (this._complete) {
                var wrappedComplete = function () { return _this._complete.call(_this._context); };
                if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(wrappedComplete);
                    this.unsubscribe();
                }
                else {
                    this.__tryOrSetError(_parentSubscriber, wrappedComplete);
                    this.unsubscribe();
                }
            }
            else {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
        try {
            fn.call(this._context, value);
        }
        catch (err) {
            this.unsubscribe();
            if (config.useDeprecatedSynchronousErrorHandling) {
                throw err;
            }
            else {
                hostReportError(err);
            }
        }
    };
    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
        if (!config.useDeprecatedSynchronousErrorHandling) {
            throw new Error('bad call');
        }
        try {
            fn.call(this._context, value);
        }
        catch (err) {
            if (config.useDeprecatedSynchronousErrorHandling) {
                parent.syncErrorValue = err;
                parent.syncErrorThrown = true;
                return true;
            }
            else {
                hostReportError(err);
                return true;
            }
        }
        return false;
    };
    SafeSubscriber.prototype._unsubscribe = function () {
        var _parentSubscriber = this._parentSubscriber;
        this._context = null;
        this._parentSubscriber = null;
        _parentSubscriber.unsubscribe();
    };
    return SafeSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START _Subscriber PURE_IMPORTS_END */
function canReportError(observer) {
    while (observer) {
        var _a = observer, closed_1 = _a.closed, destination = _a.destination, isStopped = _a.isStopped;
        if (closed_1 || isStopped) {
            return false;
        }
        else if (destination && destination instanceof Subscriber) {
            observer = destination;
        }
        else {
            observer = null;
        }
    }
    return true;
}

/** PURE_IMPORTS_START _Subscriber,_symbol_rxSubscriber,_Observer PURE_IMPORTS_END */
function toSubscriber(nextOrObserver, error, complete) {
    if (nextOrObserver) {
        if (nextOrObserver instanceof Subscriber) {
            return nextOrObserver;
        }
        if (nextOrObserver[rxSubscriber]) {
            return nextOrObserver[rxSubscriber]();
        }
    }
    if (!nextOrObserver && !error && !complete) {
        return new Subscriber(empty);
    }
    return new Subscriber(nextOrObserver, error, complete);
}

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var observable = /*@__PURE__*/ (function () { return typeof Symbol === 'function' && Symbol.observable || '@@observable'; })();

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function noop() { }

/** PURE_IMPORTS_START _noop PURE_IMPORTS_END */
function pipe() {
    var fns = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        fns[_i] = arguments[_i];
    }
    return pipeFromArray(fns);
}
function pipeFromArray(fns) {
    if (!fns) {
        return noop;
    }
    if (fns.length === 1) {
        return fns[0];
    }
    return function piped(input) {
        return fns.reduce(function (prev, fn) { return fn(prev); }, input);
    };
}

/** PURE_IMPORTS_START _util_canReportError,_util_toSubscriber,_symbol_observable,_util_pipe,_config PURE_IMPORTS_END */
var Observable = /*@__PURE__*/ (function () {
    function Observable(subscribe) {
        this._isScalar = false;
        if (subscribe) {
            this._subscribe = subscribe;
        }
    }
    Observable.prototype.lift = function (operator) {
        var observable$$1 = new Observable();
        observable$$1.source = this;
        observable$$1.operator = operator;
        return observable$$1;
    };
    Observable.prototype.subscribe = function (observerOrNext, error, complete) {
        var operator = this.operator;
        var sink = toSubscriber(observerOrNext, error, complete);
        if (operator) {
            sink.add(operator.call(sink, this.source));
        }
        else {
            sink.add(this.source || (config.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable) ?
                this._subscribe(sink) :
                this._trySubscribe(sink));
        }
        if (config.useDeprecatedSynchronousErrorHandling) {
            if (sink.syncErrorThrowable) {
                sink.syncErrorThrowable = false;
                if (sink.syncErrorThrown) {
                    throw sink.syncErrorValue;
                }
            }
        }
        return sink;
    };
    Observable.prototype._trySubscribe = function (sink) {
        try {
            return this._subscribe(sink);
        }
        catch (err) {
            if (config.useDeprecatedSynchronousErrorHandling) {
                sink.syncErrorThrown = true;
                sink.syncErrorValue = err;
            }
            if (canReportError(sink)) {
                sink.error(err);
            }
            else {
                console.warn(err);
            }
        }
    };
    Observable.prototype.forEach = function (next, promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function (resolve, reject) {
            var subscription;
            subscription = _this.subscribe(function (value) {
                try {
                    next(value);
                }
                catch (err) {
                    reject(err);
                    if (subscription) {
                        subscription.unsubscribe();
                    }
                }
            }, reject, resolve);
        });
    };
    Observable.prototype._subscribe = function (subscriber) {
        var source = this.source;
        return source && source.subscribe(subscriber);
    };
    Observable.prototype[observable] = function () {
        return this;
    };
    Observable.prototype.pipe = function () {
        var operations = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            operations[_i] = arguments[_i];
        }
        if (operations.length === 0) {
            return this;
        }
        return pipeFromArray(operations)(this);
    };
    Observable.prototype.toPromise = function (promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function (resolve, reject) {
            var value;
            _this.subscribe(function (x) { return value = x; }, function (err) { return reject(err); }, function () { return resolve(value); });
        });
    };
    Observable.create = function (subscribe) {
        return new Observable(subscribe);
    };
    return Observable;
}());
function getPromiseCtor(promiseCtor) {
    if (!promiseCtor) {
        promiseCtor = config.Promise || Promise;
    }
    if (!promiseCtor) {
        throw new Error('no Promise impl found');
    }
    return promiseCtor;
}

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var ObjectUnsubscribedErrorImpl = /*@__PURE__*/ (function () {
    function ObjectUnsubscribedErrorImpl() {
        Error.call(this);
        this.message = 'object unsubscribed';
        this.name = 'ObjectUnsubscribedError';
        return this;
    }
    ObjectUnsubscribedErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);
    return ObjectUnsubscribedErrorImpl;
})();
var ObjectUnsubscribedError = ObjectUnsubscribedErrorImpl;

/** PURE_IMPORTS_START tslib,_Subscription PURE_IMPORTS_END */
var SubjectSubscription = /*@__PURE__*/ (function (_super) {
    __extends(SubjectSubscription, _super);
    function SubjectSubscription(subject, subscriber) {
        var _this = _super.call(this) || this;
        _this.subject = subject;
        _this.subscriber = subscriber;
        _this.closed = false;
        return _this;
    }
    SubjectSubscription.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.closed = true;
        var subject = this.subject;
        var observers = subject.observers;
        this.subject = null;
        if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
            return;
        }
        var subscriberIndex = observers.indexOf(this.subscriber);
        if (subscriberIndex !== -1) {
            observers.splice(subscriberIndex, 1);
        }
    };
    return SubjectSubscription;
}(Subscription));

/** PURE_IMPORTS_START tslib,_Observable,_Subscriber,_Subscription,_util_ObjectUnsubscribedError,_SubjectSubscription,_internal_symbol_rxSubscriber PURE_IMPORTS_END */
var SubjectSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(SubjectSubscriber, _super);
    function SubjectSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        return _this;
    }
    return SubjectSubscriber;
}(Subscriber));
var Subject = /*@__PURE__*/ (function (_super) {
    __extends(Subject, _super);
    function Subject() {
        var _this = _super.call(this) || this;
        _this.observers = [];
        _this.closed = false;
        _this.isStopped = false;
        _this.hasError = false;
        _this.thrownError = null;
        return _this;
    }
    Subject.prototype[rxSubscriber] = function () {
        return new SubjectSubscriber(this);
    };
    Subject.prototype.lift = function (operator) {
        var subject = new AnonymousSubject(this, this);
        subject.operator = operator;
        return subject;
    };
    Subject.prototype.next = function (value) {
        if (this.closed) {
            throw new ObjectUnsubscribedError();
        }
        if (!this.isStopped) {
            var observers = this.observers;
            var len = observers.length;
            var copy = observers.slice();
            for (var i = 0; i < len; i++) {
                copy[i].next(value);
            }
        }
    };
    Subject.prototype.error = function (err) {
        if (this.closed) {
            throw new ObjectUnsubscribedError();
        }
        this.hasError = true;
        this.thrownError = err;
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].error(err);
        }
        this.observers.length = 0;
    };
    Subject.prototype.complete = function () {
        if (this.closed) {
            throw new ObjectUnsubscribedError();
        }
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].complete();
        }
        this.observers.length = 0;
    };
    Subject.prototype.unsubscribe = function () {
        this.isStopped = true;
        this.closed = true;
        this.observers = null;
    };
    Subject.prototype._trySubscribe = function (subscriber) {
        if (this.closed) {
            throw new ObjectUnsubscribedError();
        }
        else {
            return _super.prototype._trySubscribe.call(this, subscriber);
        }
    };
    Subject.prototype._subscribe = function (subscriber) {
        if (this.closed) {
            throw new ObjectUnsubscribedError();
        }
        else if (this.hasError) {
            subscriber.error(this.thrownError);
            return Subscription.EMPTY;
        }
        else if (this.isStopped) {
            subscriber.complete();
            return Subscription.EMPTY;
        }
        else {
            this.observers.push(subscriber);
            return new SubjectSubscription(this, subscriber);
        }
    };
    Subject.prototype.asObservable = function () {
        var observable = new Observable();
        observable.source = this;
        return observable;
    };
    Subject.create = function (destination, source) {
        return new AnonymousSubject(destination, source);
    };
    return Subject;
}(Observable));
var AnonymousSubject = /*@__PURE__*/ (function (_super) {
    __extends(AnonymousSubject, _super);
    function AnonymousSubject(destination, source) {
        var _this = _super.call(this) || this;
        _this.destination = destination;
        _this.source = source;
        return _this;
    }
    AnonymousSubject.prototype.next = function (value) {
        var destination = this.destination;
        if (destination && destination.next) {
            destination.next(value);
        }
    };
    AnonymousSubject.prototype.error = function (err) {
        var destination = this.destination;
        if (destination && destination.error) {
            this.destination.error(err);
        }
    };
    AnonymousSubject.prototype.complete = function () {
        var destination = this.destination;
        if (destination && destination.complete) {
            this.destination.complete();
        }
    };
    AnonymousSubject.prototype._subscribe = function (subscriber) {
        var source = this.source;
        if (source) {
            return this.source.subscribe(subscriber);
        }
        else {
            return Subscription.EMPTY;
        }
    };
    return AnonymousSubject;
}(Subject));

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
function refCount() {
    return function refCountOperatorFunction(source) {
        return source.lift(new RefCountOperator$1(source));
    };
}
var RefCountOperator$1 = /*@__PURE__*/ (function () {
    function RefCountOperator(connectable) {
        this.connectable = connectable;
    }
    RefCountOperator.prototype.call = function (subscriber, source) {
        var connectable = this.connectable;
        connectable._refCount++;
        var refCounter = new RefCountSubscriber$1(subscriber, connectable);
        var subscription = source.subscribe(refCounter);
        if (!refCounter.closed) {
            refCounter.connection = connectable.connect();
        }
        return subscription;
    };
    return RefCountOperator;
}());
var RefCountSubscriber$1 = /*@__PURE__*/ (function (_super) {
    __extends(RefCountSubscriber, _super);
    function RefCountSubscriber(destination, connectable) {
        var _this = _super.call(this, destination) || this;
        _this.connectable = connectable;
        return _this;
    }
    RefCountSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (!connectable) {
            this.connection = null;
            return;
        }
        this.connectable = null;
        var refCount = connectable._refCount;
        if (refCount <= 0) {
            this.connection = null;
            return;
        }
        connectable._refCount = refCount - 1;
        if (refCount > 1) {
            this.connection = null;
            return;
        }
        var connection = this.connection;
        var sharedConnection = connectable._connection;
        this.connection = null;
        if (sharedConnection && (!connection || sharedConnection === connection)) {
            sharedConnection.unsubscribe();
        }
    };
    return RefCountSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_Subject,_Observable,_Subscriber,_Subscription,_operators_refCount PURE_IMPORTS_END */
var ConnectableObservable = /*@__PURE__*/ (function (_super) {
    __extends(ConnectableObservable, _super);
    function ConnectableObservable(source, subjectFactory) {
        var _this = _super.call(this) || this;
        _this.source = source;
        _this.subjectFactory = subjectFactory;
        _this._refCount = 0;
        _this._isComplete = false;
        return _this;
    }
    ConnectableObservable.prototype._subscribe = function (subscriber) {
        return this.getSubject().subscribe(subscriber);
    };
    ConnectableObservable.prototype.getSubject = function () {
        var subject = this._subject;
        if (!subject || subject.isStopped) {
            this._subject = this.subjectFactory();
        }
        return this._subject;
    };
    ConnectableObservable.prototype.connect = function () {
        var connection = this._connection;
        if (!connection) {
            this._isComplete = false;
            connection = this._connection = new Subscription();
            connection.add(this.source
                .subscribe(new ConnectableSubscriber(this.getSubject(), this)));
            if (connection.closed) {
                this._connection = null;
                connection = Subscription.EMPTY;
            }
        }
        return connection;
    };
    ConnectableObservable.prototype.refCount = function () {
        return refCount()(this);
    };
    return ConnectableObservable;
}(Observable));

var ConnectableSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(ConnectableSubscriber, _super);
    function ConnectableSubscriber(destination, connectable) {
        var _this = _super.call(this, destination) || this;
        _this.connectable = connectable;
        return _this;
    }
    ConnectableSubscriber.prototype._error = function (err) {
        this._unsubscribe();
        _super.prototype._error.call(this, err);
    };
    ConnectableSubscriber.prototype._complete = function () {
        this.connectable._isComplete = true;
        this._unsubscribe();
        _super.prototype._complete.call(this);
    };
    ConnectableSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (connectable) {
            this.connectable = null;
            var connection = connectable._connection;
            connectable._refCount = 0;
            connectable._subject = null;
            connectable._connection = null;
            if (connection) {
                connection.unsubscribe();
            }
        }
    };
    return ConnectableSubscriber;
}(SubjectSubscriber));
var RefCountOperator = /*@__PURE__*/ (function () {
    function RefCountOperator(connectable) {
        this.connectable = connectable;
    }
    RefCountOperator.prototype.call = function (subscriber, source) {
        var connectable = this.connectable;
        connectable._refCount++;
        var refCounter = new RefCountSubscriber(subscriber, connectable);
        var subscription = source.subscribe(refCounter);
        if (!refCounter.closed) {
            refCounter.connection = connectable.connect();
        }
        return subscription;
    };
    return RefCountOperator;
}());
var RefCountSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(RefCountSubscriber, _super);
    function RefCountSubscriber(destination, connectable) {
        var _this = _super.call(this, destination) || this;
        _this.connectable = connectable;
        return _this;
    }
    RefCountSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (!connectable) {
            this.connection = null;
            return;
        }
        this.connectable = null;
        var refCount$$1 = connectable._refCount;
        if (refCount$$1 <= 0) {
            this.connection = null;
            return;
        }
        connectable._refCount = refCount$$1 - 1;
        if (refCount$$1 > 1) {
            this.connection = null;
            return;
        }
        var connection = this.connection;
        var sharedConnection = connectable._connection;
        this.connection = null;
        if (sharedConnection && (!connection || sharedConnection === connection)) {
            sharedConnection.unsubscribe();
        }
    };
    return RefCountSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_Subscriber,_Subscription,_Observable,_Subject PURE_IMPORTS_END */

var GroupByOperator = /*@__PURE__*/ (function () {
    function GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector) {
        this.keySelector = keySelector;
        this.elementSelector = elementSelector;
        this.durationSelector = durationSelector;
        this.subjectSelector = subjectSelector;
    }
    GroupByOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new GroupBySubscriber(subscriber, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector));
    };
    return GroupByOperator;
}());
var GroupBySubscriber = /*@__PURE__*/ (function (_super) {
    __extends(GroupBySubscriber, _super);
    function GroupBySubscriber(destination, keySelector, elementSelector, durationSelector, subjectSelector) {
        var _this = _super.call(this, destination) || this;
        _this.keySelector = keySelector;
        _this.elementSelector = elementSelector;
        _this.durationSelector = durationSelector;
        _this.subjectSelector = subjectSelector;
        _this.groups = null;
        _this.attemptedToUnsubscribe = false;
        _this.count = 0;
        return _this;
    }
    GroupBySubscriber.prototype._next = function (value) {
        var key;
        try {
            key = this.keySelector(value);
        }
        catch (err) {
            this.error(err);
            return;
        }
        this._group(value, key);
    };
    GroupBySubscriber.prototype._group = function (value, key) {
        var groups = this.groups;
        if (!groups) {
            groups = this.groups = new Map();
        }
        var group = groups.get(key);
        var element;
        if (this.elementSelector) {
            try {
                element = this.elementSelector(value);
            }
            catch (err) {
                this.error(err);
            }
        }
        else {
            element = value;
        }
        if (!group) {
            group = (this.subjectSelector ? this.subjectSelector() : new Subject());
            groups.set(key, group);
            var groupedObservable = new GroupedObservable(key, group, this);
            this.destination.next(groupedObservable);
            if (this.durationSelector) {
                var duration = void 0;
                try {
                    duration = this.durationSelector(new GroupedObservable(key, group));
                }
                catch (err) {
                    this.error(err);
                    return;
                }
                this.add(duration.subscribe(new GroupDurationSubscriber(key, group, this)));
            }
        }
        if (!group.closed) {
            group.next(element);
        }
    };
    GroupBySubscriber.prototype._error = function (err) {
        var groups = this.groups;
        if (groups) {
            groups.forEach(function (group, key) {
                group.error(err);
            });
            groups.clear();
        }
        this.destination.error(err);
    };
    GroupBySubscriber.prototype._complete = function () {
        var groups = this.groups;
        if (groups) {
            groups.forEach(function (group, key) {
                group.complete();
            });
            groups.clear();
        }
        this.destination.complete();
    };
    GroupBySubscriber.prototype.removeGroup = function (key) {
        this.groups.delete(key);
    };
    GroupBySubscriber.prototype.unsubscribe = function () {
        if (!this.closed) {
            this.attemptedToUnsubscribe = true;
            if (this.count === 0) {
                _super.prototype.unsubscribe.call(this);
            }
        }
    };
    return GroupBySubscriber;
}(Subscriber));
var GroupDurationSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(GroupDurationSubscriber, _super);
    function GroupDurationSubscriber(key, group, parent) {
        var _this = _super.call(this, group) || this;
        _this.key = key;
        _this.group = group;
        _this.parent = parent;
        return _this;
    }
    GroupDurationSubscriber.prototype._next = function (value) {
        this.complete();
    };
    GroupDurationSubscriber.prototype._unsubscribe = function () {
        var _a = this, parent = _a.parent, key = _a.key;
        this.key = this.parent = null;
        if (parent) {
            parent.removeGroup(key);
        }
    };
    return GroupDurationSubscriber;
}(Subscriber));
var GroupedObservable = /*@__PURE__*/ (function (_super) {
    __extends(GroupedObservable, _super);
    function GroupedObservable(key, groupSubject, refCountSubscription) {
        var _this = _super.call(this) || this;
        _this.key = key;
        _this.groupSubject = groupSubject;
        _this.refCountSubscription = refCountSubscription;
        return _this;
    }
    GroupedObservable.prototype._subscribe = function (subscriber) {
        var subscription = new Subscription();
        var _a = this, refCountSubscription = _a.refCountSubscription, groupSubject = _a.groupSubject;
        if (refCountSubscription && !refCountSubscription.closed) {
            subscription.add(new InnerRefCountSubscription(refCountSubscription));
        }
        subscription.add(groupSubject.subscribe(subscriber));
        return subscription;
    };
    return GroupedObservable;
}(Observable));
var InnerRefCountSubscription = /*@__PURE__*/ (function (_super) {
    __extends(InnerRefCountSubscription, _super);
    function InnerRefCountSubscription(parent) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        parent.count++;
        return _this;
    }
    InnerRefCountSubscription.prototype.unsubscribe = function () {
        var parent = this.parent;
        if (!parent.closed && !this.closed) {
            _super.prototype.unsubscribe.call(this);
            parent.count -= 1;
            if (parent.count === 0 && parent.attemptedToUnsubscribe) {
                parent.unsubscribe();
            }
        }
    };
    return InnerRefCountSubscription;
}(Subscription));

/** PURE_IMPORTS_START tslib,_Subject,_util_ObjectUnsubscribedError PURE_IMPORTS_END */
var BehaviorSubject = /*@__PURE__*/ (function (_super) {
    __extends(BehaviorSubject, _super);
    function BehaviorSubject(_value) {
        var _this = _super.call(this) || this;
        _this._value = _value;
        return _this;
    }
    Object.defineProperty(BehaviorSubject.prototype, "value", {
        get: function () {
            return this.getValue();
        },
        enumerable: true,
        configurable: true
    });
    BehaviorSubject.prototype._subscribe = function (subscriber) {
        var subscription = _super.prototype._subscribe.call(this, subscriber);
        if (subscription && !subscription.closed) {
            subscriber.next(this._value);
        }
        return subscription;
    };
    BehaviorSubject.prototype.getValue = function () {
        if (this.hasError) {
            throw this.thrownError;
        }
        else if (this.closed) {
            throw new ObjectUnsubscribedError();
        }
        else {
            return this._value;
        }
    };
    BehaviorSubject.prototype.next = function (value) {
        _super.prototype.next.call(this, this._value = value);
    };
    return BehaviorSubject;
}(Subject));

/** PURE_IMPORTS_START tslib,_Subscription PURE_IMPORTS_END */
var Action = /*@__PURE__*/ (function (_super) {
    __extends(Action, _super);
    function Action(scheduler, work) {
        return _super.call(this) || this;
    }
    Action.prototype.schedule = function (state, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        return this;
    };
    return Action;
}(Subscription));

/** PURE_IMPORTS_START tslib,_Action PURE_IMPORTS_END */
var AsyncAction = /*@__PURE__*/ (function (_super) {
    __extends(AsyncAction, _super);
    function AsyncAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        _this.pending = false;
        return _this;
    }
    AsyncAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if (this.closed) {
            return this;
        }
        this.state = state;
        var id = this.id;
        var scheduler = this.scheduler;
        if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, delay);
        }
        this.pending = true;
        this.delay = delay;
        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
        return this;
    };
    AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        return setInterval(scheduler.flush.bind(scheduler, this), delay);
    };
    AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if (delay !== null && this.delay === delay && this.pending === false) {
            return id;
        }
        clearInterval(id);
        return undefined;
    };
    AsyncAction.prototype.execute = function (state, delay) {
        if (this.closed) {
            return new Error('executing a cancelled action');
        }
        this.pending = false;
        var error = this._execute(state, delay);
        if (error) {
            return error;
        }
        else if (this.pending === false && this.id != null) {
            this.id = this.recycleAsyncId(this.scheduler, this.id, null);
        }
    };
    AsyncAction.prototype._execute = function (state, delay) {
        var errored = false;
        var errorValue = undefined;
        try {
            this.work(state);
        }
        catch (e) {
            errored = true;
            errorValue = !!e && e || new Error(e);
        }
        if (errored) {
            this.unsubscribe();
            return errorValue;
        }
    };
    AsyncAction.prototype._unsubscribe = function () {
        var id = this.id;
        var scheduler = this.scheduler;
        var actions = scheduler.actions;
        var index = actions.indexOf(this);
        this.work = null;
        this.state = null;
        this.pending = false;
        this.scheduler = null;
        if (index !== -1) {
            actions.splice(index, 1);
        }
        if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, null);
        }
        this.delay = null;
    };
    return AsyncAction;
}(Action));

/** PURE_IMPORTS_START tslib,_AsyncAction PURE_IMPORTS_END */
var QueueAction = /*@__PURE__*/ (function (_super) {
    __extends(QueueAction, _super);
    function QueueAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
    }
    QueueAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if (delay > 0) {
            return _super.prototype.schedule.call(this, state, delay);
        }
        this.delay = delay;
        this.state = state;
        this.scheduler.flush(this);
        return this;
    };
    QueueAction.prototype.execute = function (state, delay) {
        return (delay > 0 || this.closed) ?
            _super.prototype.execute.call(this, state, delay) :
            this._execute(state, delay);
    };
    QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        return scheduler.flush(this);
    };
    return QueueAction;
}(AsyncAction));

var Scheduler = /*@__PURE__*/ (function () {
    function Scheduler(SchedulerAction, now) {
        if (now === void 0) {
            now = Scheduler.now;
        }
        this.SchedulerAction = SchedulerAction;
        this.now = now;
    }
    Scheduler.prototype.schedule = function (work, delay, state) {
        if (delay === void 0) {
            delay = 0;
        }
        return new this.SchedulerAction(this, work).schedule(state, delay);
    };
    Scheduler.now = function () { return Date.now(); };
    return Scheduler;
}());

/** PURE_IMPORTS_START tslib,_Scheduler PURE_IMPORTS_END */
var AsyncScheduler = /*@__PURE__*/ (function (_super) {
    __extends(AsyncScheduler, _super);
    function AsyncScheduler(SchedulerAction, now) {
        if (now === void 0) {
            now = Scheduler.now;
        }
        var _this = _super.call(this, SchedulerAction, function () {
            if (AsyncScheduler.delegate && AsyncScheduler.delegate !== _this) {
                return AsyncScheduler.delegate.now();
            }
            else {
                return now();
            }
        }) || this;
        _this.actions = [];
        _this.active = false;
        _this.scheduled = undefined;
        return _this;
    }
    AsyncScheduler.prototype.schedule = function (work, delay, state) {
        if (delay === void 0) {
            delay = 0;
        }
        if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) {
            return AsyncScheduler.delegate.schedule(work, delay, state);
        }
        else {
            return _super.prototype.schedule.call(this, work, delay, state);
        }
    };
    AsyncScheduler.prototype.flush = function (action) {
        var actions = this.actions;
        if (this.active) {
            actions.push(action);
            return;
        }
        var error;
        this.active = true;
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (action = actions.shift());
        this.active = false;
        if (error) {
            while (action = actions.shift()) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AsyncScheduler;
}(Scheduler));

/** PURE_IMPORTS_START tslib,_AsyncScheduler PURE_IMPORTS_END */
var QueueScheduler = /*@__PURE__*/ (function (_super) {
    __extends(QueueScheduler, _super);
    function QueueScheduler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return QueueScheduler;
}(AsyncScheduler));

/** PURE_IMPORTS_START _QueueAction,_QueueScheduler PURE_IMPORTS_END */
var queue = /*@__PURE__*/ new QueueScheduler(QueueAction);

/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */
var EMPTY = /*@__PURE__*/ new Observable(function (subscriber) { return subscriber.complete(); });
function empty$1(scheduler) {
    return scheduler ? emptyScheduled(scheduler) : EMPTY;
}
function emptyScheduled(scheduler) {
    return new Observable(function (subscriber) { return scheduler.schedule(function () { return subscriber.complete(); }); });
}

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function isScheduler(value) {
    return value && typeof value.schedule === 'function';
}

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var subscribeToArray = function (array) {
    return function (subscriber) {
        for (var i = 0, len = array.length; i < len && !subscriber.closed; i++) {
            subscriber.next(array[i]);
        }
        subscriber.complete();
    };
};

/** PURE_IMPORTS_START _Observable,_Subscription PURE_IMPORTS_END */
function scheduleArray(input, scheduler) {
    return new Observable(function (subscriber) {
        var sub = new Subscription();
        var i = 0;
        sub.add(scheduler.schedule(function () {
            if (i === input.length) {
                subscriber.complete();
                return;
            }
            subscriber.next(input[i++]);
            if (!subscriber.closed) {
                sub.add(this.schedule());
            }
        }));
        return sub;
    });
}

/** PURE_IMPORTS_START _Observable,_util_subscribeToArray,_scheduled_scheduleArray PURE_IMPORTS_END */
function fromArray(input, scheduler) {
    if (!scheduler) {
        return new Observable(subscribeToArray(input));
    }
    else {
        return scheduleArray(input, scheduler);
    }
}

/** PURE_IMPORTS_START _util_isScheduler,_fromArray,_scheduled_scheduleArray PURE_IMPORTS_END */
function of() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var scheduler = args[args.length - 1];
    if (isScheduler(scheduler)) {
        args.pop();
        return scheduleArray(args, scheduler);
    }
    else {
        return fromArray(args);
    }
}

/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */
function throwError(error, scheduler) {
    if (!scheduler) {
        return new Observable(function (subscriber) { return subscriber.error(error); });
    }
    else {
        return new Observable(function (subscriber) { return scheduler.schedule(dispatch, 0, { error: error, subscriber: subscriber }); });
    }
}
function dispatch(_a) {
    var error = _a.error, subscriber = _a.subscriber;
    subscriber.error(error);
}

/** PURE_IMPORTS_START _observable_empty,_observable_of,_observable_throwError PURE_IMPORTS_END */
var NotificationKind;
/*@__PURE__*/ (function (NotificationKind) {
    NotificationKind["NEXT"] = "N";
    NotificationKind["ERROR"] = "E";
    NotificationKind["COMPLETE"] = "C";
})(NotificationKind || (NotificationKind = {}));
var Notification = /*@__PURE__*/ (function () {
    function Notification(kind, value, error) {
        this.kind = kind;
        this.value = value;
        this.error = error;
        this.hasValue = kind === 'N';
    }
    Notification.prototype.observe = function (observer) {
        switch (this.kind) {
            case 'N':
                return observer.next && observer.next(this.value);
            case 'E':
                return observer.error && observer.error(this.error);
            case 'C':
                return observer.complete && observer.complete();
        }
    };
    Notification.prototype.do = function (next, error, complete) {
        var kind = this.kind;
        switch (kind) {
            case 'N':
                return next && next(this.value);
            case 'E':
                return error && error(this.error);
            case 'C':
                return complete && complete();
        }
    };
    Notification.prototype.accept = function (nextOrObserver, error, complete) {
        if (nextOrObserver && typeof nextOrObserver.next === 'function') {
            return this.observe(nextOrObserver);
        }
        else {
            return this.do(nextOrObserver, error, complete);
        }
    };
    Notification.prototype.toObservable = function () {
        var kind = this.kind;
        switch (kind) {
            case 'N':
                return of(this.value);
            case 'E':
                return throwError(this.error);
            case 'C':
                return empty$1();
        }
        throw new Error('unexpected notification kind value');
    };
    Notification.createNext = function (value) {
        if (typeof value !== 'undefined') {
            return new Notification('N', value);
        }
        return Notification.undefinedValueNotification;
    };
    Notification.createError = function (err) {
        return new Notification('E', undefined, err);
    };
    Notification.createComplete = function () {
        return Notification.completeNotification;
    };
    Notification.completeNotification = new Notification('C');
    Notification.undefinedValueNotification = new Notification('N', undefined);
    return Notification;
}());

/** PURE_IMPORTS_START tslib,_Subscriber,_Notification PURE_IMPORTS_END */

var ObserveOnOperator = /*@__PURE__*/ (function () {
    function ObserveOnOperator(scheduler, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        this.scheduler = scheduler;
        this.delay = delay;
    }
    ObserveOnOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));
    };
    return ObserveOnOperator;
}());
var ObserveOnSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(ObserveOnSubscriber, _super);
    function ObserveOnSubscriber(destination, scheduler, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        var _this = _super.call(this, destination) || this;
        _this.scheduler = scheduler;
        _this.delay = delay;
        return _this;
    }
    ObserveOnSubscriber.dispatch = function (arg) {
        var notification = arg.notification, destination = arg.destination;
        notification.observe(destination);
        this.unsubscribe();
    };
    ObserveOnSubscriber.prototype.scheduleMessage = function (notification) {
        var destination = this.destination;
        destination.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));
    };
    ObserveOnSubscriber.prototype._next = function (value) {
        this.scheduleMessage(Notification.createNext(value));
    };
    ObserveOnSubscriber.prototype._error = function (err) {
        this.scheduleMessage(Notification.createError(err));
        this.unsubscribe();
    };
    ObserveOnSubscriber.prototype._complete = function () {
        this.scheduleMessage(Notification.createComplete());
        this.unsubscribe();
    };
    return ObserveOnSubscriber;
}(Subscriber));
var ObserveOnMessage = /*@__PURE__*/ (function () {
    function ObserveOnMessage(notification, destination) {
        this.notification = notification;
        this.destination = destination;
    }
    return ObserveOnMessage;
}());

/** PURE_IMPORTS_START tslib,_Subject,_scheduler_queue,_Subscription,_operators_observeOn,_util_ObjectUnsubscribedError,_SubjectSubscription PURE_IMPORTS_END */
var ReplaySubject = /*@__PURE__*/ (function (_super) {
    __extends(ReplaySubject, _super);
    function ReplaySubject(bufferSize, windowTime, scheduler) {
        if (bufferSize === void 0) {
            bufferSize = Number.POSITIVE_INFINITY;
        }
        if (windowTime === void 0) {
            windowTime = Number.POSITIVE_INFINITY;
        }
        var _this = _super.call(this) || this;
        _this.scheduler = scheduler;
        _this._events = [];
        _this._infiniteTimeWindow = false;
        _this._bufferSize = bufferSize < 1 ? 1 : bufferSize;
        _this._windowTime = windowTime < 1 ? 1 : windowTime;
        if (windowTime === Number.POSITIVE_INFINITY) {
            _this._infiniteTimeWindow = true;
            _this.next = _this.nextInfiniteTimeWindow;
        }
        else {
            _this.next = _this.nextTimeWindow;
        }
        return _this;
    }
    ReplaySubject.prototype.nextInfiniteTimeWindow = function (value) {
        var _events = this._events;
        _events.push(value);
        if (_events.length > this._bufferSize) {
            _events.shift();
        }
        _super.prototype.next.call(this, value);
    };
    ReplaySubject.prototype.nextTimeWindow = function (value) {
        this._events.push(new ReplayEvent(this._getNow(), value));
        this._trimBufferThenGetEvents();
        _super.prototype.next.call(this, value);
    };
    ReplaySubject.prototype._subscribe = function (subscriber) {
        var _infiniteTimeWindow = this._infiniteTimeWindow;
        var _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();
        var scheduler = this.scheduler;
        var len = _events.length;
        var subscription;
        if (this.closed) {
            throw new ObjectUnsubscribedError();
        }
        else if (this.isStopped || this.hasError) {
            subscription = Subscription.EMPTY;
        }
        else {
            this.observers.push(subscriber);
            subscription = new SubjectSubscription(this, subscriber);
        }
        if (scheduler) {
            subscriber.add(subscriber = new ObserveOnSubscriber(subscriber, scheduler));
        }
        if (_infiniteTimeWindow) {
            for (var i = 0; i < len && !subscriber.closed; i++) {
                subscriber.next(_events[i]);
            }
        }
        else {
            for (var i = 0; i < len && !subscriber.closed; i++) {
                subscriber.next(_events[i].value);
            }
        }
        if (this.hasError) {
            subscriber.error(this.thrownError);
        }
        else if (this.isStopped) {
            subscriber.complete();
        }
        return subscription;
    };
    ReplaySubject.prototype._getNow = function () {
        return (this.scheduler || queue).now();
    };
    ReplaySubject.prototype._trimBufferThenGetEvents = function () {
        var now = this._getNow();
        var _bufferSize = this._bufferSize;
        var _windowTime = this._windowTime;
        var _events = this._events;
        var eventsCount = _events.length;
        var spliceCount = 0;
        while (spliceCount < eventsCount) {
            if ((now - _events[spliceCount].time) < _windowTime) {
                break;
            }
            spliceCount++;
        }
        if (eventsCount > _bufferSize) {
            spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);
        }
        if (spliceCount > 0) {
            _events.splice(0, spliceCount);
        }
        return _events;
    };
    return ReplaySubject;
}(Subject));
var ReplayEvent = /*@__PURE__*/ (function () {
    function ReplayEvent(time, value) {
        this.time = time;
        this.value = value;
    }
    return ReplayEvent;
}());

/** PURE_IMPORTS_START tslib,_Subject,_Subscription PURE_IMPORTS_END */
var AsyncSubject = /*@__PURE__*/ (function (_super) {
    __extends(AsyncSubject, _super);
    function AsyncSubject() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.value = null;
        _this.hasNext = false;
        _this.hasCompleted = false;
        return _this;
    }
    AsyncSubject.prototype._subscribe = function (subscriber) {
        if (this.hasError) {
            subscriber.error(this.thrownError);
            return Subscription.EMPTY;
        }
        else if (this.hasCompleted && this.hasNext) {
            subscriber.next(this.value);
            subscriber.complete();
            return Subscription.EMPTY;
        }
        return _super.prototype._subscribe.call(this, subscriber);
    };
    AsyncSubject.prototype.next = function (value) {
        if (!this.hasCompleted) {
            this.value = value;
            this.hasNext = true;
        }
    };
    AsyncSubject.prototype.error = function (error) {
        if (!this.hasCompleted) {
            _super.prototype.error.call(this, error);
        }
    };
    AsyncSubject.prototype.complete = function () {
        this.hasCompleted = true;
        if (this.hasNext) {
            _super.prototype.next.call(this, this.value);
        }
        _super.prototype.complete.call(this);
    };
    return AsyncSubject;
}(Subject));

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var nextHandle = 1;
var RESOLVED = /*@__PURE__*/ (function () { return /*@__PURE__*/ Promise.resolve(); })();
var activeHandles = {};
function findAndClearHandle(handle) {
    if (handle in activeHandles) {
        delete activeHandles[handle];
        return true;
    }
    return false;
}
var Immediate = {
    setImmediate: function (cb) {
        var handle = nextHandle++;
        activeHandles[handle] = true;
        RESOLVED.then(function () { return findAndClearHandle(handle) && cb(); });
        return handle;
    },
    clearImmediate: function (handle) {
        findAndClearHandle(handle);
    },
};

/** PURE_IMPORTS_START tslib,_util_Immediate,_AsyncAction PURE_IMPORTS_END */
var AsapAction = /*@__PURE__*/ (function (_super) {
    __extends(AsapAction, _super);
    function AsapAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
    }
    AsapAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if (delay !== null && delay > 0) {
            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        scheduler.actions.push(this);
        return scheduler.scheduled || (scheduler.scheduled = Immediate.setImmediate(scheduler.flush.bind(scheduler, null)));
    };
    AsapAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
        }
        if (scheduler.actions.length === 0) {
            Immediate.clearImmediate(id);
            scheduler.scheduled = undefined;
        }
        return undefined;
    };
    return AsapAction;
}(AsyncAction));

/** PURE_IMPORTS_START tslib,_AsyncScheduler PURE_IMPORTS_END */
var AsapScheduler = /*@__PURE__*/ (function (_super) {
    __extends(AsapScheduler, _super);
    function AsapScheduler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AsapScheduler.prototype.flush = function (action) {
        this.active = true;
        this.scheduled = undefined;
        var actions = this.actions;
        var error;
        var index = -1;
        var count = actions.length;
        action = action || actions.shift();
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (++index < count && (action = actions.shift()));
        this.active = false;
        if (error) {
            while (++index < count && (action = actions.shift())) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AsapScheduler;
}(AsyncScheduler));

/** PURE_IMPORTS_START _AsapAction,_AsapScheduler PURE_IMPORTS_END */
var asap = /*@__PURE__*/ new AsapScheduler(AsapAction);

/** PURE_IMPORTS_START _AsyncAction,_AsyncScheduler PURE_IMPORTS_END */
var async = /*@__PURE__*/ new AsyncScheduler(AsyncAction);

/** PURE_IMPORTS_START tslib,_AsyncAction PURE_IMPORTS_END */
var AnimationFrameAction = /*@__PURE__*/ (function (_super) {
    __extends(AnimationFrameAction, _super);
    function AnimationFrameAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
    }
    AnimationFrameAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if (delay !== null && delay > 0) {
            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        scheduler.actions.push(this);
        return scheduler.scheduled || (scheduler.scheduled = requestAnimationFrame(function () { return scheduler.flush(null); }));
    };
    AnimationFrameAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
        }
        if (scheduler.actions.length === 0) {
            cancelAnimationFrame(id);
            scheduler.scheduled = undefined;
        }
        return undefined;
    };
    return AnimationFrameAction;
}(AsyncAction));

/** PURE_IMPORTS_START tslib,_AsyncScheduler PURE_IMPORTS_END */
var AnimationFrameScheduler = /*@__PURE__*/ (function (_super) {
    __extends(AnimationFrameScheduler, _super);
    function AnimationFrameScheduler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AnimationFrameScheduler.prototype.flush = function (action) {
        this.active = true;
        this.scheduled = undefined;
        var actions = this.actions;
        var error;
        var index = -1;
        var count = actions.length;
        action = action || actions.shift();
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (++index < count && (action = actions.shift()));
        this.active = false;
        if (error) {
            while (++index < count && (action = actions.shift())) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AnimationFrameScheduler;
}(AsyncScheduler));

/** PURE_IMPORTS_START _AnimationFrameAction,_AnimationFrameScheduler PURE_IMPORTS_END */
var animationFrame = /*@__PURE__*/ new AnimationFrameScheduler(AnimationFrameAction);

/** PURE_IMPORTS_START tslib,_AsyncAction,_AsyncScheduler PURE_IMPORTS_END */
var VirtualTimeScheduler = /*@__PURE__*/ (function (_super) {
    __extends(VirtualTimeScheduler, _super);
    function VirtualTimeScheduler(SchedulerAction, maxFrames) {
        if (SchedulerAction === void 0) {
            SchedulerAction = VirtualAction;
        }
        if (maxFrames === void 0) {
            maxFrames = Number.POSITIVE_INFINITY;
        }
        var _this = _super.call(this, SchedulerAction, function () { return _this.frame; }) || this;
        _this.maxFrames = maxFrames;
        _this.frame = 0;
        _this.index = -1;
        return _this;
    }
    VirtualTimeScheduler.prototype.flush = function () {
        var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;
        var error, action;
        while ((action = actions[0]) && action.delay <= maxFrames) {
            actions.shift();
            this.frame = action.delay;
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        }
        if (error) {
            while (action = actions.shift()) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    VirtualTimeScheduler.frameTimeFactor = 10;
    return VirtualTimeScheduler;
}(AsyncScheduler));
var VirtualAction = /*@__PURE__*/ (function (_super) {
    __extends(VirtualAction, _super);
    function VirtualAction(scheduler, work, index) {
        if (index === void 0) {
            index = scheduler.index += 1;
        }
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        _this.index = index;
        _this.active = true;
        _this.index = scheduler.index = index;
        return _this;
    }
    VirtualAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if (!this.id) {
            return _super.prototype.schedule.call(this, state, delay);
        }
        this.active = false;
        var action = new VirtualAction(this.scheduler, this.work);
        this.add(action);
        return action.schedule(state, delay);
    };
    VirtualAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        this.delay = scheduler.frame + delay;
        var actions = scheduler.actions;
        actions.push(this);
        actions.sort(VirtualAction.sortActions);
        return true;
    };
    VirtualAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        return undefined;
    };
    VirtualAction.prototype._execute = function (state, delay) {
        if (this.active === true) {
            return _super.prototype._execute.call(this, state, delay);
        }
    };
    VirtualAction.sortActions = function (a, b) {
        if (a.delay === b.delay) {
            if (a.index === b.index) {
                return 0;
            }
            else if (a.index > b.index) {
                return 1;
            }
            else {
                return -1;
            }
        }
        else if (a.delay > b.delay) {
            return 1;
        }
        else {
            return -1;
        }
    };
    return VirtualAction;
}(AsyncAction));

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function identity(x) {
    return x;
}

/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var ArgumentOutOfRangeErrorImpl = /*@__PURE__*/ (function () {
    function ArgumentOutOfRangeErrorImpl() {
        Error.call(this);
        this.message = 'argument out of range';
        this.name = 'ArgumentOutOfRangeError';
        return this;
    }
    ArgumentOutOfRangeErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);
    return ArgumentOutOfRangeErrorImpl;
})();
var ArgumentOutOfRangeError = ArgumentOutOfRangeErrorImpl;

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var EmptyErrorImpl = /*@__PURE__*/ (function () {
    function EmptyErrorImpl() {
        Error.call(this);
        this.message = 'no elements in sequence';
        this.name = 'EmptyError';
        return this;
    }
    EmptyErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);
    return EmptyErrorImpl;
})();
var EmptyError = EmptyErrorImpl;

/** PURE_IMPORTS_START  PURE_IMPORTS_END */

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
function map(project, thisArg) {
    return function mapOperation(source) {
        if (typeof project !== 'function') {
            throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
        }
        return source.lift(new MapOperator(project, thisArg));
    };
}
var MapOperator = /*@__PURE__*/ (function () {
    function MapOperator(project, thisArg) {
        this.project = project;
        this.thisArg = thisArg;
    }
    MapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
    };
    return MapOperator;
}());
var MapSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(MapSubscriber, _super);
    function MapSubscriber(destination, project, thisArg) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.count = 0;
        _this.thisArg = thisArg || _this;
        return _this;
    }
    MapSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.project.call(this.thisArg, value, this.count++);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return MapSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START _Observable,_AsyncSubject,_operators_map,_util_canReportError,_util_isArray,_util_isScheduler PURE_IMPORTS_END */

/** PURE_IMPORTS_START _Observable,_AsyncSubject,_operators_map,_util_canReportError,_util_isScheduler,_util_isArray PURE_IMPORTS_END */

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
var OuterSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(OuterSubscriber, _super);
    function OuterSubscriber() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    OuterSubscriber.prototype.notifyError = function (error, innerSub) {
        this.destination.error(error);
    };
    OuterSubscriber.prototype.notifyComplete = function (innerSub) {
        this.destination.complete();
    };
    return OuterSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
var InnerSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(InnerSubscriber, _super);
    function InnerSubscriber(parent, outerValue, outerIndex) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        _this.outerValue = outerValue;
        _this.outerIndex = outerIndex;
        _this.index = 0;
        return _this;
    }
    InnerSubscriber.prototype._next = function (value) {
        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
    };
    InnerSubscriber.prototype._error = function (error) {
        this.parent.notifyError(error, this);
        this.unsubscribe();
    };
    InnerSubscriber.prototype._complete = function () {
        this.parent.notifyComplete(this);
        this.unsubscribe();
    };
    return InnerSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START _hostReportError PURE_IMPORTS_END */
var subscribeToPromise = function (promise) {
    return function (subscriber) {
        promise.then(function (value) {
            if (!subscriber.closed) {
                subscriber.next(value);
                subscriber.complete();
            }
        }, function (err) { return subscriber.error(err); })
            .then(null, hostReportError);
        return subscriber;
    };
};

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function getSymbolIterator() {
    if (typeof Symbol !== 'function' || !Symbol.iterator) {
        return '@@iterator';
    }
    return Symbol.iterator;
}
var iterator = /*@__PURE__*/ getSymbolIterator();

/** PURE_IMPORTS_START _symbol_iterator PURE_IMPORTS_END */
var subscribeToIterable = function (iterable) {
    return function (subscriber) {
        var iterator$$1 = iterable[iterator]();
        do {
            var item = iterator$$1.next();
            if (item.done) {
                subscriber.complete();
                break;
            }
            subscriber.next(item.value);
            if (subscriber.closed) {
                break;
            }
        } while (true);
        if (typeof iterator$$1.return === 'function') {
            subscriber.add(function () {
                if (iterator$$1.return) {
                    iterator$$1.return();
                }
            });
        }
        return subscriber;
    };
};

/** PURE_IMPORTS_START _symbol_observable PURE_IMPORTS_END */
var subscribeToObservable = function (obj) {
    return function (subscriber) {
        var obs = obj[observable]();
        if (typeof obs.subscribe !== 'function') {
            throw new TypeError('Provided object does not correctly implement Symbol.observable');
        }
        else {
            return obs.subscribe(subscriber);
        }
    };
};

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var isArrayLike = (function (x) { return x && typeof x.length === 'number' && typeof x !== 'function'; });

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function isPromise(value) {
    return !!value && typeof value.subscribe !== 'function' && typeof value.then === 'function';
}

/** PURE_IMPORTS_START _subscribeToArray,_subscribeToPromise,_subscribeToIterable,_subscribeToObservable,_isArrayLike,_isPromise,_isObject,_symbol_iterator,_symbol_observable PURE_IMPORTS_END */
var subscribeTo = function (result) {
    if (!!result && typeof result[observable] === 'function') {
        return subscribeToObservable(result);
    }
    else if (isArrayLike(result)) {
        return subscribeToArray(result);
    }
    else if (isPromise(result)) {
        return subscribeToPromise(result);
    }
    else if (!!result && typeof result[iterator] === 'function') {
        return subscribeToIterable(result);
    }
    else {
        var value = isObject(result) ? 'an invalid object' : "'" + result + "'";
        var msg = "You provided " + value + " where a stream was expected."
            + ' You can provide an Observable, Promise, Array, or Iterable.';
        throw new TypeError(msg);
    }
};

/** PURE_IMPORTS_START _InnerSubscriber,_subscribeTo,_Observable PURE_IMPORTS_END */
function subscribeToResult(outerSubscriber, result, outerValue, outerIndex, innerSubscriber) {
    if (innerSubscriber === void 0) {
        innerSubscriber = new InnerSubscriber(outerSubscriber, outerValue, outerIndex);
    }
    if (innerSubscriber.closed) {
        return undefined;
    }
    if (result instanceof Observable) {
        return result.subscribe(innerSubscriber);
    }
    return subscribeTo(result)(innerSubscriber);
}

/** PURE_IMPORTS_START tslib,_util_isScheduler,_util_isArray,_OuterSubscriber,_util_subscribeToResult,_fromArray PURE_IMPORTS_END */
var NONE = {};
function combineLatest() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    var resultSelector = null;
    var scheduler = null;
    if (isScheduler(observables[observables.length - 1])) {
        scheduler = observables.pop();
    }
    if (typeof observables[observables.length - 1] === 'function') {
        resultSelector = observables.pop();
    }
    if (observables.length === 1 && isArray(observables[0])) {
        observables = observables[0];
    }
    return fromArray(observables, scheduler).lift(new CombineLatestOperator(resultSelector));
}
var CombineLatestOperator = /*@__PURE__*/ (function () {
    function CombineLatestOperator(resultSelector) {
        this.resultSelector = resultSelector;
    }
    CombineLatestOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new CombineLatestSubscriber(subscriber, this.resultSelector));
    };
    return CombineLatestOperator;
}());
var CombineLatestSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(CombineLatestSubscriber, _super);
    function CombineLatestSubscriber(destination, resultSelector) {
        var _this = _super.call(this, destination) || this;
        _this.resultSelector = resultSelector;
        _this.active = 0;
        _this.values = [];
        _this.observables = [];
        return _this;
    }
    CombineLatestSubscriber.prototype._next = function (observable) {
        this.values.push(NONE);
        this.observables.push(observable);
    };
    CombineLatestSubscriber.prototype._complete = function () {
        var observables = this.observables;
        var len = observables.length;
        if (len === 0) {
            this.destination.complete();
        }
        else {
            this.active = len;
            this.toRespond = len;
            for (var i = 0; i < len; i++) {
                var observable = observables[i];
                this.add(subscribeToResult(this, observable, observable, i));
            }
        }
    };
    CombineLatestSubscriber.prototype.notifyComplete = function (unused) {
        if ((this.active -= 1) === 0) {
            this.destination.complete();
        }
    };
    CombineLatestSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var values = this.values;
        var oldVal = values[outerIndex];
        var toRespond = !this.toRespond
            ? 0
            : oldVal === NONE ? --this.toRespond : this.toRespond;
        values[outerIndex] = innerValue;
        if (toRespond === 0) {
            if (this.resultSelector) {
                this._tryResultSelector(values);
            }
            else {
                this.destination.next(values.slice());
            }
        }
    };
    CombineLatestSubscriber.prototype._tryResultSelector = function (values) {
        var result;
        try {
            result = this.resultSelector.apply(this, values);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return CombineLatestSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START _Observable,_Subscription,_symbol_observable PURE_IMPORTS_END */
function scheduleObservable(input, scheduler) {
    return new Observable(function (subscriber) {
        var sub = new Subscription();
        sub.add(scheduler.schedule(function () {
            var observable$$1 = input[observable]();
            sub.add(observable$$1.subscribe({
                next: function (value) { sub.add(scheduler.schedule(function () { return subscriber.next(value); })); },
                error: function (err) { sub.add(scheduler.schedule(function () { return subscriber.error(err); })); },
                complete: function () { sub.add(scheduler.schedule(function () { return subscriber.complete(); })); },
            }));
        }));
        return sub;
    });
}

/** PURE_IMPORTS_START _Observable,_Subscription PURE_IMPORTS_END */
function schedulePromise(input, scheduler) {
    return new Observable(function (subscriber) {
        var sub = new Subscription();
        sub.add(scheduler.schedule(function () {
            return input.then(function (value) {
                sub.add(scheduler.schedule(function () {
                    subscriber.next(value);
                    sub.add(scheduler.schedule(function () { return subscriber.complete(); }));
                }));
            }, function (err) {
                sub.add(scheduler.schedule(function () { return subscriber.error(err); }));
            });
        }));
        return sub;
    });
}

/** PURE_IMPORTS_START _Observable,_Subscription,_symbol_iterator PURE_IMPORTS_END */
function scheduleIterable(input, scheduler) {
    if (!input) {
        throw new Error('Iterable cannot be null');
    }
    return new Observable(function (subscriber) {
        var sub = new Subscription();
        var iterator$$1;
        sub.add(function () {
            if (iterator$$1 && typeof iterator$$1.return === 'function') {
                iterator$$1.return();
            }
        });
        sub.add(scheduler.schedule(function () {
            iterator$$1 = input[iterator]();
            sub.add(scheduler.schedule(function () {
                if (subscriber.closed) {
                    return;
                }
                var value;
                var done;
                try {
                    var result = iterator$$1.next();
                    value = result.value;
                    done = result.done;
                }
                catch (err) {
                    subscriber.error(err);
                    return;
                }
                if (done) {
                    subscriber.complete();
                }
                else {
                    subscriber.next(value);
                    this.schedule();
                }
            }));
        }));
        return sub;
    });
}

/** PURE_IMPORTS_START _symbol_observable PURE_IMPORTS_END */
function isInteropObservable(input) {
    return input && typeof input[observable] === 'function';
}

/** PURE_IMPORTS_START _symbol_iterator PURE_IMPORTS_END */
function isIterable(input) {
    return input && typeof input[iterator] === 'function';
}

/** PURE_IMPORTS_START _scheduleObservable,_schedulePromise,_scheduleArray,_scheduleIterable,_util_isInteropObservable,_util_isPromise,_util_isArrayLike,_util_isIterable PURE_IMPORTS_END */
function scheduled(input, scheduler) {
    if (input != null) {
        if (isInteropObservable(input)) {
            return scheduleObservable(input, scheduler);
        }
        else if (isPromise(input)) {
            return schedulePromise(input, scheduler);
        }
        else if (isArrayLike(input)) {
            return scheduleArray(input, scheduler);
        }
        else if (isIterable(input) || typeof input === 'string') {
            return scheduleIterable(input, scheduler);
        }
    }
    throw new TypeError((input !== null && typeof input || input) + ' is not observable');
}

/** PURE_IMPORTS_START _Observable,_util_subscribeTo,_scheduled_scheduled PURE_IMPORTS_END */
function from(input, scheduler) {
    if (!scheduler) {
        if (input instanceof Observable) {
            return input;
        }
        return new Observable(subscribeTo(input));
    }
    else {
        return scheduled(input, scheduler);
    }
}

/** PURE_IMPORTS_START tslib,_util_subscribeToResult,_OuterSubscriber,_InnerSubscriber,_map,_observable_from PURE_IMPORTS_END */
function mergeMap(project, resultSelector, concurrent) {
    if (concurrent === void 0) {
        concurrent = Number.POSITIVE_INFINITY;
    }
    if (typeof resultSelector === 'function') {
        return function (source) { return source.pipe(mergeMap(function (a, i) { return from(project(a, i)).pipe(map(function (b, ii) { return resultSelector(a, b, i, ii); })); }, concurrent)); };
    }
    else if (typeof resultSelector === 'number') {
        concurrent = resultSelector;
    }
    return function (source) { return source.lift(new MergeMapOperator(project, concurrent)); };
}
var MergeMapOperator = /*@__PURE__*/ (function () {
    function MergeMapOperator(project, concurrent) {
        if (concurrent === void 0) {
            concurrent = Number.POSITIVE_INFINITY;
        }
        this.project = project;
        this.concurrent = concurrent;
    }
    MergeMapOperator.prototype.call = function (observer, source) {
        return source.subscribe(new MergeMapSubscriber(observer, this.project, this.concurrent));
    };
    return MergeMapOperator;
}());
var MergeMapSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(MergeMapSubscriber, _super);
    function MergeMapSubscriber(destination, project, concurrent) {
        if (concurrent === void 0) {
            concurrent = Number.POSITIVE_INFINITY;
        }
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.concurrent = concurrent;
        _this.hasCompleted = false;
        _this.buffer = [];
        _this.active = 0;
        _this.index = 0;
        return _this;
    }
    MergeMapSubscriber.prototype._next = function (value) {
        if (this.active < this.concurrent) {
            this._tryNext(value);
        }
        else {
            this.buffer.push(value);
        }
    };
    MergeMapSubscriber.prototype._tryNext = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.active++;
        this._innerSub(result, value, index);
    };
    MergeMapSubscriber.prototype._innerSub = function (ish, value, index) {
        var innerSubscriber = new InnerSubscriber(this, value, index);
        var destination = this.destination;
        destination.add(innerSubscriber);
        var innerSubscription = subscribeToResult(this, ish, undefined, undefined, innerSubscriber);
        if (innerSubscription !== innerSubscriber) {
            destination.add(innerSubscription);
        }
    };
    MergeMapSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
            this.destination.complete();
        }
        this.unsubscribe();
    };
    MergeMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    MergeMapSubscriber.prototype.notifyComplete = function (innerSub) {
        var buffer = this.buffer;
        this.remove(innerSub);
        this.active--;
        if (buffer.length > 0) {
            this._next(buffer.shift());
        }
        else if (this.active === 0 && this.hasCompleted) {
            this.destination.complete();
        }
    };
    return MergeMapSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START _mergeMap,_util_identity PURE_IMPORTS_END */
function mergeAll(concurrent) {
    if (concurrent === void 0) {
        concurrent = Number.POSITIVE_INFINITY;
    }
    return mergeMap(identity, concurrent);
}

/** PURE_IMPORTS_START _mergeAll PURE_IMPORTS_END */
function concatAll() {
    return mergeAll(1);
}

/** PURE_IMPORTS_START _of,_operators_concatAll PURE_IMPORTS_END */
function concat() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    return concatAll()(of.apply(void 0, observables));
}

/** PURE_IMPORTS_START _Observable,_from,_empty PURE_IMPORTS_END */
function defer(observableFactory) {
    return new Observable(function (subscriber) {
        var input;
        try {
            input = observableFactory();
        }
        catch (err) {
            subscriber.error(err);
            return undefined;
        }
        var source = input ? from(input) : empty$1();
        return source.subscribe(subscriber);
    });
}

/** PURE_IMPORTS_START _Observable,_util_isArray,_operators_map,_util_isObject,_from PURE_IMPORTS_END */

/** PURE_IMPORTS_START _Observable,_util_isArray,_util_isFunction,_operators_map PURE_IMPORTS_END */
function fromEvent(target, eventName, options, resultSelector) {
    if (isFunction(options)) {
        resultSelector = options;
        options = undefined;
    }
    if (resultSelector) {
        return fromEvent(target, eventName, options).pipe(map(function (args) { return isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));
    }
    return new Observable(function (subscriber) {
        function handler(e) {
            if (arguments.length > 1) {
                subscriber.next(Array.prototype.slice.call(arguments));
            }
            else {
                subscriber.next(e);
            }
        }
        setupSubscription(target, eventName, handler, subscriber, options);
    });
}
function setupSubscription(sourceObj, eventName, handler, subscriber, options) {
    var unsubscribe;
    if (isEventTarget(sourceObj)) {
        var source_1 = sourceObj;
        sourceObj.addEventListener(eventName, handler, options);
        unsubscribe = function () { return source_1.removeEventListener(eventName, handler, options); };
    }
    else if (isJQueryStyleEventEmitter(sourceObj)) {
        var source_2 = sourceObj;
        sourceObj.on(eventName, handler);
        unsubscribe = function () { return source_2.off(eventName, handler); };
    }
    else if (isNodeStyleEventEmitter(sourceObj)) {
        var source_3 = sourceObj;
        sourceObj.addListener(eventName, handler);
        unsubscribe = function () { return source_3.removeListener(eventName, handler); };
    }
    else if (sourceObj && sourceObj.length) {
        for (var i = 0, len = sourceObj.length; i < len; i++) {
            setupSubscription(sourceObj[i], eventName, handler, subscriber, options);
        }
    }
    else {
        throw new TypeError('Invalid event target');
    }
    subscriber.add(unsubscribe);
}
function isNodeStyleEventEmitter(sourceObj) {
    return sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';
}
function isJQueryStyleEventEmitter(sourceObj) {
    return sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';
}
function isEventTarget(sourceObj) {
    return sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';
}

/** PURE_IMPORTS_START _Observable,_util_isArray,_util_isFunction,_operators_map PURE_IMPORTS_END */

/** PURE_IMPORTS_START _Observable,_util_identity,_util_isScheduler PURE_IMPORTS_END */

/** PURE_IMPORTS_START _defer,_empty PURE_IMPORTS_END */

/** PURE_IMPORTS_START _isArray PURE_IMPORTS_END */
function isNumeric(val) {
    return !isArray(val) && (val - parseFloat(val) + 1) >= 0;
}

/** PURE_IMPORTS_START _Observable,_scheduler_async,_util_isNumeric PURE_IMPORTS_END */

/** PURE_IMPORTS_START _Observable,_util_isScheduler,_operators_mergeAll,_fromArray PURE_IMPORTS_END */

/** PURE_IMPORTS_START _Observable,_util_noop PURE_IMPORTS_END */
var NEVER = /*@__PURE__*/ new Observable(noop);

/** PURE_IMPORTS_START _Observable,_from,_util_isArray,_empty PURE_IMPORTS_END */

/** PURE_IMPORTS_START _Observable,_Subscription PURE_IMPORTS_END */

/** PURE_IMPORTS_START  PURE_IMPORTS_END */

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
function filter(predicate, thisArg) {
    return function filterOperatorFunction(source) {
        return source.lift(new FilterOperator(predicate, thisArg));
    };
}
var FilterOperator = /*@__PURE__*/ (function () {
    function FilterOperator(predicate, thisArg) {
        this.predicate = predicate;
        this.thisArg = thisArg;
    }
    FilterOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
    };
    return FilterOperator;
}());
var FilterSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(FilterSubscriber, _super);
    function FilterSubscriber(destination, predicate, thisArg) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.thisArg = thisArg;
        _this.count = 0;
        return _this;
    }
    FilterSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.predicate.call(this.thisArg, value, this.count++);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        if (result) {
            this.destination.next(value);
        }
    };
    return FilterSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START _util_not,_util_subscribeTo,_operators_filter,_Observable PURE_IMPORTS_END */

/** PURE_IMPORTS_START tslib,_util_isArray,_fromArray,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

var RaceOperator = /*@__PURE__*/ (function () {
    function RaceOperator() {
    }
    RaceOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RaceSubscriber(subscriber));
    };
    return RaceOperator;
}());
var RaceSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(RaceSubscriber, _super);
    function RaceSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.hasFirst = false;
        _this.observables = [];
        _this.subscriptions = [];
        return _this;
    }
    RaceSubscriber.prototype._next = function (observable) {
        this.observables.push(observable);
    };
    RaceSubscriber.prototype._complete = function () {
        var observables = this.observables;
        var len = observables.length;
        if (len === 0) {
            this.destination.complete();
        }
        else {
            for (var i = 0; i < len && !this.hasFirst; i++) {
                var observable = observables[i];
                var subscription = subscribeToResult(this, observable, observable, i);
                if (this.subscriptions) {
                    this.subscriptions.push(subscription);
                }
                this.add(subscription);
            }
            this.observables = null;
        }
    };
    RaceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (!this.hasFirst) {
            this.hasFirst = true;
            for (var i = 0; i < this.subscriptions.length; i++) {
                if (i !== outerIndex) {
                    var subscription = this.subscriptions[i];
                    subscription.unsubscribe();
                    this.remove(subscription);
                }
            }
            this.subscriptions = null;
        }
        this.destination.next(innerValue);
    };
    return RaceSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */

/** PURE_IMPORTS_START _Observable,_scheduler_async,_util_isNumeric,_util_isScheduler PURE_IMPORTS_END */

/** PURE_IMPORTS_START _Observable,_from,_empty PURE_IMPORTS_END */

/** PURE_IMPORTS_START tslib,_fromArray,_util_isArray,_Subscriber,_OuterSubscriber,_util_subscribeToResult,_.._internal_symbol_iterator PURE_IMPORTS_END */

var ZipOperator = /*@__PURE__*/ (function () {
    function ZipOperator(resultSelector) {
        this.resultSelector = resultSelector;
    }
    ZipOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ZipSubscriber(subscriber, this.resultSelector));
    };
    return ZipOperator;
}());
var ZipSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(ZipSubscriber, _super);
    function ZipSubscriber(destination, resultSelector, values) {
        if (values === void 0) {
            values = Object.create(null);
        }
        var _this = _super.call(this, destination) || this;
        _this.iterators = [];
        _this.active = 0;
        _this.resultSelector = (typeof resultSelector === 'function') ? resultSelector : null;
        _this.values = values;
        return _this;
    }
    ZipSubscriber.prototype._next = function (value) {
        var iterators = this.iterators;
        if (isArray(value)) {
            iterators.push(new StaticArrayIterator(value));
        }
        else if (typeof value[iterator] === 'function') {
            iterators.push(new StaticIterator(value[iterator]()));
        }
        else {
            iterators.push(new ZipBufferIterator(this.destination, this, value));
        }
    };
    ZipSubscriber.prototype._complete = function () {
        var iterators = this.iterators;
        var len = iterators.length;
        this.unsubscribe();
        if (len === 0) {
            this.destination.complete();
            return;
        }
        this.active = len;
        for (var i = 0; i < len; i++) {
            var iterator$$1 = iterators[i];
            if (iterator$$1.stillUnsubscribed) {
                var destination = this.destination;
                destination.add(iterator$$1.subscribe(iterator$$1, i));
            }
            else {
                this.active--;
            }
        }
    };
    ZipSubscriber.prototype.notifyInactive = function () {
        this.active--;
        if (this.active === 0) {
            this.destination.complete();
        }
    };
    ZipSubscriber.prototype.checkIterators = function () {
        var iterators = this.iterators;
        var len = iterators.length;
        var destination = this.destination;
        for (var i = 0; i < len; i++) {
            var iterator$$1 = iterators[i];
            if (typeof iterator$$1.hasValue === 'function' && !iterator$$1.hasValue()) {
                return;
            }
        }
        var shouldComplete = false;
        var args = [];
        for (var i = 0; i < len; i++) {
            var iterator$$1 = iterators[i];
            var result = iterator$$1.next();
            if (iterator$$1.hasCompleted()) {
                shouldComplete = true;
            }
            if (result.done) {
                destination.complete();
                return;
            }
            args.push(result.value);
        }
        if (this.resultSelector) {
            this._tryresultSelector(args);
        }
        else {
            destination.next(args);
        }
        if (shouldComplete) {
            destination.complete();
        }
    };
    ZipSubscriber.prototype._tryresultSelector = function (args) {
        var result;
        try {
            result = this.resultSelector.apply(this, args);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return ZipSubscriber;
}(Subscriber));
var StaticIterator = /*@__PURE__*/ (function () {
    function StaticIterator(iterator$$1) {
        this.iterator = iterator$$1;
        this.nextResult = iterator$$1.next();
    }
    StaticIterator.prototype.hasValue = function () {
        return true;
    };
    StaticIterator.prototype.next = function () {
        var result = this.nextResult;
        this.nextResult = this.iterator.next();
        return result;
    };
    StaticIterator.prototype.hasCompleted = function () {
        var nextResult = this.nextResult;
        return nextResult && nextResult.done;
    };
    return StaticIterator;
}());
var StaticArrayIterator = /*@__PURE__*/ (function () {
    function StaticArrayIterator(array) {
        this.array = array;
        this.index = 0;
        this.length = 0;
        this.length = array.length;
    }
    StaticArrayIterator.prototype[iterator] = function () {
        return this;
    };
    StaticArrayIterator.prototype.next = function (value) {
        var i = this.index++;
        var array = this.array;
        return i < this.length ? { value: array[i], done: false } : { value: null, done: true };
    };
    StaticArrayIterator.prototype.hasValue = function () {
        return this.array.length > this.index;
    };
    StaticArrayIterator.prototype.hasCompleted = function () {
        return this.array.length === this.index;
    };
    return StaticArrayIterator;
}());
var ZipBufferIterator = /*@__PURE__*/ (function (_super) {
    __extends(ZipBufferIterator, _super);
    function ZipBufferIterator(destination, parent, observable) {
        var _this = _super.call(this, destination) || this;
        _this.parent = parent;
        _this.observable = observable;
        _this.stillUnsubscribed = true;
        _this.buffer = [];
        _this.isComplete = false;
        return _this;
    }
    ZipBufferIterator.prototype[iterator] = function () {
        return this;
    };
    ZipBufferIterator.prototype.next = function () {
        var buffer = this.buffer;
        if (buffer.length === 0 && this.isComplete) {
            return { value: null, done: true };
        }
        else {
            return { value: buffer.shift(), done: false };
        }
    };
    ZipBufferIterator.prototype.hasValue = function () {
        return this.buffer.length > 0;
    };
    ZipBufferIterator.prototype.hasCompleted = function () {
        return this.buffer.length === 0 && this.isComplete;
    };
    ZipBufferIterator.prototype.notifyComplete = function () {
        if (this.buffer.length > 0) {
            this.isComplete = true;
            this.parent.notifyInactive();
        }
        else {
            this.destination.complete();
        }
    };
    ZipBufferIterator.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.buffer.push(innerValue);
        this.parent.checkIterators();
    };
    ZipBufferIterator.prototype.subscribe = function (value, index) {
        return subscribeToResult(this, this.observable, this, index);
    };
    return ZipBufferIterator;
}(OuterSubscriber));

/** PURE_IMPORTS_START  PURE_IMPORTS_END */

/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

var AuditOperator = /*@__PURE__*/ (function () {
    function AuditOperator(durationSelector) {
        this.durationSelector = durationSelector;
    }
    AuditOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new AuditSubscriber(subscriber, this.durationSelector));
    };
    return AuditOperator;
}());
var AuditSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(AuditSubscriber, _super);
    function AuditSubscriber(destination, durationSelector) {
        var _this = _super.call(this, destination) || this;
        _this.durationSelector = durationSelector;
        _this.hasValue = false;
        return _this;
    }
    AuditSubscriber.prototype._next = function (value) {
        this.value = value;
        this.hasValue = true;
        if (!this.throttled) {
            var duration = void 0;
            try {
                var durationSelector = this.durationSelector;
                duration = durationSelector(value);
            }
            catch (err) {
                return this.destination.error(err);
            }
            var innerSubscription = subscribeToResult(this, duration);
            if (!innerSubscription || innerSubscription.closed) {
                this.clearThrottle();
            }
            else {
                this.add(this.throttled = innerSubscription);
            }
        }
    };
    AuditSubscriber.prototype.clearThrottle = function () {
        var _a = this, value = _a.value, hasValue = _a.hasValue, throttled = _a.throttled;
        if (throttled) {
            this.remove(throttled);
            this.throttled = null;
            throttled.unsubscribe();
        }
        if (hasValue) {
            this.value = null;
            this.hasValue = false;
            this.destination.next(value);
        }
    };
    AuditSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {
        this.clearThrottle();
    };
    AuditSubscriber.prototype.notifyComplete = function () {
        this.clearThrottle();
    };
    return AuditSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START _scheduler_async,_audit,_observable_timer PURE_IMPORTS_END */

/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

var BufferOperator = /*@__PURE__*/ (function () {
    function BufferOperator(closingNotifier) {
        this.closingNotifier = closingNotifier;
    }
    BufferOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new BufferSubscriber(subscriber, this.closingNotifier));
    };
    return BufferOperator;
}());
var BufferSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(BufferSubscriber, _super);
    function BufferSubscriber(destination, closingNotifier) {
        var _this = _super.call(this, destination) || this;
        _this.buffer = [];
        _this.add(subscribeToResult(_this, closingNotifier));
        return _this;
    }
    BufferSubscriber.prototype._next = function (value) {
        this.buffer.push(value);
    };
    BufferSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var buffer = this.buffer;
        this.buffer = [];
        this.destination.next(buffer);
    };
    return BufferSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */

var BufferCountOperator = /*@__PURE__*/ (function () {
    function BufferCountOperator(bufferSize, startBufferEvery) {
        this.bufferSize = bufferSize;
        this.startBufferEvery = startBufferEvery;
        if (!startBufferEvery || bufferSize === startBufferEvery) {
            this.subscriberClass = BufferCountSubscriber;
        }
        else {
            this.subscriberClass = BufferSkipCountSubscriber;
        }
    }
    BufferCountOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new this.subscriberClass(subscriber, this.bufferSize, this.startBufferEvery));
    };
    return BufferCountOperator;
}());
var BufferCountSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(BufferCountSubscriber, _super);
    function BufferCountSubscriber(destination, bufferSize) {
        var _this = _super.call(this, destination) || this;
        _this.bufferSize = bufferSize;
        _this.buffer = [];
        return _this;
    }
    BufferCountSubscriber.prototype._next = function (value) {
        var buffer = this.buffer;
        buffer.push(value);
        if (buffer.length == this.bufferSize) {
            this.destination.next(buffer);
            this.buffer = [];
        }
    };
    BufferCountSubscriber.prototype._complete = function () {
        var buffer = this.buffer;
        if (buffer.length > 0) {
            this.destination.next(buffer);
        }
        _super.prototype._complete.call(this);
    };
    return BufferCountSubscriber;
}(Subscriber));
var BufferSkipCountSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(BufferSkipCountSubscriber, _super);
    function BufferSkipCountSubscriber(destination, bufferSize, startBufferEvery) {
        var _this = _super.call(this, destination) || this;
        _this.bufferSize = bufferSize;
        _this.startBufferEvery = startBufferEvery;
        _this.buffers = [];
        _this.count = 0;
        return _this;
    }
    BufferSkipCountSubscriber.prototype._next = function (value) {
        var _a = this, bufferSize = _a.bufferSize, startBufferEvery = _a.startBufferEvery, buffers = _a.buffers, count = _a.count;
        this.count++;
        if (count % startBufferEvery === 0) {
            buffers.push([]);
        }
        for (var i = buffers.length; i--;) {
            var buffer = buffers[i];
            buffer.push(value);
            if (buffer.length === bufferSize) {
                buffers.splice(i, 1);
                this.destination.next(buffer);
            }
        }
    };
    BufferSkipCountSubscriber.prototype._complete = function () {
        var _a = this, buffers = _a.buffers, destination = _a.destination;
        while (buffers.length > 0) {
            var buffer = buffers.shift();
            if (buffer.length > 0) {
                destination.next(buffer);
            }
        }
        _super.prototype._complete.call(this);
    };
    return BufferSkipCountSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_scheduler_async,_Subscriber,_util_isScheduler PURE_IMPORTS_END */

var BufferTimeOperator = /*@__PURE__*/ (function () {
    function BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
        this.bufferTimeSpan = bufferTimeSpan;
        this.bufferCreationInterval = bufferCreationInterval;
        this.maxBufferSize = maxBufferSize;
        this.scheduler = scheduler;
    }
    BufferTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));
    };
    return BufferTimeOperator;
}());
var Context = /*@__PURE__*/ (function () {
    function Context() {
        this.buffer = [];
    }
    return Context;
}());
var BufferTimeSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(BufferTimeSubscriber, _super);
    function BufferTimeSubscriber(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.bufferTimeSpan = bufferTimeSpan;
        _this.bufferCreationInterval = bufferCreationInterval;
        _this.maxBufferSize = maxBufferSize;
        _this.scheduler = scheduler;
        _this.contexts = [];
        var context = _this.openContext();
        _this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;
        if (_this.timespanOnly) {
            var timeSpanOnlyState = { subscriber: _this, context: context, bufferTimeSpan: bufferTimeSpan };
            _this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
        }
        else {
            var closeState = { subscriber: _this, context: context };
            var creationState = { bufferTimeSpan: bufferTimeSpan, bufferCreationInterval: bufferCreationInterval, subscriber: _this, scheduler: scheduler };
            _this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));
            _this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));
        }
        return _this;
    }
    BufferTimeSubscriber.prototype._next = function (value) {
        var contexts = this.contexts;
        var len = contexts.length;
        var filledBufferContext;
        for (var i = 0; i < len; i++) {
            var context_1 = contexts[i];
            var buffer = context_1.buffer;
            buffer.push(value);
            if (buffer.length == this.maxBufferSize) {
                filledBufferContext = context_1;
            }
        }
        if (filledBufferContext) {
            this.onBufferFull(filledBufferContext);
        }
    };
    BufferTimeSubscriber.prototype._error = function (err) {
        this.contexts.length = 0;
        _super.prototype._error.call(this, err);
    };
    BufferTimeSubscriber.prototype._complete = function () {
        var _a = this, contexts = _a.contexts, destination = _a.destination;
        while (contexts.length > 0) {
            var context_2 = contexts.shift();
            destination.next(context_2.buffer);
        }
        _super.prototype._complete.call(this);
    };
    BufferTimeSubscriber.prototype._unsubscribe = function () {
        this.contexts = null;
    };
    BufferTimeSubscriber.prototype.onBufferFull = function (context) {
        this.closeContext(context);
        var closeAction = context.closeAction;
        closeAction.unsubscribe();
        this.remove(closeAction);
        if (!this.closed && this.timespanOnly) {
            context = this.openContext();
            var bufferTimeSpan = this.bufferTimeSpan;
            var timeSpanOnlyState = { subscriber: this, context: context, bufferTimeSpan: bufferTimeSpan };
            this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
        }
    };
    BufferTimeSubscriber.prototype.openContext = function () {
        var context = new Context();
        this.contexts.push(context);
        return context;
    };
    BufferTimeSubscriber.prototype.closeContext = function (context) {
        this.destination.next(context.buffer);
        var contexts = this.contexts;
        var spliceIndex = contexts ? contexts.indexOf(context) : -1;
        if (spliceIndex >= 0) {
            contexts.splice(contexts.indexOf(context), 1);
        }
    };
    return BufferTimeSubscriber;
}(Subscriber));
function dispatchBufferTimeSpanOnly(state) {
    var subscriber = state.subscriber;
    var prevContext = state.context;
    if (prevContext) {
        subscriber.closeContext(prevContext);
    }
    if (!subscriber.closed) {
        state.context = subscriber.openContext();
        state.context.closeAction = this.schedule(state, state.bufferTimeSpan);
    }
}
function dispatchBufferCreation(state) {
    var bufferCreationInterval = state.bufferCreationInterval, bufferTimeSpan = state.bufferTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler;
    var context = subscriber.openContext();
    var action = this;
    if (!subscriber.closed) {
        subscriber.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, { subscriber: subscriber, context: context }));
        action.schedule(state, bufferCreationInterval);
    }
}
function dispatchBufferClose(arg) {
    var subscriber = arg.subscriber, context = arg.context;
    subscriber.closeContext(context);
}

/** PURE_IMPORTS_START tslib,_Subscription,_util_subscribeToResult,_OuterSubscriber PURE_IMPORTS_END */

var BufferToggleOperator = /*@__PURE__*/ (function () {
    function BufferToggleOperator(openings, closingSelector) {
        this.openings = openings;
        this.closingSelector = closingSelector;
    }
    BufferToggleOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new BufferToggleSubscriber(subscriber, this.openings, this.closingSelector));
    };
    return BufferToggleOperator;
}());
var BufferToggleSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(BufferToggleSubscriber, _super);
    function BufferToggleSubscriber(destination, openings, closingSelector) {
        var _this = _super.call(this, destination) || this;
        _this.openings = openings;
        _this.closingSelector = closingSelector;
        _this.contexts = [];
        _this.add(subscribeToResult(_this, openings));
        return _this;
    }
    BufferToggleSubscriber.prototype._next = function (value) {
        var contexts = this.contexts;
        var len = contexts.length;
        for (var i = 0; i < len; i++) {
            contexts[i].buffer.push(value);
        }
    };
    BufferToggleSubscriber.prototype._error = function (err) {
        var contexts = this.contexts;
        while (contexts.length > 0) {
            var context_1 = contexts.shift();
            context_1.subscription.unsubscribe();
            context_1.buffer = null;
            context_1.subscription = null;
        }
        this.contexts = null;
        _super.prototype._error.call(this, err);
    };
    BufferToggleSubscriber.prototype._complete = function () {
        var contexts = this.contexts;
        while (contexts.length > 0) {
            var context_2 = contexts.shift();
            this.destination.next(context_2.buffer);
            context_2.subscription.unsubscribe();
            context_2.buffer = null;
            context_2.subscription = null;
        }
        this.contexts = null;
        _super.prototype._complete.call(this);
    };
    BufferToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        outerValue ? this.closeBuffer(outerValue) : this.openBuffer(innerValue);
    };
    BufferToggleSubscriber.prototype.notifyComplete = function (innerSub) {
        this.closeBuffer(innerSub.context);
    };
    BufferToggleSubscriber.prototype.openBuffer = function (value) {
        try {
            var closingSelector = this.closingSelector;
            var closingNotifier = closingSelector.call(this, value);
            if (closingNotifier) {
                this.trySubscribe(closingNotifier);
            }
        }
        catch (err) {
            this._error(err);
        }
    };
    BufferToggleSubscriber.prototype.closeBuffer = function (context) {
        var contexts = this.contexts;
        if (contexts && context) {
            var buffer = context.buffer, subscription = context.subscription;
            this.destination.next(buffer);
            contexts.splice(contexts.indexOf(context), 1);
            this.remove(subscription);
            subscription.unsubscribe();
        }
    };
    BufferToggleSubscriber.prototype.trySubscribe = function (closingNotifier) {
        var contexts = this.contexts;
        var buffer = [];
        var subscription = new Subscription();
        var context = { buffer: buffer, subscription: subscription };
        contexts.push(context);
        var innerSubscription = subscribeToResult(this, closingNotifier, context);
        if (!innerSubscription || innerSubscription.closed) {
            this.closeBuffer(context);
        }
        else {
            innerSubscription.context = context;
            this.add(innerSubscription);
            subscription.add(innerSubscription);
        }
    };
    return BufferToggleSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_Subscription,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

var BufferWhenOperator = /*@__PURE__*/ (function () {
    function BufferWhenOperator(closingSelector) {
        this.closingSelector = closingSelector;
    }
    BufferWhenOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new BufferWhenSubscriber(subscriber, this.closingSelector));
    };
    return BufferWhenOperator;
}());
var BufferWhenSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(BufferWhenSubscriber, _super);
    function BufferWhenSubscriber(destination, closingSelector) {
        var _this = _super.call(this, destination) || this;
        _this.closingSelector = closingSelector;
        _this.subscribing = false;
        _this.openBuffer();
        return _this;
    }
    BufferWhenSubscriber.prototype._next = function (value) {
        this.buffer.push(value);
    };
    BufferWhenSubscriber.prototype._complete = function () {
        var buffer = this.buffer;
        if (buffer) {
            this.destination.next(buffer);
        }
        _super.prototype._complete.call(this);
    };
    BufferWhenSubscriber.prototype._unsubscribe = function () {
        this.buffer = null;
        this.subscribing = false;
    };
    BufferWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.openBuffer();
    };
    BufferWhenSubscriber.prototype.notifyComplete = function () {
        if (this.subscribing) {
            this.complete();
        }
        else {
            this.openBuffer();
        }
    };
    BufferWhenSubscriber.prototype.openBuffer = function () {
        var closingSubscription = this.closingSubscription;
        if (closingSubscription) {
            this.remove(closingSubscription);
            closingSubscription.unsubscribe();
        }
        var buffer = this.buffer;
        if (this.buffer) {
            this.destination.next(buffer);
        }
        this.buffer = [];
        var closingNotifier;
        try {
            var closingSelector = this.closingSelector;
            closingNotifier = closingSelector();
        }
        catch (err) {
            return this.error(err);
        }
        closingSubscription = new Subscription();
        this.closingSubscription = closingSubscription;
        this.add(closingSubscription);
        this.subscribing = true;
        closingSubscription.add(subscribeToResult(this, closingNotifier));
        this.subscribing = false;
    };
    return BufferWhenSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_OuterSubscriber,_InnerSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
function catchError(selector) {
    return function catchErrorOperatorFunction(source) {
        var operator = new CatchOperator(selector);
        var caught = source.lift(operator);
        return (operator.caught = caught);
    };
}
var CatchOperator = /*@__PURE__*/ (function () {
    function CatchOperator(selector) {
        this.selector = selector;
    }
    CatchOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));
    };
    return CatchOperator;
}());
var CatchSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(CatchSubscriber, _super);
    function CatchSubscriber(destination, selector, caught) {
        var _this = _super.call(this, destination) || this;
        _this.selector = selector;
        _this.caught = caught;
        return _this;
    }
    CatchSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var result = void 0;
            try {
                result = this.selector(err, this.caught);
            }
            catch (err2) {
                _super.prototype.error.call(this, err2);
                return;
            }
            this._unsubscribeAndRecycle();
            var innerSubscriber = new InnerSubscriber(this, undefined, undefined);
            this.add(innerSubscriber);
            var innerSubscription = subscribeToResult(this, result, undefined, undefined, innerSubscriber);
            if (innerSubscription !== innerSubscriber) {
                this.add(innerSubscription);
            }
        }
    };
    return CatchSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START _observable_combineLatest PURE_IMPORTS_END */

/** PURE_IMPORTS_START _util_isArray,_observable_combineLatest,_observable_from PURE_IMPORTS_END */

/** PURE_IMPORTS_START _observable_concat PURE_IMPORTS_END */

/** PURE_IMPORTS_START _mergeMap PURE_IMPORTS_END */
function concatMap(project, resultSelector) {
    return mergeMap(project, resultSelector, 1);
}

/** PURE_IMPORTS_START _concatMap PURE_IMPORTS_END */

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */

var CountOperator = /*@__PURE__*/ (function () {
    function CountOperator(predicate, source) {
        this.predicate = predicate;
        this.source = source;
    }
    CountOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new CountSubscriber(subscriber, this.predicate, this.source));
    };
    return CountOperator;
}());
var CountSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(CountSubscriber, _super);
    function CountSubscriber(destination, predicate, source) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.source = source;
        _this.count = 0;
        _this.index = 0;
        return _this;
    }
    CountSubscriber.prototype._next = function (value) {
        if (this.predicate) {
            this._tryPredicate(value);
        }
        else {
            this.count++;
        }
    };
    CountSubscriber.prototype._tryPredicate = function (value) {
        var result;
        try {
            result = this.predicate(value, this.index++, this.source);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        if (result) {
            this.count++;
        }
    };
    CountSubscriber.prototype._complete = function () {
        this.destination.next(this.count);
        this.destination.complete();
    };
    return CountSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

var DebounceOperator = /*@__PURE__*/ (function () {
    function DebounceOperator(durationSelector) {
        this.durationSelector = durationSelector;
    }
    DebounceOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DebounceSubscriber(subscriber, this.durationSelector));
    };
    return DebounceOperator;
}());
var DebounceSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(DebounceSubscriber, _super);
    function DebounceSubscriber(destination, durationSelector) {
        var _this = _super.call(this, destination) || this;
        _this.durationSelector = durationSelector;
        _this.hasValue = false;
        _this.durationSubscription = null;
        return _this;
    }
    DebounceSubscriber.prototype._next = function (value) {
        try {
            var result = this.durationSelector.call(this, value);
            if (result) {
                this._tryNext(value, result);
            }
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    DebounceSubscriber.prototype._complete = function () {
        this.emitValue();
        this.destination.complete();
    };
    DebounceSubscriber.prototype._tryNext = function (value, duration) {
        var subscription = this.durationSubscription;
        this.value = value;
        this.hasValue = true;
        if (subscription) {
            subscription.unsubscribe();
            this.remove(subscription);
        }
        subscription = subscribeToResult(this, duration);
        if (subscription && !subscription.closed) {
            this.add(this.durationSubscription = subscription);
        }
    };
    DebounceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.emitValue();
    };
    DebounceSubscriber.prototype.notifyComplete = function () {
        this.emitValue();
    };
    DebounceSubscriber.prototype.emitValue = function () {
        if (this.hasValue) {
            var value = this.value;
            var subscription = this.durationSubscription;
            if (subscription) {
                this.durationSubscription = null;
                subscription.unsubscribe();
                this.remove(subscription);
            }
            this.value = null;
            this.hasValue = false;
            _super.prototype._next.call(this, value);
        }
    };
    return DebounceSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_Subscriber,_scheduler_async PURE_IMPORTS_END */

var DebounceTimeOperator = /*@__PURE__*/ (function () {
    function DebounceTimeOperator(dueTime, scheduler) {
        this.dueTime = dueTime;
        this.scheduler = scheduler;
    }
    DebounceTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));
    };
    return DebounceTimeOperator;
}());
var DebounceTimeSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(DebounceTimeSubscriber, _super);
    function DebounceTimeSubscriber(destination, dueTime, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.dueTime = dueTime;
        _this.scheduler = scheduler;
        _this.debouncedSubscription = null;
        _this.lastValue = null;
        _this.hasValue = false;
        return _this;
    }
    DebounceTimeSubscriber.prototype._next = function (value) {
        this.clearDebounce();
        this.lastValue = value;
        this.hasValue = true;
        this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext$2, this.dueTime, this));
    };
    DebounceTimeSubscriber.prototype._complete = function () {
        this.debouncedNext();
        this.destination.complete();
    };
    DebounceTimeSubscriber.prototype.debouncedNext = function () {
        this.clearDebounce();
        if (this.hasValue) {
            var lastValue = this.lastValue;
            this.lastValue = null;
            this.hasValue = false;
            this.destination.next(lastValue);
        }
    };
    DebounceTimeSubscriber.prototype.clearDebounce = function () {
        var debouncedSubscription = this.debouncedSubscription;
        if (debouncedSubscription !== null) {
            this.remove(debouncedSubscription);
            debouncedSubscription.unsubscribe();
            this.debouncedSubscription = null;
        }
    };
    return DebounceTimeSubscriber;
}(Subscriber));
function dispatchNext$2(subscriber) {
    subscriber.debouncedNext();
}

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
function defaultIfEmpty(defaultValue) {
    if (defaultValue === void 0) {
        defaultValue = null;
    }
    return function (source) { return source.lift(new DefaultIfEmptyOperator(defaultValue)); };
}
var DefaultIfEmptyOperator = /*@__PURE__*/ (function () {
    function DefaultIfEmptyOperator(defaultValue) {
        this.defaultValue = defaultValue;
    }
    DefaultIfEmptyOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DefaultIfEmptySubscriber(subscriber, this.defaultValue));
    };
    return DefaultIfEmptyOperator;
}());
var DefaultIfEmptySubscriber = /*@__PURE__*/ (function (_super) {
    __extends(DefaultIfEmptySubscriber, _super);
    function DefaultIfEmptySubscriber(destination, defaultValue) {
        var _this = _super.call(this, destination) || this;
        _this.defaultValue = defaultValue;
        _this.isEmpty = true;
        return _this;
    }
    DefaultIfEmptySubscriber.prototype._next = function (value) {
        this.isEmpty = false;
        this.destination.next(value);
    };
    DefaultIfEmptySubscriber.prototype._complete = function () {
        if (this.isEmpty) {
            this.destination.next(this.defaultValue);
        }
        this.destination.complete();
    };
    return DefaultIfEmptySubscriber;
}(Subscriber));

/** PURE_IMPORTS_START  PURE_IMPORTS_END */

/** PURE_IMPORTS_START tslib,_scheduler_async,_util_isDate,_Subscriber,_Notification PURE_IMPORTS_END */

var DelayOperator = /*@__PURE__*/ (function () {
    function DelayOperator(delay, scheduler) {
        this.delay = delay;
        this.scheduler = scheduler;
    }
    DelayOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));
    };
    return DelayOperator;
}());
var DelaySubscriber = /*@__PURE__*/ (function (_super) {
    __extends(DelaySubscriber, _super);
    function DelaySubscriber(destination, delay, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.delay = delay;
        _this.scheduler = scheduler;
        _this.queue = [];
        _this.active = false;
        _this.errored = false;
        return _this;
    }
    DelaySubscriber.dispatch = function (state) {
        var source = state.source;
        var queue = source.queue;
        var scheduler = state.scheduler;
        var destination = state.destination;
        while (queue.length > 0 && (queue[0].time - scheduler.now()) <= 0) {
            queue.shift().notification.observe(destination);
        }
        if (queue.length > 0) {
            var delay_1 = Math.max(0, queue[0].time - scheduler.now());
            this.schedule(state, delay_1);
        }
        else {
            this.unsubscribe();
            source.active = false;
        }
    };
    DelaySubscriber.prototype._schedule = function (scheduler) {
        this.active = true;
        var destination = this.destination;
        destination.add(scheduler.schedule(DelaySubscriber.dispatch, this.delay, {
            source: this, destination: this.destination, scheduler: scheduler
        }));
    };
    DelaySubscriber.prototype.scheduleNotification = function (notification) {
        if (this.errored === true) {
            return;
        }
        var scheduler = this.scheduler;
        var message = new DelayMessage(scheduler.now() + this.delay, notification);
        this.queue.push(message);
        if (this.active === false) {
            this._schedule(scheduler);
        }
    };
    DelaySubscriber.prototype._next = function (value) {
        this.scheduleNotification(Notification.createNext(value));
    };
    DelaySubscriber.prototype._error = function (err) {
        this.errored = true;
        this.queue = [];
        this.destination.error(err);
        this.unsubscribe();
    };
    DelaySubscriber.prototype._complete = function () {
        this.scheduleNotification(Notification.createComplete());
        this.unsubscribe();
    };
    return DelaySubscriber;
}(Subscriber));
var DelayMessage = /*@__PURE__*/ (function () {
    function DelayMessage(time, notification) {
        this.time = time;
        this.notification = notification;
    }
    return DelayMessage;
}());

/** PURE_IMPORTS_START tslib,_Subscriber,_Observable,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

var DelayWhenOperator = /*@__PURE__*/ (function () {
    function DelayWhenOperator(delayDurationSelector) {
        this.delayDurationSelector = delayDurationSelector;
    }
    DelayWhenOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DelayWhenSubscriber(subscriber, this.delayDurationSelector));
    };
    return DelayWhenOperator;
}());
var DelayWhenSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(DelayWhenSubscriber, _super);
    function DelayWhenSubscriber(destination, delayDurationSelector) {
        var _this = _super.call(this, destination) || this;
        _this.delayDurationSelector = delayDurationSelector;
        _this.completed = false;
        _this.delayNotifierSubscriptions = [];
        _this.index = 0;
        return _this;
    }
    DelayWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(outerValue);
        this.removeSubscription(innerSub);
        this.tryComplete();
    };
    DelayWhenSubscriber.prototype.notifyError = function (error, innerSub) {
        this._error(error);
    };
    DelayWhenSubscriber.prototype.notifyComplete = function (innerSub) {
        var value = this.removeSubscription(innerSub);
        if (value) {
            this.destination.next(value);
        }
        this.tryComplete();
    };
    DelayWhenSubscriber.prototype._next = function (value) {
        var index = this.index++;
        try {
            var delayNotifier = this.delayDurationSelector(value, index);
            if (delayNotifier) {
                this.tryDelay(delayNotifier, value);
            }
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    DelayWhenSubscriber.prototype._complete = function () {
        this.completed = true;
        this.tryComplete();
        this.unsubscribe();
    };
    DelayWhenSubscriber.prototype.removeSubscription = function (subscription) {
        subscription.unsubscribe();
        var subscriptionIdx = this.delayNotifierSubscriptions.indexOf(subscription);
        if (subscriptionIdx !== -1) {
            this.delayNotifierSubscriptions.splice(subscriptionIdx, 1);
        }
        return subscription.outerValue;
    };
    DelayWhenSubscriber.prototype.tryDelay = function (delayNotifier, value) {
        var notifierSubscription = subscribeToResult(this, delayNotifier, value);
        if (notifierSubscription && !notifierSubscription.closed) {
            var destination = this.destination;
            destination.add(notifierSubscription);
            this.delayNotifierSubscriptions.push(notifierSubscription);
        }
    };
    DelayWhenSubscriber.prototype.tryComplete = function () {
        if (this.completed && this.delayNotifierSubscriptions.length === 0) {
            this.destination.complete();
        }
    };
    return DelayWhenSubscriber;
}(OuterSubscriber));
var SubscriptionDelayObservable = /*@__PURE__*/ (function (_super) {
    __extends(SubscriptionDelayObservable, _super);
    function SubscriptionDelayObservable(source, subscriptionDelay) {
        var _this = _super.call(this) || this;
        _this.source = source;
        _this.subscriptionDelay = subscriptionDelay;
        return _this;
    }
    SubscriptionDelayObservable.prototype._subscribe = function (subscriber) {
        this.subscriptionDelay.subscribe(new SubscriptionDelaySubscriber(subscriber, this.source));
    };
    return SubscriptionDelayObservable;
}(Observable));
var SubscriptionDelaySubscriber = /*@__PURE__*/ (function (_super) {
    __extends(SubscriptionDelaySubscriber, _super);
    function SubscriptionDelaySubscriber(parent, source) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        _this.source = source;
        _this.sourceSubscribed = false;
        return _this;
    }
    SubscriptionDelaySubscriber.prototype._next = function (unused) {
        this.subscribeToSource();
    };
    SubscriptionDelaySubscriber.prototype._error = function (err) {
        this.unsubscribe();
        this.parent.error(err);
    };
    SubscriptionDelaySubscriber.prototype._complete = function () {
        this.unsubscribe();
        this.subscribeToSource();
    };
    SubscriptionDelaySubscriber.prototype.subscribeToSource = function () {
        if (!this.sourceSubscribed) {
            this.sourceSubscribed = true;
            this.unsubscribe();
            this.source.subscribe(this.parent);
        }
    };
    return SubscriptionDelaySubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */

var DeMaterializeOperator = /*@__PURE__*/ (function () {
    function DeMaterializeOperator() {
    }
    DeMaterializeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DeMaterializeSubscriber(subscriber));
    };
    return DeMaterializeOperator;
}());
var DeMaterializeSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(DeMaterializeSubscriber, _super);
    function DeMaterializeSubscriber(destination) {
        return _super.call(this, destination) || this;
    }
    DeMaterializeSubscriber.prototype._next = function (value) {
        value.observe(this.destination);
    };
    return DeMaterializeSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

var DistinctOperator = /*@__PURE__*/ (function () {
    function DistinctOperator(keySelector, flushes) {
        this.keySelector = keySelector;
        this.flushes = flushes;
    }
    DistinctOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DistinctSubscriber(subscriber, this.keySelector, this.flushes));
    };
    return DistinctOperator;
}());
var DistinctSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(DistinctSubscriber, _super);
    function DistinctSubscriber(destination, keySelector, flushes) {
        var _this = _super.call(this, destination) || this;
        _this.keySelector = keySelector;
        _this.values = new Set();
        if (flushes) {
            _this.add(subscribeToResult(_this, flushes));
        }
        return _this;
    }
    DistinctSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.values.clear();
    };
    DistinctSubscriber.prototype.notifyError = function (error, innerSub) {
        this._error(error);
    };
    DistinctSubscriber.prototype._next = function (value) {
        if (this.keySelector) {
            this._useKeySelector(value);
        }
        else {
            this._finalizeNext(value, value);
        }
    };
    DistinctSubscriber.prototype._useKeySelector = function (value) {
        var key;
        var destination = this.destination;
        try {
            key = this.keySelector(value);
        }
        catch (err) {
            destination.error(err);
            return;
        }
        this._finalizeNext(key, value);
    };
    DistinctSubscriber.prototype._finalizeNext = function (key, value) {
        var values = this.values;
        if (!values.has(key)) {
            values.add(key);
            this.destination.next(value);
        }
    };
    return DistinctSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */

var DistinctUntilChangedOperator = /*@__PURE__*/ (function () {
    function DistinctUntilChangedOperator(compare, keySelector) {
        this.compare = compare;
        this.keySelector = keySelector;
    }
    DistinctUntilChangedOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));
    };
    return DistinctUntilChangedOperator;
}());
var DistinctUntilChangedSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(DistinctUntilChangedSubscriber, _super);
    function DistinctUntilChangedSubscriber(destination, compare, keySelector) {
        var _this = _super.call(this, destination) || this;
        _this.keySelector = keySelector;
        _this.hasKey = false;
        if (typeof compare === 'function') {
            _this.compare = compare;
        }
        return _this;
    }
    DistinctUntilChangedSubscriber.prototype.compare = function (x, y) {
        return x === y;
    };
    DistinctUntilChangedSubscriber.prototype._next = function (value) {
        var key;
        try {
            var keySelector = this.keySelector;
            key = keySelector ? keySelector(value) : value;
        }
        catch (err) {
            return this.destination.error(err);
        }
        var result = false;
        if (this.hasKey) {
            try {
                var compare = this.compare;
                result = compare(this.key, key);
            }
            catch (err) {
                return this.destination.error(err);
            }
        }
        else {
            this.hasKey = true;
        }
        if (!result) {
            this.key = key;
            this.destination.next(value);
        }
    };
    return DistinctUntilChangedSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START _distinctUntilChanged PURE_IMPORTS_END */

/** PURE_IMPORTS_START tslib,_util_EmptyError,_Subscriber PURE_IMPORTS_END */
function throwIfEmpty(errorFactory) {
    if (errorFactory === void 0) {
        errorFactory = defaultErrorFactory;
    }
    return function (source) {
        return source.lift(new ThrowIfEmptyOperator(errorFactory));
    };
}
var ThrowIfEmptyOperator = /*@__PURE__*/ (function () {
    function ThrowIfEmptyOperator(errorFactory) {
        this.errorFactory = errorFactory;
    }
    ThrowIfEmptyOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ThrowIfEmptySubscriber(subscriber, this.errorFactory));
    };
    return ThrowIfEmptyOperator;
}());
var ThrowIfEmptySubscriber = /*@__PURE__*/ (function (_super) {
    __extends(ThrowIfEmptySubscriber, _super);
    function ThrowIfEmptySubscriber(destination, errorFactory) {
        var _this = _super.call(this, destination) || this;
        _this.errorFactory = errorFactory;
        _this.hasValue = false;
        return _this;
    }
    ThrowIfEmptySubscriber.prototype._next = function (value) {
        this.hasValue = true;
        this.destination.next(value);
    };
    ThrowIfEmptySubscriber.prototype._complete = function () {
        if (!this.hasValue) {
            var err = void 0;
            try {
                err = this.errorFactory();
            }
            catch (e) {
                err = e;
            }
            this.destination.error(err);
        }
        else {
            return this.destination.complete();
        }
    };
    return ThrowIfEmptySubscriber;
}(Subscriber));
function defaultErrorFactory() {
    return new EmptyError();
}

/** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError,_observable_empty PURE_IMPORTS_END */
function take(count) {
    return function (source) {
        if (count === 0) {
            return empty$1();
        }
        else {
            return source.lift(new TakeOperator(count));
        }
    };
}
var TakeOperator = /*@__PURE__*/ (function () {
    function TakeOperator(total) {
        this.total = total;
        if (this.total < 0) {
            throw new ArgumentOutOfRangeError;
        }
    }
    TakeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeSubscriber(subscriber, this.total));
    };
    return TakeOperator;
}());
var TakeSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(TakeSubscriber, _super);
    function TakeSubscriber(destination, total) {
        var _this = _super.call(this, destination) || this;
        _this.total = total;
        _this.count = 0;
        return _this;
    }
    TakeSubscriber.prototype._next = function (value) {
        var total = this.total;
        var count = ++this.count;
        if (count <= total) {
            this.destination.next(value);
            if (count === total) {
                this.destination.complete();
                this.unsubscribe();
            }
        }
    };
    return TakeSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START _util_ArgumentOutOfRangeError,_filter,_throwIfEmpty,_defaultIfEmpty,_take PURE_IMPORTS_END */

/** PURE_IMPORTS_START _observable_concat,_observable_of PURE_IMPORTS_END */

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
function every(predicate, thisArg) {
    return function (source) { return source.lift(new EveryOperator(predicate, thisArg, source)); };
}
var EveryOperator = /*@__PURE__*/ (function () {
    function EveryOperator(predicate, thisArg, source) {
        this.predicate = predicate;
        this.thisArg = thisArg;
        this.source = source;
    }
    EveryOperator.prototype.call = function (observer, source) {
        return source.subscribe(new EverySubscriber(observer, this.predicate, this.thisArg, this.source));
    };
    return EveryOperator;
}());
var EverySubscriber = /*@__PURE__*/ (function (_super) {
    __extends(EverySubscriber, _super);
    function EverySubscriber(destination, predicate, thisArg, source) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.thisArg = thisArg;
        _this.source = source;
        _this.index = 0;
        _this.thisArg = thisArg || _this;
        return _this;
    }
    EverySubscriber.prototype.notifyComplete = function (everyValueMatch) {
        this.destination.next(everyValueMatch);
        this.destination.complete();
    };
    EverySubscriber.prototype._next = function (value) {
        var result = false;
        try {
            result = this.predicate.call(this.thisArg, value, this.index++, this.source);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        if (!result) {
            this.notifyComplete(false);
        }
    };
    EverySubscriber.prototype._complete = function () {
        this.notifyComplete(true);
    };
    return EverySubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

var SwitchFirstOperator = /*@__PURE__*/ (function () {
    function SwitchFirstOperator() {
    }
    SwitchFirstOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SwitchFirstSubscriber(subscriber));
    };
    return SwitchFirstOperator;
}());
var SwitchFirstSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(SwitchFirstSubscriber, _super);
    function SwitchFirstSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.hasCompleted = false;
        _this.hasSubscription = false;
        return _this;
    }
    SwitchFirstSubscriber.prototype._next = function (value) {
        if (!this.hasSubscription) {
            this.hasSubscription = true;
            this.add(subscribeToResult(this, value));
        }
    };
    SwitchFirstSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (!this.hasSubscription) {
            this.destination.complete();
        }
    };
    SwitchFirstSubscriber.prototype.notifyComplete = function (innerSub) {
        this.remove(innerSub);
        this.hasSubscription = false;
        if (this.hasCompleted) {
            this.destination.complete();
        }
    };
    return SwitchFirstSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_OuterSubscriber,_InnerSubscriber,_util_subscribeToResult,_map,_observable_from PURE_IMPORTS_END */

var ExhaustMapOperator = /*@__PURE__*/ (function () {
    function ExhaustMapOperator(project) {
        this.project = project;
    }
    ExhaustMapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ExhaustMapSubscriber(subscriber, this.project));
    };
    return ExhaustMapOperator;
}());
var ExhaustMapSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(ExhaustMapSubscriber, _super);
    function ExhaustMapSubscriber(destination, project) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.hasSubscription = false;
        _this.hasCompleted = false;
        _this.index = 0;
        return _this;
    }
    ExhaustMapSubscriber.prototype._next = function (value) {
        if (!this.hasSubscription) {
            this.tryNext(value);
        }
    };
    ExhaustMapSubscriber.prototype.tryNext = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.hasSubscription = true;
        this._innerSub(result, value, index);
    };
    ExhaustMapSubscriber.prototype._innerSub = function (result, value, index) {
        var innerSubscriber = new InnerSubscriber(this, value, index);
        var destination = this.destination;
        destination.add(innerSubscriber);
        var innerSubscription = subscribeToResult(this, result, undefined, undefined, innerSubscriber);
        if (innerSubscription !== innerSubscriber) {
            destination.add(innerSubscription);
        }
    };
    ExhaustMapSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (!this.hasSubscription) {
            this.destination.complete();
        }
        this.unsubscribe();
    };
    ExhaustMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    ExhaustMapSubscriber.prototype.notifyError = function (err) {
        this.destination.error(err);
    };
    ExhaustMapSubscriber.prototype.notifyComplete = function (innerSub) {
        var destination = this.destination;
        destination.remove(innerSub);
        this.hasSubscription = false;
        if (this.hasCompleted) {
            this.destination.complete();
        }
    };
    return ExhaustMapSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

var ExpandOperator = /*@__PURE__*/ (function () {
    function ExpandOperator(project, concurrent, scheduler) {
        this.project = project;
        this.concurrent = concurrent;
        this.scheduler = scheduler;
    }
    ExpandOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ExpandSubscriber(subscriber, this.project, this.concurrent, this.scheduler));
    };
    return ExpandOperator;
}());
var ExpandSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(ExpandSubscriber, _super);
    function ExpandSubscriber(destination, project, concurrent, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.concurrent = concurrent;
        _this.scheduler = scheduler;
        _this.index = 0;
        _this.active = 0;
        _this.hasCompleted = false;
        if (concurrent < Number.POSITIVE_INFINITY) {
            _this.buffer = [];
        }
        return _this;
    }
    ExpandSubscriber.dispatch = function (arg) {
        var subscriber = arg.subscriber, result = arg.result, value = arg.value, index = arg.index;
        subscriber.subscribeToProjection(result, value, index);
    };
    ExpandSubscriber.prototype._next = function (value) {
        var destination = this.destination;
        if (destination.closed) {
            this._complete();
            return;
        }
        var index = this.index++;
        if (this.active < this.concurrent) {
            destination.next(value);
            try {
                var project = this.project;
                var result = project(value, index);
                if (!this.scheduler) {
                    this.subscribeToProjection(result, value, index);
                }
                else {
                    var state = { subscriber: this, result: result, value: value, index: index };
                    var destination_1 = this.destination;
                    destination_1.add(this.scheduler.schedule(ExpandSubscriber.dispatch, 0, state));
                }
            }
            catch (e) {
                destination.error(e);
            }
        }
        else {
            this.buffer.push(value);
        }
    };
    ExpandSubscriber.prototype.subscribeToProjection = function (result, value, index) {
        this.active++;
        var destination = this.destination;
        destination.add(subscribeToResult(this, result, value, index));
    };
    ExpandSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.hasCompleted && this.active === 0) {
            this.destination.complete();
        }
        this.unsubscribe();
    };
    ExpandSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this._next(innerValue);
    };
    ExpandSubscriber.prototype.notifyComplete = function (innerSub) {
        var buffer = this.buffer;
        var destination = this.destination;
        destination.remove(innerSub);
        this.active--;
        if (buffer && buffer.length > 0) {
            this._next(buffer.shift());
        }
        if (this.hasCompleted && this.active === 0) {
            this.destination.complete();
        }
    };
    return ExpandSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_Subscriber,_Subscription PURE_IMPORTS_END */
function finalize(callback) {
    return function (source) { return source.lift(new FinallyOperator(callback)); };
}
var FinallyOperator = /*@__PURE__*/ (function () {
    function FinallyOperator(callback) {
        this.callback = callback;
    }
    FinallyOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new FinallySubscriber(subscriber, this.callback));
    };
    return FinallyOperator;
}());
var FinallySubscriber = /*@__PURE__*/ (function (_super) {
    __extends(FinallySubscriber, _super);
    function FinallySubscriber(destination, callback) {
        var _this = _super.call(this, destination) || this;
        _this.add(new Subscription(callback));
        return _this;
    }
    return FinallySubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */

var FindValueOperator = /*@__PURE__*/ (function () {
    function FindValueOperator(predicate, source, yieldIndex, thisArg) {
        this.predicate = predicate;
        this.source = source;
        this.yieldIndex = yieldIndex;
        this.thisArg = thisArg;
    }
    FindValueOperator.prototype.call = function (observer, source) {
        return source.subscribe(new FindValueSubscriber(observer, this.predicate, this.source, this.yieldIndex, this.thisArg));
    };
    return FindValueOperator;
}());
var FindValueSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(FindValueSubscriber, _super);
    function FindValueSubscriber(destination, predicate, source, yieldIndex, thisArg) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.source = source;
        _this.yieldIndex = yieldIndex;
        _this.thisArg = thisArg;
        _this.index = 0;
        return _this;
    }
    FindValueSubscriber.prototype.notifyComplete = function (value) {
        var destination = this.destination;
        destination.next(value);
        destination.complete();
        this.unsubscribe();
    };
    FindValueSubscriber.prototype._next = function (value) {
        var _a = this, predicate = _a.predicate, thisArg = _a.thisArg;
        var index = this.index++;
        try {
            var result = predicate.call(thisArg || this, value, index, this.source);
            if (result) {
                this.notifyComplete(this.yieldIndex ? index : value);
            }
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    FindValueSubscriber.prototype._complete = function () {
        this.notifyComplete(this.yieldIndex ? -1 : undefined);
    };
    return FindValueSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START _operators_find PURE_IMPORTS_END */

/** PURE_IMPORTS_START _util_EmptyError,_filter,_take,_defaultIfEmpty,_throwIfEmpty,_util_identity PURE_IMPORTS_END */
function first(predicate, defaultValue) {
    var hasDefaultValue = arguments.length >= 2;
    return function (source) { return source.pipe(predicate ? filter(function (v, i) { return predicate(v, i, source); }) : identity, take(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function () { return new EmptyError(); })); };
}

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */

var IgnoreElementsOperator = /*@__PURE__*/ (function () {
    function IgnoreElementsOperator() {
    }
    IgnoreElementsOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new IgnoreElementsSubscriber(subscriber));
    };
    return IgnoreElementsOperator;
}());
var IgnoreElementsSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(IgnoreElementsSubscriber, _super);
    function IgnoreElementsSubscriber() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    IgnoreElementsSubscriber.prototype._next = function (unused) {
    };
    return IgnoreElementsSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */

var IsEmptyOperator = /*@__PURE__*/ (function () {
    function IsEmptyOperator() {
    }
    IsEmptyOperator.prototype.call = function (observer, source) {
        return source.subscribe(new IsEmptySubscriber(observer));
    };
    return IsEmptyOperator;
}());
var IsEmptySubscriber = /*@__PURE__*/ (function (_super) {
    __extends(IsEmptySubscriber, _super);
    function IsEmptySubscriber(destination) {
        return _super.call(this, destination) || this;
    }
    IsEmptySubscriber.prototype.notifyComplete = function (isEmpty) {
        var destination = this.destination;
        destination.next(isEmpty);
        destination.complete();
    };
    IsEmptySubscriber.prototype._next = function (value) {
        this.notifyComplete(false);
    };
    IsEmptySubscriber.prototype._complete = function () {
        this.notifyComplete(true);
    };
    return IsEmptySubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError,_observable_empty PURE_IMPORTS_END */
function takeLast(count) {
    return function takeLastOperatorFunction(source) {
        if (count === 0) {
            return empty$1();
        }
        else {
            return source.lift(new TakeLastOperator(count));
        }
    };
}
var TakeLastOperator = /*@__PURE__*/ (function () {
    function TakeLastOperator(total) {
        this.total = total;
        if (this.total < 0) {
            throw new ArgumentOutOfRangeError;
        }
    }
    TakeLastOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeLastSubscriber(subscriber, this.total));
    };
    return TakeLastOperator;
}());
var TakeLastSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(TakeLastSubscriber, _super);
    function TakeLastSubscriber(destination, total) {
        var _this = _super.call(this, destination) || this;
        _this.total = total;
        _this.ring = new Array();
        _this.count = 0;
        return _this;
    }
    TakeLastSubscriber.prototype._next = function (value) {
        var ring = this.ring;
        var total = this.total;
        var count = this.count++;
        if (ring.length < total) {
            ring.push(value);
        }
        else {
            var index = count % total;
            ring[index] = value;
        }
    };
    TakeLastSubscriber.prototype._complete = function () {
        var destination = this.destination;
        var count = this.count;
        if (count > 0) {
            var total = this.count >= this.total ? this.total : this.count;
            var ring = this.ring;
            for (var i = 0; i < total; i++) {
                var idx = (count++) % total;
                destination.next(ring[idx]);
            }
        }
        destination.complete();
    };
    return TakeLastSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START _util_EmptyError,_filter,_takeLast,_throwIfEmpty,_defaultIfEmpty,_util_identity PURE_IMPORTS_END */
function last(predicate, defaultValue) {
    var hasDefaultValue = arguments.length >= 2;
    return function (source) { return source.pipe(predicate ? filter(function (v, i) { return predicate(v, i, source); }) : identity, takeLast(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function () { return new EmptyError(); })); };
}

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */

var MapToOperator = /*@__PURE__*/ (function () {
    function MapToOperator(value) {
        this.value = value;
    }
    MapToOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MapToSubscriber(subscriber, this.value));
    };
    return MapToOperator;
}());
var MapToSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(MapToSubscriber, _super);
    function MapToSubscriber(destination, value) {
        var _this = _super.call(this, destination) || this;
        _this.value = value;
        return _this;
    }
    MapToSubscriber.prototype._next = function (x) {
        this.destination.next(this.value);
    };
    return MapToSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_Subscriber,_Notification PURE_IMPORTS_END */

var MaterializeOperator = /*@__PURE__*/ (function () {
    function MaterializeOperator() {
    }
    MaterializeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MaterializeSubscriber(subscriber));
    };
    return MaterializeOperator;
}());
var MaterializeSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(MaterializeSubscriber, _super);
    function MaterializeSubscriber(destination) {
        return _super.call(this, destination) || this;
    }
    MaterializeSubscriber.prototype._next = function (value) {
        this.destination.next(Notification.createNext(value));
    };
    MaterializeSubscriber.prototype._error = function (err) {
        var destination = this.destination;
        destination.next(Notification.createError(err));
        destination.complete();
    };
    MaterializeSubscriber.prototype._complete = function () {
        var destination = this.destination;
        destination.next(Notification.createComplete());
        destination.complete();
    };
    return MaterializeSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
function scan(accumulator, seed) {
    var hasSeed = false;
    if (arguments.length >= 2) {
        hasSeed = true;
    }
    return function scanOperatorFunction(source) {
        return source.lift(new ScanOperator(accumulator, seed, hasSeed));
    };
}
var ScanOperator = /*@__PURE__*/ (function () {
    function ScanOperator(accumulator, seed, hasSeed) {
        if (hasSeed === void 0) {
            hasSeed = false;
        }
        this.accumulator = accumulator;
        this.seed = seed;
        this.hasSeed = hasSeed;
    }
    ScanOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ScanSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));
    };
    return ScanOperator;
}());
var ScanSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(ScanSubscriber, _super);
    function ScanSubscriber(destination, accumulator, _seed, hasSeed) {
        var _this = _super.call(this, destination) || this;
        _this.accumulator = accumulator;
        _this._seed = _seed;
        _this.hasSeed = hasSeed;
        _this.index = 0;
        return _this;
    }
    Object.defineProperty(ScanSubscriber.prototype, "seed", {
        get: function () {
            return this._seed;
        },
        set: function (value) {
            this.hasSeed = true;
            this._seed = value;
        },
        enumerable: true,
        configurable: true
    });
    ScanSubscriber.prototype._next = function (value) {
        if (!this.hasSeed) {
            this.seed = value;
            this.destination.next(value);
        }
        else {
            return this._tryNext(value);
        }
    };
    ScanSubscriber.prototype._tryNext = function (value) {
        var index = this.index++;
        var result;
        try {
            result = this.accumulator(this.seed, value, index);
        }
        catch (err) {
            this.destination.error(err);
        }
        this.seed = result;
        this.destination.next(result);
    };
    return ScanSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START _scan,_takeLast,_defaultIfEmpty,_util_pipe PURE_IMPORTS_END */
function reduce(accumulator, seed) {
    if (arguments.length >= 2) {
        return function reduceOperatorFunctionWithSeed(source) {
            return pipe(scan(accumulator, seed), takeLast(1), defaultIfEmpty(seed))(source);
        };
    }
    return function reduceOperatorFunction(source) {
        return pipe(scan(function (acc, value, index) { return accumulator(acc, value, index + 1); }), takeLast(1))(source);
    };
}

/** PURE_IMPORTS_START _reduce PURE_IMPORTS_END */

/** PURE_IMPORTS_START _observable_merge PURE_IMPORTS_END */

/** PURE_IMPORTS_START _mergeMap PURE_IMPORTS_END */

/** PURE_IMPORTS_START tslib,_util_subscribeToResult,_OuterSubscriber,_InnerSubscriber PURE_IMPORTS_END */

var MergeScanOperator = /*@__PURE__*/ (function () {
    function MergeScanOperator(accumulator, seed, concurrent) {
        this.accumulator = accumulator;
        this.seed = seed;
        this.concurrent = concurrent;
    }
    MergeScanOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MergeScanSubscriber(subscriber, this.accumulator, this.seed, this.concurrent));
    };
    return MergeScanOperator;
}());
var MergeScanSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(MergeScanSubscriber, _super);
    function MergeScanSubscriber(destination, accumulator, acc, concurrent) {
        var _this = _super.call(this, destination) || this;
        _this.accumulator = accumulator;
        _this.acc = acc;
        _this.concurrent = concurrent;
        _this.hasValue = false;
        _this.hasCompleted = false;
        _this.buffer = [];
        _this.active = 0;
        _this.index = 0;
        return _this;
    }
    MergeScanSubscriber.prototype._next = function (value) {
        if (this.active < this.concurrent) {
            var index = this.index++;
            var destination = this.destination;
            var ish = void 0;
            try {
                var accumulator = this.accumulator;
                ish = accumulator(this.acc, value, index);
            }
            catch (e) {
                return destination.error(e);
            }
            this.active++;
            this._innerSub(ish, value, index);
        }
        else {
            this.buffer.push(value);
        }
    };
    MergeScanSubscriber.prototype._innerSub = function (ish, value, index) {
        var innerSubscriber = new InnerSubscriber(this, value, index);
        var destination = this.destination;
        destination.add(innerSubscriber);
        var innerSubscription = subscribeToResult(this, ish, undefined, undefined, innerSubscriber);
        if (innerSubscription !== innerSubscriber) {
            destination.add(innerSubscription);
        }
    };
    MergeScanSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
            if (this.hasValue === false) {
                this.destination.next(this.acc);
            }
            this.destination.complete();
        }
        this.unsubscribe();
    };
    MergeScanSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var destination = this.destination;
        this.acc = innerValue;
        this.hasValue = true;
        destination.next(innerValue);
    };
    MergeScanSubscriber.prototype.notifyComplete = function (innerSub) {
        var buffer = this.buffer;
        var destination = this.destination;
        destination.remove(innerSub);
        this.active--;
        if (buffer.length > 0) {
            this._next(buffer.shift());
        }
        else if (this.active === 0 && this.hasCompleted) {
            if (this.hasValue === false) {
                this.destination.next(this.acc);
            }
            this.destination.complete();
        }
    };
    return MergeScanSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START _reduce PURE_IMPORTS_END */

/** PURE_IMPORTS_START _observable_ConnectableObservable PURE_IMPORTS_END */

var MulticastOperator = /*@__PURE__*/ (function () {
    function MulticastOperator(subjectFactory, selector) {
        this.subjectFactory = subjectFactory;
        this.selector = selector;
    }
    MulticastOperator.prototype.call = function (subscriber, source) {
        var selector = this.selector;
        var subject = this.subjectFactory();
        var subscription = selector(subject).subscribe(subscriber);
        subscription.add(source.subscribe(subject));
        return subscription;
    };
    return MulticastOperator;
}());

/** PURE_IMPORTS_START tslib,_observable_from,_util_isArray,_OuterSubscriber,_InnerSubscriber,_util_subscribeToResult PURE_IMPORTS_END */


var OnErrorResumeNextOperator = /*@__PURE__*/ (function () {
    function OnErrorResumeNextOperator(nextSources) {
        this.nextSources = nextSources;
    }
    OnErrorResumeNextOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new OnErrorResumeNextSubscriber(subscriber, this.nextSources));
    };
    return OnErrorResumeNextOperator;
}());
var OnErrorResumeNextSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(OnErrorResumeNextSubscriber, _super);
    function OnErrorResumeNextSubscriber(destination, nextSources) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.nextSources = nextSources;
        return _this;
    }
    OnErrorResumeNextSubscriber.prototype.notifyError = function (error, innerSub) {
        this.subscribeToNextSource();
    };
    OnErrorResumeNextSubscriber.prototype.notifyComplete = function (innerSub) {
        this.subscribeToNextSource();
    };
    OnErrorResumeNextSubscriber.prototype._error = function (err) {
        this.subscribeToNextSource();
        this.unsubscribe();
    };
    OnErrorResumeNextSubscriber.prototype._complete = function () {
        this.subscribeToNextSource();
        this.unsubscribe();
    };
    OnErrorResumeNextSubscriber.prototype.subscribeToNextSource = function () {
        var next = this.nextSources.shift();
        if (!!next) {
            var innerSubscriber = new InnerSubscriber(this, undefined, undefined);
            var destination = this.destination;
            destination.add(innerSubscriber);
            var innerSubscription = subscribeToResult(this, next, undefined, undefined, innerSubscriber);
            if (innerSubscription !== innerSubscriber) {
                destination.add(innerSubscription);
            }
        }
        else {
            this.destination.complete();
        }
    };
    return OnErrorResumeNextSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */

var PairwiseOperator = /*@__PURE__*/ (function () {
    function PairwiseOperator() {
    }
    PairwiseOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new PairwiseSubscriber(subscriber));
    };
    return PairwiseOperator;
}());
var PairwiseSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(PairwiseSubscriber, _super);
    function PairwiseSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.hasPrev = false;
        return _this;
    }
    PairwiseSubscriber.prototype._next = function (value) {
        var pair;
        if (this.hasPrev) {
            pair = [this.prev, value];
        }
        else {
            this.hasPrev = true;
        }
        this.prev = value;
        if (pair) {
            this.destination.next(pair);
        }
    };
    return PairwiseSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START _util_not,_filter PURE_IMPORTS_END */

/** PURE_IMPORTS_START _map PURE_IMPORTS_END */

/** PURE_IMPORTS_START _Subject,_multicast PURE_IMPORTS_END */

/** PURE_IMPORTS_START _BehaviorSubject,_multicast PURE_IMPORTS_END */

/** PURE_IMPORTS_START _AsyncSubject,_multicast PURE_IMPORTS_END */

/** PURE_IMPORTS_START _ReplaySubject,_multicast PURE_IMPORTS_END */

/** PURE_IMPORTS_START _util_isArray,_observable_race PURE_IMPORTS_END */

/** PURE_IMPORTS_START tslib,_Subscriber,_observable_empty PURE_IMPORTS_END */

var RepeatOperator = /*@__PURE__*/ (function () {
    function RepeatOperator(count, source) {
        this.count = count;
        this.source = source;
    }
    RepeatOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RepeatSubscriber(subscriber, this.count, this.source));
    };
    return RepeatOperator;
}());
var RepeatSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(RepeatSubscriber, _super);
    function RepeatSubscriber(destination, count, source) {
        var _this = _super.call(this, destination) || this;
        _this.count = count;
        _this.source = source;
        return _this;
    }
    RepeatSubscriber.prototype.complete = function () {
        if (!this.isStopped) {
            var _a = this, source = _a.source, count = _a.count;
            if (count === 0) {
                return _super.prototype.complete.call(this);
            }
            else if (count > -1) {
                this.count = count - 1;
            }
            source.subscribe(this._unsubscribeAndRecycle());
        }
    };
    return RepeatSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_Subject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

var RepeatWhenOperator = /*@__PURE__*/ (function () {
    function RepeatWhenOperator(notifier) {
        this.notifier = notifier;
    }
    RepeatWhenOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RepeatWhenSubscriber(subscriber, this.notifier, source));
    };
    return RepeatWhenOperator;
}());
var RepeatWhenSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(RepeatWhenSubscriber, _super);
    function RepeatWhenSubscriber(destination, notifier, source) {
        var _this = _super.call(this, destination) || this;
        _this.notifier = notifier;
        _this.source = source;
        _this.sourceIsBeingSubscribedTo = true;
        return _this;
    }
    RepeatWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.sourceIsBeingSubscribedTo = true;
        this.source.subscribe(this);
    };
    RepeatWhenSubscriber.prototype.notifyComplete = function (innerSub) {
        if (this.sourceIsBeingSubscribedTo === false) {
            return _super.prototype.complete.call(this);
        }
    };
    RepeatWhenSubscriber.prototype.complete = function () {
        this.sourceIsBeingSubscribedTo = false;
        if (!this.isStopped) {
            if (!this.retries) {
                this.subscribeToRetries();
            }
            if (!this.retriesSubscription || this.retriesSubscription.closed) {
                return _super.prototype.complete.call(this);
            }
            this._unsubscribeAndRecycle();
            this.notifications.next();
        }
    };
    RepeatWhenSubscriber.prototype._unsubscribe = function () {
        var _a = this, notifications = _a.notifications, retriesSubscription = _a.retriesSubscription;
        if (notifications) {
            notifications.unsubscribe();
            this.notifications = null;
        }
        if (retriesSubscription) {
            retriesSubscription.unsubscribe();
            this.retriesSubscription = null;
        }
        this.retries = null;
    };
    RepeatWhenSubscriber.prototype._unsubscribeAndRecycle = function () {
        var _unsubscribe = this._unsubscribe;
        this._unsubscribe = null;
        _super.prototype._unsubscribeAndRecycle.call(this);
        this._unsubscribe = _unsubscribe;
        return this;
    };
    RepeatWhenSubscriber.prototype.subscribeToRetries = function () {
        this.notifications = new Subject();
        var retries;
        try {
            var notifier = this.notifier;
            retries = notifier(this.notifications);
        }
        catch (e) {
            return _super.prototype.complete.call(this);
        }
        this.retries = retries;
        this.retriesSubscription = subscribeToResult(this, retries);
    };
    return RepeatWhenSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */

var RetryOperator = /*@__PURE__*/ (function () {
    function RetryOperator(count, source) {
        this.count = count;
        this.source = source;
    }
    RetryOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RetrySubscriber(subscriber, this.count, this.source));
    };
    return RetryOperator;
}());
var RetrySubscriber = /*@__PURE__*/ (function (_super) {
    __extends(RetrySubscriber, _super);
    function RetrySubscriber(destination, count, source) {
        var _this = _super.call(this, destination) || this;
        _this.count = count;
        _this.source = source;
        return _this;
    }
    RetrySubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var _a = this, source = _a.source, count = _a.count;
            if (count === 0) {
                return _super.prototype.error.call(this, err);
            }
            else if (count > -1) {
                this.count = count - 1;
            }
            source.subscribe(this._unsubscribeAndRecycle());
        }
    };
    return RetrySubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_Subject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

var RetryWhenOperator = /*@__PURE__*/ (function () {
    function RetryWhenOperator(notifier, source) {
        this.notifier = notifier;
        this.source = source;
    }
    RetryWhenOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RetryWhenSubscriber(subscriber, this.notifier, this.source));
    };
    return RetryWhenOperator;
}());
var RetryWhenSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(RetryWhenSubscriber, _super);
    function RetryWhenSubscriber(destination, notifier, source) {
        var _this = _super.call(this, destination) || this;
        _this.notifier = notifier;
        _this.source = source;
        return _this;
    }
    RetryWhenSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var errors = this.errors;
            var retries = this.retries;
            var retriesSubscription = this.retriesSubscription;
            if (!retries) {
                errors = new Subject();
                try {
                    var notifier = this.notifier;
                    retries = notifier(errors);
                }
                catch (e) {
                    return _super.prototype.error.call(this, e);
                }
                retriesSubscription = subscribeToResult(this, retries);
            }
            else {
                this.errors = null;
                this.retriesSubscription = null;
            }
            this._unsubscribeAndRecycle();
            this.errors = errors;
            this.retries = retries;
            this.retriesSubscription = retriesSubscription;
            errors.next(err);
        }
    };
    RetryWhenSubscriber.prototype._unsubscribe = function () {
        var _a = this, errors = _a.errors, retriesSubscription = _a.retriesSubscription;
        if (errors) {
            errors.unsubscribe();
            this.errors = null;
        }
        if (retriesSubscription) {
            retriesSubscription.unsubscribe();
            this.retriesSubscription = null;
        }
        this.retries = null;
    };
    RetryWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var _unsubscribe = this._unsubscribe;
        this._unsubscribe = null;
        this._unsubscribeAndRecycle();
        this._unsubscribe = _unsubscribe;
        this.source.subscribe(this);
    };
    return RetryWhenSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

var SampleOperator = /*@__PURE__*/ (function () {
    function SampleOperator(notifier) {
        this.notifier = notifier;
    }
    SampleOperator.prototype.call = function (subscriber, source) {
        var sampleSubscriber = new SampleSubscriber(subscriber);
        var subscription = source.subscribe(sampleSubscriber);
        subscription.add(subscribeToResult(sampleSubscriber, this.notifier));
        return subscription;
    };
    return SampleOperator;
}());
var SampleSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(SampleSubscriber, _super);
    function SampleSubscriber() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.hasValue = false;
        return _this;
    }
    SampleSubscriber.prototype._next = function (value) {
        this.value = value;
        this.hasValue = true;
    };
    SampleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.emitValue();
    };
    SampleSubscriber.prototype.notifyComplete = function () {
        this.emitValue();
    };
    SampleSubscriber.prototype.emitValue = function () {
        if (this.hasValue) {
            this.hasValue = false;
            this.destination.next(this.value);
        }
    };
    return SampleSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_Subscriber,_scheduler_async PURE_IMPORTS_END */

var SampleTimeOperator = /*@__PURE__*/ (function () {
    function SampleTimeOperator(period, scheduler) {
        this.period = period;
        this.scheduler = scheduler;
    }
    SampleTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SampleTimeSubscriber(subscriber, this.period, this.scheduler));
    };
    return SampleTimeOperator;
}());
var SampleTimeSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(SampleTimeSubscriber, _super);
    function SampleTimeSubscriber(destination, period, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.period = period;
        _this.scheduler = scheduler;
        _this.hasValue = false;
        _this.add(scheduler.schedule(dispatchNotification, period, { subscriber: _this, period: period }));
        return _this;
    }
    SampleTimeSubscriber.prototype._next = function (value) {
        this.lastValue = value;
        this.hasValue = true;
    };
    SampleTimeSubscriber.prototype.notifyNext = function () {
        if (this.hasValue) {
            this.hasValue = false;
            this.destination.next(this.lastValue);
        }
    };
    return SampleTimeSubscriber;
}(Subscriber));
function dispatchNotification(state) {
    var subscriber = state.subscriber, period = state.period;
    subscriber.notifyNext();
    this.schedule(state, period);
}

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */

var SequenceEqualOperator = /*@__PURE__*/ (function () {
    function SequenceEqualOperator(compareTo, comparator) {
        this.compareTo = compareTo;
        this.comparator = comparator;
    }
    SequenceEqualOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SequenceEqualSubscriber(subscriber, this.compareTo, this.comparator));
    };
    return SequenceEqualOperator;
}());
var SequenceEqualSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(SequenceEqualSubscriber, _super);
    function SequenceEqualSubscriber(destination, compareTo, comparator) {
        var _this = _super.call(this, destination) || this;
        _this.compareTo = compareTo;
        _this.comparator = comparator;
        _this._a = [];
        _this._b = [];
        _this._oneComplete = false;
        _this.destination.add(compareTo.subscribe(new SequenceEqualCompareToSubscriber(destination, _this)));
        return _this;
    }
    SequenceEqualSubscriber.prototype._next = function (value) {
        if (this._oneComplete && this._b.length === 0) {
            this.emit(false);
        }
        else {
            this._a.push(value);
            this.checkValues();
        }
    };
    SequenceEqualSubscriber.prototype._complete = function () {
        if (this._oneComplete) {
            this.emit(this._a.length === 0 && this._b.length === 0);
        }
        else {
            this._oneComplete = true;
        }
        this.unsubscribe();
    };
    SequenceEqualSubscriber.prototype.checkValues = function () {
        var _c = this, _a = _c._a, _b = _c._b, comparator = _c.comparator;
        while (_a.length > 0 && _b.length > 0) {
            var a = _a.shift();
            var b = _b.shift();
            var areEqual = false;
            try {
                areEqual = comparator ? comparator(a, b) : a === b;
            }
            catch (e) {
                this.destination.error(e);
            }
            if (!areEqual) {
                this.emit(false);
            }
        }
    };
    SequenceEqualSubscriber.prototype.emit = function (value) {
        var destination = this.destination;
        destination.next(value);
        destination.complete();
    };
    SequenceEqualSubscriber.prototype.nextB = function (value) {
        if (this._oneComplete && this._a.length === 0) {
            this.emit(false);
        }
        else {
            this._b.push(value);
            this.checkValues();
        }
    };
    SequenceEqualSubscriber.prototype.completeB = function () {
        if (this._oneComplete) {
            this.emit(this._a.length === 0 && this._b.length === 0);
        }
        else {
            this._oneComplete = true;
        }
    };
    return SequenceEqualSubscriber;
}(Subscriber));
var SequenceEqualCompareToSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(SequenceEqualCompareToSubscriber, _super);
    function SequenceEqualCompareToSubscriber(destination, parent) {
        var _this = _super.call(this, destination) || this;
        _this.parent = parent;
        return _this;
    }
    SequenceEqualCompareToSubscriber.prototype._next = function (value) {
        this.parent.nextB(value);
    };
    SequenceEqualCompareToSubscriber.prototype._error = function (err) {
        this.parent.error(err);
        this.unsubscribe();
    };
    SequenceEqualCompareToSubscriber.prototype._complete = function () {
        this.parent.completeB();
        this.unsubscribe();
    };
    return SequenceEqualCompareToSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START _multicast,_refCount,_Subject PURE_IMPORTS_END */

/** PURE_IMPORTS_START _ReplaySubject PURE_IMPORTS_END */

/** PURE_IMPORTS_START tslib,_Subscriber,_util_EmptyError PURE_IMPORTS_END */

var SingleOperator = /*@__PURE__*/ (function () {
    function SingleOperator(predicate, source) {
        this.predicate = predicate;
        this.source = source;
    }
    SingleOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SingleSubscriber(subscriber, this.predicate, this.source));
    };
    return SingleOperator;
}());
var SingleSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(SingleSubscriber, _super);
    function SingleSubscriber(destination, predicate, source) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.source = source;
        _this.seenValue = false;
        _this.index = 0;
        return _this;
    }
    SingleSubscriber.prototype.applySingleValue = function (value) {
        if (this.seenValue) {
            this.destination.error('Sequence contains more than one element');
        }
        else {
            this.seenValue = true;
            this.singleValue = value;
        }
    };
    SingleSubscriber.prototype._next = function (value) {
        var index = this.index++;
        if (this.predicate) {
            this.tryNext(value, index);
        }
        else {
            this.applySingleValue(value);
        }
    };
    SingleSubscriber.prototype.tryNext = function (value, index) {
        try {
            if (this.predicate(value, index, this.source)) {
                this.applySingleValue(value);
            }
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    SingleSubscriber.prototype._complete = function () {
        var destination = this.destination;
        if (this.index > 0) {
            destination.next(this.seenValue ? this.singleValue : undefined);
            destination.complete();
        }
        else {
            destination.error(new EmptyError);
        }
    };
    return SingleSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */

var SkipOperator = /*@__PURE__*/ (function () {
    function SkipOperator(total) {
        this.total = total;
    }
    SkipOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SkipSubscriber(subscriber, this.total));
    };
    return SkipOperator;
}());
var SkipSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(SkipSubscriber, _super);
    function SkipSubscriber(destination, total) {
        var _this = _super.call(this, destination) || this;
        _this.total = total;
        _this.count = 0;
        return _this;
    }
    SkipSubscriber.prototype._next = function (x) {
        if (++this.count > this.total) {
            this.destination.next(x);
        }
    };
    return SkipSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError PURE_IMPORTS_END */

var SkipLastOperator = /*@__PURE__*/ (function () {
    function SkipLastOperator(_skipCount) {
        this._skipCount = _skipCount;
        if (this._skipCount < 0) {
            throw new ArgumentOutOfRangeError;
        }
    }
    SkipLastOperator.prototype.call = function (subscriber, source) {
        if (this._skipCount === 0) {
            return source.subscribe(new Subscriber(subscriber));
        }
        else {
            return source.subscribe(new SkipLastSubscriber(subscriber, this._skipCount));
        }
    };
    return SkipLastOperator;
}());
var SkipLastSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(SkipLastSubscriber, _super);
    function SkipLastSubscriber(destination, _skipCount) {
        var _this = _super.call(this, destination) || this;
        _this._skipCount = _skipCount;
        _this._count = 0;
        _this._ring = new Array(_skipCount);
        return _this;
    }
    SkipLastSubscriber.prototype._next = function (value) {
        var skipCount = this._skipCount;
        var count = this._count++;
        if (count < skipCount) {
            this._ring[count] = value;
        }
        else {
            var currentIndex = count % skipCount;
            var ring = this._ring;
            var oldValue = ring[currentIndex];
            ring[currentIndex] = value;
            this.destination.next(oldValue);
        }
    };
    return SkipLastSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_OuterSubscriber,_InnerSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

var SkipUntilOperator = /*@__PURE__*/ (function () {
    function SkipUntilOperator(notifier) {
        this.notifier = notifier;
    }
    SkipUntilOperator.prototype.call = function (destination, source) {
        return source.subscribe(new SkipUntilSubscriber(destination, this.notifier));
    };
    return SkipUntilOperator;
}());
var SkipUntilSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(SkipUntilSubscriber, _super);
    function SkipUntilSubscriber(destination, notifier) {
        var _this = _super.call(this, destination) || this;
        _this.hasValue = false;
        var innerSubscriber = new InnerSubscriber(_this, undefined, undefined);
        _this.add(innerSubscriber);
        _this.innerSubscription = innerSubscriber;
        var innerSubscription = subscribeToResult(_this, notifier, undefined, undefined, innerSubscriber);
        if (innerSubscription !== innerSubscriber) {
            _this.add(innerSubscription);
            _this.innerSubscription = innerSubscription;
        }
        return _this;
    }
    SkipUntilSubscriber.prototype._next = function (value) {
        if (this.hasValue) {
            _super.prototype._next.call(this, value);
        }
    };
    SkipUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.hasValue = true;
        if (this.innerSubscription) {
            this.innerSubscription.unsubscribe();
        }
    };
    SkipUntilSubscriber.prototype.notifyComplete = function () {
    };
    return SkipUntilSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */

var SkipWhileOperator = /*@__PURE__*/ (function () {
    function SkipWhileOperator(predicate) {
        this.predicate = predicate;
    }
    SkipWhileOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SkipWhileSubscriber(subscriber, this.predicate));
    };
    return SkipWhileOperator;
}());
var SkipWhileSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(SkipWhileSubscriber, _super);
    function SkipWhileSubscriber(destination, predicate) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.skipping = true;
        _this.index = 0;
        return _this;
    }
    SkipWhileSubscriber.prototype._next = function (value) {
        var destination = this.destination;
        if (this.skipping) {
            this.tryCallPredicate(value);
        }
        if (!this.skipping) {
            destination.next(value);
        }
    };
    SkipWhileSubscriber.prototype.tryCallPredicate = function (value) {
        try {
            var result = this.predicate(value, this.index++);
            this.skipping = Boolean(result);
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    return SkipWhileSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START _observable_concat,_util_isScheduler PURE_IMPORTS_END */
function startWith() {
    var array = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        array[_i] = arguments[_i];
    }
    var scheduler = array[array.length - 1];
    if (isScheduler(scheduler)) {
        array.pop();
        return function (source) { return concat(array, source, scheduler); };
    }
    else {
        return function (source) { return concat(array, source); };
    }
}

/** PURE_IMPORTS_START tslib,_Observable,_scheduler_asap,_util_isNumeric PURE_IMPORTS_END */
var SubscribeOnObservable = /*@__PURE__*/ (function (_super) {
    __extends(SubscribeOnObservable, _super);
    function SubscribeOnObservable(source, delayTime, scheduler) {
        if (delayTime === void 0) {
            delayTime = 0;
        }
        if (scheduler === void 0) {
            scheduler = asap;
        }
        var _this = _super.call(this) || this;
        _this.source = source;
        _this.delayTime = delayTime;
        _this.scheduler = scheduler;
        if (!isNumeric(delayTime) || delayTime < 0) {
            _this.delayTime = 0;
        }
        if (!scheduler || typeof scheduler.schedule !== 'function') {
            _this.scheduler = asap;
        }
        return _this;
    }
    SubscribeOnObservable.create = function (source, delay, scheduler) {
        if (delay === void 0) {
            delay = 0;
        }
        if (scheduler === void 0) {
            scheduler = asap;
        }
        return new SubscribeOnObservable(source, delay, scheduler);
    };
    SubscribeOnObservable.dispatch = function (arg) {
        var source = arg.source, subscriber = arg.subscriber;
        return this.add(source.subscribe(subscriber));
    };
    SubscribeOnObservable.prototype._subscribe = function (subscriber) {
        var delay = this.delayTime;
        var source = this.source;
        var scheduler = this.scheduler;
        return scheduler.schedule(SubscribeOnObservable.dispatch, delay, {
            source: source, subscriber: subscriber
        });
    };
    return SubscribeOnObservable;
}(Observable));

/** PURE_IMPORTS_START _observable_SubscribeOnObservable PURE_IMPORTS_END */

var SubscribeOnOperator = /*@__PURE__*/ (function () {
    function SubscribeOnOperator(scheduler, delay) {
        this.scheduler = scheduler;
        this.delay = delay;
    }
    SubscribeOnOperator.prototype.call = function (subscriber, source) {
        return new SubscribeOnObservable(source, this.delay, this.scheduler).subscribe(subscriber);
    };
    return SubscribeOnOperator;
}());

/** PURE_IMPORTS_START tslib,_OuterSubscriber,_InnerSubscriber,_util_subscribeToResult,_map,_observable_from PURE_IMPORTS_END */
function switchMap(project, resultSelector) {
    if (typeof resultSelector === 'function') {
        return function (source) { return source.pipe(switchMap(function (a, i) { return from(project(a, i)).pipe(map(function (b, ii) { return resultSelector(a, b, i, ii); })); })); };
    }
    return function (source) { return source.lift(new SwitchMapOperator(project)); };
}
var SwitchMapOperator = /*@__PURE__*/ (function () {
    function SwitchMapOperator(project) {
        this.project = project;
    }
    SwitchMapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SwitchMapSubscriber(subscriber, this.project));
    };
    return SwitchMapOperator;
}());
var SwitchMapSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(SwitchMapSubscriber, _super);
    function SwitchMapSubscriber(destination, project) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.index = 0;
        return _this;
    }
    SwitchMapSubscriber.prototype._next = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        }
        catch (error) {
            this.destination.error(error);
            return;
        }
        this._innerSub(result, value, index);
    };
    SwitchMapSubscriber.prototype._innerSub = function (result, value, index) {
        var innerSubscription = this.innerSubscription;
        if (innerSubscription) {
            innerSubscription.unsubscribe();
        }
        var innerSubscriber = new InnerSubscriber(this, value, index);
        var destination = this.destination;
        destination.add(innerSubscriber);
        this.innerSubscription = subscribeToResult(this, result, undefined, undefined, innerSubscriber);
        if (this.innerSubscription !== innerSubscriber) {
            destination.add(this.innerSubscription);
        }
    };
    SwitchMapSubscriber.prototype._complete = function () {
        var innerSubscription = this.innerSubscription;
        if (!innerSubscription || innerSubscription.closed) {
            _super.prototype._complete.call(this);
        }
        this.unsubscribe();
    };
    SwitchMapSubscriber.prototype._unsubscribe = function () {
        this.innerSubscription = null;
    };
    SwitchMapSubscriber.prototype.notifyComplete = function (innerSub) {
        var destination = this.destination;
        destination.remove(innerSub);
        this.innerSubscription = null;
        if (this.isStopped) {
            _super.prototype._complete.call(this);
        }
    };
    SwitchMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    return SwitchMapSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START _switchMap,_util_identity PURE_IMPORTS_END */

/** PURE_IMPORTS_START _switchMap PURE_IMPORTS_END */

/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

var TakeUntilOperator = /*@__PURE__*/ (function () {
    function TakeUntilOperator(notifier) {
        this.notifier = notifier;
    }
    TakeUntilOperator.prototype.call = function (subscriber, source) {
        var takeUntilSubscriber = new TakeUntilSubscriber(subscriber);
        var notifierSubscription = subscribeToResult(takeUntilSubscriber, this.notifier);
        if (notifierSubscription && !takeUntilSubscriber.seenValue) {
            takeUntilSubscriber.add(notifierSubscription);
            return source.subscribe(takeUntilSubscriber);
        }
        return takeUntilSubscriber;
    };
    return TakeUntilOperator;
}());
var TakeUntilSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(TakeUntilSubscriber, _super);
    function TakeUntilSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.seenValue = false;
        return _this;
    }
    TakeUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.seenValue = true;
        this.complete();
    };
    TakeUntilSubscriber.prototype.notifyComplete = function () {
    };
    return TakeUntilSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */

var TakeWhileOperator = /*@__PURE__*/ (function () {
    function TakeWhileOperator(predicate, inclusive) {
        this.predicate = predicate;
        this.inclusive = inclusive;
    }
    TakeWhileOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeWhileSubscriber(subscriber, this.predicate, this.inclusive));
    };
    return TakeWhileOperator;
}());
var TakeWhileSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(TakeWhileSubscriber, _super);
    function TakeWhileSubscriber(destination, predicate, inclusive) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.inclusive = inclusive;
        _this.index = 0;
        return _this;
    }
    TakeWhileSubscriber.prototype._next = function (value) {
        var destination = this.destination;
        var result;
        try {
            result = this.predicate(value, this.index++);
        }
        catch (err) {
            destination.error(err);
            return;
        }
        this.nextOrComplete(value, result);
    };
    TakeWhileSubscriber.prototype.nextOrComplete = function (value, predicateResult) {
        var destination = this.destination;
        if (Boolean(predicateResult)) {
            destination.next(value);
        }
        else {
            if (this.inclusive) {
                destination.next(value);
            }
            destination.complete();
        }
    };
    return TakeWhileSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_Subscriber,_util_noop,_util_isFunction PURE_IMPORTS_END */
function tap(nextOrObserver, error, complete) {
    return function tapOperatorFunction(source) {
        return source.lift(new DoOperator(nextOrObserver, error, complete));
    };
}
var DoOperator = /*@__PURE__*/ (function () {
    function DoOperator(nextOrObserver, error, complete) {
        this.nextOrObserver = nextOrObserver;
        this.error = error;
        this.complete = complete;
    }
    DoOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TapSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));
    };
    return DoOperator;
}());
var TapSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(TapSubscriber, _super);
    function TapSubscriber(destination, observerOrNext, error, complete) {
        var _this = _super.call(this, destination) || this;
        _this._tapNext = noop;
        _this._tapError = noop;
        _this._tapComplete = noop;
        _this._tapError = error || noop;
        _this._tapComplete = complete || noop;
        if (isFunction(observerOrNext)) {
            _this._context = _this;
            _this._tapNext = observerOrNext;
        }
        else if (observerOrNext) {
            _this._context = observerOrNext;
            _this._tapNext = observerOrNext.next || noop;
            _this._tapError = observerOrNext.error || noop;
            _this._tapComplete = observerOrNext.complete || noop;
        }
        return _this;
    }
    TapSubscriber.prototype._next = function (value) {
        try {
            this._tapNext.call(this._context, value);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(value);
    };
    TapSubscriber.prototype._error = function (err) {
        try {
            this._tapError.call(this._context, err);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.error(err);
    };
    TapSubscriber.prototype._complete = function () {
        try {
            this._tapComplete.call(this._context);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        return this.destination.complete();
    };
    return TapSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */


var ThrottleOperator = /*@__PURE__*/ (function () {
    function ThrottleOperator(durationSelector, leading, trailing) {
        this.durationSelector = durationSelector;
        this.leading = leading;
        this.trailing = trailing;
    }
    ThrottleOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ThrottleSubscriber(subscriber, this.durationSelector, this.leading, this.trailing));
    };
    return ThrottleOperator;
}());
var ThrottleSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(ThrottleSubscriber, _super);
    function ThrottleSubscriber(destination, durationSelector, _leading, _trailing) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.durationSelector = durationSelector;
        _this._leading = _leading;
        _this._trailing = _trailing;
        _this._hasValue = false;
        return _this;
    }
    ThrottleSubscriber.prototype._next = function (value) {
        this._hasValue = true;
        this._sendValue = value;
        if (!this._throttled) {
            if (this._leading) {
                this.send();
            }
            else {
                this.throttle(value);
            }
        }
    };
    ThrottleSubscriber.prototype.send = function () {
        var _a = this, _hasValue = _a._hasValue, _sendValue = _a._sendValue;
        if (_hasValue) {
            this.destination.next(_sendValue);
            this.throttle(_sendValue);
        }
        this._hasValue = false;
        this._sendValue = null;
    };
    ThrottleSubscriber.prototype.throttle = function (value) {
        var duration = this.tryDurationSelector(value);
        if (!!duration) {
            this.add(this._throttled = subscribeToResult(this, duration));
        }
    };
    ThrottleSubscriber.prototype.tryDurationSelector = function (value) {
        try {
            return this.durationSelector(value);
        }
        catch (err) {
            this.destination.error(err);
            return null;
        }
    };
    ThrottleSubscriber.prototype.throttlingDone = function () {
        var _a = this, _throttled = _a._throttled, _trailing = _a._trailing;
        if (_throttled) {
            _throttled.unsubscribe();
        }
        this._throttled = null;
        if (_trailing) {
            this.send();
        }
    };
    ThrottleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.throttlingDone();
    };
    ThrottleSubscriber.prototype.notifyComplete = function () {
        this.throttlingDone();
    };
    return ThrottleSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_Subscriber,_scheduler_async,_throttle PURE_IMPORTS_END */

var ThrottleTimeOperator = /*@__PURE__*/ (function () {
    function ThrottleTimeOperator(duration, scheduler, leading, trailing) {
        this.duration = duration;
        this.scheduler = scheduler;
        this.leading = leading;
        this.trailing = trailing;
    }
    ThrottleTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ThrottleTimeSubscriber(subscriber, this.duration, this.scheduler, this.leading, this.trailing));
    };
    return ThrottleTimeOperator;
}());
var ThrottleTimeSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(ThrottleTimeSubscriber, _super);
    function ThrottleTimeSubscriber(destination, duration, scheduler, leading, trailing) {
        var _this = _super.call(this, destination) || this;
        _this.duration = duration;
        _this.scheduler = scheduler;
        _this.leading = leading;
        _this.trailing = trailing;
        _this._hasTrailingValue = false;
        _this._trailingValue = null;
        return _this;
    }
    ThrottleTimeSubscriber.prototype._next = function (value) {
        if (this.throttled) {
            if (this.trailing) {
                this._trailingValue = value;
                this._hasTrailingValue = true;
            }
        }
        else {
            this.add(this.throttled = this.scheduler.schedule(dispatchNext$3, this.duration, { subscriber: this }));
            if (this.leading) {
                this.destination.next(value);
            }
            else if (this.trailing) {
                this._trailingValue = value;
                this._hasTrailingValue = true;
            }
        }
    };
    ThrottleTimeSubscriber.prototype._complete = function () {
        if (this._hasTrailingValue) {
            this.destination.next(this._trailingValue);
            this.destination.complete();
        }
        else {
            this.destination.complete();
        }
    };
    ThrottleTimeSubscriber.prototype.clearThrottle = function () {
        var throttled = this.throttled;
        if (throttled) {
            if (this.trailing && this._hasTrailingValue) {
                this.destination.next(this._trailingValue);
                this._trailingValue = null;
                this._hasTrailingValue = false;
            }
            throttled.unsubscribe();
            this.remove(throttled);
            this.throttled = null;
        }
    };
    return ThrottleTimeSubscriber;
}(Subscriber));
function dispatchNext$3(arg) {
    var subscriber = arg.subscriber;
    subscriber.clearThrottle();
}

/** PURE_IMPORTS_START _scheduler_async,_scan,_observable_defer,_map PURE_IMPORTS_END */

/** PURE_IMPORTS_START tslib,_scheduler_async,_util_isDate,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

var TimeoutWithOperator = /*@__PURE__*/ (function () {
    function TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler) {
        this.waitFor = waitFor;
        this.absoluteTimeout = absoluteTimeout;
        this.withObservable = withObservable;
        this.scheduler = scheduler;
    }
    TimeoutWithOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TimeoutWithSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));
    };
    return TimeoutWithOperator;
}());
var TimeoutWithSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(TimeoutWithSubscriber, _super);
    function TimeoutWithSubscriber(destination, absoluteTimeout, waitFor, withObservable, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.absoluteTimeout = absoluteTimeout;
        _this.waitFor = waitFor;
        _this.withObservable = withObservable;
        _this.scheduler = scheduler;
        _this.action = null;
        _this.scheduleTimeout();
        return _this;
    }
    TimeoutWithSubscriber.dispatchTimeout = function (subscriber) {
        var withObservable = subscriber.withObservable;
        subscriber._unsubscribeAndRecycle();
        subscriber.add(subscribeToResult(subscriber, withObservable));
    };
    TimeoutWithSubscriber.prototype.scheduleTimeout = function () {
        var action = this.action;
        if (action) {
            this.action = action.schedule(this, this.waitFor);
        }
        else {
            this.add(this.action = this.scheduler.schedule(TimeoutWithSubscriber.dispatchTimeout, this.waitFor, this));
        }
    };
    TimeoutWithSubscriber.prototype._next = function (value) {
        if (!this.absoluteTimeout) {
            this.scheduleTimeout();
        }
        _super.prototype._next.call(this, value);
    };
    TimeoutWithSubscriber.prototype._unsubscribe = function () {
        this.action = null;
        this.scheduler = null;
        this.withObservable = null;
    };
    return TimeoutWithSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START _scheduler_async,_util_TimeoutError,_timeoutWith,_observable_throwError PURE_IMPORTS_END */

/** PURE_IMPORTS_START _scheduler_async,_map PURE_IMPORTS_END */

/** PURE_IMPORTS_START _reduce PURE_IMPORTS_END */

/** PURE_IMPORTS_START tslib,_Subject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

var WindowOperator = /*@__PURE__*/ (function () {
    function WindowOperator(windowBoundaries) {
        this.windowBoundaries = windowBoundaries;
    }
    WindowOperator.prototype.call = function (subscriber, source) {
        var windowSubscriber = new WindowSubscriber(subscriber);
        var sourceSubscription = source.subscribe(windowSubscriber);
        if (!sourceSubscription.closed) {
            windowSubscriber.add(subscribeToResult(windowSubscriber, this.windowBoundaries));
        }
        return sourceSubscription;
    };
    return WindowOperator;
}());
var WindowSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(WindowSubscriber, _super);
    function WindowSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.window = new Subject();
        destination.next(_this.window);
        return _this;
    }
    WindowSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.openWindow();
    };
    WindowSubscriber.prototype.notifyError = function (error, innerSub) {
        this._error(error);
    };
    WindowSubscriber.prototype.notifyComplete = function (innerSub) {
        this._complete();
    };
    WindowSubscriber.prototype._next = function (value) {
        this.window.next(value);
    };
    WindowSubscriber.prototype._error = function (err) {
        this.window.error(err);
        this.destination.error(err);
    };
    WindowSubscriber.prototype._complete = function () {
        this.window.complete();
        this.destination.complete();
    };
    WindowSubscriber.prototype._unsubscribe = function () {
        this.window = null;
    };
    WindowSubscriber.prototype.openWindow = function () {
        var prevWindow = this.window;
        if (prevWindow) {
            prevWindow.complete();
        }
        var destination = this.destination;
        var newWindow = this.window = new Subject();
        destination.next(newWindow);
    };
    return WindowSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_Subscriber,_Subject PURE_IMPORTS_END */

var WindowCountOperator = /*@__PURE__*/ (function () {
    function WindowCountOperator(windowSize, startWindowEvery) {
        this.windowSize = windowSize;
        this.startWindowEvery = startWindowEvery;
    }
    WindowCountOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WindowCountSubscriber(subscriber, this.windowSize, this.startWindowEvery));
    };
    return WindowCountOperator;
}());
var WindowCountSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(WindowCountSubscriber, _super);
    function WindowCountSubscriber(destination, windowSize, startWindowEvery) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.windowSize = windowSize;
        _this.startWindowEvery = startWindowEvery;
        _this.windows = [new Subject()];
        _this.count = 0;
        destination.next(_this.windows[0]);
        return _this;
    }
    WindowCountSubscriber.prototype._next = function (value) {
        var startWindowEvery = (this.startWindowEvery > 0) ? this.startWindowEvery : this.windowSize;
        var destination = this.destination;
        var windowSize = this.windowSize;
        var windows = this.windows;
        var len = windows.length;
        for (var i = 0; i < len && !this.closed; i++) {
            windows[i].next(value);
        }
        var c = this.count - windowSize + 1;
        if (c >= 0 && c % startWindowEvery === 0 && !this.closed) {
            windows.shift().complete();
        }
        if (++this.count % startWindowEvery === 0 && !this.closed) {
            var window_1 = new Subject();
            windows.push(window_1);
            destination.next(window_1);
        }
    };
    WindowCountSubscriber.prototype._error = function (err) {
        var windows = this.windows;
        if (windows) {
            while (windows.length > 0 && !this.closed) {
                windows.shift().error(err);
            }
        }
        this.destination.error(err);
    };
    WindowCountSubscriber.prototype._complete = function () {
        var windows = this.windows;
        if (windows) {
            while (windows.length > 0 && !this.closed) {
                windows.shift().complete();
            }
        }
        this.destination.complete();
    };
    WindowCountSubscriber.prototype._unsubscribe = function () {
        this.count = 0;
        this.windows = null;
    };
    return WindowCountSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_Subject,_scheduler_async,_Subscriber,_util_isNumeric,_util_isScheduler PURE_IMPORTS_END */

var WindowTimeOperator = /*@__PURE__*/ (function () {
    function WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
        this.windowTimeSpan = windowTimeSpan;
        this.windowCreationInterval = windowCreationInterval;
        this.maxWindowSize = maxWindowSize;
        this.scheduler = scheduler;
    }
    WindowTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WindowTimeSubscriber(subscriber, this.windowTimeSpan, this.windowCreationInterval, this.maxWindowSize, this.scheduler));
    };
    return WindowTimeOperator;
}());
var CountedSubject = /*@__PURE__*/ (function (_super) {
    __extends(CountedSubject, _super);
    function CountedSubject() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._numberOfNextedValues = 0;
        return _this;
    }
    CountedSubject.prototype.next = function (value) {
        this._numberOfNextedValues++;
        _super.prototype.next.call(this, value);
    };
    Object.defineProperty(CountedSubject.prototype, "numberOfNextedValues", {
        get: function () {
            return this._numberOfNextedValues;
        },
        enumerable: true,
        configurable: true
    });
    return CountedSubject;
}(Subject));
var WindowTimeSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(WindowTimeSubscriber, _super);
    function WindowTimeSubscriber(destination, windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.windowTimeSpan = windowTimeSpan;
        _this.windowCreationInterval = windowCreationInterval;
        _this.maxWindowSize = maxWindowSize;
        _this.scheduler = scheduler;
        _this.windows = [];
        var window = _this.openWindow();
        if (windowCreationInterval !== null && windowCreationInterval >= 0) {
            var closeState = { subscriber: _this, window: window, context: null };
            var creationState = { windowTimeSpan: windowTimeSpan, windowCreationInterval: windowCreationInterval, subscriber: _this, scheduler: scheduler };
            _this.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, closeState));
            _this.add(scheduler.schedule(dispatchWindowCreation, windowCreationInterval, creationState));
        }
        else {
            var timeSpanOnlyState = { subscriber: _this, window: window, windowTimeSpan: windowTimeSpan };
            _this.add(scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));
        }
        return _this;
    }
    WindowTimeSubscriber.prototype._next = function (value) {
        var windows = this.windows;
        var len = windows.length;
        for (var i = 0; i < len; i++) {
            var window_1 = windows[i];
            if (!window_1.closed) {
                window_1.next(value);
                if (window_1.numberOfNextedValues >= this.maxWindowSize) {
                    this.closeWindow(window_1);
                }
            }
        }
    };
    WindowTimeSubscriber.prototype._error = function (err) {
        var windows = this.windows;
        while (windows.length > 0) {
            windows.shift().error(err);
        }
        this.destination.error(err);
    };
    WindowTimeSubscriber.prototype._complete = function () {
        var windows = this.windows;
        while (windows.length > 0) {
            var window_2 = windows.shift();
            if (!window_2.closed) {
                window_2.complete();
            }
        }
        this.destination.complete();
    };
    WindowTimeSubscriber.prototype.openWindow = function () {
        var window = new CountedSubject();
        this.windows.push(window);
        var destination = this.destination;
        destination.next(window);
        return window;
    };
    WindowTimeSubscriber.prototype.closeWindow = function (window) {
        window.complete();
        var windows = this.windows;
        windows.splice(windows.indexOf(window), 1);
    };
    return WindowTimeSubscriber;
}(Subscriber));
function dispatchWindowTimeSpanOnly(state) {
    var subscriber = state.subscriber, windowTimeSpan = state.windowTimeSpan, window = state.window;
    if (window) {
        subscriber.closeWindow(window);
    }
    state.window = subscriber.openWindow();
    this.schedule(state, windowTimeSpan);
}
function dispatchWindowCreation(state) {
    var windowTimeSpan = state.windowTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler, windowCreationInterval = state.windowCreationInterval;
    var window = subscriber.openWindow();
    var action = this;
    var context = { action: action, subscription: null };
    var timeSpanState = { subscriber: subscriber, window: window, context: context };
    context.subscription = scheduler.schedule(dispatchWindowClose, windowTimeSpan, timeSpanState);
    action.add(context.subscription);
    action.schedule(state, windowCreationInterval);
}
function dispatchWindowClose(state) {
    var subscriber = state.subscriber, window = state.window, context = state.context;
    if (context && context.action && context.subscription) {
        context.action.remove(context.subscription);
    }
    subscriber.closeWindow(window);
}

/** PURE_IMPORTS_START tslib,_Subject,_Subscription,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

var WindowToggleOperator = /*@__PURE__*/ (function () {
    function WindowToggleOperator(openings, closingSelector) {
        this.openings = openings;
        this.closingSelector = closingSelector;
    }
    WindowToggleOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WindowToggleSubscriber(subscriber, this.openings, this.closingSelector));
    };
    return WindowToggleOperator;
}());
var WindowToggleSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(WindowToggleSubscriber, _super);
    function WindowToggleSubscriber(destination, openings, closingSelector) {
        var _this = _super.call(this, destination) || this;
        _this.openings = openings;
        _this.closingSelector = closingSelector;
        _this.contexts = [];
        _this.add(_this.openSubscription = subscribeToResult(_this, openings, openings));
        return _this;
    }
    WindowToggleSubscriber.prototype._next = function (value) {
        var contexts = this.contexts;
        if (contexts) {
            var len = contexts.length;
            for (var i = 0; i < len; i++) {
                contexts[i].window.next(value);
            }
        }
    };
    WindowToggleSubscriber.prototype._error = function (err) {
        var contexts = this.contexts;
        this.contexts = null;
        if (contexts) {
            var len = contexts.length;
            var index = -1;
            while (++index < len) {
                var context_1 = contexts[index];
                context_1.window.error(err);
                context_1.subscription.unsubscribe();
            }
        }
        _super.prototype._error.call(this, err);
    };
    WindowToggleSubscriber.prototype._complete = function () {
        var contexts = this.contexts;
        this.contexts = null;
        if (contexts) {
            var len = contexts.length;
            var index = -1;
            while (++index < len) {
                var context_2 = contexts[index];
                context_2.window.complete();
                context_2.subscription.unsubscribe();
            }
        }
        _super.prototype._complete.call(this);
    };
    WindowToggleSubscriber.prototype._unsubscribe = function () {
        var contexts = this.contexts;
        this.contexts = null;
        if (contexts) {
            var len = contexts.length;
            var index = -1;
            while (++index < len) {
                var context_3 = contexts[index];
                context_3.window.unsubscribe();
                context_3.subscription.unsubscribe();
            }
        }
    };
    WindowToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (outerValue === this.openings) {
            var closingNotifier = void 0;
            try {
                var closingSelector = this.closingSelector;
                closingNotifier = closingSelector(innerValue);
            }
            catch (e) {
                return this.error(e);
            }
            var window_1 = new Subject();
            var subscription = new Subscription();
            var context_4 = { window: window_1, subscription: subscription };
            this.contexts.push(context_4);
            var innerSubscription = subscribeToResult(this, closingNotifier, context_4);
            if (innerSubscription.closed) {
                this.closeWindow(this.contexts.length - 1);
            }
            else {
                innerSubscription.context = context_4;
                subscription.add(innerSubscription);
            }
            this.destination.next(window_1);
        }
        else {
            this.closeWindow(this.contexts.indexOf(outerValue));
        }
    };
    WindowToggleSubscriber.prototype.notifyError = function (err) {
        this.error(err);
    };
    WindowToggleSubscriber.prototype.notifyComplete = function (inner) {
        if (inner !== this.openSubscription) {
            this.closeWindow(this.contexts.indexOf(inner.context));
        }
    };
    WindowToggleSubscriber.prototype.closeWindow = function (index) {
        if (index === -1) {
            return;
        }
        var contexts = this.contexts;
        var context = contexts[index];
        var window = context.window, subscription = context.subscription;
        contexts.splice(index, 1);
        window.complete();
        subscription.unsubscribe();
    };
    return WindowToggleSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_Subject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

var WindowOperator$1 = /*@__PURE__*/ (function () {
    function WindowOperator(closingSelector) {
        this.closingSelector = closingSelector;
    }
    WindowOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WindowSubscriber$1(subscriber, this.closingSelector));
    };
    return WindowOperator;
}());
var WindowSubscriber$1 = /*@__PURE__*/ (function (_super) {
    __extends(WindowSubscriber, _super);
    function WindowSubscriber(destination, closingSelector) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.closingSelector = closingSelector;
        _this.openWindow();
        return _this;
    }
    WindowSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.openWindow(innerSub);
    };
    WindowSubscriber.prototype.notifyError = function (error, innerSub) {
        this._error(error);
    };
    WindowSubscriber.prototype.notifyComplete = function (innerSub) {
        this.openWindow(innerSub);
    };
    WindowSubscriber.prototype._next = function (value) {
        this.window.next(value);
    };
    WindowSubscriber.prototype._error = function (err) {
        this.window.error(err);
        this.destination.error(err);
        this.unsubscribeClosingNotification();
    };
    WindowSubscriber.prototype._complete = function () {
        this.window.complete();
        this.destination.complete();
        this.unsubscribeClosingNotification();
    };
    WindowSubscriber.prototype.unsubscribeClosingNotification = function () {
        if (this.closingNotification) {
            this.closingNotification.unsubscribe();
        }
    };
    WindowSubscriber.prototype.openWindow = function (innerSub) {
        if (innerSub === void 0) {
            innerSub = null;
        }
        if (innerSub) {
            this.remove(innerSub);
            innerSub.unsubscribe();
        }
        var prevWindow = this.window;
        if (prevWindow) {
            prevWindow.complete();
        }
        var window = this.window = new Subject();
        this.destination.next(window);
        var closingNotifier;
        try {
            var closingSelector = this.closingSelector;
            closingNotifier = closingSelector();
        }
        catch (e) {
            this.destination.error(e);
            this.window.error(e);
            return;
        }
        this.add(this.closingNotification = subscribeToResult(this, closingNotifier));
    };
    return WindowSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

var WithLatestFromOperator = /*@__PURE__*/ (function () {
    function WithLatestFromOperator(observables, project) {
        this.observables = observables;
        this.project = project;
    }
    WithLatestFromOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WithLatestFromSubscriber(subscriber, this.observables, this.project));
    };
    return WithLatestFromOperator;
}());
var WithLatestFromSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(WithLatestFromSubscriber, _super);
    function WithLatestFromSubscriber(destination, observables, project) {
        var _this = _super.call(this, destination) || this;
        _this.observables = observables;
        _this.project = project;
        _this.toRespond = [];
        var len = observables.length;
        _this.values = new Array(len);
        for (var i = 0; i < len; i++) {
            _this.toRespond.push(i);
        }
        for (var i = 0; i < len; i++) {
            var observable = observables[i];
            _this.add(subscribeToResult(_this, observable, observable, i));
        }
        return _this;
    }
    WithLatestFromSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.values[outerIndex] = innerValue;
        var toRespond = this.toRespond;
        if (toRespond.length > 0) {
            var found = toRespond.indexOf(outerIndex);
            if (found !== -1) {
                toRespond.splice(found, 1);
            }
        }
    };
    WithLatestFromSubscriber.prototype.notifyComplete = function () {
    };
    WithLatestFromSubscriber.prototype._next = function (value) {
        if (this.toRespond.length === 0) {
            var args = [value].concat(this.values);
            if (this.project) {
                this._tryProject(args);
            }
            else {
                this.destination.next(args);
            }
        }
    };
    WithLatestFromSubscriber.prototype._tryProject = function (args) {
        var result;
        try {
            result = this.project.apply(this, args);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return WithLatestFromSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START _observable_zip PURE_IMPORTS_END */

/** PURE_IMPORTS_START _observable_zip PURE_IMPORTS_END */

/** PURE_IMPORTS_START  PURE_IMPORTS_END */

/**
 * @license Angular v7.2.16
 * (c) 2010-2019 Google LLC. https://angular.io/
 * License: MIT
 */

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Transforms an `HttpRequest` into a stream of `HttpEvent`s, one of which will likely be a
 * `HttpResponse`.
 *
 * `HttpHandler` is injectable. When injected, the handler instance dispatches requests to the
 * first interceptor in the chain, which dispatches to the second, etc, eventually reaching the
 * `HttpBackend`.
 *
 * In an `HttpInterceptor`, the `HttpHandler` parameter is the next interceptor in the chain.
 *
 * @publicApi
 */
var HttpHandler = /** @class */ (function () {
    function HttpHandler() {
    }
    return HttpHandler;
}());
/**
 * A final `HttpHandler` which will dispatch the request via browser HTTP APIs to a backend.
 *
 * Interceptors sit between the `HttpClient` interface and the `HttpBackend`.
 *
 * When injected, `HttpBackend` dispatches requests directly to the backend, without going
 * through the interceptor chain.
 *
 * @publicApi
 */
var HttpBackend = /** @class */ (function () {
    function HttpBackend() {
    }
    return HttpBackend;
}());

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * `HttpHeaders` class represents the header configuration options for an HTTP request.
 * Instances should be assumed immutable with lazy parsing.
 *
 * @publicApi
 */
var HttpHeaders = /** @class */ (function () {
    /**  Constructs a new HTTP header object with the given values.*/
    function HttpHeaders(headers) {
        var _this = this;
        /**
         * Internal map of lowercased header names to the normalized
         * form of the name (the form seen first).
         */
        this.normalizedNames = new Map();
        /**
         * Queued updates to be materialized the next initialization.
         */
        this.lazyUpdate = null;
        if (!headers) {
            this.headers = new Map();
        }
        else if (typeof headers === 'string') {
            this.lazyInit = function () {
                _this.headers = new Map();
                headers.split('\n').forEach(function (line) {
                    var index = line.indexOf(':');
                    if (index > 0) {
                        var name_1 = line.slice(0, index);
                        var key = name_1.toLowerCase();
                        var value = line.slice(index + 1).trim();
                        _this.maybeSetNormalizedName(name_1, key);
                        if (_this.headers.has(key)) {
                            _this.headers.get(key).push(value);
                        }
                        else {
                            _this.headers.set(key, [value]);
                        }
                    }
                });
            };
        }
        else {
            this.lazyInit = function () {
                _this.headers = new Map();
                Object.keys(headers).forEach(function (name) {
                    var values = headers[name];
                    var key = name.toLowerCase();
                    if (typeof values === 'string') {
                        values = [values];
                    }
                    if (values.length > 0) {
                        _this.headers.set(key, values);
                        _this.maybeSetNormalizedName(name, key);
                    }
                });
            };
        }
    }
    /**
     * Checks for existence of a header by a given name.
     *
     * @param name The header name to check for existence.
     *
     * @returns Whether the header exits.
     */
    HttpHeaders.prototype.has = function (name) {
        this.init();
        return this.headers.has(name.toLowerCase());
    };
    /**
     * Returns the first header value that matches a given name.
     *
     * @param name The header name to retrieve.
     *
     * @returns A string if the header exists, null otherwise
     */
    HttpHeaders.prototype.get = function (name) {
        this.init();
        var values = this.headers.get(name.toLowerCase());
        return values && values.length > 0 ? values[0] : null;
    };
    /**
     * Returns the names of the headers.
     *
     * @returns A list of header names.
     */
    HttpHeaders.prototype.keys = function () {
        this.init();
        return Array.from(this.normalizedNames.values());
    };
    /**
     * Returns a list of header values for a given header name.
     *
     * @param name The header name from which to retrieve the values.
     *
     * @returns A string of values if the header exists, null otherwise.
     */
    HttpHeaders.prototype.getAll = function (name) {
        this.init();
        return this.headers.get(name.toLowerCase()) || null;
    };
    /**
     * Appends a new header value to the existing set of
     * header values.
     *
     * @param name The header name for which to append the values.
     *
     * @returns A clone of the HTTP header object with the value appended.
     */
    HttpHeaders.prototype.append = function (name, value) {
        return this.clone({ name: name, value: value, op: 'a' });
    };
    /**
     * Sets a header value for a given name. If the header name already exists,
     * its value is replaced with the given value.
     *
     * @param name The header name.
     * @param value Provides the value to set or overide for a given name.
     *
     * @returns A clone of the HTTP header object with the newly set header value.
     */
    HttpHeaders.prototype.set = function (name, value) {
        return this.clone({ name: name, value: value, op: 's' });
    };
    /**
     * Deletes all header values for a given name.
     *
     * @param name The header name.
     * @param value The header values to delete for a given name.
     *
     * @returns A clone of the HTTP header object.
     */
    HttpHeaders.prototype.delete = function (name, value) {
        return this.clone({ name: name, value: value, op: 'd' });
    };
    HttpHeaders.prototype.maybeSetNormalizedName = function (name, lcName) {
        if (!this.normalizedNames.has(lcName)) {
            this.normalizedNames.set(lcName, name);
        }
    };
    HttpHeaders.prototype.init = function () {
        var _this = this;
        if (!!this.lazyInit) {
            if (this.lazyInit instanceof HttpHeaders) {
                this.copyFrom(this.lazyInit);
            }
            else {
                this.lazyInit();
            }
            this.lazyInit = null;
            if (!!this.lazyUpdate) {
                this.lazyUpdate.forEach(function (update) { return _this.applyUpdate(update); });
                this.lazyUpdate = null;
            }
        }
    };
    HttpHeaders.prototype.copyFrom = function (other) {
        var _this = this;
        other.init();
        Array.from(other.headers.keys()).forEach(function (key) {
            _this.headers.set(key, other.headers.get(key));
            _this.normalizedNames.set(key, other.normalizedNames.get(key));
        });
    };
    HttpHeaders.prototype.clone = function (update) {
        var clone = new HttpHeaders();
        clone.lazyInit =
            (!!this.lazyInit && this.lazyInit instanceof HttpHeaders) ? this.lazyInit : this;
        clone.lazyUpdate = (this.lazyUpdate || []).concat([update]);
        return clone;
    };
    HttpHeaders.prototype.applyUpdate = function (update) {
        var key = update.name.toLowerCase();
        switch (update.op) {
            case 'a':
            case 's':
                var value = update.value;
                if (typeof value === 'string') {
                    value = [value];
                }
                if (value.length === 0) {
                    return;
                }
                this.maybeSetNormalizedName(update.name, key);
                var base = (update.op === 'a' ? this.headers.get(key) : undefined) || [];
                base.push.apply(base, __spread(value));
                this.headers.set(key, base);
                break;
            case 'd':
                var toDelete_1 = update.value;
                if (!toDelete_1) {
                    this.headers.delete(key);
                    this.normalizedNames.delete(key);
                }
                else {
                    var existing = this.headers.get(key);
                    if (!existing) {
                        return;
                    }
                    existing = existing.filter(function (value) { return toDelete_1.indexOf(value) === -1; });
                    if (existing.length === 0) {
                        this.headers.delete(key);
                        this.normalizedNames.delete(key);
                    }
                    else {
                        this.headers.set(key, existing);
                    }
                }
                break;
        }
    };
    /**
     * @internal
     */
    HttpHeaders.prototype.forEach = function (fn) {
        var _this = this;
        this.init();
        Array.from(this.normalizedNames.keys())
            .forEach(function (key) { return fn(_this.normalizedNames.get(key), _this.headers.get(key)); });
    };
    return HttpHeaders;
}());

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * A class that uses `encodeURIComponent` and `decodeURIComponent` to
 * serialize and parse URL parameter keys and values. If you pass URL query parameters
 * without encoding, the query parameters can get misinterpreted at the receiving end.
 * Use the `HttpParameterCodec` class to encode and decode the query-string values.
 *
 * @publicApi
 */
var HttpUrlEncodingCodec = /** @class */ (function () {
    function HttpUrlEncodingCodec() {
    }
    HttpUrlEncodingCodec.prototype.encodeKey = function (key) { return standardEncoding(key); };
    HttpUrlEncodingCodec.prototype.encodeValue = function (value) { return standardEncoding(value); };
    HttpUrlEncodingCodec.prototype.decodeKey = function (key) { return decodeURIComponent(key); };
    HttpUrlEncodingCodec.prototype.decodeValue = function (value) { return decodeURIComponent(value); };
    return HttpUrlEncodingCodec;
}());
function paramParser(rawParams, codec) {
    var map$$1 = new Map();
    if (rawParams.length > 0) {
        var params = rawParams.split('&');
        params.forEach(function (param) {
            var eqIdx = param.indexOf('=');
            var _a = __read(eqIdx == -1 ?
                [codec.decodeKey(param), ''] :
                [codec.decodeKey(param.slice(0, eqIdx)), codec.decodeValue(param.slice(eqIdx + 1))], 2), key = _a[0], val = _a[1];
            var list = map$$1.get(key) || [];
            list.push(val);
            map$$1.set(key, list);
        });
    }
    return map$$1;
}
function standardEncoding(v) {
    return encodeURIComponent(v)
        .replace(/%40/gi, '@')
        .replace(/%3A/gi, ':')
        .replace(/%24/gi, '$')
        .replace(/%2C/gi, ',')
        .replace(/%3B/gi, ';')
        .replace(/%2B/gi, '+')
        .replace(/%3D/gi, '=')
        .replace(/%3F/gi, '?')
        .replace(/%2F/gi, '/');
}
/**
 * An HTTP request/response body that represents serialized parameters,
 * per the MIME type `application/x-www-form-urlencoded`.
 *
 * This class is immutable - all mutation operations return a new instance.
 *
 * @publicApi
 */
var HttpParams = /** @class */ (function () {
    function HttpParams(options) {
        if (options === void 0) { options = {}; }
        var _this = this;
        this.updates = null;
        this.cloneFrom = null;
        this.encoder = options.encoder || new HttpUrlEncodingCodec();
        if (!!options.fromString) {
            if (!!options.fromObject) {
                throw new Error("Cannot specify both fromString and fromObject.");
            }
            this.map = paramParser(options.fromString, this.encoder);
        }
        else if (!!options.fromObject) {
            this.map = new Map();
            Object.keys(options.fromObject).forEach(function (key) {
                var value = options.fromObject[key];
                _this.map.set(key, Array.isArray(value) ? value : [value]);
            });
        }
        else {
            this.map = null;
        }
    }
    /**
     * Check whether the body has one or more values for the given parameter name.
     */
    HttpParams.prototype.has = function (param) {
        this.init();
        return this.map.has(param);
    };
    /**
     * Get the first value for the given parameter name, or `null` if it's not present.
     */
    HttpParams.prototype.get = function (param) {
        this.init();
        var res = this.map.get(param);
        return !!res ? res[0] : null;
    };
    /**
     * Get all values for the given parameter name, or `null` if it's not present.
     */
    HttpParams.prototype.getAll = function (param) {
        this.init();
        return this.map.get(param) || null;
    };
    /**
     * Get all the parameter names for this body.
     */
    HttpParams.prototype.keys = function () {
        this.init();
        return Array.from(this.map.keys());
    };
    /**
     * Construct a new body with an appended value for the given parameter name.
     */
    HttpParams.prototype.append = function (param, value) { return this.clone({ param: param, value: value, op: 'a' }); };
    /**
     * Construct a new body with a new value for the given parameter name.
     */
    HttpParams.prototype.set = function (param, value) { return this.clone({ param: param, value: value, op: 's' }); };
    /**
     * Construct a new body with either the given value for the given parameter
     * removed, if a value is given, or all values for the given parameter removed
     * if not.
     */
    HttpParams.prototype.delete = function (param, value) { return this.clone({ param: param, value: value, op: 'd' }); };
    /**
     * Serialize the body to an encoded string, where key-value pairs (separated by `=`) are
     * separated by `&`s.
     */
    HttpParams.prototype.toString = function () {
        var _this = this;
        this.init();
        return this.keys()
            .map(function (key) {
            var eKey = _this.encoder.encodeKey(key);
            return _this.map.get(key).map(function (value) { return eKey + '=' + _this.encoder.encodeValue(value); })
                .join('&');
        })
            .join('&');
    };
    HttpParams.prototype.clone = function (update) {
        var clone = new HttpParams({ encoder: this.encoder });
        clone.cloneFrom = this.cloneFrom || this;
        clone.updates = (this.updates || []).concat([update]);
        return clone;
    };
    HttpParams.prototype.init = function () {
        var _this = this;
        if (this.map === null) {
            this.map = new Map();
        }
        if (this.cloneFrom !== null) {
            this.cloneFrom.init();
            this.cloneFrom.keys().forEach(function (key) { return _this.map.set(key, _this.cloneFrom.map.get(key)); });
            this.updates.forEach(function (update) {
                switch (update.op) {
                    case 'a':
                    case 's':
                        var base = (update.op === 'a' ? _this.map.get(update.param) : undefined) || [];
                        base.push(update.value);
                        _this.map.set(update.param, base);
                        break;
                    case 'd':
                        if (update.value !== undefined) {
                            var base_1 = _this.map.get(update.param) || [];
                            var idx = base_1.indexOf(update.value);
                            if (idx !== -1) {
                                base_1.splice(idx, 1);
                            }
                            if (base_1.length > 0) {
                                _this.map.set(update.param, base_1);
                            }
                            else {
                                _this.map.delete(update.param);
                            }
                        }
                        else {
                            _this.map.delete(update.param);
                            break;
                        }
                }
            });
            this.cloneFrom = this.updates = null;
        }
    };
    return HttpParams;
}());

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Determine whether the given HTTP method may include a body.
 */
function mightHaveBody(method) {
    switch (method) {
        case 'DELETE':
        case 'GET':
        case 'HEAD':
        case 'OPTIONS':
        case 'JSONP':
            return false;
        default:
            return true;
    }
}
/**
 * Safely assert whether the given value is an ArrayBuffer.
 *
 * In some execution environments ArrayBuffer is not defined.
 */
function isArrayBuffer(value) {
    return typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer;
}
/**
 * Safely assert whether the given value is a Blob.
 *
 * In some execution environments Blob is not defined.
 */
function isBlob(value) {
    return typeof Blob !== 'undefined' && value instanceof Blob;
}
/**
 * Safely assert whether the given value is a FormData instance.
 *
 * In some execution environments FormData is not defined.
 */
function isFormData(value) {
    return typeof FormData !== 'undefined' && value instanceof FormData;
}
/**
 * An outgoing HTTP request with an optional typed body.
 *
 * `HttpRequest` represents an outgoing request, including URL, method,
 * headers, body, and other request configuration options. Instances should be
 * assumed to be immutable. To modify a `HttpRequest`, the `clone`
 * method should be used.
 *
 * @publicApi
 */
var HttpRequest = /** @class */ (function () {
    function HttpRequest(method, url, third, fourth) {
        this.url = url;
        /**
         * The request body, or `null` if one isn't set.
         *
         * Bodies are not enforced to be immutable, as they can include a reference to any
         * user-defined data type. However, interceptors should take care to preserve
         * idempotence by treating them as such.
         */
        this.body = null;
        /**
         * Whether this request should be made in a way that exposes progress events.
         *
         * Progress events are expensive (change detection runs on each event) and so
         * they should only be requested if the consumer intends to monitor them.
         */
        this.reportProgress = false;
        /**
         * Whether this request should be sent with outgoing credentials (cookies).
         */
        this.withCredentials = false;
        /**
         * The expected response type of the server.
         *
         * This is used to parse the response appropriately before returning it to
         * the requestee.
         */
        this.responseType = 'json';
        this.method = method.toUpperCase();
        // Next, need to figure out which argument holds the HttpRequestInit
        // options, if any.
        var options;
        // Check whether a body argument is expected. The only valid way to omit
        // the body argument is to use a known no-body method like GET.
        if (mightHaveBody(this.method) || !!fourth) {
            // Body is the third argument, options are the fourth.
            this.body = (third !== undefined) ? third : null;
            options = fourth;
        }
        else {
            // No body required, options are the third argument. The body stays null.
            options = third;
        }
        // If options have been passed, interpret them.
        if (options) {
            // Normalize reportProgress and withCredentials.
            this.reportProgress = !!options.reportProgress;
            this.withCredentials = !!options.withCredentials;
            // Override default response type of 'json' if one is provided.
            if (!!options.responseType) {
                this.responseType = options.responseType;
            }
            // Override headers if they're provided.
            if (!!options.headers) {
                this.headers = options.headers;
            }
            if (!!options.params) {
                this.params = options.params;
            }
        }
        // If no headers have been passed in, construct a new HttpHeaders instance.
        if (!this.headers) {
            this.headers = new HttpHeaders();
        }
        // If no parameters have been passed in, construct a new HttpUrlEncodedParams instance.
        if (!this.params) {
            this.params = new HttpParams();
            this.urlWithParams = url;
        }
        else {
            // Encode the parameters to a string in preparation for inclusion in the URL.
            var params = this.params.toString();
            if (params.length === 0) {
                // No parameters, the visible URL is just the URL given at creation time.
                this.urlWithParams = url;
            }
            else {
                // Does the URL already have query parameters? Look for '?'.
                var qIdx = url.indexOf('?');
                // There are 3 cases to handle:
                // 1) No existing parameters -> append '?' followed by params.
                // 2) '?' exists and is followed by existing query string ->
                //    append '&' followed by params.
                // 3) '?' exists at the end of the url -> append params directly.
                // This basically amounts to determining the character, if any, with
                // which to join the URL and parameters.
                var sep = qIdx === -1 ? '?' : (qIdx < url.length - 1 ? '&' : '');
                this.urlWithParams = url + sep + params;
            }
        }
    }
    /**
     * Transform the free-form body into a serialized format suitable for
     * transmission to the server.
     */
    HttpRequest.prototype.serializeBody = function () {
        // If no body is present, no need to serialize it.
        if (this.body === null) {
            return null;
        }
        // Check whether the body is already in a serialized form. If so,
        // it can just be returned directly.
        if (isArrayBuffer(this.body) || isBlob(this.body) || isFormData(this.body) ||
            typeof this.body === 'string') {
            return this.body;
        }
        // Check whether the body is an instance of HttpUrlEncodedParams.
        if (this.body instanceof HttpParams) {
            return this.body.toString();
        }
        // Check whether the body is an object or array, and serialize with JSON if so.
        if (typeof this.body === 'object' || typeof this.body === 'boolean' ||
            Array.isArray(this.body)) {
            return JSON.stringify(this.body);
        }
        // Fall back on toString() for everything else.
        return this.body.toString();
    };
    /**
     * Examine the body and attempt to infer an appropriate MIME type
     * for it.
     *
     * If no such type can be inferred, this method will return `null`.
     */
    HttpRequest.prototype.detectContentTypeHeader = function () {
        // An empty body has no content type.
        if (this.body === null) {
            return null;
        }
        // FormData bodies rely on the browser's content type assignment.
        if (isFormData(this.body)) {
            return null;
        }
        // Blobs usually have their own content type. If it doesn't, then
        // no type can be inferred.
        if (isBlob(this.body)) {
            return this.body.type || null;
        }
        // Array buffers have unknown contents and thus no type can be inferred.
        if (isArrayBuffer(this.body)) {
            return null;
        }
        // Technically, strings could be a form of JSON data, but it's safe enough
        // to assume they're plain strings.
        if (typeof this.body === 'string') {
            return 'text/plain';
        }
        // `HttpUrlEncodedParams` has its own content-type.
        if (this.body instanceof HttpParams) {
            return 'application/x-www-form-urlencoded;charset=UTF-8';
        }
        // Arrays, objects, and numbers will be encoded as JSON.
        if (typeof this.body === 'object' || typeof this.body === 'number' ||
            Array.isArray(this.body)) {
            return 'application/json';
        }
        // No type could be inferred.
        return null;
    };
    HttpRequest.prototype.clone = function (update) {
        if (update === void 0) { update = {}; }
        // For method, url, and responseType, take the current value unless
        // it is overridden in the update hash.
        var method = update.method || this.method;
        var url = update.url || this.url;
        var responseType = update.responseType || this.responseType;
        // The body is somewhat special - a `null` value in update.body means
        // whatever current body is present is being overridden with an empty
        // body, whereas an `undefined` value in update.body implies no
        // override.
        var body = (update.body !== undefined) ? update.body : this.body;
        // Carefully handle the boolean options to differentiate between
        // `false` and `undefined` in the update args.
        var withCredentials = (update.withCredentials !== undefined) ? update.withCredentials : this.withCredentials;
        var reportProgress = (update.reportProgress !== undefined) ? update.reportProgress : this.reportProgress;
        // Headers and params may be appended to if `setHeaders` or
        // `setParams` are used.
        var headers = update.headers || this.headers;
        var params = update.params || this.params;
        // Check whether the caller has asked to add headers.
        if (update.setHeaders !== undefined) {
            // Set every requested header.
            headers =
                Object.keys(update.setHeaders)
                    .reduce(function (headers, name) { return headers.set(name, update.setHeaders[name]); }, headers);
        }
        // Check whether the caller has asked to set params.
        if (update.setParams) {
            // Set every requested param.
            params = Object.keys(update.setParams)
                .reduce(function (params, param) { return params.set(param, update.setParams[param]); }, params);
        }
        // Finally, construct the new HttpRequest using the pieces from above.
        return new HttpRequest(method, url, body, {
            params: params, headers: headers, reportProgress: reportProgress, responseType: responseType, withCredentials: withCredentials,
        });
    };
    return HttpRequest;
}());

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Type enumeration for the different kinds of `HttpEvent`.
 *
 * @publicApi
 */
var HttpEventType;
(function (HttpEventType) {
    /**
     * The request was sent out over the wire.
     */
    HttpEventType[HttpEventType["Sent"] = 0] = "Sent";
    /**
     * An upload progress event was received.
     */
    HttpEventType[HttpEventType["UploadProgress"] = 1] = "UploadProgress";
    /**
     * The response status code and headers were received.
     */
    HttpEventType[HttpEventType["ResponseHeader"] = 2] = "ResponseHeader";
    /**
     * A download progress event was received.
     */
    HttpEventType[HttpEventType["DownloadProgress"] = 3] = "DownloadProgress";
    /**
     * The full response including the body was received.
     */
    HttpEventType[HttpEventType["Response"] = 4] = "Response";
    /**
     * A custom event from an interceptor or a backend.
     */
    HttpEventType[HttpEventType["User"] = 5] = "User";
})(HttpEventType || (HttpEventType = {}));
/**
 * Base class for both `HttpResponse` and `HttpHeaderResponse`.
 *
 * @publicApi
 */
var HttpResponseBase = /** @class */ (function () {
    /**
     * Super-constructor for all responses.
     *
     * The single parameter accepted is an initialization hash. Any properties
     * of the response passed there will override the default values.
     */
    function HttpResponseBase(init, defaultStatus, defaultStatusText) {
        if (defaultStatus === void 0) { defaultStatus = 200; }
        if (defaultStatusText === void 0) { defaultStatusText = 'OK'; }
        // If the hash has values passed, use them to initialize the response.
        // Otherwise use the default values.
        this.headers = init.headers || new HttpHeaders();
        this.status = init.status !== undefined ? init.status : defaultStatus;
        this.statusText = init.statusText || defaultStatusText;
        this.url = init.url || null;
        // Cache the ok value to avoid defining a getter.
        this.ok = this.status >= 200 && this.status < 300;
    }
    return HttpResponseBase;
}());
/**
 * A partial HTTP response which only includes the status and header data,
 * but no response body.
 *
 * `HttpHeaderResponse` is a `HttpEvent` available on the response
 * event stream, only when progress events are requested.
 *
 * @publicApi
 */
var HttpHeaderResponse = /** @class */ (function (_super) {
    __extends(HttpHeaderResponse, _super);
    /**
     * Create a new `HttpHeaderResponse` with the given parameters.
     */
    function HttpHeaderResponse(init) {
        if (init === void 0) { init = {}; }
        var _this = _super.call(this, init) || this;
        _this.type = HttpEventType.ResponseHeader;
        return _this;
    }
    /**
     * Copy this `HttpHeaderResponse`, overriding its contents with the
     * given parameter hash.
     */
    HttpHeaderResponse.prototype.clone = function (update) {
        if (update === void 0) { update = {}; }
        // Perform a straightforward initialization of the new HttpHeaderResponse,
        // overriding the current parameters with new ones if given.
        return new HttpHeaderResponse({
            headers: update.headers || this.headers,
            status: update.status !== undefined ? update.status : this.status,
            statusText: update.statusText || this.statusText,
            url: update.url || this.url || undefined,
        });
    };
    return HttpHeaderResponse;
}(HttpResponseBase));
/**
 * A full HTTP response, including a typed response body (which may be `null`
 * if one was not returned).
 *
 * `HttpResponse` is a `HttpEvent` available on the response event
 * stream.
 *
 * @publicApi
 */
var HttpResponse = /** @class */ (function (_super) {
    __extends(HttpResponse, _super);
    /**
     * Construct a new `HttpResponse`.
     */
    function HttpResponse(init) {
        if (init === void 0) { init = {}; }
        var _this = _super.call(this, init) || this;
        _this.type = HttpEventType.Response;
        _this.body = init.body !== undefined ? init.body : null;
        return _this;
    }
    HttpResponse.prototype.clone = function (update) {
        if (update === void 0) { update = {}; }
        return new HttpResponse({
            body: (update.body !== undefined) ? update.body : this.body,
            headers: update.headers || this.headers,
            status: (update.status !== undefined) ? update.status : this.status,
            statusText: update.statusText || this.statusText,
            url: update.url || this.url || undefined,
        });
    };
    return HttpResponse;
}(HttpResponseBase));
/**
 * A response that represents an error or failure, either from a
 * non-successful HTTP status, an error while executing the request,
 * or some other failure which occurred during the parsing of the response.
 *
 * Any error returned on the `Observable` response stream will be
 * wrapped in an `HttpErrorResponse` to provide additional context about
 * the state of the HTTP layer when the error occurred. The error property
 * will contain either a wrapped Error object or the error response returned
 * from the server.
 *
 * @publicApi
 */
var HttpErrorResponse = /** @class */ (function (_super) {
    __extends(HttpErrorResponse, _super);
    function HttpErrorResponse(init) {
        var _this = 
        // Initialize with a default status of 0 / Unknown Error.
        _super.call(this, init, 0, 'Unknown Error') || this;
        _this.name = 'HttpErrorResponse';
        /**
         * Errors are never okay, even when the status code is in the 2xx success range.
         */
        _this.ok = false;
        // If the response was successful, then this was a parse error. Otherwise, it was
        // a protocol-level failure of some sort. Either the request failed in transit
        // or the server returned an unsuccessful status code.
        if (_this.status >= 200 && _this.status < 300) {
            _this.message = "Http failure during parsing for " + (init.url || '(unknown url)');
        }
        else {
            _this.message =
                "Http failure response for " + (init.url || '(unknown url)') + ": " + init.status + " " + init.statusText;
        }
        _this.error = init.error || null;
        return _this;
    }
    return HttpErrorResponse;
}(HttpResponseBase));

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Constructs an instance of `HttpRequestOptions<T>` from a source `HttpMethodOptions` and
 * the given `body`. This function clones the object and adds the body.
 */
function addBody(options, body) {
    return {
        body: body,
        headers: options.headers,
        observe: options.observe,
        params: options.params,
        reportProgress: options.reportProgress,
        responseType: options.responseType,
        withCredentials: options.withCredentials,
    };
}
/**
 * Performs HTTP requests.
 *
 * `HttpClient` is available as an injectable class, with methods to perform HTTP requests.
 * Each request method has multiple signatures, and the return type varies based on
 * the signature that is called (mainly the values of `observe` and `responseType`).
 *
 *
 * @see [HTTP Guide](guide/http)
 *
 *
 * @usageNotes
 * Sample HTTP requests for the [Tour of Heroes](/tutorial/toh-pt0) application.
 *
 * ### HTTP Request Example
 *
 * ```
 *  // GET heroes whose name contains search term
 * searchHeroes(term: string): observable<Hero[]>{
 *
 *  const params = new HttpParams({fromString: 'name=term'});
 *    return this.httpClient.request('GET', this.heroesUrl, {responseType:'json', params});
 * }
 * ```
 * ### JSONP Example
 * ```
 * requestJsonp(url, callback = 'callback') {
 *  return this.httpClient.jsonp(this.heroesURL, callback);
 * }
 * ```
 *
 *
 * ### PATCH Example
 * ```
 * // PATCH one of the heroes' name
 * patchHero (id: number, heroName: string): Observable<{}> {
 * const url = `${this.heroesUrl}/${id}`;   // PATCH api/heroes/42
 *  return this.httpClient.patch(url, {name: heroName}, httpOptions)
 *    .pipe(catchError(this.handleError('patchHero')));
 * }
* ```
 *
 * @publicApi
 */
var HttpClient = /** @class */ (function () {
    function HttpClient(handler) {
        this.handler = handler;
    }
    /**
     * Constructs an observable for a generic HTTP request that, when subscribed,
     * fires the request through the chain of registered interceptors and on to the
     * server.
     *
     * You can pass an `HttpRequest` directly as the only parameter. In this case,
     * the call returns an observable of the raw `HttpEvent` stream.
     *
     * Alternatively you can pass an HTTP method as the first parameter,
     * a URL string as the second, and an options hash containing the request body as the third.
     * See `addBody()`. In this case, the specified `responseType` and `observe` options determine the
     * type of returned observable.
     *   * The `responseType` value determines how a successful response body is parsed.
     *   * If `responseType` is the default `json`, you can pass a type interface for the resulting
     * object as a type parameter to the call.
     *
     * The `observe` value determines the return type, according to what you are interested in
     * observing.
     *   * An `observe` value of events returns an observable of the raw `HttpEvent` stream, including
     * progress events by default.
     *   * An `observe` value of response returns an observable of `HttpResponse<T>`,
     * where the `T` parameter depends on the `responseType` and any optionally provided type
     * parameter.
     *   * An `observe` value of body returns an observable of `<T>` with the same `T` body type.
     *
     */
    HttpClient.prototype.request = function (first, url, options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        var req;
        // First, check whether the primary argument is an instance of `HttpRequest`.
        if (first instanceof HttpRequest) {
            // It is. The other arguments must be undefined (per the signatures) and can be
            // ignored.
            req = first;
        }
        else {
            // It's a string, so it represents a URL. Construct a request based on it,
            // and incorporate the remaining arguments (assuming `GET` unless a method is
            // provided.
            // Figure out the headers.
            var headers = undefined;
            if (options.headers instanceof HttpHeaders) {
                headers = options.headers;
            }
            else {
                headers = new HttpHeaders(options.headers);
            }
            // Sort out parameters.
            var params = undefined;
            if (!!options.params) {
                if (options.params instanceof HttpParams) {
                    params = options.params;
                }
                else {
                    params = new HttpParams({ fromObject: options.params });
                }
            }
            // Construct the request.
            req = new HttpRequest(first, url, (options.body !== undefined ? options.body : null), {
                headers: headers,
                params: params,
                reportProgress: options.reportProgress,
                // By default, JSON is assumed to be returned for all calls.
                responseType: options.responseType || 'json',
                withCredentials: options.withCredentials,
            });
        }
        // Start with an Observable.of() the initial request, and run the handler (which
        // includes all interceptors) inside a concatMap(). This way, the handler runs
        // inside an Observable chain, which causes interceptors to be re-run on every
        // subscription (this also makes retries re-run the handler, including interceptors).
        var events$ = of(req).pipe(concatMap(function (req) { return _this.handler.handle(req); }));
        // If coming via the API signature which accepts a previously constructed HttpRequest,
        // the only option is to get the event stream. Otherwise, return the event stream if
        // that is what was requested.
        if (first instanceof HttpRequest || options.observe === 'events') {
            return events$;
        }
        // The requested stream contains either the full response or the body. In either
        // case, the first step is to filter the event stream to extract a stream of
        // responses(s).
        var res$ = events$.pipe(filter(function (event) { return event instanceof HttpResponse; }));
        // Decide which stream to return.
        switch (options.observe || 'body') {
            case 'body':
                // The requested stream is the body. Map the response stream to the response
                // body. This could be done more simply, but a misbehaving interceptor might
                // transform the response body into a different format and ignore the requested
                // responseType. Guard against this by validating that the response is of the
                // requested type.
                switch (req.responseType) {
                    case 'arraybuffer':
                        return res$.pipe(map(function (res) {
                            // Validate that the body is an ArrayBuffer.
                            if (res.body !== null && !(res.body instanceof ArrayBuffer)) {
                                throw new Error('Response is not an ArrayBuffer.');
                            }
                            return res.body;
                        }));
                    case 'blob':
                        return res$.pipe(map(function (res) {
                            // Validate that the body is a Blob.
                            if (res.body !== null && !(res.body instanceof Blob)) {
                                throw new Error('Response is not a Blob.');
                            }
                            return res.body;
                        }));
                    case 'text':
                        return res$.pipe(map(function (res) {
                            // Validate that the body is a string.
                            if (res.body !== null && typeof res.body !== 'string') {
                                throw new Error('Response is not a string.');
                            }
                            return res.body;
                        }));
                    case 'json':
                    default:
                        // No validation needed for JSON responses, as they can be of any type.
                        return res$.pipe(map(function (res) { return res.body; }));
                }
            case 'response':
                // The response stream was requested directly, so return it.
                return res$;
            default:
                // Guard against new future observe types being added.
                throw new Error("Unreachable: unhandled observe type " + options.observe + "}");
        }
    };
    /**
     * Constructs an observable that, when subscribed, causes the configured
     * `DELETE` request to execute on the server. See the individual overloads for
     * details on the return type.
     *
     * @param url     The endpoint URL.
     * @param options The HTTP options to send with the request.
     *
     */
    HttpClient.prototype.delete = function (url, options) {
        if (options === void 0) { options = {}; }
        return this.request('DELETE', url, options);
    };
    /**
     * Constructs an observable that, when subscribed, causes the configured
     * `GET` request to execute on the server. See the individual overloads for
     * details on the return type.
     */
    HttpClient.prototype.get = function (url, options) {
        if (options === void 0) { options = {}; }
        return this.request('GET', url, options);
    };
    /**
     * Constructs an observable that, when subscribed, causes the configured
     * `HEAD` request to execute on the server. The `HEAD` method returns
     * meta information about the resource without transferring the
     * resource itself. See the individual overloads for
     * details on the return type.
     */
    HttpClient.prototype.head = function (url, options) {
        if (options === void 0) { options = {}; }
        return this.request('HEAD', url, options);
    };
    /**
     * Constructs an `Observable` that, when subscribed, causes a request with the special method
     * `JSONP` to be dispatched via the interceptor pipeline.
     * The [JSONP pattern](https://en.wikipedia.org/wiki/JSONP) works around limitations of certain
     * API endpoints that don't support newer,
     * and preferable [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) protocol.
     * JSONP treats the endpoint API as a JavaScript file and tricks the browser to process the
     * requests even if the API endpoint is not located on the same domain (origin) as the client-side
     * application making the request.
     * The endpoint API must support JSONP callback for JSONP requests to work.
     * The resource API returns the JSON response wrapped in a callback function.
     * You can pass the callback function name as one of the query parameters.
     * Note that JSONP requests can only be used with `GET` requests.
     *
     * @param url The resource URL.
     * @param callbackParam The callback function name.
     *
     */
    HttpClient.prototype.jsonp = function (url, callbackParam) {
        return this.request('JSONP', url, {
            params: new HttpParams().append(callbackParam, 'JSONP_CALLBACK'),
            observe: 'body',
            responseType: 'json',
        });
    };
    /**
     * Constructs an `Observable` that, when subscribed, causes the configured
     * `OPTIONS` request to execute on the server. This method allows the client
     * to determine the supported HTTP methods and other capabilites of an endpoint,
     * without implying a resource action. See the individual overloads for
     * details on the return type.
     */
    HttpClient.prototype.options = function (url, options) {
        if (options === void 0) { options = {}; }
        return this.request('OPTIONS', url, options);
    };
    /**
     * Constructs an observable that, when subscribed, causes the configured
     * `PATCH` request to execute on the server. See the individual overloads for
     * details on the return type.
     */
    HttpClient.prototype.patch = function (url, body, options) {
        if (options === void 0) { options = {}; }
        return this.request('PATCH', url, addBody(options, body));
    };
    /**
     * Constructs an observable that, when subscribed, causes the configured
     * `POST` request to execute on the server. The server responds with the location of
     * the replaced resource. See the individual overloads for
     * details on the return type.
     */
    HttpClient.prototype.post = function (url, body, options) {
        if (options === void 0) { options = {}; }
        return this.request('POST', url, addBody(options, body));
    };
    /**
     * Constructs an observable that, when subscribed, causes the configured
     * `PUT` request to execute on the server. The `PUT` method replaces an existing resource
     * with a new set of values.
     * See the individual overloads for details on the return type.
     */
    HttpClient.prototype.put = function (url, body, options) {
        if (options === void 0) { options = {}; }
        return this.request('PUT', url, addBody(options, body));
    };
    HttpClient = __decorate([
        Injectable(),
        __metadata("design:paramtypes", [HttpHandler])
    ], HttpClient);
    return HttpClient;
}());

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * `HttpHandler` which applies an `HttpInterceptor` to an `HttpRequest`.
 *
 *
 */
var HttpInterceptorHandler = /** @class */ (function () {
    function HttpInterceptorHandler(next, interceptor) {
        this.next = next;
        this.interceptor = interceptor;
    }
    HttpInterceptorHandler.prototype.handle = function (req) {
        return this.interceptor.intercept(req, this.next);
    };
    return HttpInterceptorHandler;
}());
/**
 * A multi-provider token which represents the array of `HttpInterceptor`s that
 * are registered.
 *
 * @publicApi
 */
var HTTP_INTERCEPTORS = new InjectionToken('HTTP_INTERCEPTORS');
var NoopInterceptor = /** @class */ (function () {
    function NoopInterceptor() {
    }
    NoopInterceptor.prototype.intercept = function (req, next) {
        return next.handle(req);
    };
    NoopInterceptor = __decorate([
        Injectable()
    ], NoopInterceptor);
    return NoopInterceptor;
}());

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
// Every request made through JSONP needs a callback name that's unique across the
// whole page. Each request is assigned an id and the callback name is constructed
// from that. The next id to be assigned is tracked in a global variable here that
// is shared among all applications on the page.
var nextRequestId = 0;
// Error text given when a JSONP script is injected, but doesn't invoke the callback
// passed in its URL.
var JSONP_ERR_NO_CALLBACK = 'JSONP injected script did not invoke callback.';
// Error text given when a request is passed to the JsonpClientBackend that doesn't
// have a request method JSONP.
var JSONP_ERR_WRONG_METHOD = 'JSONP requests must use JSONP request method.';
var JSONP_ERR_WRONG_RESPONSE_TYPE = 'JSONP requests must use Json response type.';
/**
 * DI token/abstract type representing a map of JSONP callbacks.
 *
 * In the browser, this should always be the `window` object.
 *
 *
 */
var JsonpCallbackContext = /** @class */ (function () {
    function JsonpCallbackContext() {
    }
    return JsonpCallbackContext;
}());
/**
 * `HttpBackend` that only processes `HttpRequest` with the JSONP method,
 * by performing JSONP style requests.
 *
 * @publicApi
 */
var JsonpClientBackend = /** @class */ (function () {
    function JsonpClientBackend(callbackMap, document) {
        this.callbackMap = callbackMap;
        this.document = document;
    }
    /**
     * Get the name of the next callback method, by incrementing the global `nextRequestId`.
     */
    JsonpClientBackend.prototype.nextCallback = function () { return "ng_jsonp_callback_" + nextRequestId++; };
    /**
     * Process a JSONP request and return an event stream of the results.
     */
    JsonpClientBackend.prototype.handle = function (req) {
        var _this = this;
        // Firstly, check both the method and response type. If either doesn't match
        // then the request was improperly routed here and cannot be handled.
        if (req.method !== 'JSONP') {
            throw new Error(JSONP_ERR_WRONG_METHOD);
        }
        else if (req.responseType !== 'json') {
            throw new Error(JSONP_ERR_WRONG_RESPONSE_TYPE);
        }
        // Everything else happens inside the Observable boundary.
        return new Observable(function (observer) {
            // The first step to make a request is to generate the callback name, and replace the
            // callback placeholder in the URL with the name. Care has to be taken here to ensure
            // a trailing &, if matched, gets inserted back into the URL in the correct place.
            var callback = _this.nextCallback();
            var url = req.urlWithParams.replace(/=JSONP_CALLBACK(&|$)/, "=" + callback + "$1");
            // Construct the <script> tag and point it at the URL.
            var node = _this.document.createElement('script');
            node.src = url;
            // A JSONP request requires waiting for multiple callbacks. These variables
            // are closed over and track state across those callbacks.
            // The response object, if one has been received, or null otherwise.
            var body = null;
            // Whether the response callback has been called.
            var finished = false;
            // Whether the request has been cancelled (and thus any other callbacks)
            // should be ignored.
            var cancelled = false;
            // Set the response callback in this.callbackMap (which will be the window
            // object in the browser. The script being loaded via the <script> tag will
            // eventually call this callback.
            _this.callbackMap[callback] = function (data) {
                // Data has been received from the JSONP script. Firstly, delete this callback.
                delete _this.callbackMap[callback];
                // Next, make sure the request wasn't cancelled in the meantime.
                if (cancelled) {
                    return;
                }
                // Set state to indicate data was received.
                body = data;
                finished = true;
            };
            // cleanup() is a utility closure that removes the <script> from the page and
            // the response callback from the window. This logic is used in both the
            // success, error, and cancellation paths, so it's extracted out for convenience.
            var cleanup = function () {
                // Remove the <script> tag if it's still on the page.
                if (node.parentNode) {
                    node.parentNode.removeChild(node);
                }
                // Remove the response callback from the callbackMap (window object in the
                // browser).
                delete _this.callbackMap[callback];
            };
            // onLoad() is the success callback which runs after the response callback
            // if the JSONP script loads successfully. The event itself is unimportant.
            // If something went wrong, onLoad() may run without the response callback
            // having been invoked.
            var onLoad = function (event) {
                // Do nothing if the request has been cancelled.
                if (cancelled) {
                    return;
                }
                // Cleanup the page.
                cleanup();
                // Check whether the response callback has run.
                if (!finished) {
                    // It hasn't, something went wrong with the request. Return an error via
                    // the Observable error path. All JSONP errors have status 0.
                    observer.error(new HttpErrorResponse({
                        url: url,
                        status: 0,
                        statusText: 'JSONP Error',
                        error: new Error(JSONP_ERR_NO_CALLBACK),
                    }));
                    return;
                }
                // Success. body either contains the response body or null if none was
                // returned.
                observer.next(new HttpResponse({
                    body: body,
                    status: 200,
                    statusText: 'OK', url: url,
                }));
                // Complete the stream, the response is over.
                observer.complete();
            };
            // onError() is the error callback, which runs if the script returned generates
            // a Javascript error. It emits the error via the Observable error channel as
            // a HttpErrorResponse.
            var onError = function (error) {
                // If the request was already cancelled, no need to emit anything.
                if (cancelled) {
                    return;
                }
                cleanup();
                // Wrap the error in a HttpErrorResponse.
                observer.error(new HttpErrorResponse({
                    error: error,
                    status: 0,
                    statusText: 'JSONP Error', url: url,
                }));
            };
            // Subscribe to both the success (load) and error events on the <script> tag,
            // and add it to the page.
            node.addEventListener('load', onLoad);
            node.addEventListener('error', onError);
            _this.document.body.appendChild(node);
            // The request has now been successfully sent.
            observer.next({ type: HttpEventType.Sent });
            // Cancellation handler.
            return function () {
                // Track the cancellation so event listeners won't do anything even if already scheduled.
                cancelled = true;
                // Remove the event listeners so they won't run if the events later fire.
                node.removeEventListener('load', onLoad);
                node.removeEventListener('error', onError);
                // And finally, clean up the page.
                cleanup();
            };
        });
    };
    JsonpClientBackend = __decorate([
        Injectable(),
        __param(1, Inject(DOCUMENT)),
        __metadata("design:paramtypes", [JsonpCallbackContext, Object])
    ], JsonpClientBackend);
    return JsonpClientBackend;
}());
/**
 * An `HttpInterceptor` which identifies requests with the method JSONP and
 * shifts them to the `JsonpClientBackend`.
 *
 * @publicApi
 */
var JsonpInterceptor = /** @class */ (function () {
    function JsonpInterceptor(jsonp) {
        this.jsonp = jsonp;
    }
    JsonpInterceptor.prototype.intercept = function (req, next) {
        if (req.method === 'JSONP') {
            return this.jsonp.handle(req);
        }
        // Fall through for normal HTTP requests.
        return next.handle(req);
    };
    JsonpInterceptor = __decorate([
        Injectable(),
        __metadata("design:paramtypes", [JsonpClientBackend])
    ], JsonpInterceptor);
    return JsonpInterceptor;
}());

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var XSSI_PREFIX = /^\)\]\}',?\n/;
/**
 * Determine an appropriate URL for the response, by checking either
 * XMLHttpRequest.responseURL or the X-Request-URL header.
 */
function getResponseUrl(xhr) {
    if ('responseURL' in xhr && xhr.responseURL) {
        return xhr.responseURL;
    }
    if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {
        return xhr.getResponseHeader('X-Request-URL');
    }
    return null;
}
/**
 * A wrapper around the `XMLHttpRequest` constructor.
 *
 * @publicApi
 */
var XhrFactory = /** @class */ (function () {
    function XhrFactory() {
    }
    return XhrFactory;
}());
/**
 * A factory for @{link HttpXhrBackend} that uses the `XMLHttpRequest` browser API.
 *
 *
 */
var BrowserXhr = /** @class */ (function () {
    function BrowserXhr() {
    }
    BrowserXhr.prototype.build = function () { return (new XMLHttpRequest()); };
    BrowserXhr = __decorate([
        Injectable(),
        __metadata("design:paramtypes", [])
    ], BrowserXhr);
    return BrowserXhr;
}());
/**
 * An `HttpBackend` which uses the XMLHttpRequest API to send
 * requests to a backend server.
 *
 * @publicApi
 */
var HttpXhrBackend = /** @class */ (function () {
    function HttpXhrBackend(xhrFactory) {
        this.xhrFactory = xhrFactory;
    }
    /**
     * Process a request and return a stream of response events.
     */
    HttpXhrBackend.prototype.handle = function (req) {
        var _this = this;
        // Quick check to give a better error message when a user attempts to use
        // HttpClient.jsonp() without installing the JsonpClientModule
        if (req.method === 'JSONP') {
            throw new Error("Attempted to construct Jsonp request without JsonpClientModule installed.");
        }
        // Everything happens on Observable subscription.
        return new Observable(function (observer) {
            // Start by setting up the XHR object with request method, URL, and withCredentials flag.
            var xhr = _this.xhrFactory.build();
            xhr.open(req.method, req.urlWithParams);
            if (!!req.withCredentials) {
                xhr.withCredentials = true;
            }
            // Add all the requested headers.
            req.headers.forEach(function (name, values) { return xhr.setRequestHeader(name, values.join(',')); });
            // Add an Accept header if one isn't present already.
            if (!req.headers.has('Accept')) {
                xhr.setRequestHeader('Accept', 'application/json, text/plain, */*');
            }
            // Auto-detect the Content-Type header if one isn't present already.
            if (!req.headers.has('Content-Type')) {
                var detectedType = req.detectContentTypeHeader();
                // Sometimes Content-Type detection fails.
                if (detectedType !== null) {
                    xhr.setRequestHeader('Content-Type', detectedType);
                }
            }
            // Set the responseType if one was requested.
            if (req.responseType) {
                var responseType = req.responseType.toLowerCase();
                // JSON responses need to be processed as text. This is because if the server
                // returns an XSSI-prefixed JSON response, the browser will fail to parse it,
                // xhr.response will be null, and xhr.responseText cannot be accessed to
                // retrieve the prefixed JSON data in order to strip the prefix. Thus, all JSON
                // is parsed by first requesting text and then applying JSON.parse.
                xhr.responseType = ((responseType !== 'json') ? responseType : 'text');
            }
            // Serialize the request body if one is present. If not, this will be set to null.
            var reqBody = req.serializeBody();
            // If progress events are enabled, response headers will be delivered
            // in two events - the HttpHeaderResponse event and the full HttpResponse
            // event. However, since response headers don't change in between these
            // two events, it doesn't make sense to parse them twice. So headerResponse
            // caches the data extracted from the response whenever it's first parsed,
            // to ensure parsing isn't duplicated.
            var headerResponse = null;
            // partialFromXhr extracts the HttpHeaderResponse from the current XMLHttpRequest
            // state, and memoizes it into headerResponse.
            var partialFromXhr = function () {
                if (headerResponse !== null) {
                    return headerResponse;
                }
                // Read status and normalize an IE9 bug (http://bugs.jquery.com/ticket/1450).
                var status = xhr.status === 1223 ? 204 : xhr.status;
                var statusText = xhr.statusText || 'OK';
                // Parse headers from XMLHttpRequest - this step is lazy.
                var headers = new HttpHeaders(xhr.getAllResponseHeaders());
                // Read the response URL from the XMLHttpResponse instance and fall back on the
                // request URL.
                var url = getResponseUrl(xhr) || req.url;
                // Construct the HttpHeaderResponse and memoize it.
                headerResponse = new HttpHeaderResponse({ headers: headers, status: status, statusText: statusText, url: url });
                return headerResponse;
            };
            // Next, a few closures are defined for the various events which XMLHttpRequest can
            // emit. This allows them to be unregistered as event listeners later.
            // First up is the load event, which represents a response being fully available.
            var onLoad = function () {
                // Read response state from the memoized partial data.
                var _a = partialFromXhr(), headers = _a.headers, status = _a.status, statusText = _a.statusText, url = _a.url;
                // The body will be read out if present.
                var body = null;
                if (status !== 204) {
                    // Use XMLHttpRequest.response if set, responseText otherwise.
                    body = (typeof xhr.response === 'undefined') ? xhr.responseText : xhr.response;
                }
                // Normalize another potential bug (this one comes from CORS).
                if (status === 0) {
                    status = !!body ? 200 : 0;
                }
                // ok determines whether the response will be transmitted on the event or
                // error channel. Unsuccessful status codes (not 2xx) will always be errors,
                // but a successful status code can still result in an error if the user
                // asked for JSON data and the body cannot be parsed as such.
                var ok = status >= 200 && status < 300;
                // Check whether the body needs to be parsed as JSON (in many cases the browser
                // will have done that already).
                if (req.responseType === 'json' && typeof body === 'string') {
                    // Save the original body, before attempting XSSI prefix stripping.
                    var originalBody = body;
                    body = body.replace(XSSI_PREFIX, '');
                    try {
                        // Attempt the parse. If it fails, a parse error should be delivered to the user.
                        body = body !== '' ? JSON.parse(body) : null;
                    }
                    catch (error) {
                        // Since the JSON.parse failed, it's reasonable to assume this might not have been a
                        // JSON response. Restore the original body (including any XSSI prefix) to deliver
                        // a better error response.
                        body = originalBody;
                        // If this was an error request to begin with, leave it as a string, it probably
                        // just isn't JSON. Otherwise, deliver the parsing error to the user.
                        if (ok) {
                            // Even though the response status was 2xx, this is still an error.
                            ok = false;
                            // The parse error contains the text of the body that failed to parse.
                            body = { error: error, text: body };
                        }
                    }
                }
                if (ok) {
                    // A successful response is delivered on the event stream.
                    observer.next(new HttpResponse({
                        body: body,
                        headers: headers,
                        status: status,
                        statusText: statusText,
                        url: url || undefined,
                    }));
                    // The full body has been received and delivered, no further events
                    // are possible. This request is complete.
                    observer.complete();
                }
                else {
                    // An unsuccessful request is delivered on the error channel.
                    observer.error(new HttpErrorResponse({
                        // The error in this case is the response body (error from the server).
                        error: body,
                        headers: headers,
                        status: status,
                        statusText: statusText,
                        url: url || undefined,
                    }));
                }
            };
            // The onError callback is called when something goes wrong at the network level.
            // Connection timeout, DNS error, offline, etc. These are actual errors, and are
            // transmitted on the error channel.
            var onError = function (error) {
                var url = partialFromXhr().url;
                var res = new HttpErrorResponse({
                    error: error,
                    status: xhr.status || 0,
                    statusText: xhr.statusText || 'Unknown Error',
                    url: url || undefined,
                });
                observer.error(res);
            };
            // The sentHeaders flag tracks whether the HttpResponseHeaders event
            // has been sent on the stream. This is necessary to track if progress
            // is enabled since the event will be sent on only the first download
            // progerss event.
            var sentHeaders = false;
            // The download progress event handler, which is only registered if
            // progress events are enabled.
            var onDownProgress = function (event) {
                // Send the HttpResponseHeaders event if it hasn't been sent already.
                if (!sentHeaders) {
                    observer.next(partialFromXhr());
                    sentHeaders = true;
                }
                // Start building the download progress event to deliver on the response
                // event stream.
                var progressEvent = {
                    type: HttpEventType.DownloadProgress,
                    loaded: event.loaded,
                };
                // Set the total number of bytes in the event if it's available.
                if (event.lengthComputable) {
                    progressEvent.total = event.total;
                }
                // If the request was for text content and a partial response is
                // available on XMLHttpRequest, include it in the progress event
                // to allow for streaming reads.
                if (req.responseType === 'text' && !!xhr.responseText) {
                    progressEvent.partialText = xhr.responseText;
                }
                // Finally, fire the event.
                observer.next(progressEvent);
            };
            // The upload progress event handler, which is only registered if
            // progress events are enabled.
            var onUpProgress = function (event) {
                // Upload progress events are simpler. Begin building the progress
                // event.
                var progress = {
                    type: HttpEventType.UploadProgress,
                    loaded: event.loaded,
                };
                // If the total number of bytes being uploaded is available, include
                // it.
                if (event.lengthComputable) {
                    progress.total = event.total;
                }
                // Send the event.
                observer.next(progress);
            };
            // By default, register for load and error events.
            xhr.addEventListener('load', onLoad);
            xhr.addEventListener('error', onError);
            // Progress events are only enabled if requested.
            if (req.reportProgress) {
                // Download progress is always enabled if requested.
                xhr.addEventListener('progress', onDownProgress);
                // Upload progress depends on whether there is a body to upload.
                if (reqBody !== null && xhr.upload) {
                    xhr.upload.addEventListener('progress', onUpProgress);
                }
            }
            // Fire the request, and notify the event stream that it was fired.
            xhr.send(reqBody);
            observer.next({ type: HttpEventType.Sent });
            // This is the return from the Observable function, which is the
            // request cancellation handler.
            return function () {
                // On a cancellation, remove all registered event listeners.
                xhr.removeEventListener('error', onError);
                xhr.removeEventListener('load', onLoad);
                if (req.reportProgress) {
                    xhr.removeEventListener('progress', onDownProgress);
                    if (reqBody !== null && xhr.upload) {
                        xhr.upload.removeEventListener('progress', onUpProgress);
                    }
                }
                // Finally, abort the in-flight request.
                xhr.abort();
            };
        });
    };
    HttpXhrBackend = __decorate([
        Injectable(),
        __metadata("design:paramtypes", [XhrFactory])
    ], HttpXhrBackend);
    return HttpXhrBackend;
}());

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var XSRF_COOKIE_NAME = new InjectionToken('XSRF_COOKIE_NAME');
var XSRF_HEADER_NAME = new InjectionToken('XSRF_HEADER_NAME');
/**
 * Retrieves the current XSRF token to use with the next outgoing request.
 *
 * @publicApi
 */
var HttpXsrfTokenExtractor = /** @class */ (function () {
    function HttpXsrfTokenExtractor() {
    }
    return HttpXsrfTokenExtractor;
}());
/**
 * `HttpXsrfTokenExtractor` which retrieves the token from a cookie.
 */
var HttpXsrfCookieExtractor = /** @class */ (function () {
    function HttpXsrfCookieExtractor(doc, platform, cookieName) {
        this.doc = doc;
        this.platform = platform;
        this.cookieName = cookieName;
        this.lastCookieString = '';
        this.lastToken = null;
        /**
         * @internal for testing
         */
        this.parseCount = 0;
    }
    HttpXsrfCookieExtractor.prototype.getToken = function () {
        if (this.platform === 'server') {
            return null;
        }
        var cookieString = this.doc.cookie || '';
        if (cookieString !== this.lastCookieString) {
            this.parseCount++;
            this.lastToken = ɵparseCookieValue(cookieString, this.cookieName);
            this.lastCookieString = cookieString;
        }
        return this.lastToken;
    };
    HttpXsrfCookieExtractor = __decorate([
        Injectable(),
        __param(0, Inject(DOCUMENT)), __param(1, Inject(PLATFORM_ID)),
        __param(2, Inject(XSRF_COOKIE_NAME)),
        __metadata("design:paramtypes", [Object, String, String])
    ], HttpXsrfCookieExtractor);
    return HttpXsrfCookieExtractor;
}());
/**
 * `HttpInterceptor` which adds an XSRF token to eligible outgoing requests.
 */
var HttpXsrfInterceptor = /** @class */ (function () {
    function HttpXsrfInterceptor(tokenService, headerName) {
        this.tokenService = tokenService;
        this.headerName = headerName;
    }
    HttpXsrfInterceptor.prototype.intercept = function (req, next) {
        var lcUrl = req.url.toLowerCase();
        // Skip both non-mutating requests and absolute URLs.
        // Non-mutating requests don't require a token, and absolute URLs require special handling
        // anyway as the cookie set
        // on our origin is not the same as the token expected by another origin.
        if (req.method === 'GET' || req.method === 'HEAD' || lcUrl.startsWith('http://') ||
            lcUrl.startsWith('https://')) {
            return next.handle(req);
        }
        var token = this.tokenService.getToken();
        // Be careful not to overwrite an existing header of the same name.
        if (token !== null && !req.headers.has(this.headerName)) {
            req = req.clone({ headers: req.headers.set(this.headerName, token) });
        }
        return next.handle(req);
    };
    HttpXsrfInterceptor = __decorate([
        Injectable(),
        __param(1, Inject(XSRF_HEADER_NAME)),
        __metadata("design:paramtypes", [HttpXsrfTokenExtractor, String])
    ], HttpXsrfInterceptor);
    return HttpXsrfInterceptor;
}());

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * An injectable `HttpHandler` that applies multiple interceptors
 * to a request before passing it to the given `HttpBackend`.
 *
 * The interceptors are loaded lazily from the injector, to allow
 * interceptors to themselves inject classes depending indirectly
 * on `HttpInterceptingHandler` itself.
 * @see `HttpInterceptor`
 */
var HttpInterceptingHandler = /** @class */ (function () {
    function HttpInterceptingHandler(backend, injector) {
        this.backend = backend;
        this.injector = injector;
        this.chain = null;
    }
    HttpInterceptingHandler.prototype.handle = function (req) {
        if (this.chain === null) {
            var interceptors = this.injector.get(HTTP_INTERCEPTORS, []);
            this.chain = interceptors.reduceRight(function (next, interceptor) { return new HttpInterceptorHandler(next, interceptor); }, this.backend);
        }
        return this.chain.handle(req);
    };
    HttpInterceptingHandler = __decorate([
        Injectable(),
        __metadata("design:paramtypes", [HttpBackend, Injector])
    ], HttpInterceptingHandler);
    return HttpInterceptingHandler;
}());
/**
 * Factory function that determines where to store JSONP callbacks.
 *
 * Ordinarily JSONP callbacks are stored on the `window` object, but this may not exist
 * in test environments. In that case, callbacks are stored on an anonymous object instead.
 *
 *
 */
function jsonpCallbackContext() {
    if (typeof window === 'object') {
        return window;
    }
    return {};
}
/**
 * Configures XSRF protection support for outgoing requests.
 *
 * For a server that supports a cookie-based XSRF protection system,
 * use directly to configure XSRF protection with the correct
 * cookie and header names.
 *
 * If no names are supplied, the default cookie name is `XSRF-TOKEN`
 * and the default header name is `X-XSRF-TOKEN`.
 *
 * @publicApi
 */
var HttpClientXsrfModule = /** @class */ (function () {
    function HttpClientXsrfModule() {
    }
    HttpClientXsrfModule_1 = HttpClientXsrfModule;
    /**
     * Disable the default XSRF protection.
     */
    HttpClientXsrfModule.disable = function () {
        return {
            ngModule: HttpClientXsrfModule_1,
            providers: [
                { provide: HttpXsrfInterceptor, useClass: NoopInterceptor },
            ],
        };
    };
    /**
     * Configure XSRF protection.
     * @param options An object that can specify either or both
     * cookie name or header name.
     * - Cookie name default is `XSRF-TOKEN`.
     * - Header name default is `X-XSRF-TOKEN`.
     *
     */
    HttpClientXsrfModule.withOptions = function (options) {
        if (options === void 0) { options = {}; }
        return {
            ngModule: HttpClientXsrfModule_1,
            providers: [
                options.cookieName ? { provide: XSRF_COOKIE_NAME, useValue: options.cookieName } : [],
                options.headerName ? { provide: XSRF_HEADER_NAME, useValue: options.headerName } : [],
            ],
        };
    };
    var HttpClientXsrfModule_1;
    HttpClientXsrfModule = HttpClientXsrfModule_1 = __decorate([
        NgModule({
            providers: [
                HttpXsrfInterceptor,
                { provide: HTTP_INTERCEPTORS, useExisting: HttpXsrfInterceptor, multi: true },
                { provide: HttpXsrfTokenExtractor, useClass: HttpXsrfCookieExtractor },
                { provide: XSRF_COOKIE_NAME, useValue: 'XSRF-TOKEN' },
                { provide: XSRF_HEADER_NAME, useValue: 'X-XSRF-TOKEN' },
            ],
        })
    ], HttpClientXsrfModule);
    return HttpClientXsrfModule;
}());
/**
 * Configures the [dependency injector](guide/glossary#injector) for `HttpClient`
 * with supporting services for XSRF. Automatically imported by `HttpClientModule`.
 *
 * You can add interceptors to the chain behind `HttpClient` by binding them to the
 * multiprovider for built-in [DI token](guide/glossary#di-token) `HTTP_INTERCEPTORS`.
 *
 * @publicApi
 */
var HttpClientModule = /** @class */ (function () {
    function HttpClientModule() {
    }
    HttpClientModule = __decorate([
        NgModule({
            /**
             * Optional configuration for XSRF protection.
             */
            imports: [
                HttpClientXsrfModule.withOptions({
                    cookieName: 'XSRF-TOKEN',
                    headerName: 'X-XSRF-TOKEN',
                }),
            ],
            /**
             * Configures the [dependency injector](guide/glossary#injector) where it is imported
             * with supporting services for HTTP communications.
             */
            providers: [
                HttpClient,
                { provide: HttpHandler, useClass: HttpInterceptingHandler },
                HttpXhrBackend,
                { provide: HttpBackend, useExisting: HttpXhrBackend },
                BrowserXhr,
                { provide: XhrFactory, useExisting: BrowserXhr },
            ],
        })
    ], HttpClientModule);
    return HttpClientModule;
}());
/**
 * Configures the [dependency injector](guide/glossary#injector) for `HttpClient`
 * with supporting services for JSONP.
 * Without this module, Jsonp requests reach the backend
 * with method JSONP, where they are rejected.
 *
 * You can add interceptors to the chain behind `HttpClient` by binding them to the
 * multiprovider for built-in [DI token](guide/glossary#di-token) `HTTP_INTERCEPTORS`.
 *
 * @publicApi
 */
var HttpClientJsonpModule = /** @class */ (function () {
    function HttpClientJsonpModule() {
    }
    HttpClientJsonpModule = __decorate([
        NgModule({
            providers: [
                JsonpClientBackend,
                { provide: JsonpCallbackContext, useFactory: jsonpCallbackContext },
                { provide: HTTP_INTERCEPTORS, useClass: JsonpInterceptor, multi: true },
            ],
        })
    ], HttpClientJsonpModule);
    return HttpClientJsonpModule;
}());

/**
 * @license Angular v7.2.16
 * (c) 2010-2019 Google LLC. https://angular.io/
 * License: MIT
 */

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @description
 *
 * Base for events the Router goes through, as opposed to events tied to a specific
 * Route. `RouterEvent`s will only be fired one time for any given navigation.
 *
 * Example:
 *
 * ```
 * class MyService {
 *   constructor(public router: Router, logger: Logger) {
 *     router.events.pipe(
 *       filter(e => e instanceof RouterEvent)
 *     ).subscribe(e => {
 *       logger.log(e.id, e.url);
 *     });
 *   }
 * }
 * ```
 *
 * @publicApi
 */
var RouterEvent = /** @class */ (function () {
    function RouterEvent(
    /** @docsNotRequired */
    id, 
    /** @docsNotRequired */
    url) {
        this.id = id;
        this.url = url;
    }
    return RouterEvent;
}());
/**
 * @description
 *
 * Represents an event triggered when a navigation starts.
 *
 * @publicApi
 */
var NavigationStart = /** @class */ (function (_super) {
    __extends(NavigationStart, _super);
    function NavigationStart(
    /** @docsNotRequired */
    id, 
    /** @docsNotRequired */
    url, 
    /** @docsNotRequired */
    navigationTrigger, 
    /** @docsNotRequired */
    restoredState) {
        if (navigationTrigger === void 0) { navigationTrigger = 'imperative'; }
        if (restoredState === void 0) { restoredState = null; }
        var _this = _super.call(this, id, url) || this;
        _this.navigationTrigger = navigationTrigger;
        _this.restoredState = restoredState;
        return _this;
    }
    /** @docsNotRequired */
    NavigationStart.prototype.toString = function () { return "NavigationStart(id: " + this.id + ", url: '" + this.url + "')"; };
    return NavigationStart;
}(RouterEvent));
/**
 * @description
 *
 * Represents an event triggered when a navigation ends successfully.
 *
 * @publicApi
 */
var NavigationEnd = /** @class */ (function (_super) {
    __extends(NavigationEnd, _super);
    function NavigationEnd(
    /** @docsNotRequired */
    id, 
    /** @docsNotRequired */
    url, 
    /** @docsNotRequired */
    urlAfterRedirects) {
        var _this = _super.call(this, id, url) || this;
        _this.urlAfterRedirects = urlAfterRedirects;
        return _this;
    }
    /** @docsNotRequired */
    NavigationEnd.prototype.toString = function () {
        return "NavigationEnd(id: " + this.id + ", url: '" + this.url + "', urlAfterRedirects: '" + this.urlAfterRedirects + "')";
    };
    return NavigationEnd;
}(RouterEvent));
/**
 * @description
 *
 * Represents an event triggered when a navigation is canceled.
 *
 * @publicApi
 */
var NavigationCancel = /** @class */ (function (_super) {
    __extends(NavigationCancel, _super);
    function NavigationCancel(
    /** @docsNotRequired */
    id, 
    /** @docsNotRequired */
    url, 
    /** @docsNotRequired */
    reason) {
        var _this = _super.call(this, id, url) || this;
        _this.reason = reason;
        return _this;
    }
    /** @docsNotRequired */
    NavigationCancel.prototype.toString = function () { return "NavigationCancel(id: " + this.id + ", url: '" + this.url + "')"; };
    return NavigationCancel;
}(RouterEvent));
/**
 * @description
 *
 * Represents an event triggered when a navigation fails due to an unexpected error.
 *
 * @publicApi
 */
var NavigationError = /** @class */ (function (_super) {
    __extends(NavigationError, _super);
    function NavigationError(
    /** @docsNotRequired */
    id, 
    /** @docsNotRequired */
    url, 
    /** @docsNotRequired */
    error) {
        var _this = _super.call(this, id, url) || this;
        _this.error = error;
        return _this;
    }
    /** @docsNotRequired */
    NavigationError.prototype.toString = function () {
        return "NavigationError(id: " + this.id + ", url: '" + this.url + "', error: " + this.error + ")";
    };
    return NavigationError;
}(RouterEvent));
/**
 * @description
 *
 * Represents an event triggered when routes are recognized.
 *
 * @publicApi
 */
var RoutesRecognized = /** @class */ (function (_super) {
    __extends(RoutesRecognized, _super);
    function RoutesRecognized(
    /** @docsNotRequired */
    id, 
    /** @docsNotRequired */
    url, 
    /** @docsNotRequired */
    urlAfterRedirects, 
    /** @docsNotRequired */
    state) {
        var _this = _super.call(this, id, url) || this;
        _this.urlAfterRedirects = urlAfterRedirects;
        _this.state = state;
        return _this;
    }
    /** @docsNotRequired */
    RoutesRecognized.prototype.toString = function () {
        return "RoutesRecognized(id: " + this.id + ", url: '" + this.url + "', urlAfterRedirects: '" + this.urlAfterRedirects + "', state: " + this.state + ")";
    };
    return RoutesRecognized;
}(RouterEvent));
/**
 * @description
 *
 * Represents the start of the Guard phase of routing.
 *
 * @publicApi
 */
var GuardsCheckStart = /** @class */ (function (_super) {
    __extends(GuardsCheckStart, _super);
    function GuardsCheckStart(
    /** @docsNotRequired */
    id, 
    /** @docsNotRequired */
    url, 
    /** @docsNotRequired */
    urlAfterRedirects, 
    /** @docsNotRequired */
    state) {
        var _this = _super.call(this, id, url) || this;
        _this.urlAfterRedirects = urlAfterRedirects;
        _this.state = state;
        return _this;
    }
    GuardsCheckStart.prototype.toString = function () {
        return "GuardsCheckStart(id: " + this.id + ", url: '" + this.url + "', urlAfterRedirects: '" + this.urlAfterRedirects + "', state: " + this.state + ")";
    };
    return GuardsCheckStart;
}(RouterEvent));
/**
 * @description
 *
 * Represents the end of the Guard phase of routing.
 *
 * @publicApi
 */
var GuardsCheckEnd = /** @class */ (function (_super) {
    __extends(GuardsCheckEnd, _super);
    function GuardsCheckEnd(
    /** @docsNotRequired */
    id, 
    /** @docsNotRequired */
    url, 
    /** @docsNotRequired */
    urlAfterRedirects, 
    /** @docsNotRequired */
    state, 
    /** @docsNotRequired */
    shouldActivate) {
        var _this = _super.call(this, id, url) || this;
        _this.urlAfterRedirects = urlAfterRedirects;
        _this.state = state;
        _this.shouldActivate = shouldActivate;
        return _this;
    }
    GuardsCheckEnd.prototype.toString = function () {
        return "GuardsCheckEnd(id: " + this.id + ", url: '" + this.url + "', urlAfterRedirects: '" + this.urlAfterRedirects + "', state: " + this.state + ", shouldActivate: " + this.shouldActivate + ")";
    };
    return GuardsCheckEnd;
}(RouterEvent));
/**
 * @description
 *
 * Represents the start of the Resolve phase of routing. The timing of this
 * event may change, thus it's experimental. In the current iteration it will run
 * in the "resolve" phase whether there's things to resolve or not. In the future this
 * behavior may change to only run when there are things to be resolved.
 *
 * @publicApi
 */
var ResolveStart = /** @class */ (function (_super) {
    __extends(ResolveStart, _super);
    function ResolveStart(
    /** @docsNotRequired */
    id, 
    /** @docsNotRequired */
    url, 
    /** @docsNotRequired */
    urlAfterRedirects, 
    /** @docsNotRequired */
    state) {
        var _this = _super.call(this, id, url) || this;
        _this.urlAfterRedirects = urlAfterRedirects;
        _this.state = state;
        return _this;
    }
    ResolveStart.prototype.toString = function () {
        return "ResolveStart(id: " + this.id + ", url: '" + this.url + "', urlAfterRedirects: '" + this.urlAfterRedirects + "', state: " + this.state + ")";
    };
    return ResolveStart;
}(RouterEvent));
/**
 * @description
 *
 * Represents the end of the Resolve phase of routing. See note on
 * `ResolveStart` for use of this experimental API.
 *
 * @publicApi
 */
var ResolveEnd = /** @class */ (function (_super) {
    __extends(ResolveEnd, _super);
    function ResolveEnd(
    /** @docsNotRequired */
    id, 
    /** @docsNotRequired */
    url, 
    /** @docsNotRequired */
    urlAfterRedirects, 
    /** @docsNotRequired */
    state) {
        var _this = _super.call(this, id, url) || this;
        _this.urlAfterRedirects = urlAfterRedirects;
        _this.state = state;
        return _this;
    }
    ResolveEnd.prototype.toString = function () {
        return "ResolveEnd(id: " + this.id + ", url: '" + this.url + "', urlAfterRedirects: '" + this.urlAfterRedirects + "', state: " + this.state + ")";
    };
    return ResolveEnd;
}(RouterEvent));
/**
 * @description
 *
 * Represents an event triggered before lazy loading a route config.
 *
 * @publicApi
 */
var RouteConfigLoadStart = /** @class */ (function () {
    function RouteConfigLoadStart(
    /** @docsNotRequired */
    route) {
        this.route = route;
    }
    RouteConfigLoadStart.prototype.toString = function () { return "RouteConfigLoadStart(path: " + this.route.path + ")"; };
    return RouteConfigLoadStart;
}());
/**
 * @description
 *
 * Represents an event triggered when a route has been lazy loaded.
 *
 * @publicApi
 */
var RouteConfigLoadEnd = /** @class */ (function () {
    function RouteConfigLoadEnd(
    /** @docsNotRequired */
    route) {
        this.route = route;
    }
    RouteConfigLoadEnd.prototype.toString = function () { return "RouteConfigLoadEnd(path: " + this.route.path + ")"; };
    return RouteConfigLoadEnd;
}());
/**
 * @description
 *
 * Represents the start of end of the Resolve phase of routing. See note on
 * `ChildActivationEnd` for use of this experimental API.
 *
 * @publicApi
 */
var ChildActivationStart = /** @class */ (function () {
    function ChildActivationStart(
    /** @docsNotRequired */
    snapshot) {
        this.snapshot = snapshot;
    }
    ChildActivationStart.prototype.toString = function () {
        var path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';
        return "ChildActivationStart(path: '" + path + "')";
    };
    return ChildActivationStart;
}());
/**
 * @description
 *
 * Represents the start of end of the Resolve phase of routing. See note on
 * `ChildActivationStart` for use of this experimental API.
 *
 * @publicApi
 */
var ChildActivationEnd = /** @class */ (function () {
    function ChildActivationEnd(
    /** @docsNotRequired */
    snapshot) {
        this.snapshot = snapshot;
    }
    ChildActivationEnd.prototype.toString = function () {
        var path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';
        return "ChildActivationEnd(path: '" + path + "')";
    };
    return ChildActivationEnd;
}());
/**
 * @description
 *
 * Represents the start of end of the Resolve phase of routing. See note on
 * `ActivationEnd` for use of this experimental API.
 *
 * @publicApi
 */
var ActivationStart = /** @class */ (function () {
    function ActivationStart(
    /** @docsNotRequired */
    snapshot) {
        this.snapshot = snapshot;
    }
    ActivationStart.prototype.toString = function () {
        var path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';
        return "ActivationStart(path: '" + path + "')";
    };
    return ActivationStart;
}());
/**
 * @description
 *
 * Represents the start of end of the Resolve phase of routing. See note on
 * `ActivationStart` for use of this experimental API.
 *
 * @publicApi
 */
var ActivationEnd = /** @class */ (function () {
    function ActivationEnd(
    /** @docsNotRequired */
    snapshot) {
        this.snapshot = snapshot;
    }
    ActivationEnd.prototype.toString = function () {
        var path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || '';
        return "ActivationEnd(path: '" + path + "')";
    };
    return ActivationEnd;
}());
/**
 * @description
 *
 * Represents a scrolling event.
 *
 * @publicApi
 */
var Scroll = /** @class */ (function () {
    function Scroll(
    /** @docsNotRequired */
    routerEvent, 
    /** @docsNotRequired */
    position, 
    /** @docsNotRequired */
    anchor) {
        this.routerEvent = routerEvent;
        this.position = position;
        this.anchor = anchor;
    }
    Scroll.prototype.toString = function () {
        var pos = this.position ? this.position[0] + ", " + this.position[1] : null;
        return "Scroll(anchor: '" + this.anchor + "', position: '" + pos + "')";
    };
    return Scroll;
}());

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * This component is used internally within the router to be a placeholder when an empty
 * router-outlet is needed. For example, with a config such as:
 *
 * `{path: 'parent', outlet: 'nav', children: [...]}`
 *
 * In order to render, there needs to be a component on this config, which will default
 * to this `EmptyOutletComponent`.
 */
var EmptyOutletComponent = /** @class */ (function () {
    function EmptyOutletComponent() {
    }
    EmptyOutletComponent = __decorate([
        Component({ template: "<router-outlet></router-outlet>" })
    ], EmptyOutletComponent);
    return EmptyOutletComponent;
}());

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @description
 *
 * Name of the primary outlet.
 *
 * @publicApi
 */
var PRIMARY_OUTLET = 'primary';
var ParamsAsMap = /** @class */ (function () {
    function ParamsAsMap(params) {
        this.params = params || {};
    }
    ParamsAsMap.prototype.has = function (name) { return this.params.hasOwnProperty(name); };
    ParamsAsMap.prototype.get = function (name) {
        if (this.has(name)) {
            var v = this.params[name];
            return Array.isArray(v) ? v[0] : v;
        }
        return null;
    };
    ParamsAsMap.prototype.getAll = function (name) {
        if (this.has(name)) {
            var v = this.params[name];
            return Array.isArray(v) ? v : [v];
        }
        return [];
    };
    Object.defineProperty(ParamsAsMap.prototype, "keys", {
        get: function () { return Object.keys(this.params); },
        enumerable: true,
        configurable: true
    });
    return ParamsAsMap;
}());
/**
 * Convert a `Params` instance to a `ParamMap`.
 *
 * @publicApi
 */
function convertToParamMap(params) {
    return new ParamsAsMap(params);
}
var NAVIGATION_CANCELING_ERROR = 'ngNavigationCancelingError';
function navigationCancelingError(message) {
    var error = Error('NavigationCancelingError: ' + message);
    error[NAVIGATION_CANCELING_ERROR] = true;
    return error;
}
function isNavigationCancelingError(error) {
    return error && error[NAVIGATION_CANCELING_ERROR];
}
// Matches the route configuration (`route`) against the actual URL (`segments`).
function defaultUrlMatcher(segments, segmentGroup, route) {
    var parts = route.path.split('/');
    if (parts.length > segments.length) {
        // The actual URL is shorter than the config, no match
        return null;
    }
    if (route.pathMatch === 'full' &&
        (segmentGroup.hasChildren() || parts.length < segments.length)) {
        // The config is longer than the actual URL but we are looking for a full match, return null
        return null;
    }
    var posParams = {};
    // Check each config part against the actual URL
    for (var index = 0; index < parts.length; index++) {
        var part = parts[index];
        var segment = segments[index];
        var isParameter = part.startsWith(':');
        if (isParameter) {
            posParams[part.substring(1)] = segment;
        }
        else if (part !== segment.path) {
            // The actual URL part does not match the config, no match
            return null;
        }
    }
    return { consumed: segments.slice(0, parts.length), posParams: posParams };
}

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var LoadedRouterConfig = /** @class */ (function () {
    function LoadedRouterConfig(routes, module) {
        this.routes = routes;
        this.module = module;
    }
    return LoadedRouterConfig;
}());
function validateConfig(config, parentPath) {
    if (parentPath === void 0) { parentPath = ''; }
    // forEach doesn't iterate undefined values
    for (var i = 0; i < config.length; i++) {
        var route = config[i];
        var fullPath = getFullPath(parentPath, route);
        validateNode(route, fullPath);
    }
}
function validateNode(route, fullPath) {
    if (!route) {
        throw new Error("\n      Invalid configuration of route '" + fullPath + "': Encountered undefined route.\n      The reason might be an extra comma.\n\n      Example:\n      const routes: Routes = [\n        { path: '', redirectTo: '/dashboard', pathMatch: 'full' },\n        { path: 'dashboard',  component: DashboardComponent },, << two commas\n        { path: 'detail/:id', component: HeroDetailComponent }\n      ];\n    ");
    }
    if (Array.isArray(route)) {
        throw new Error("Invalid configuration of route '" + fullPath + "': Array cannot be specified");
    }
    if (!route.component && !route.children && !route.loadChildren &&
        (route.outlet && route.outlet !== PRIMARY_OUTLET)) {
        throw new Error("Invalid configuration of route '" + fullPath + "': a componentless route without children or loadChildren cannot have a named outlet set");
    }
    if (route.redirectTo && route.children) {
        throw new Error("Invalid configuration of route '" + fullPath + "': redirectTo and children cannot be used together");
    }
    if (route.redirectTo && route.loadChildren) {
        throw new Error("Invalid configuration of route '" + fullPath + "': redirectTo and loadChildren cannot be used together");
    }
    if (route.children && route.loadChildren) {
        throw new Error("Invalid configuration of route '" + fullPath + "': children and loadChildren cannot be used together");
    }
    if (route.redirectTo && route.component) {
        throw new Error("Invalid configuration of route '" + fullPath + "': redirectTo and component cannot be used together");
    }
    if (route.path && route.matcher) {
        throw new Error("Invalid configuration of route '" + fullPath + "': path and matcher cannot be used together");
    }
    if (route.redirectTo === void 0 && !route.component && !route.children && !route.loadChildren) {
        throw new Error("Invalid configuration of route '" + fullPath + "'. One of the following must be provided: component, redirectTo, children or loadChildren");
    }
    if (route.path === void 0 && route.matcher === void 0) {
        throw new Error("Invalid configuration of route '" + fullPath + "': routes must have either a path or a matcher specified");
    }
    if (typeof route.path === 'string' && route.path.charAt(0) === '/') {
        throw new Error("Invalid configuration of route '" + fullPath + "': path cannot start with a slash");
    }
    if (route.path === '' && route.redirectTo !== void 0 && route.pathMatch === void 0) {
        var exp = "The default value of 'pathMatch' is 'prefix', but often the intent is to use 'full'.";
        throw new Error("Invalid configuration of route '{path: \"" + fullPath + "\", redirectTo: \"" + route.redirectTo + "\"}': please provide 'pathMatch'. " + exp);
    }
    if (route.pathMatch !== void 0 && route.pathMatch !== 'full' && route.pathMatch !== 'prefix') {
        throw new Error("Invalid configuration of route '" + fullPath + "': pathMatch can only be set to 'prefix' or 'full'");
    }
    if (route.children) {
        validateConfig(route.children, fullPath);
    }
}
function getFullPath(parentPath, currentRoute) {
    if (!currentRoute) {
        return parentPath;
    }
    if (!parentPath && !currentRoute.path) {
        return '';
    }
    else if (parentPath && !currentRoute.path) {
        return parentPath + "/";
    }
    else if (!parentPath && currentRoute.path) {
        return currentRoute.path;
    }
    else {
        return parentPath + "/" + currentRoute.path;
    }
}
/**
 * Makes a copy of the config and adds any default required properties.
 */
function standardizeConfig(r) {
    var children = r.children && r.children.map(standardizeConfig);
    var c = children ? __assign({}, r, { children: children }) : __assign({}, r);
    if (!c.component && (children || c.loadChildren) && (c.outlet && c.outlet !== PRIMARY_OUTLET)) {
        c.component = EmptyOutletComponent;
    }
    return c;
}

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
function shallowEqualArrays(a, b) {
    if (a.length !== b.length)
        return false;
    for (var i = 0; i < a.length; ++i) {
        if (!shallowEqual(a[i], b[i]))
            return false;
    }
    return true;
}
function shallowEqual(a, b) {
    var k1 = Object.keys(a);
    var k2 = Object.keys(b);
    if (k1.length != k2.length) {
        return false;
    }
    var key;
    for (var i = 0; i < k1.length; i++) {
        key = k1[i];
        if (a[key] !== b[key]) {
            return false;
        }
    }
    return true;
}
/**
 * Flattens single-level nested arrays.
 */
function flatten(arr) {
    return Array.prototype.concat.apply([], arr);
}
/**
 * Return the last element of an array.
 */
function last$1(a) {
    return a.length > 0 ? a[a.length - 1] : null;
}
function forEach(map$$1, callback) {
    for (var prop in map$$1) {
        if (map$$1.hasOwnProperty(prop)) {
            callback(map$$1[prop], prop);
        }
    }
}
function waitForMap(obj, fn) {
    if (Object.keys(obj).length === 0) {
        return of({});
    }
    var waitHead = [];
    var waitTail = [];
    var res = {};
    forEach(obj, function (a, k) {
        var mapped = fn(k, a).pipe(map(function (r) { return res[k] = r; }));
        if (k === PRIMARY_OUTLET) {
            waitHead.push(mapped);
        }
        else {
            waitTail.push(mapped);
        }
    });
    // Closure compiler has problem with using spread operator here. So just using Array.concat.
    return of.apply(null, waitHead.concat(waitTail)).pipe(concatAll(), last(), map(function () { return res; }));
}
function wrapIntoObservable(value) {
    if (ɵisObservable(value)) {
        return value;
    }
    if (ɵisPromise(value)) {
        // Use `Promise.resolve()` to wrap promise-like instances.
        // Required ie when a Resolver returns a AngularJS `$q` promise to correctly trigger the
        // change detection.
        return from(Promise.resolve(value));
    }
    return of(value);
}

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
function createEmptyUrlTree() {
    return new UrlTree(new UrlSegmentGroup([], {}), {}, null);
}
function containsTree(container, containee, exact) {
    if (exact) {
        return equalQueryParams(container.queryParams, containee.queryParams) &&
            equalSegmentGroups(container.root, containee.root);
    }
    return containsQueryParams(container.queryParams, containee.queryParams) &&
        containsSegmentGroup(container.root, containee.root);
}
function equalQueryParams(container, containee) {
    // TODO: This does not handle array params correctly.
    return shallowEqual(container, containee);
}
function equalSegmentGroups(container, containee) {
    if (!equalPath(container.segments, containee.segments))
        return false;
    if (container.numberOfChildren !== containee.numberOfChildren)
        return false;
    for (var c in containee.children) {
        if (!container.children[c])
            return false;
        if (!equalSegmentGroups(container.children[c], containee.children[c]))
            return false;
    }
    return true;
}
function containsQueryParams(container, containee) {
    // TODO: This does not handle array params correctly.
    return Object.keys(containee).length <= Object.keys(container).length &&
        Object.keys(containee).every(function (key) { return containee[key] === container[key]; });
}
function containsSegmentGroup(container, containee) {
    return containsSegmentGroupHelper(container, containee, containee.segments);
}
function containsSegmentGroupHelper(container, containee, containeePaths) {
    if (container.segments.length > containeePaths.length) {
        var current = container.segments.slice(0, containeePaths.length);
        if (!equalPath(current, containeePaths))
            return false;
        if (containee.hasChildren())
            return false;
        return true;
    }
    else if (container.segments.length === containeePaths.length) {
        if (!equalPath(container.segments, containeePaths))
            return false;
        for (var c in containee.children) {
            if (!container.children[c])
                return false;
            if (!containsSegmentGroup(container.children[c], containee.children[c]))
                return false;
        }
        return true;
    }
    else {
        var current = containeePaths.slice(0, container.segments.length);
        var next = containeePaths.slice(container.segments.length);
        if (!equalPath(container.segments, current))
            return false;
        if (!container.children[PRIMARY_OUTLET])
            return false;
        return containsSegmentGroupHelper(container.children[PRIMARY_OUTLET], containee, next);
    }
}
/**
 * @description
 *
 * Represents the parsed URL.
 *
 * Since a router state is a tree, and the URL is nothing but a serialized state, the URL is a
 * serialized tree.
 * UrlTree is a data structure that provides a lot of affordances in dealing with URLs
 *
 * @usageNotes
 * ### Example
 *
 * ```
 * @Component({templateUrl:'template.html'})
 * class MyComponent {
 *   constructor(router: Router) {
 *     const tree: UrlTree =
 *       router.parseUrl('/team/33/(user/victor//support:help)?debug=true#fragment');
 *     const f = tree.fragment; // return 'fragment'
 *     const q = tree.queryParams; // returns {debug: 'true'}
 *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];
 *     const s: UrlSegment[] = g.segments; // returns 2 segments 'team' and '33'
 *     g.children[PRIMARY_OUTLET].segments; // returns 2 segments 'user' and 'victor'
 *     g.children['support'].segments; // return 1 segment 'help'
 *   }
 * }
 * ```
 *
 * @publicApi
 */
var UrlTree = /** @class */ (function () {
    /** @internal */
    function UrlTree(
    /** The root segment group of the URL tree */
    root, 
    /** The query params of the URL */
    queryParams, 
    /** The fragment of the URL */
    fragment) {
        this.root = root;
        this.queryParams = queryParams;
        this.fragment = fragment;
    }
    Object.defineProperty(UrlTree.prototype, "queryParamMap", {
        get: function () {
            if (!this._queryParamMap) {
                this._queryParamMap = convertToParamMap(this.queryParams);
            }
            return this._queryParamMap;
        },
        enumerable: true,
        configurable: true
    });
    /** @docsNotRequired */
    UrlTree.prototype.toString = function () { return DEFAULT_SERIALIZER.serialize(this); };
    return UrlTree;
}());
/**
 * @description
 *
 * Represents the parsed URL segment group.
 *
 * See `UrlTree` for more information.
 *
 * @publicApi
 */
var UrlSegmentGroup = /** @class */ (function () {
    function UrlSegmentGroup(
    /** The URL segments of this group. See `UrlSegment` for more information */
    segments, 
    /** The list of children of this group */
    children) {
        var _this = this;
        this.segments = segments;
        this.children = children;
        /** The parent node in the url tree */
        this.parent = null;
        forEach(children, function (v, k) { return v.parent = _this; });
    }
    /** Whether the segment has child segments */
    UrlSegmentGroup.prototype.hasChildren = function () { return this.numberOfChildren > 0; };
    Object.defineProperty(UrlSegmentGroup.prototype, "numberOfChildren", {
        /** Number of child segments */
        get: function () { return Object.keys(this.children).length; },
        enumerable: true,
        configurable: true
    });
    /** @docsNotRequired */
    UrlSegmentGroup.prototype.toString = function () { return serializePaths(this); };
    return UrlSegmentGroup;
}());
/**
 * @description
 *
 * Represents a single URL segment.
 *
 * A UrlSegment is a part of a URL between the two slashes. It contains a path and the matrix
 * parameters associated with the segment.
 *
 * @usageNotes
 * ### Example
 *
 * ```
 * @Component({templateUrl:'template.html'})
 * class MyComponent {
 *   constructor(router: Router) {
 *     const tree: UrlTree = router.parseUrl('/team;id=33');
 *     const g: UrlSegmentGroup = tree.root.children[PRIMARY_OUTLET];
 *     const s: UrlSegment[] = g.segments;
 *     s[0].path; // returns 'team'
 *     s[0].parameters; // returns {id: 33}
 *   }
 * }
 * ```
 *
 * @publicApi
 */
var UrlSegment = /** @class */ (function () {
    function UrlSegment(
    /** The path part of a URL segment */
    path, 
    /** The matrix parameters associated with a segment */
    parameters) {
        this.path = path;
        this.parameters = parameters;
    }
    Object.defineProperty(UrlSegment.prototype, "parameterMap", {
        get: function () {
            if (!this._parameterMap) {
                this._parameterMap = convertToParamMap(this.parameters);
            }
            return this._parameterMap;
        },
        enumerable: true,
        configurable: true
    });
    /** @docsNotRequired */
    UrlSegment.prototype.toString = function () { return serializePath(this); };
    return UrlSegment;
}());
function equalSegments(as, bs) {
    return equalPath(as, bs) && as.every(function (a, i) { return shallowEqual(a.parameters, bs[i].parameters); });
}
function equalPath(as, bs) {
    if (as.length !== bs.length)
        return false;
    return as.every(function (a, i) { return a.path === bs[i].path; });
}
function mapChildrenIntoArray(segment, fn) {
    var res = [];
    forEach(segment.children, function (child, childOutlet) {
        if (childOutlet === PRIMARY_OUTLET) {
            res = res.concat(fn(child, childOutlet));
        }
    });
    forEach(segment.children, function (child, childOutlet) {
        if (childOutlet !== PRIMARY_OUTLET) {
            res = res.concat(fn(child, childOutlet));
        }
    });
    return res;
}
/**
 * @description
 *
 * Serializes and deserializes a URL string into a URL tree.
 *
 * The url serialization strategy is customizable. You can
 * make all URLs case insensitive by providing a custom UrlSerializer.
 *
 * See `DefaultUrlSerializer` for an example of a URL serializer.
 *
 * @publicApi
 */
var UrlSerializer = /** @class */ (function () {
    function UrlSerializer() {
    }
    return UrlSerializer;
}());
/**
 * @description
 *
 * A default implementation of the `UrlSerializer`.
 *
 * Example URLs:
 *
 * ```
 * /inbox/33(popup:compose)
 * /inbox/33;open=true/messages/44
 * ```
 *
 * DefaultUrlSerializer uses parentheses to serialize secondary segments (e.g., popup:compose), the
 * colon syntax to specify the outlet, and the ';parameter=value' syntax (e.g., open=true) to
 * specify route specific parameters.
 *
 * @publicApi
 */
var DefaultUrlSerializer = /** @class */ (function () {
    function DefaultUrlSerializer() {
    }
    /** Parses a url into a `UrlTree` */
    DefaultUrlSerializer.prototype.parse = function (url) {
        var p = new UrlParser(url);
        return new UrlTree(p.parseRootSegment(), p.parseQueryParams(), p.parseFragment());
    };
    /** Converts a `UrlTree` into a url */
    DefaultUrlSerializer.prototype.serialize = function (tree) {
        var segment = "/" + serializeSegment(tree.root, true);
        var query = serializeQueryParams(tree.queryParams);
        var fragment = typeof tree.fragment === "string" ? "#" + encodeUriFragment(tree.fragment) : '';
        return "" + segment + query + fragment;
    };
    return DefaultUrlSerializer;
}());
var DEFAULT_SERIALIZER = new DefaultUrlSerializer();
function serializePaths(segment) {
    return segment.segments.map(function (p) { return serializePath(p); }).join('/');
}
function serializeSegment(segment, root) {
    if (!segment.hasChildren()) {
        return serializePaths(segment);
    }
    if (root) {
        var primary = segment.children[PRIMARY_OUTLET] ?
            serializeSegment(segment.children[PRIMARY_OUTLET], false) :
            '';
        var children_1 = [];
        forEach(segment.children, function (v, k) {
            if (k !== PRIMARY_OUTLET) {
                children_1.push(k + ":" + serializeSegment(v, false));
            }
        });
        return children_1.length > 0 ? primary + "(" + children_1.join('//') + ")" : primary;
    }
    else {
        var children = mapChildrenIntoArray(segment, function (v, k) {
            if (k === PRIMARY_OUTLET) {
                return [serializeSegment(segment.children[PRIMARY_OUTLET], false)];
            }
            return [k + ":" + serializeSegment(v, false)];
        });
        return serializePaths(segment) + "/(" + children.join('//') + ")";
    }
}
/**
 * Encodes a URI string with the default encoding. This function will only ever be called from
 * `encodeUriQuery` or `encodeUriSegment` as it's the base set of encodings to be used. We need
 * a custom encoding because encodeURIComponent is too aggressive and encodes stuff that doesn't
 * have to be encoded per https://url.spec.whatwg.org.
 */
function encodeUriString(s) {
    return encodeURIComponent(s)
        .replace(/%40/g, '@')
        .replace(/%3A/gi, ':')
        .replace(/%24/g, '$')
        .replace(/%2C/gi, ',');
}
/**
 * This function should be used to encode both keys and values in a query string key/value. In
 * the following URL, you need to call encodeUriQuery on "k" and "v":
 *
 * http://www.site.org/html;mk=mv?k=v#f
 */
function encodeUriQuery(s) {
    return encodeUriString(s).replace(/%3B/gi, ';');
}
/**
 * This function should be used to encode a URL fragment. In the following URL, you need to call
 * encodeUriFragment on "f":
 *
 * http://www.site.org/html;mk=mv?k=v#f
 */
function encodeUriFragment(s) {
    return encodeURI(s);
}
/**
 * This function should be run on any URI segment as well as the key and value in a key/value
 * pair for matrix params. In the following URL, you need to call encodeUriSegment on "html",
 * "mk", and "mv":
 *
 * http://www.site.org/html;mk=mv?k=v#f
 */
function encodeUriSegment(s) {
    return encodeUriString(s).replace(/\(/g, '%28').replace(/\)/g, '%29').replace(/%26/gi, '&');
}
function decode(s) {
    return decodeURIComponent(s);
}
// Query keys/values should have the "+" replaced first, as "+" in a query string is " ".
// decodeURIComponent function will not decode "+" as a space.
function decodeQuery(s) {
    return decode(s.replace(/\+/g, '%20'));
}
function serializePath(path) {
    return "" + encodeUriSegment(path.path) + serializeMatrixParams(path.parameters);
}
function serializeMatrixParams(params) {
    return Object.keys(params)
        .map(function (key) { return ";" + encodeUriSegment(key) + "=" + encodeUriSegment(params[key]); })
        .join('');
}
function serializeQueryParams(params) {
    var strParams = Object.keys(params).map(function (name) {
        var value = params[name];
        return Array.isArray(value) ?
            value.map(function (v) { return encodeUriQuery(name) + "=" + encodeUriQuery(v); }).join('&') :
            encodeUriQuery(name) + "=" + encodeUriQuery(value);
    });
    return strParams.length ? "?" + strParams.join("&") : '';
}
var SEGMENT_RE = /^[^\/()?;=#]+/;
function matchSegments(str) {
    var match = str.match(SEGMENT_RE);
    return match ? match[0] : '';
}
var QUERY_PARAM_RE = /^[^=?&#]+/;
// Return the name of the query param at the start of the string or an empty string
function matchQueryParams(str) {
    var match = str.match(QUERY_PARAM_RE);
    return match ? match[0] : '';
}
var QUERY_PARAM_VALUE_RE = /^[^?&#]+/;
// Return the value of the query param at the start of the string or an empty string
function matchUrlQueryParamValue(str) {
    var match = str.match(QUERY_PARAM_VALUE_RE);
    return match ? match[0] : '';
}
var UrlParser = /** @class */ (function () {
    function UrlParser(url) {
        this.url = url;
        this.remaining = url;
    }
    UrlParser.prototype.parseRootSegment = function () {
        this.consumeOptional('/');
        if (this.remaining === '' || this.peekStartsWith('?') || this.peekStartsWith('#')) {
            return new UrlSegmentGroup([], {});
        }
        // The root segment group never has segments
        return new UrlSegmentGroup([], this.parseChildren());
    };
    UrlParser.prototype.parseQueryParams = function () {
        var params = {};
        if (this.consumeOptional('?')) {
            do {
                this.parseQueryParam(params);
            } while (this.consumeOptional('&'));
        }
        return params;
    };
    UrlParser.prototype.parseFragment = function () {
        return this.consumeOptional('#') ? decodeURIComponent(this.remaining) : null;
    };
    UrlParser.prototype.parseChildren = function () {
        if (this.remaining === '') {
            return {};
        }
        this.consumeOptional('/');
        var segments = [];
        if (!this.peekStartsWith('(')) {
            segments.push(this.parseSegment());
        }
        while (this.peekStartsWith('/') && !this.peekStartsWith('//') && !this.peekStartsWith('/(')) {
            this.capture('/');
            segments.push(this.parseSegment());
        }
        var children = {};
        if (this.peekStartsWith('/(')) {
            this.capture('/');
            children = this.parseParens(true);
        }
        var res = {};
        if (this.peekStartsWith('(')) {
            res = this.parseParens(false);
        }
        if (segments.length > 0 || Object.keys(children).length > 0) {
            res[PRIMARY_OUTLET] = new UrlSegmentGroup(segments, children);
        }
        return res;
    };
    // parse a segment with its matrix parameters
    // ie `name;k1=v1;k2`
    UrlParser.prototype.parseSegment = function () {
        var path = matchSegments(this.remaining);
        if (path === '' && this.peekStartsWith(';')) {
            throw new Error("Empty path url segment cannot have parameters: '" + this.remaining + "'.");
        }
        this.capture(path);
        return new UrlSegment(decode(path), this.parseMatrixParams());
    };
    UrlParser.prototype.parseMatrixParams = function () {
        var params = {};
        while (this.consumeOptional(';')) {
            this.parseParam(params);
        }
        return params;
    };
    UrlParser.prototype.parseParam = function (params) {
        var key = matchSegments(this.remaining);
        if (!key) {
            return;
        }
        this.capture(key);
        var value = '';
        if (this.consumeOptional('=')) {
            var valueMatch = matchSegments(this.remaining);
            if (valueMatch) {
                value = valueMatch;
                this.capture(value);
            }
        }
        params[decode(key)] = decode(value);
    };
    // Parse a single query parameter `name[=value]`
    UrlParser.prototype.parseQueryParam = function (params) {
        var key = matchQueryParams(this.remaining);
        if (!key) {
            return;
        }
        this.capture(key);
        var value = '';
        if (this.consumeOptional('=')) {
            var valueMatch = matchUrlQueryParamValue(this.remaining);
            if (valueMatch) {
                value = valueMatch;
                this.capture(value);
            }
        }
        var decodedKey = decodeQuery(key);
        var decodedVal = decodeQuery(value);
        if (params.hasOwnProperty(decodedKey)) {
            // Append to existing values
            var currentVal = params[decodedKey];
            if (!Array.isArray(currentVal)) {
                currentVal = [currentVal];
                params[decodedKey] = currentVal;
            }
            currentVal.push(decodedVal);
        }
        else {
            // Create a new value
            params[decodedKey] = decodedVal;
        }
    };
    // parse `(a/b//outlet_name:c/d)`
    UrlParser.prototype.parseParens = function (allowPrimary) {
        var segments = {};
        this.capture('(');
        while (!this.consumeOptional(')') && this.remaining.length > 0) {
            var path = matchSegments(this.remaining);
            var next = this.remaining[path.length];
            // if is is not one of these characters, then the segment was unescaped
            // or the group was not closed
            if (next !== '/' && next !== ')' && next !== ';') {
                throw new Error("Cannot parse url '" + this.url + "'");
            }
            var outletName = undefined;
            if (path.indexOf(':') > -1) {
                outletName = path.substr(0, path.indexOf(':'));
                this.capture(outletName);
                this.capture(':');
            }
            else if (allowPrimary) {
                outletName = PRIMARY_OUTLET;
            }
            var children = this.parseChildren();
            segments[outletName] = Object.keys(children).length === 1 ? children[PRIMARY_OUTLET] :
                new UrlSegmentGroup([], children);
            this.consumeOptional('//');
        }
        return segments;
    };
    UrlParser.prototype.peekStartsWith = function (str) { return this.remaining.startsWith(str); };
    // Consumes the prefix when it is present and returns whether it has been consumed
    UrlParser.prototype.consumeOptional = function (str) {
        if (this.peekStartsWith(str)) {
            this.remaining = this.remaining.substring(str.length);
            return true;
        }
        return false;
    };
    UrlParser.prototype.capture = function (str) {
        if (!this.consumeOptional(str)) {
            throw new Error("Expected \"" + str + "\".");
        }
    };
    return UrlParser;
}());

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var Tree = /** @class */ (function () {
    function Tree(root) {
        this._root = root;
    }
    Object.defineProperty(Tree.prototype, "root", {
        get: function () { return this._root.value; },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal
     */
    Tree.prototype.parent = function (t) {
        var p = this.pathFromRoot(t);
        return p.length > 1 ? p[p.length - 2] : null;
    };
    /**
     * @internal
     */
    Tree.prototype.children = function (t) {
        var n = findNode(t, this._root);
        return n ? n.children.map(function (t) { return t.value; }) : [];
    };
    /**
     * @internal
     */
    Tree.prototype.firstChild = function (t) {
        var n = findNode(t, this._root);
        return n && n.children.length > 0 ? n.children[0].value : null;
    };
    /**
     * @internal
     */
    Tree.prototype.siblings = function (t) {
        var p = findPath(t, this._root);
        if (p.length < 2)
            return [];
        var c = p[p.length - 2].children.map(function (c) { return c.value; });
        return c.filter(function (cc) { return cc !== t; });
    };
    /**
     * @internal
     */
    Tree.prototype.pathFromRoot = function (t) { return findPath(t, this._root).map(function (s) { return s.value; }); };
    return Tree;
}());
// DFS for the node matching the value
function findNode(value, node) {
    var e_1, _a;
    if (value === node.value)
        return node;
    try {
        for (var _b = __values(node.children), _c = _b.next(); !_c.done; _c = _b.next()) {
            var child = _c.value;
            var node_1 = findNode(value, child);
            if (node_1)
                return node_1;
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return null;
}
// Return the path to the node with the given value using DFS
function findPath(value, node) {
    var e_2, _a;
    if (value === node.value)
        return [node];
    try {
        for (var _b = __values(node.children), _c = _b.next(); !_c.done; _c = _b.next()) {
            var child = _c.value;
            var path = findPath(value, child);
            if (path.length) {
                path.unshift(node);
                return path;
            }
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return [];
}
var TreeNode = /** @class */ (function () {
    function TreeNode(value, children) {
        this.value = value;
        this.children = children;
    }
    TreeNode.prototype.toString = function () { return "TreeNode(" + this.value + ")"; };
    return TreeNode;
}());
// Return the list of T indexed by outlet name
function nodeChildrenAsMap(node) {
    var map$$1 = {};
    if (node) {
        node.children.forEach(function (child) { return map$$1[child.value.outlet] = child; });
    }
    return map$$1;
}

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @description
 *
 * Represents the state of the router.
 *
 * RouterState is a tree of activated routes. Every node in this tree knows about the "consumed" URL
 * segments, the extracted parameters, and the resolved data.
 *
 * @usageNotes
 * ### Example
 *
 * ```
 * @Component({templateUrl:'template.html'})
 * class MyComponent {
 *   constructor(router: Router) {
 *     const state: RouterState = router.routerState;
 *     const root: ActivatedRoute = state.root;
 *     const child = root.firstChild;
 *     const id: Observable<string> = child.params.map(p => p.id);
 *     //...
 *   }
 * }
 * ```
 *
 * See `ActivatedRoute` for more information.
 *
 * @publicApi
 */
var RouterState = /** @class */ (function (_super) {
    __extends(RouterState, _super);
    /** @internal */
    function RouterState(root, 
    /** The current snapshot of the router state */
    snapshot) {
        var _this = _super.call(this, root) || this;
        _this.snapshot = snapshot;
        setRouterState(_this, root);
        return _this;
    }
    RouterState.prototype.toString = function () { return this.snapshot.toString(); };
    return RouterState;
}(Tree));
function createEmptyState(urlTree, rootComponent) {
    var snapshot = createEmptyStateSnapshot(urlTree, rootComponent);
    var emptyUrl = new BehaviorSubject([new UrlSegment('', {})]);
    var emptyParams = new BehaviorSubject({});
    var emptyData = new BehaviorSubject({});
    var emptyQueryParams = new BehaviorSubject({});
    var fragment = new BehaviorSubject('');
    var activated = new ActivatedRoute(emptyUrl, emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, snapshot.root);
    activated.snapshot = snapshot.root;
    return new RouterState(new TreeNode(activated, []), snapshot);
}
function createEmptyStateSnapshot(urlTree, rootComponent) {
    var emptyParams = {};
    var emptyData = {};
    var emptyQueryParams = {};
    var fragment = '';
    var activated = new ActivatedRouteSnapshot([], emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, null, urlTree.root, -1, {});
    return new RouterStateSnapshot('', new TreeNode(activated, []));
}
/**
 * @description
 *
 * Contains the information about a route associated with a component loaded in an
 * outlet.  An `ActivatedRoute` can also be used to traverse the router state tree.
 *
 * ```
 * @Component({...})
 * class MyComponent {
 *   constructor(route: ActivatedRoute) {
 *     const id: Observable<string> = route.params.pipe(map(p => p.id));
 *     const url: Observable<string> = route.url.pipe(map(segments => segments.join('')));
 *     // route.data includes both `data` and `resolve`
 *     const user = route.data.pipe(map(d => d.user));
 *   }
 * }
 * ```
 *
 * @publicApi
 */
var ActivatedRoute = /** @class */ (function () {
    /** @internal */
    function ActivatedRoute(
    /** An observable of the URL segments matched by this route */
    url, 
    /** An observable of the matrix parameters scoped to this route */
    params, 
    /** An observable of the query parameters shared by all the routes */
    queryParams, 
    /** An observable of the URL fragment shared by all the routes */
    fragment, 
    /** An observable of the static and resolved data of this route. */
    data, 
    /** The outlet name of the route. It's a constant */
    outlet, 
    /** The component of the route. It's a constant */
    // TODO(vsavkin): remove |string
    component, futureSnapshot) {
        this.url = url;
        this.params = params;
        this.queryParams = queryParams;
        this.fragment = fragment;
        this.data = data;
        this.outlet = outlet;
        this.component = component;
        this._futureSnapshot = futureSnapshot;
    }
    Object.defineProperty(ActivatedRoute.prototype, "routeConfig", {
        /** The configuration used to match this route */
        get: function () { return this._futureSnapshot.routeConfig; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActivatedRoute.prototype, "root", {
        /** The root of the router state */
        get: function () { return this._routerState.root; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActivatedRoute.prototype, "parent", {
        /** The parent of this route in the router state tree */
        get: function () { return this._routerState.parent(this); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActivatedRoute.prototype, "firstChild", {
        /** The first child of this route in the router state tree */
        get: function () { return this._routerState.firstChild(this); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActivatedRoute.prototype, "children", {
        /** The children of this route in the router state tree */
        get: function () { return this._routerState.children(this); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActivatedRoute.prototype, "pathFromRoot", {
        /** The path from the root of the router state tree to this route */
        get: function () { return this._routerState.pathFromRoot(this); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActivatedRoute.prototype, "paramMap", {
        get: function () {
            if (!this._paramMap) {
                this._paramMap = this.params.pipe(map(function (p) { return convertToParamMap(p); }));
            }
            return this._paramMap;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActivatedRoute.prototype, "queryParamMap", {
        get: function () {
            if (!this._queryParamMap) {
                this._queryParamMap =
                    this.queryParams.pipe(map(function (p) { return convertToParamMap(p); }));
            }
            return this._queryParamMap;
        },
        enumerable: true,
        configurable: true
    });
    ActivatedRoute.prototype.toString = function () {
        return this.snapshot ? this.snapshot.toString() : "Future(" + this._futureSnapshot + ")";
    };
    return ActivatedRoute;
}());
/**
 * Returns the inherited params, data, and resolve for a given route.
 * By default, this only inherits values up to the nearest path-less or component-less route.
 * @internal
 */
function inheritedParamsDataResolve(route, paramsInheritanceStrategy) {
    if (paramsInheritanceStrategy === void 0) { paramsInheritanceStrategy = 'emptyOnly'; }
    var pathFromRoot = route.pathFromRoot;
    var inheritingStartingFrom = 0;
    if (paramsInheritanceStrategy !== 'always') {
        inheritingStartingFrom = pathFromRoot.length - 1;
        while (inheritingStartingFrom >= 1) {
            var current = pathFromRoot[inheritingStartingFrom];
            var parent_1 = pathFromRoot[inheritingStartingFrom - 1];
            // current route is an empty path => inherits its parent's params and data
            if (current.routeConfig && current.routeConfig.path === '') {
                inheritingStartingFrom--;
                // parent is componentless => current route should inherit its params and data
            }
            else if (!parent_1.component) {
                inheritingStartingFrom--;
            }
            else {
                break;
            }
        }
    }
    return flattenInherited(pathFromRoot.slice(inheritingStartingFrom));
}
/** @internal */
function flattenInherited(pathFromRoot) {
    return pathFromRoot.reduce(function (res, curr) {
        var params = __assign({}, res.params, curr.params);
        var data = __assign({}, res.data, curr.data);
        var resolve = __assign({}, res.resolve, curr._resolvedData);
        return { params: params, data: data, resolve: resolve };
    }, { params: {}, data: {}, resolve: {} });
}
/**
 * @description
 *
 * Contains the information about a route associated with a component loaded in an
 * outlet at a particular moment in time. ActivatedRouteSnapshot can also be used to
 * traverse the router state tree.
 *
 * ```
 * @Component({templateUrl:'./my-component.html'})
 * class MyComponent {
 *   constructor(route: ActivatedRoute) {
 *     const id: string = route.snapshot.params.id;
 *     const url: string = route.snapshot.url.join('');
 *     const user = route.snapshot.data.user;
 *   }
 * }
 * ```
 *
 * @publicApi
 */
var ActivatedRouteSnapshot = /** @class */ (function () {
    /** @internal */
    function ActivatedRouteSnapshot(
    /** The URL segments matched by this route */
    url, 
    /** The matrix parameters scoped to this route */
    params, 
    /** The query parameters shared by all the routes */
    queryParams, 
    /** The URL fragment shared by all the routes */
    fragment, 
    /** The static and resolved data of this route */
    data, 
    /** The outlet name of the route */
    outlet, 
    /** The component of the route */
    component, routeConfig, urlSegment, lastPathIndex, resolve) {
        this.url = url;
        this.params = params;
        this.queryParams = queryParams;
        this.fragment = fragment;
        this.data = data;
        this.outlet = outlet;
        this.component = component;
        this.routeConfig = routeConfig;
        this._urlSegment = urlSegment;
        this._lastPathIndex = lastPathIndex;
        this._resolve = resolve;
    }
    Object.defineProperty(ActivatedRouteSnapshot.prototype, "root", {
        /** The root of the router state */
        get: function () { return this._routerState.root; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActivatedRouteSnapshot.prototype, "parent", {
        /** The parent of this route in the router state tree */
        get: function () { return this._routerState.parent(this); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActivatedRouteSnapshot.prototype, "firstChild", {
        /** The first child of this route in the router state tree */
        get: function () { return this._routerState.firstChild(this); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActivatedRouteSnapshot.prototype, "children", {
        /** The children of this route in the router state tree */
        get: function () { return this._routerState.children(this); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActivatedRouteSnapshot.prototype, "pathFromRoot", {
        /** The path from the root of the router state tree to this route */
        get: function () { return this._routerState.pathFromRoot(this); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActivatedRouteSnapshot.prototype, "paramMap", {
        get: function () {
            if (!this._paramMap) {
                this._paramMap = convertToParamMap(this.params);
            }
            return this._paramMap;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ActivatedRouteSnapshot.prototype, "queryParamMap", {
        get: function () {
            if (!this._queryParamMap) {
                this._queryParamMap = convertToParamMap(this.queryParams);
            }
            return this._queryParamMap;
        },
        enumerable: true,
        configurable: true
    });
    ActivatedRouteSnapshot.prototype.toString = function () {
        var url = this.url.map(function (segment) { return segment.toString(); }).join('/');
        var matched = this.routeConfig ? this.routeConfig.path : '';
        return "Route(url:'" + url + "', path:'" + matched + "')";
    };
    return ActivatedRouteSnapshot;
}());
/**
 * @description
 *
 * Represents the state of the router at a moment in time.
 *
 * This is a tree of activated route snapshots. Every node in this tree knows about
 * the "consumed" URL segments, the extracted parameters, and the resolved data.
 *
 * @usageNotes
 * ### Example
 *
 * ```
 * @Component({templateUrl:'template.html'})
 * class MyComponent {
 *   constructor(router: Router) {
 *     const state: RouterState = router.routerState;
 *     const snapshot: RouterStateSnapshot = state.snapshot;
 *     const root: ActivatedRouteSnapshot = snapshot.root;
 *     const child = root.firstChild;
 *     const id: Observable<string> = child.params.map(p => p.id);
 *     //...
 *   }
 * }
 * ```
 *
 * @publicApi
 */
var RouterStateSnapshot = /** @class */ (function (_super) {
    __extends(RouterStateSnapshot, _super);
    /** @internal */
    function RouterStateSnapshot(
    /** The url from which this snapshot was created */
    url, root) {
        var _this = _super.call(this, root) || this;
        _this.url = url;
        setRouterState(_this, root);
        return _this;
    }
    RouterStateSnapshot.prototype.toString = function () { return serializeNode(this._root); };
    return RouterStateSnapshot;
}(Tree));
function setRouterState(state, node) {
    node.value._routerState = state;
    node.children.forEach(function (c) { return setRouterState(state, c); });
}
function serializeNode(node) {
    var c = node.children.length > 0 ? " { " + node.children.map(serializeNode).join(', ') + " } " : '';
    return "" + node.value + c;
}
/**
 * The expectation is that the activate route is created with the right set of parameters.
 * So we push new values into the observables only when they are not the initial values.
 * And we detect that by checking if the snapshot field is set.
 */
function advanceActivatedRoute(route) {
    if (route.snapshot) {
        var currentSnapshot = route.snapshot;
        var nextSnapshot = route._futureSnapshot;
        route.snapshot = nextSnapshot;
        if (!shallowEqual(currentSnapshot.queryParams, nextSnapshot.queryParams)) {
            route.queryParams.next(nextSnapshot.queryParams);
        }
        if (currentSnapshot.fragment !== nextSnapshot.fragment) {
            route.fragment.next(nextSnapshot.fragment);
        }
        if (!shallowEqual(currentSnapshot.params, nextSnapshot.params)) {
            route.params.next(nextSnapshot.params);
        }
        if (!shallowEqualArrays(currentSnapshot.url, nextSnapshot.url)) {
            route.url.next(nextSnapshot.url);
        }
        if (!shallowEqual(currentSnapshot.data, nextSnapshot.data)) {
            route.data.next(nextSnapshot.data);
        }
    }
    else {
        route.snapshot = route._futureSnapshot;
        // this is for resolved data
        route.data.next(route._futureSnapshot.data);
    }
}
function equalParamsAndUrlSegments(a, b) {
    var equalUrlParams = shallowEqual(a.params, b.params) && equalSegments(a.url, b.url);
    var parentsMismatch = !a.parent !== !b.parent;
    return equalUrlParams && !parentsMismatch &&
        (!a.parent || equalParamsAndUrlSegments(a.parent, b.parent));
}

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
function createRouterState(routeReuseStrategy, curr, prevState) {
    var root = createNode(routeReuseStrategy, curr._root, prevState ? prevState._root : undefined);
    return new RouterState(root, curr);
}
function createNode(routeReuseStrategy, curr, prevState) {
    // reuse an activated route that is currently displayed on the screen
    if (prevState && routeReuseStrategy.shouldReuseRoute(curr.value, prevState.value.snapshot)) {
        var value = prevState.value;
        value._futureSnapshot = curr.value;
        var children = createOrReuseChildren(routeReuseStrategy, curr, prevState);
        return new TreeNode(value, children);
        // retrieve an activated route that is used to be displayed, but is not currently displayed
    }
    else {
        var detachedRouteHandle = routeReuseStrategy.retrieve(curr.value);
        if (detachedRouteHandle) {
            var tree = detachedRouteHandle.route;
            setFutureSnapshotsOfActivatedRoutes(curr, tree);
            return tree;
        }
        else {
            var value = createActivatedRoute(curr.value);
            var children = curr.children.map(function (c) { return createNode(routeReuseStrategy, c); });
            return new TreeNode(value, children);
        }
    }
}
function setFutureSnapshotsOfActivatedRoutes(curr, result) {
    if (curr.value.routeConfig !== result.value.routeConfig) {
        throw new Error('Cannot reattach ActivatedRouteSnapshot created from a different route');
    }
    if (curr.children.length !== result.children.length) {
        throw new Error('Cannot reattach ActivatedRouteSnapshot with a different number of children');
    }
    result.value._futureSnapshot = curr.value;
    for (var i = 0; i < curr.children.length; ++i) {
        setFutureSnapshotsOfActivatedRoutes(curr.children[i], result.children[i]);
    }
}
function createOrReuseChildren(routeReuseStrategy, curr, prevState) {
    return curr.children.map(function (child) {
        var e_1, _a;
        try {
            for (var _b = __values(prevState.children), _c = _b.next(); !_c.done; _c = _b.next()) {
                var p = _c.value;
                if (routeReuseStrategy.shouldReuseRoute(p.value.snapshot, child.value)) {
                    return createNode(routeReuseStrategy, child, p);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return createNode(routeReuseStrategy, child);
    });
}
function createActivatedRoute(c) {
    return new ActivatedRoute(new BehaviorSubject(c.url), new BehaviorSubject(c.params), new BehaviorSubject(c.queryParams), new BehaviorSubject(c.fragment), new BehaviorSubject(c.data), c.outlet, c.component, c);
}

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
function createUrlTree(route, urlTree, commands, queryParams, fragment) {
    if (commands.length === 0) {
        return tree(urlTree.root, urlTree.root, urlTree, queryParams, fragment);
    }
    var nav = computeNavigation(commands);
    if (nav.toRoot()) {
        return tree(urlTree.root, new UrlSegmentGroup([], {}), urlTree, queryParams, fragment);
    }
    var startingPosition = findStartingPosition(nav, urlTree, route);
    var segmentGroup = startingPosition.processChildren ?
        updateSegmentGroupChildren(startingPosition.segmentGroup, startingPosition.index, nav.commands) :
        updateSegmentGroup(startingPosition.segmentGroup, startingPosition.index, nav.commands);
    return tree(startingPosition.segmentGroup, segmentGroup, urlTree, queryParams, fragment);
}
function isMatrixParams(command) {
    return typeof command === 'object' && command != null && !command.outlets && !command.segmentPath;
}
function tree(oldSegmentGroup, newSegmentGroup, urlTree, queryParams, fragment) {
    var qp = {};
    if (queryParams) {
        forEach(queryParams, function (value, name) {
            qp[name] = Array.isArray(value) ? value.map(function (v) { return "" + v; }) : "" + value;
        });
    }
    if (urlTree.root === oldSegmentGroup) {
        return new UrlTree(newSegmentGroup, qp, fragment);
    }
    return new UrlTree(replaceSegment(urlTree.root, oldSegmentGroup, newSegmentGroup), qp, fragment);
}
function replaceSegment(current, oldSegment, newSegment) {
    var children = {};
    forEach(current.children, function (c, outletName) {
        if (c === oldSegment) {
            children[outletName] = newSegment;
        }
        else {
            children[outletName] = replaceSegment(c, oldSegment, newSegment);
        }
    });
    return new UrlSegmentGroup(current.segments, children);
}
var Navigation = /** @class */ (function () {
    function Navigation(isAbsolute, numberOfDoubleDots, commands) {
        this.isAbsolute = isAbsolute;
        this.numberOfDoubleDots = numberOfDoubleDots;
        this.commands = commands;
        if (isAbsolute && commands.length > 0 && isMatrixParams(commands[0])) {
            throw new Error('Root segment cannot have matrix parameters');
        }
        var cmdWithOutlet = commands.find(function (c) { return typeof c === 'object' && c != null && c.outlets; });
        if (cmdWithOutlet && cmdWithOutlet !== last$1(commands)) {
            throw new Error('{outlets:{}} has to be the last command');
        }
    }
    Navigation.prototype.toRoot = function () {
        return this.isAbsolute && this.commands.length === 1 && this.commands[0] == '/';
    };
    return Navigation;
}());
/** Transforms commands to a normalized `Navigation` */
function computeNavigation(commands) {
    if ((typeof commands[0] === 'string') && commands.length === 1 && commands[0] === '/') {
        return new Navigation(true, 0, commands);
    }
    var numberOfDoubleDots = 0;
    var isAbsolute = false;
    var res = commands.reduce(function (res, cmd, cmdIdx) {
        if (typeof cmd === 'object' && cmd != null) {
            if (cmd.outlets) {
                var outlets_1 = {};
                forEach(cmd.outlets, function (commands, name) {
                    outlets_1[name] = typeof commands === 'string' ? commands.split('/') : commands;
                });
                return __spread(res, [{ outlets: outlets_1 }]);
            }
            if (cmd.segmentPath) {
                return __spread(res, [cmd.segmentPath]);
            }
        }
        if (!(typeof cmd === 'string')) {
            return __spread(res, [cmd]);
        }
        if (cmdIdx === 0) {
            cmd.split('/').forEach(function (urlPart, partIndex) {
                if (partIndex == 0 && urlPart === '.') ;
                else if (partIndex == 0 && urlPart === '') { //  '/a'
                    isAbsolute = true;
                }
                else if (urlPart === '..') { //  '../a'
                    numberOfDoubleDots++;
                }
                else if (urlPart != '') {
                    res.push(urlPart);
                }
            });
            return res;
        }
        return __spread(res, [cmd]);
    }, []);
    return new Navigation(isAbsolute, numberOfDoubleDots, res);
}
var Position = /** @class */ (function () {
    function Position(segmentGroup, processChildren, index) {
        this.segmentGroup = segmentGroup;
        this.processChildren = processChildren;
        this.index = index;
    }
    return Position;
}());
function findStartingPosition(nav, tree, route) {
    if (nav.isAbsolute) {
        return new Position(tree.root, true, 0);
    }
    if (route.snapshot._lastPathIndex === -1) {
        return new Position(route.snapshot._urlSegment, true, 0);
    }
    var modifier = isMatrixParams(nav.commands[0]) ? 0 : 1;
    var index = route.snapshot._lastPathIndex + modifier;
    return createPositionApplyingDoubleDots(route.snapshot._urlSegment, index, nav.numberOfDoubleDots);
}
function createPositionApplyingDoubleDots(group, index, numberOfDoubleDots) {
    var g = group;
    var ci = index;
    var dd = numberOfDoubleDots;
    while (dd > ci) {
        dd -= ci;
        g = g.parent;
        if (!g) {
            throw new Error('Invalid number of \'../\'');
        }
        ci = g.segments.length;
    }
    return new Position(g, false, ci - dd);
}
function getPath(command) {
    if (typeof command === 'object' && command != null && command.outlets) {
        return command.outlets[PRIMARY_OUTLET];
    }
    return "" + command;
}
function getOutlets(commands) {
    var _a, _b;
    if (!(typeof commands[0] === 'object'))
        return _a = {}, _a[PRIMARY_OUTLET] = commands, _a;
    if (commands[0].outlets === undefined)
        return _b = {}, _b[PRIMARY_OUTLET] = commands, _b;
    return commands[0].outlets;
}
function updateSegmentGroup(segmentGroup, startIndex, commands) {
    if (!segmentGroup) {
        segmentGroup = new UrlSegmentGroup([], {});
    }
    if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {
        return updateSegmentGroupChildren(segmentGroup, startIndex, commands);
    }
    var m = prefixedWith(segmentGroup, startIndex, commands);
    var slicedCommands = commands.slice(m.commandIndex);
    if (m.match && m.pathIndex < segmentGroup.segments.length) {
        var g = new UrlSegmentGroup(segmentGroup.segments.slice(0, m.pathIndex), {});
        g.children[PRIMARY_OUTLET] =
            new UrlSegmentGroup(segmentGroup.segments.slice(m.pathIndex), segmentGroup.children);
        return updateSegmentGroupChildren(g, 0, slicedCommands);
    }
    else if (m.match && slicedCommands.length === 0) {
        return new UrlSegmentGroup(segmentGroup.segments, {});
    }
    else if (m.match && !segmentGroup.hasChildren()) {
        return createNewSegmentGroup(segmentGroup, startIndex, commands);
    }
    else if (m.match) {
        return updateSegmentGroupChildren(segmentGroup, 0, slicedCommands);
    }
    else {
        return createNewSegmentGroup(segmentGroup, startIndex, commands);
    }
}
function updateSegmentGroupChildren(segmentGroup, startIndex, commands) {
    if (commands.length === 0) {
        return new UrlSegmentGroup(segmentGroup.segments, {});
    }
    else {
        var outlets_2 = getOutlets(commands);
        var children_1 = {};
        forEach(outlets_2, function (commands, outlet) {
            if (commands !== null) {
                children_1[outlet] = updateSegmentGroup(segmentGroup.children[outlet], startIndex, commands);
            }
        });
        forEach(segmentGroup.children, function (child, childOutlet) {
            if (outlets_2[childOutlet] === undefined) {
                children_1[childOutlet] = child;
            }
        });
        return new UrlSegmentGroup(segmentGroup.segments, children_1);
    }
}
function prefixedWith(segmentGroup, startIndex, commands) {
    var currentCommandIndex = 0;
    var currentPathIndex = startIndex;
    var noMatch = { match: false, pathIndex: 0, commandIndex: 0 };
    while (currentPathIndex < segmentGroup.segments.length) {
        if (currentCommandIndex >= commands.length)
            return noMatch;
        var path = segmentGroup.segments[currentPathIndex];
        var curr = getPath(commands[currentCommandIndex]);
        var next = currentCommandIndex < commands.length - 1 ? commands[currentCommandIndex + 1] : null;
        if (currentPathIndex > 0 && curr === undefined)
            break;
        if (curr && next && (typeof next === 'object') && next.outlets === undefined) {
            if (!compare(curr, next, path))
                return noMatch;
            currentCommandIndex += 2;
        }
        else {
            if (!compare(curr, {}, path))
                return noMatch;
            currentCommandIndex++;
        }
        currentPathIndex++;
    }
    return { match: true, pathIndex: currentPathIndex, commandIndex: currentCommandIndex };
}
function createNewSegmentGroup(segmentGroup, startIndex, commands) {
    var paths = segmentGroup.segments.slice(0, startIndex);
    var i = 0;
    while (i < commands.length) {
        if (typeof commands[i] === 'object' && commands[i].outlets !== undefined) {
            var children = createNewSegmentChildren(commands[i].outlets);
            return new UrlSegmentGroup(paths, children);
        }
        // if we start with an object literal, we need to reuse the path part from the segment
        if (i === 0 && isMatrixParams(commands[0])) {
            var p = segmentGroup.segments[startIndex];
            paths.push(new UrlSegment(p.path, commands[0]));
            i++;
            continue;
        }
        var curr = getPath(commands[i]);
        var next = (i < commands.length - 1) ? commands[i + 1] : null;
        if (curr && next && isMatrixParams(next)) {
            paths.push(new UrlSegment(curr, stringify(next)));
            i += 2;
        }
        else {
            paths.push(new UrlSegment(curr, {}));
            i++;
        }
    }
    return new UrlSegmentGroup(paths, {});
}
function createNewSegmentChildren(outlets) {
    var children = {};
    forEach(outlets, function (commands, outlet) {
        if (commands !== null) {
            children[outlet] = createNewSegmentGroup(new UrlSegmentGroup([], {}), 0, commands);
        }
    });
    return children;
}
function stringify(params) {
    var res = {};
    forEach(params, function (v, k) { return res[k] = "" + v; });
    return res;
}
function compare(path, params, segment) {
    return path == segment.path && shallowEqual(params, segment.parameters);
}

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var activateRoutes = function (rootContexts, routeReuseStrategy, forwardEvent) {
    return map(function (t) {
        new ActivateRoutes(routeReuseStrategy, t.targetRouterState, t.currentRouterState, forwardEvent)
            .activate(rootContexts);
        return t;
    });
};
var ActivateRoutes = /** @class */ (function () {
    function ActivateRoutes(routeReuseStrategy, futureState, currState, forwardEvent) {
        this.routeReuseStrategy = routeReuseStrategy;
        this.futureState = futureState;
        this.currState = currState;
        this.forwardEvent = forwardEvent;
    }
    ActivateRoutes.prototype.activate = function (parentContexts) {
        var futureRoot = this.futureState._root;
        var currRoot = this.currState ? this.currState._root : null;
        this.deactivateChildRoutes(futureRoot, currRoot, parentContexts);
        advanceActivatedRoute(this.futureState.root);
        this.activateChildRoutes(futureRoot, currRoot, parentContexts);
    };
    // De-activate the child route that are not re-used for the future state
    ActivateRoutes.prototype.deactivateChildRoutes = function (futureNode, currNode, contexts) {
        var _this = this;
        var children = nodeChildrenAsMap(currNode);
        // Recurse on the routes active in the future state to de-activate deeper children
        futureNode.children.forEach(function (futureChild) {
            var childOutletName = futureChild.value.outlet;
            _this.deactivateRoutes(futureChild, children[childOutletName], contexts);
            delete children[childOutletName];
        });
        // De-activate the routes that will not be re-used
        forEach(children, function (v, childName) {
            _this.deactivateRouteAndItsChildren(v, contexts);
        });
    };
    ActivateRoutes.prototype.deactivateRoutes = function (futureNode, currNode, parentContext) {
        var future = futureNode.value;
        var curr = currNode ? currNode.value : null;
        if (future === curr) {
            // Reusing the node, check to see if the children need to be de-activated
            if (future.component) {
                // If we have a normal route, we need to go through an outlet.
                var context = parentContext.getContext(future.outlet);
                if (context) {
                    this.deactivateChildRoutes(futureNode, currNode, context.children);
                }
            }
            else {
                // if we have a componentless route, we recurse but keep the same outlet map.
                this.deactivateChildRoutes(futureNode, currNode, parentContext);
            }
        }
        else {
            if (curr) {
                // Deactivate the current route which will not be re-used
                this.deactivateRouteAndItsChildren(currNode, parentContext);
            }
        }
    };
    ActivateRoutes.prototype.deactivateRouteAndItsChildren = function (route, parentContexts) {
        if (this.routeReuseStrategy.shouldDetach(route.value.snapshot)) {
            this.detachAndStoreRouteSubtree(route, parentContexts);
        }
        else {
            this.deactivateRouteAndOutlet(route, parentContexts);
        }
    };
    ActivateRoutes.prototype.detachAndStoreRouteSubtree = function (route, parentContexts) {
        var context = parentContexts.getContext(route.value.outlet);
        if (context && context.outlet) {
            var componentRef = context.outlet.detach();
            var contexts = context.children.onOutletDeactivated();
            this.routeReuseStrategy.store(route.value.snapshot, { componentRef: componentRef, route: route, contexts: contexts });
        }
    };
    ActivateRoutes.prototype.deactivateRouteAndOutlet = function (route, parentContexts) {
        var _this = this;
        var context = parentContexts.getContext(route.value.outlet);
        if (context) {
            var children = nodeChildrenAsMap(route);
            var contexts_1 = route.value.component ? context.children : parentContexts;
            forEach(children, function (v, k) { return _this.deactivateRouteAndItsChildren(v, contexts_1); });
            if (context.outlet) {
                // Destroy the component
                context.outlet.deactivate();
                // Destroy the contexts for all the outlets that were in the component
                context.children.onOutletDeactivated();
            }
        }
    };
    ActivateRoutes.prototype.activateChildRoutes = function (futureNode, currNode, contexts) {
        var _this = this;
        var children = nodeChildrenAsMap(currNode);
        futureNode.children.forEach(function (c) {
            _this.activateRoutes(c, children[c.value.outlet], contexts);
            _this.forwardEvent(new ActivationEnd(c.value.snapshot));
        });
        if (futureNode.children.length) {
            this.forwardEvent(new ChildActivationEnd(futureNode.value.snapshot));
        }
    };
    ActivateRoutes.prototype.activateRoutes = function (futureNode, currNode, parentContexts) {
        var future = futureNode.value;
        var curr = currNode ? currNode.value : null;
        advanceActivatedRoute(future);
        // reusing the node
        if (future === curr) {
            if (future.component) {
                // If we have a normal route, we need to go through an outlet.
                var context = parentContexts.getOrCreateContext(future.outlet);
                this.activateChildRoutes(futureNode, currNode, context.children);
            }
            else {
                // if we have a componentless route, we recurse but keep the same outlet map.
                this.activateChildRoutes(futureNode, currNode, parentContexts);
            }
        }
        else {
            if (future.component) {
                // if we have a normal route, we need to place the component into the outlet and recurse.
                var context = parentContexts.getOrCreateContext(future.outlet);
                if (this.routeReuseStrategy.shouldAttach(future.snapshot)) {
                    var stored = this.routeReuseStrategy.retrieve(future.snapshot);
                    this.routeReuseStrategy.store(future.snapshot, null);
                    context.children.onOutletReAttached(stored.contexts);
                    context.attachRef = stored.componentRef;
                    context.route = stored.route.value;
                    if (context.outlet) {
                        // Attach right away when the outlet has already been instantiated
                        // Otherwise attach from `RouterOutlet.ngOnInit` when it is instantiated
                        context.outlet.attach(stored.componentRef, stored.route.value);
                    }
                    advanceActivatedRouteNodeAndItsChildren(stored.route);
                }
                else {
                    var config = parentLoadedConfig(future.snapshot);
                    var cmpFactoryResolver = config ? config.module.componentFactoryResolver : null;
                    context.attachRef = null;
                    context.route = future;
                    context.resolver = cmpFactoryResolver;
                    if (context.outlet) {
                        // Activate the outlet when it has already been instantiated
                        // Otherwise it will get activated from its `ngOnInit` when instantiated
                        context.outlet.activateWith(future, cmpFactoryResolver);
                    }
                    this.activateChildRoutes(futureNode, null, context.children);
                }
            }
            else {
                // if we have a componentless route, we recurse but keep the same outlet map.
                this.activateChildRoutes(futureNode, null, parentContexts);
            }
        }
    };
    return ActivateRoutes;
}());
function advanceActivatedRouteNodeAndItsChildren(node) {
    advanceActivatedRoute(node.value);
    node.children.forEach(advanceActivatedRouteNodeAndItsChildren);
}
function parentLoadedConfig(snapshot) {
    for (var s = snapshot.parent; s; s = s.parent) {
        var route = s.routeConfig;
        if (route && route._loadedConfig)
            return route._loadedConfig;
        if (route && route.component)
            return null;
    }
    return null;
}

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Simple function check, but generic so type inference will flow. Example:
 *
 * function product(a: number, b: number) {
 *   return a * b;
 * }
 *
 * if (isFunction<product>(fn)) {
 *   return fn(1, 2);
 * } else {
 *   throw "Must provide the `product` function";
 * }
 */
function isFunction$1(v) {
    return typeof v === 'function';
}
function isBoolean(v) {
    return typeof v === 'boolean';
}
function isUrlTree(v) {
    return v instanceof UrlTree;
}
function isCanLoad(guard) {
    return guard && isFunction$1(guard.canLoad);
}
function isCanActivate(guard) {
    return guard && isFunction$1(guard.canActivate);
}
function isCanActivateChild(guard) {
    return guard && isFunction$1(guard.canActivateChild);
}
function isCanDeactivate(guard) {
    return guard && isFunction$1(guard.canDeactivate);
}

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var NoMatch = /** @class */ (function () {
    function NoMatch(segmentGroup) {
        this.segmentGroup = segmentGroup || null;
    }
    return NoMatch;
}());
var AbsoluteRedirect = /** @class */ (function () {
    function AbsoluteRedirect(urlTree) {
        this.urlTree = urlTree;
    }
    return AbsoluteRedirect;
}());
function noMatch(segmentGroup) {
    return new Observable(function (obs) { return obs.error(new NoMatch(segmentGroup)); });
}
function absoluteRedirect(newTree) {
    return new Observable(function (obs) { return obs.error(new AbsoluteRedirect(newTree)); });
}
function namedOutletsRedirect(redirectTo) {
    return new Observable(function (obs) { return obs.error(new Error("Only absolute redirects can have named outlets. redirectTo: '" + redirectTo + "'")); });
}
function canLoadFails(route) {
    return new Observable(function (obs) { return obs.error(navigationCancelingError("Cannot load children because the guard of the route \"path: '" + route.path + "'\" returned false")); });
}
/**
 * Returns the `UrlTree` with the redirection applied.
 *
 * Lazy modules are loaded along the way.
 */
function applyRedirects(moduleInjector, configLoader, urlSerializer, urlTree, config) {
    return new ApplyRedirects(moduleInjector, configLoader, urlSerializer, urlTree, config).apply();
}
var ApplyRedirects = /** @class */ (function () {
    function ApplyRedirects(moduleInjector, configLoader, urlSerializer, urlTree, config) {
        this.configLoader = configLoader;
        this.urlSerializer = urlSerializer;
        this.urlTree = urlTree;
        this.config = config;
        this.allowRedirects = true;
        this.ngModule = moduleInjector.get(NgModuleRef);
    }
    ApplyRedirects.prototype.apply = function () {
        var _this = this;
        var expanded$ = this.expandSegmentGroup(this.ngModule, this.config, this.urlTree.root, PRIMARY_OUTLET);
        var urlTrees$ = expanded$.pipe(map(function (rootSegmentGroup) { return _this.createUrlTree(rootSegmentGroup, _this.urlTree.queryParams, _this.urlTree.fragment); }));
        return urlTrees$.pipe(catchError(function (e) {
            if (e instanceof AbsoluteRedirect) {
                // after an absolute redirect we do not apply any more redirects!
                _this.allowRedirects = false;
                // we need to run matching, so we can fetch all lazy-loaded modules
                return _this.match(e.urlTree);
            }
            if (e instanceof NoMatch) {
                throw _this.noMatchError(e);
            }
            throw e;
        }));
    };
    ApplyRedirects.prototype.match = function (tree) {
        var _this = this;
        var expanded$ = this.expandSegmentGroup(this.ngModule, this.config, tree.root, PRIMARY_OUTLET);
        var mapped$ = expanded$.pipe(map(function (rootSegmentGroup) {
            return _this.createUrlTree(rootSegmentGroup, tree.queryParams, tree.fragment);
        }));
        return mapped$.pipe(catchError(function (e) {
            if (e instanceof NoMatch) {
                throw _this.noMatchError(e);
            }
            throw e;
        }));
    };
    ApplyRedirects.prototype.noMatchError = function (e) {
        return new Error("Cannot match any routes. URL Segment: '" + e.segmentGroup + "'");
    };
    ApplyRedirects.prototype.createUrlTree = function (rootCandidate, queryParams, fragment) {
        var _a;
        var root = rootCandidate.segments.length > 0 ?
            new UrlSegmentGroup([], (_a = {}, _a[PRIMARY_OUTLET] = rootCandidate, _a)) :
            rootCandidate;
        return new UrlTree(root, queryParams, fragment);
    };
    ApplyRedirects.prototype.expandSegmentGroup = function (ngModule, routes, segmentGroup, outlet) {
        if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {
            return this.expandChildren(ngModule, routes, segmentGroup)
                .pipe(map(function (children) { return new UrlSegmentGroup([], children); }));
        }
        return this.expandSegment(ngModule, segmentGroup, routes, segmentGroup.segments, outlet, true);
    };
    // Recursively expand segment groups for all the child outlets
    ApplyRedirects.prototype.expandChildren = function (ngModule, routes, segmentGroup) {
        var _this = this;
        return waitForMap(segmentGroup.children, function (childOutlet, child) { return _this.expandSegmentGroup(ngModule, routes, child, childOutlet); });
    };
    ApplyRedirects.prototype.expandSegment = function (ngModule, segmentGroup, routes, segments, outlet, allowRedirects) {
        var _this = this;
        return of.apply(void 0, __spread(routes)).pipe(map(function (r) {
            var expanded$ = _this.expandSegmentAgainstRoute(ngModule, segmentGroup, routes, r, segments, outlet, allowRedirects);
            return expanded$.pipe(catchError(function (e) {
                if (e instanceof NoMatch) {
                    // TODO(i): this return type doesn't match the declared Observable<UrlSegmentGroup> -
                    // talk to Jason
                    return of(null);
                }
                throw e;
            }));
        }), concatAll(), first(function (s) { return !!s; }), catchError(function (e, _) {
            if (e instanceof EmptyError || e.name === 'EmptyError') {
                if (_this.noLeftoversInUrl(segmentGroup, segments, outlet)) {
                    return of(new UrlSegmentGroup([], {}));
                }
                throw new NoMatch(segmentGroup);
            }
            throw e;
        }));
    };
    ApplyRedirects.prototype.noLeftoversInUrl = function (segmentGroup, segments, outlet) {
        return segments.length === 0 && !segmentGroup.children[outlet];
    };
    ApplyRedirects.prototype.expandSegmentAgainstRoute = function (ngModule, segmentGroup, routes, route, paths, outlet, allowRedirects) {
        if (getOutlet(route) !== outlet) {
            return noMatch(segmentGroup);
        }
        if (route.redirectTo === undefined) {
            return this.matchSegmentAgainstRoute(ngModule, segmentGroup, route, paths);
        }
        if (allowRedirects && this.allowRedirects) {
            return this.expandSegmentAgainstRouteUsingRedirect(ngModule, segmentGroup, routes, route, paths, outlet);
        }
        return noMatch(segmentGroup);
    };
    ApplyRedirects.prototype.expandSegmentAgainstRouteUsingRedirect = function (ngModule, segmentGroup, routes, route, segments, outlet) {
        if (route.path === '**') {
            return this.expandWildCardWithParamsAgainstRouteUsingRedirect(ngModule, routes, route, outlet);
        }
        return this.expandRegularSegmentAgainstRouteUsingRedirect(ngModule, segmentGroup, routes, route, segments, outlet);
    };
    ApplyRedirects.prototype.expandWildCardWithParamsAgainstRouteUsingRedirect = function (ngModule, routes, route, outlet) {
        var _this = this;
        var newTree = this.applyRedirectCommands([], route.redirectTo, {});
        if (route.redirectTo.startsWith('/')) {
            return absoluteRedirect(newTree);
        }
        return this.lineralizeSegments(route, newTree).pipe(mergeMap(function (newSegments) {
            var group = new UrlSegmentGroup(newSegments, {});
            return _this.expandSegment(ngModule, group, routes, newSegments, outlet, false);
        }));
    };
    ApplyRedirects.prototype.expandRegularSegmentAgainstRouteUsingRedirect = function (ngModule, segmentGroup, routes, route, segments, outlet) {
        var _this = this;
        var _a = match(segmentGroup, route, segments), matched = _a.matched, consumedSegments = _a.consumedSegments, lastChild = _a.lastChild, positionalParamSegments = _a.positionalParamSegments;
        if (!matched)
            return noMatch(segmentGroup);
        var newTree = this.applyRedirectCommands(consumedSegments, route.redirectTo, positionalParamSegments);
        if (route.redirectTo.startsWith('/')) {
            return absoluteRedirect(newTree);
        }
        return this.lineralizeSegments(route, newTree).pipe(mergeMap(function (newSegments) {
            return _this.expandSegment(ngModule, segmentGroup, routes, newSegments.concat(segments.slice(lastChild)), outlet, false);
        }));
    };
    ApplyRedirects.prototype.matchSegmentAgainstRoute = function (ngModule, rawSegmentGroup, route, segments) {
        var _this = this;
        if (route.path === '**') {
            if (route.loadChildren) {
                return this.configLoader.load(ngModule.injector, route)
                    .pipe(map(function (cfg) {
                    route._loadedConfig = cfg;
                    return new UrlSegmentGroup(segments, {});
                }));
            }
            return of(new UrlSegmentGroup(segments, {}));
        }
        var _a = match(rawSegmentGroup, route, segments), matched = _a.matched, consumedSegments = _a.consumedSegments, lastChild = _a.lastChild;
        if (!matched)
            return noMatch(rawSegmentGroup);
        var rawSlicedSegments = segments.slice(lastChild);
        var childConfig$ = this.getChildConfig(ngModule, route, segments);
        return childConfig$.pipe(mergeMap(function (routerConfig) {
            var childModule = routerConfig.module;
            var childConfig = routerConfig.routes;
            var _a = split(rawSegmentGroup, consumedSegments, rawSlicedSegments, childConfig), segmentGroup = _a.segmentGroup, slicedSegments = _a.slicedSegments;
            if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {
                var expanded$_1 = _this.expandChildren(childModule, childConfig, segmentGroup);
                return expanded$_1.pipe(map(function (children) { return new UrlSegmentGroup(consumedSegments, children); }));
            }
            if (childConfig.length === 0 && slicedSegments.length === 0) {
                return of(new UrlSegmentGroup(consumedSegments, {}));
            }
            var expanded$ = _this.expandSegment(childModule, segmentGroup, childConfig, slicedSegments, PRIMARY_OUTLET, true);
            return expanded$.pipe(map(function (cs) {
                return new UrlSegmentGroup(consumedSegments.concat(cs.segments), cs.children);
            }));
        }));
    };
    ApplyRedirects.prototype.getChildConfig = function (ngModule, route, segments) {
        var _this = this;
        if (route.children) {
            // The children belong to the same module
            return of(new LoadedRouterConfig(route.children, ngModule));
        }
        if (route.loadChildren) {
            // lazy children belong to the loaded module
            if (route._loadedConfig !== undefined) {
                return of(route._loadedConfig);
            }
            return runCanLoadGuard(ngModule.injector, route, segments)
                .pipe(mergeMap(function (shouldLoad) {
                if (shouldLoad) {
                    return _this.configLoader.load(ngModule.injector, route)
                        .pipe(map(function (cfg) {
                        route._loadedConfig = cfg;
                        return cfg;
                    }));
                }
                return canLoadFails(route);
            }));
        }
        return of(new LoadedRouterConfig([], ngModule));
    };
    ApplyRedirects.prototype.lineralizeSegments = function (route, urlTree) {
        var res = [];
        var c = urlTree.root;
        while (true) {
            res = res.concat(c.segments);
            if (c.numberOfChildren === 0) {
                return of(res);
            }
            if (c.numberOfChildren > 1 || !c.children[PRIMARY_OUTLET]) {
                return namedOutletsRedirect(route.redirectTo);
            }
            c = c.children[PRIMARY_OUTLET];
        }
    };
    ApplyRedirects.prototype.applyRedirectCommands = function (segments, redirectTo, posParams) {
        return this.applyRedirectCreatreUrlTree(redirectTo, this.urlSerializer.parse(redirectTo), segments, posParams);
    };
    ApplyRedirects.prototype.applyRedirectCreatreUrlTree = function (redirectTo, urlTree, segments, posParams) {
        var newRoot = this.createSegmentGroup(redirectTo, urlTree.root, segments, posParams);
        return new UrlTree(newRoot, this.createQueryParams(urlTree.queryParams, this.urlTree.queryParams), urlTree.fragment);
    };
    ApplyRedirects.prototype.createQueryParams = function (redirectToParams, actualParams) {
        var res = {};
        forEach(redirectToParams, function (v, k) {
            var copySourceValue = typeof v === 'string' && v.startsWith(':');
            if (copySourceValue) {
                var sourceName = v.substring(1);
                res[k] = actualParams[sourceName];
            }
            else {
                res[k] = v;
            }
        });
        return res;
    };
    ApplyRedirects.prototype.createSegmentGroup = function (redirectTo, group, segments, posParams) {
        var _this = this;
        var updatedSegments = this.createSegments(redirectTo, group.segments, segments, posParams);
        var children = {};
        forEach(group.children, function (child, name) {
            children[name] = _this.createSegmentGroup(redirectTo, child, segments, posParams);
        });
        return new UrlSegmentGroup(updatedSegments, children);
    };
    ApplyRedirects.prototype.createSegments = function (redirectTo, redirectToSegments, actualSegments, posParams) {
        var _this = this;
        return redirectToSegments.map(function (s) { return s.path.startsWith(':') ? _this.findPosParam(redirectTo, s, posParams) :
            _this.findOrReturn(s, actualSegments); });
    };
    ApplyRedirects.prototype.findPosParam = function (redirectTo, redirectToUrlSegment, posParams) {
        var pos = posParams[redirectToUrlSegment.path.substring(1)];
        if (!pos)
            throw new Error("Cannot redirect to '" + redirectTo + "'. Cannot find '" + redirectToUrlSegment.path + "'.");
        return pos;
    };
    ApplyRedirects.prototype.findOrReturn = function (redirectToUrlSegment, actualSegments) {
        var e_1, _a;
        var idx = 0;
        try {
            for (var actualSegments_1 = __values(actualSegments), actualSegments_1_1 = actualSegments_1.next(); !actualSegments_1_1.done; actualSegments_1_1 = actualSegments_1.next()) {
                var s = actualSegments_1_1.value;
                if (s.path === redirectToUrlSegment.path) {
                    actualSegments.splice(idx);
                    return s;
                }
                idx++;
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (actualSegments_1_1 && !actualSegments_1_1.done && (_a = actualSegments_1.return)) _a.call(actualSegments_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return redirectToUrlSegment;
    };
    return ApplyRedirects;
}());
function runCanLoadGuard(moduleInjector, route, segments) {
    var canLoad = route.canLoad;
    if (!canLoad || canLoad.length === 0)
        return of(true);
    var obs = from(canLoad).pipe(map(function (injectionToken) {
        var guard = moduleInjector.get(injectionToken);
        var guardVal;
        if (isCanLoad(guard)) {
            guardVal = guard.canLoad(route, segments);
        }
        else if (isFunction$1(guard)) {
            guardVal = guard(route, segments);
        }
        else {
            throw new Error('Invalid CanLoad guard');
        }
        return wrapIntoObservable(guardVal);
    }));
    return obs.pipe(concatAll(), every(function (result) { return result === true; }));
}
function match(segmentGroup, route, segments) {
    if (route.path === '') {
        if ((route.pathMatch === 'full') && (segmentGroup.hasChildren() || segments.length > 0)) {
            return { matched: false, consumedSegments: [], lastChild: 0, positionalParamSegments: {} };
        }
        return { matched: true, consumedSegments: [], lastChild: 0, positionalParamSegments: {} };
    }
    var matcher = route.matcher || defaultUrlMatcher;
    var res = matcher(segments, segmentGroup, route);
    if (!res) {
        return {
            matched: false,
            consumedSegments: [],
            lastChild: 0,
            positionalParamSegments: {},
        };
    }
    return {
        matched: true,
        consumedSegments: res.consumed,
        lastChild: res.consumed.length,
        positionalParamSegments: res.posParams,
    };
}
function split(segmentGroup, consumedSegments, slicedSegments, config) {
    if (slicedSegments.length > 0 &&
        containsEmptyPathRedirectsWithNamedOutlets(segmentGroup, slicedSegments, config)) {
        var s = new UrlSegmentGroup(consumedSegments, createChildrenForEmptySegments(config, new UrlSegmentGroup(slicedSegments, segmentGroup.children)));
        return { segmentGroup: mergeTrivialChildren(s), slicedSegments: [] };
    }
    if (slicedSegments.length === 0 &&
        containsEmptyPathRedirects(segmentGroup, slicedSegments, config)) {
        var s = new UrlSegmentGroup(segmentGroup.segments, addEmptySegmentsToChildrenIfNeeded(segmentGroup, slicedSegments, config, segmentGroup.children));
        return { segmentGroup: mergeTrivialChildren(s), slicedSegments: slicedSegments };
    }
    return { segmentGroup: segmentGroup, slicedSegments: slicedSegments };
}
function mergeTrivialChildren(s) {
    if (s.numberOfChildren === 1 && s.children[PRIMARY_OUTLET]) {
        var c = s.children[PRIMARY_OUTLET];
        return new UrlSegmentGroup(s.segments.concat(c.segments), c.children);
    }
    return s;
}
function addEmptySegmentsToChildrenIfNeeded(segmentGroup, slicedSegments, routes, children) {
    var e_2, _a;
    var res = {};
    try {
        for (var routes_1 = __values(routes), routes_1_1 = routes_1.next(); !routes_1_1.done; routes_1_1 = routes_1.next()) {
            var r = routes_1_1.value;
            if (isEmptyPathRedirect(segmentGroup, slicedSegments, r) && !children[getOutlet(r)]) {
                res[getOutlet(r)] = new UrlSegmentGroup([], {});
            }
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (routes_1_1 && !routes_1_1.done && (_a = routes_1.return)) _a.call(routes_1);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return __assign({}, children, res);
}
function createChildrenForEmptySegments(routes, primarySegmentGroup) {
    var e_3, _a;
    var res = {};
    res[PRIMARY_OUTLET] = primarySegmentGroup;
    try {
        for (var routes_2 = __values(routes), routes_2_1 = routes_2.next(); !routes_2_1.done; routes_2_1 = routes_2.next()) {
            var r = routes_2_1.value;
            if (r.path === '' && getOutlet(r) !== PRIMARY_OUTLET) {
                res[getOutlet(r)] = new UrlSegmentGroup([], {});
            }
        }
    }
    catch (e_3_1) { e_3 = { error: e_3_1 }; }
    finally {
        try {
            if (routes_2_1 && !routes_2_1.done && (_a = routes_2.return)) _a.call(routes_2);
        }
        finally { if (e_3) throw e_3.error; }
    }
    return res;
}
function containsEmptyPathRedirectsWithNamedOutlets(segmentGroup, segments, routes) {
    return routes.some(function (r) { return isEmptyPathRedirect(segmentGroup, segments, r) && getOutlet(r) !== PRIMARY_OUTLET; });
}
function containsEmptyPathRedirects(segmentGroup, segments, routes) {
    return routes.some(function (r) { return isEmptyPathRedirect(segmentGroup, segments, r); });
}
function isEmptyPathRedirect(segmentGroup, segments, r) {
    if ((segmentGroup.hasChildren() || segments.length > 0) && r.pathMatch === 'full') {
        return false;
    }
    return r.path === '' && r.redirectTo !== undefined;
}
function getOutlet(route) {
    return route.outlet || PRIMARY_OUTLET;
}

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
function applyRedirects$1(moduleInjector, configLoader, urlSerializer, config) {
    return function (source) {
        return source.pipe(switchMap(function (t) { return applyRedirects(moduleInjector, configLoader, urlSerializer, t.extractedUrl, config)
            .pipe(map(function (urlAfterRedirects) { return (__assign({}, t, { urlAfterRedirects: urlAfterRedirects })); })); }));
    };
}

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var CanActivate = /** @class */ (function () {
    function CanActivate(path) {
        this.path = path;
        this.route = this.path[this.path.length - 1];
    }
    return CanActivate;
}());
var CanDeactivate = /** @class */ (function () {
    function CanDeactivate(component, route) {
        this.component = component;
        this.route = route;
    }
    return CanDeactivate;
}());
function getAllRouteGuards(future, curr, parentContexts) {
    var futureRoot = future._root;
    var currRoot = curr ? curr._root : null;
    return getChildRouteGuards(futureRoot, currRoot, parentContexts, [futureRoot.value]);
}
function getCanActivateChild(p) {
    var canActivateChild = p.routeConfig ? p.routeConfig.canActivateChild : null;
    if (!canActivateChild || canActivateChild.length === 0)
        return null;
    return { node: p, guards: canActivateChild };
}
function getToken(token, snapshot, moduleInjector) {
    var config = getClosestLoadedConfig(snapshot);
    var injector = config ? config.module.injector : moduleInjector;
    return injector.get(token);
}
function getClosestLoadedConfig(snapshot) {
    if (!snapshot)
        return null;
    for (var s = snapshot.parent; s; s = s.parent) {
        var route = s.routeConfig;
        if (route && route._loadedConfig)
            return route._loadedConfig;
    }
    return null;
}
function getChildRouteGuards(futureNode, currNode, contexts, futurePath, checks) {
    if (checks === void 0) { checks = {
        canDeactivateChecks: [],
        canActivateChecks: []
    }; }
    var prevChildren = nodeChildrenAsMap(currNode);
    // Process the children of the future route
    futureNode.children.forEach(function (c) {
        getRouteGuards(c, prevChildren[c.value.outlet], contexts, futurePath.concat([c.value]), checks);
        delete prevChildren[c.value.outlet];
    });
    // Process any children left from the current route (not active for the future route)
    forEach(prevChildren, function (v, k) {
        return deactivateRouteAndItsChildren(v, contexts.getContext(k), checks);
    });
    return checks;
}
function getRouteGuards(futureNode, currNode, parentContexts, futurePath, checks) {
    if (checks === void 0) { checks = {
        canDeactivateChecks: [],
        canActivateChecks: []
    }; }
    var future = futureNode.value;
    var curr = currNode ? currNode.value : null;
    var context = parentContexts ? parentContexts.getContext(futureNode.value.outlet) : null;
    // reusing the node
    if (curr && future.routeConfig === curr.routeConfig) {
        var shouldRun = shouldRunGuardsAndResolvers(curr, future, future.routeConfig.runGuardsAndResolvers);
        if (shouldRun) {
            checks.canActivateChecks.push(new CanActivate(futurePath));
        }
        else {
            // we need to set the data
            future.data = curr.data;
            future._resolvedData = curr._resolvedData;
        }
        // If we have a component, we need to go through an outlet.
        if (future.component) {
            getChildRouteGuards(futureNode, currNode, context ? context.children : null, futurePath, checks);
            // if we have a componentless route, we recurse but keep the same outlet map.
        }
        else {
            getChildRouteGuards(futureNode, currNode, parentContexts, futurePath, checks);
        }
        if (shouldRun) {
            var component = context && context.outlet && context.outlet.component || null;
            checks.canDeactivateChecks.push(new CanDeactivate(component, curr));
        }
    }
    else {
        if (curr) {
            deactivateRouteAndItsChildren(currNode, context, checks);
        }
        checks.canActivateChecks.push(new CanActivate(futurePath));
        // If we have a component, we need to go through an outlet.
        if (future.component) {
            getChildRouteGuards(futureNode, null, context ? context.children : null, futurePath, checks);
            // if we have a componentless route, we recurse but keep the same outlet map.
        }
        else {
            getChildRouteGuards(futureNode, null, parentContexts, futurePath, checks);
        }
    }
    return checks;
}
function shouldRunGuardsAndResolvers(curr, future, mode) {
    if (typeof mode === 'function') {
        return mode(curr, future);
    }
    switch (mode) {
        case 'pathParamsChange':
            return !equalPath(curr.url, future.url);
        case 'pathParamsOrQueryParamsChange':
            return !equalPath(curr.url, future.url) ||
                !shallowEqual(curr.queryParams, future.queryParams);
        case 'always':
            return true;
        case 'paramsOrQueryParamsChange':
            return !equalParamsAndUrlSegments(curr, future) ||
                !shallowEqual(curr.queryParams, future.queryParams);
        case 'paramsChange':
        default:
            return !equalParamsAndUrlSegments(curr, future);
    }
}
function deactivateRouteAndItsChildren(route, context, checks) {
    var children = nodeChildrenAsMap(route);
    var r = route.value;
    forEach(children, function (node, childName) {
        if (!r.component) {
            deactivateRouteAndItsChildren(node, context, checks);
        }
        else if (context) {
            deactivateRouteAndItsChildren(node, context.children.getContext(childName), checks);
        }
        else {
            deactivateRouteAndItsChildren(node, null, checks);
        }
    });
    if (!r.component) {
        checks.canDeactivateChecks.push(new CanDeactivate(null, r));
    }
    else if (context && context.outlet && context.outlet.isActivated) {
        checks.canDeactivateChecks.push(new CanDeactivate(context.outlet.component, r));
    }
    else {
        checks.canDeactivateChecks.push(new CanDeactivate(null, r));
    }
}

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var INITIAL_VALUE = Symbol('INITIAL_VALUE');
function prioritizedGuardValue() {
    return switchMap(function (obs) {
        return combineLatest.apply(void 0, __spread(obs.map(function (o) { return o.pipe(take(1), startWith(INITIAL_VALUE)); }))).pipe(scan(function (acc, list) {
            var isPending = false;
            return list.reduce(function (innerAcc, val, i) {
                if (innerAcc !== INITIAL_VALUE)
                    return innerAcc;
                // Toggle pending flag if any values haven't been set yet
                if (val === INITIAL_VALUE)
                    isPending = true;
                // Any other return values are only valid if we haven't yet hit a pending call.
                // This guarantees that in the case of a guard at the bottom of the tree that
                // returns a redirect, we will wait for the higher priority guard at the top to
                // finish before performing the redirect.
                if (!isPending) {
                    // Early return when we hit a `false` value as that should always cancel
                    // navigation
                    if (val === false)
                        return val;
                    if (i === list.length - 1 || isUrlTree(val)) {
                        return val;
                    }
                }
                return innerAcc;
            }, acc);
        }, INITIAL_VALUE), filter(function (item) { return item !== INITIAL_VALUE; }), map(function (item) { return isUrlTree(item) ? item : item === true; }), //
        take(1));
    });
}

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
function checkGuards(moduleInjector, forwardEvent) {
    return function (source) {
        return source.pipe(mergeMap(function (t) {
            var targetSnapshot = t.targetSnapshot, currentSnapshot = t.currentSnapshot, _a = t.guards, canActivateChecks = _a.canActivateChecks, canDeactivateChecks = _a.canDeactivateChecks;
            if (canDeactivateChecks.length === 0 && canActivateChecks.length === 0) {
                return of(__assign({}, t, { guardsResult: true }));
            }
            return runCanDeactivateChecks(canDeactivateChecks, targetSnapshot, currentSnapshot, moduleInjector)
                .pipe(mergeMap(function (canDeactivate) {
                return canDeactivate && isBoolean(canDeactivate) ?
                    runCanActivateChecks(targetSnapshot, canActivateChecks, moduleInjector, forwardEvent) :
                    of(canDeactivate);
            }), map(function (guardsResult) { return (__assign({}, t, { guardsResult: guardsResult })); }));
        }));
    };
}
function runCanDeactivateChecks(checks, futureRSS, currRSS, moduleInjector) {
    return from(checks).pipe(mergeMap(function (check) {
        return runCanDeactivate(check.component, check.route, currRSS, futureRSS, moduleInjector);
    }), first(function (result) { return result !== true; }, true));
}
function runCanActivateChecks(futureSnapshot, checks, moduleInjector, forwardEvent) {
    return from(checks).pipe(concatMap(function (check) {
        return from([
            fireChildActivationStart(check.route.parent, forwardEvent),
            fireActivationStart(check.route, forwardEvent),
            runCanActivateChild(futureSnapshot, check.path, moduleInjector),
            runCanActivate(futureSnapshot, check.route, moduleInjector)
        ])
            .pipe(concatAll(), first(function (result) {
            return result !== true;
        }, true));
    }), first(function (result) { return result !== true; }, true));
}
/**
   * This should fire off `ActivationStart` events for each route being activated at this
   * level.
   * In other words, if you're activating `a` and `b` below, `path` will contain the
   * `ActivatedRouteSnapshot`s for both and we will fire `ActivationStart` for both. Always
   * return
   * `true` so checks continue to run.
   */
function fireActivationStart(snapshot, forwardEvent) {
    if (snapshot !== null && forwardEvent) {
        forwardEvent(new ActivationStart(snapshot));
    }
    return of(true);
}
/**
   * This should fire off `ChildActivationStart` events for each route being activated at this
   * level.
   * In other words, if you're activating `a` and `b` below, `path` will contain the
   * `ActivatedRouteSnapshot`s for both and we will fire `ChildActivationStart` for both. Always
   * return
   * `true` so checks continue to run.
   */
function fireChildActivationStart(snapshot, forwardEvent) {
    if (snapshot !== null && forwardEvent) {
        forwardEvent(new ChildActivationStart(snapshot));
    }
    return of(true);
}
function runCanActivate(futureRSS, futureARS, moduleInjector) {
    var canActivate = futureARS.routeConfig ? futureARS.routeConfig.canActivate : null;
    if (!canActivate || canActivate.length === 0)
        return of(true);
    var canActivateObservables = canActivate.map(function (c) {
        return defer(function () {
            var guard = getToken(c, futureARS, moduleInjector);
            var observable;
            if (isCanActivate(guard)) {
                observable = wrapIntoObservable(guard.canActivate(futureARS, futureRSS));
            }
            else if (isFunction$1(guard)) {
                observable = wrapIntoObservable(guard(futureARS, futureRSS));
            }
            else {
                throw new Error('Invalid CanActivate guard');
            }
            return observable.pipe(first());
        });
    });
    return of(canActivateObservables).pipe(prioritizedGuardValue());
}
function runCanActivateChild(futureRSS, path, moduleInjector) {
    var futureARS = path[path.length - 1];
    var canActivateChildGuards = path.slice(0, path.length - 1)
        .reverse()
        .map(function (p) { return getCanActivateChild(p); })
        .filter(function (_) { return _ !== null; });
    var canActivateChildGuardsMapped = canActivateChildGuards.map(function (d) {
        return defer(function () {
            var guardsMapped = d.guards.map(function (c) {
                var guard = getToken(c, d.node, moduleInjector);
                var observable;
                if (isCanActivateChild(guard)) {
                    observable = wrapIntoObservable(guard.canActivateChild(futureARS, futureRSS));
                }
                else if (isFunction$1(guard)) {
                    observable = wrapIntoObservable(guard(futureARS, futureRSS));
                }
                else {
                    throw new Error('Invalid CanActivateChild guard');
                }
                return observable.pipe(first());
            });
            return of(guardsMapped).pipe(prioritizedGuardValue());
        });
    });
    return of(canActivateChildGuardsMapped).pipe(prioritizedGuardValue());
}
function runCanDeactivate(component, currARS, currRSS, futureRSS, moduleInjector) {
    var canDeactivate = currARS && currARS.routeConfig ? currARS.routeConfig.canDeactivate : null;
    if (!canDeactivate || canDeactivate.length === 0)
        return of(true);
    var canDeactivateObservables = canDeactivate.map(function (c) {
        var guard = getToken(c, currARS, moduleInjector);
        var observable;
        if (isCanDeactivate(guard)) {
            observable =
                wrapIntoObservable(guard.canDeactivate(component, currARS, currRSS, futureRSS));
        }
        else if (isFunction$1(guard)) {
            observable = wrapIntoObservable(guard(component, currARS, currRSS, futureRSS));
        }
        else {
            throw new Error('Invalid CanDeactivate guard');
        }
        return observable.pipe(first());
    });
    return of(canDeactivateObservables).pipe(prioritizedGuardValue());
}

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var NoMatch$1 = /** @class */ (function () {
    function NoMatch() {
    }
    return NoMatch;
}());
function recognize(rootComponentType, config, urlTree, url, paramsInheritanceStrategy, relativeLinkResolution) {
    if (paramsInheritanceStrategy === void 0) { paramsInheritanceStrategy = 'emptyOnly'; }
    if (relativeLinkResolution === void 0) { relativeLinkResolution = 'legacy'; }
    return new Recognizer(rootComponentType, config, urlTree, url, paramsInheritanceStrategy, relativeLinkResolution)
        .recognize();
}
var Recognizer = /** @class */ (function () {
    function Recognizer(rootComponentType, config, urlTree, url, paramsInheritanceStrategy, relativeLinkResolution) {
        this.rootComponentType = rootComponentType;
        this.config = config;
        this.urlTree = urlTree;
        this.url = url;
        this.paramsInheritanceStrategy = paramsInheritanceStrategy;
        this.relativeLinkResolution = relativeLinkResolution;
    }
    Recognizer.prototype.recognize = function () {
        try {
            var rootSegmentGroup = split$1(this.urlTree.root, [], [], this.config, this.relativeLinkResolution).segmentGroup;
            var children = this.processSegmentGroup(this.config, rootSegmentGroup, PRIMARY_OUTLET);
            var root = new ActivatedRouteSnapshot([], Object.freeze({}), Object.freeze(__assign({}, this.urlTree.queryParams)), this.urlTree.fragment, {}, PRIMARY_OUTLET, this.rootComponentType, null, this.urlTree.root, -1, {});
            var rootNode = new TreeNode(root, children);
            var routeState = new RouterStateSnapshot(this.url, rootNode);
            this.inheritParamsAndData(routeState._root);
            return of(routeState);
        }
        catch (e) {
            return new Observable(function (obs) { return obs.error(e); });
        }
    };
    Recognizer.prototype.inheritParamsAndData = function (routeNode) {
        var _this = this;
        var route = routeNode.value;
        var i = inheritedParamsDataResolve(route, this.paramsInheritanceStrategy);
        route.params = Object.freeze(i.params);
        route.data = Object.freeze(i.data);
        routeNode.children.forEach(function (n) { return _this.inheritParamsAndData(n); });
    };
    Recognizer.prototype.processSegmentGroup = function (config, segmentGroup, outlet) {
        if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {
            return this.processChildren(config, segmentGroup);
        }
        return this.processSegment(config, segmentGroup, segmentGroup.segments, outlet);
    };
    Recognizer.prototype.processChildren = function (config, segmentGroup) {
        var _this = this;
        var children = mapChildrenIntoArray(segmentGroup, function (child, childOutlet) { return _this.processSegmentGroup(config, child, childOutlet); });
        checkOutletNameUniqueness(children);
        sortActivatedRouteSnapshots(children);
        return children;
    };
    Recognizer.prototype.processSegment = function (config, segmentGroup, segments, outlet) {
        var e_1, _a;
        try {
            for (var config_1 = __values(config), config_1_1 = config_1.next(); !config_1_1.done; config_1_1 = config_1.next()) {
                var r = config_1_1.value;
                try {
                    return this.processSegmentAgainstRoute(r, segmentGroup, segments, outlet);
                }
                catch (e) {
                    if (!(e instanceof NoMatch$1))
                        throw e;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (config_1_1 && !config_1_1.done && (_a = config_1.return)) _a.call(config_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        if (this.noLeftoversInUrl(segmentGroup, segments, outlet)) {
            return [];
        }
        throw new NoMatch$1();
    };
    Recognizer.prototype.noLeftoversInUrl = function (segmentGroup, segments, outlet) {
        return segments.length === 0 && !segmentGroup.children[outlet];
    };
    Recognizer.prototype.processSegmentAgainstRoute = function (route, rawSegment, segments, outlet) {
        if (route.redirectTo)
            throw new NoMatch$1();
        if ((route.outlet || PRIMARY_OUTLET) !== outlet)
            throw new NoMatch$1();
        var snapshot;
        var consumedSegments = [];
        var rawSlicedSegments = [];
        if (route.path === '**') {
            var params = segments.length > 0 ? last$1(segments).parameters : {};
            snapshot = new ActivatedRouteSnapshot(segments, params, Object.freeze(__assign({}, this.urlTree.queryParams)), this.urlTree.fragment, getData(route), outlet, route.component, route, getSourceSegmentGroup(rawSegment), getPathIndexShift(rawSegment) + segments.length, getResolve(route));
        }
        else {
            var result = match$1(rawSegment, route, segments);
            consumedSegments = result.consumedSegments;
            rawSlicedSegments = segments.slice(result.lastChild);
            snapshot = new ActivatedRouteSnapshot(consumedSegments, result.parameters, Object.freeze(__assign({}, this.urlTree.queryParams)), this.urlTree.fragment, getData(route), outlet, route.component, route, getSourceSegmentGroup(rawSegment), getPathIndexShift(rawSegment) + consumedSegments.length, getResolve(route));
        }
        var childConfig = getChildConfig(route);
        var _a = split$1(rawSegment, consumedSegments, rawSlicedSegments, childConfig, this.relativeLinkResolution), segmentGroup = _a.segmentGroup, slicedSegments = _a.slicedSegments;
        if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {
            var children_1 = this.processChildren(childConfig, segmentGroup);
            return [new TreeNode(snapshot, children_1)];
        }
        if (childConfig.length === 0 && slicedSegments.length === 0) {
            return [new TreeNode(snapshot, [])];
        }
        var children = this.processSegment(childConfig, segmentGroup, slicedSegments, PRIMARY_OUTLET);
        return [new TreeNode(snapshot, children)];
    };
    return Recognizer;
}());
function sortActivatedRouteSnapshots(nodes) {
    nodes.sort(function (a, b) {
        if (a.value.outlet === PRIMARY_OUTLET)
            return -1;
        if (b.value.outlet === PRIMARY_OUTLET)
            return 1;
        return a.value.outlet.localeCompare(b.value.outlet);
    });
}
function getChildConfig(route) {
    if (route.children) {
        return route.children;
    }
    if (route.loadChildren) {
        return route._loadedConfig.routes;
    }
    return [];
}
function match$1(segmentGroup, route, segments) {
    if (route.path === '') {
        if (route.pathMatch === 'full' && (segmentGroup.hasChildren() || segments.length > 0)) {
            throw new NoMatch$1();
        }
        return { consumedSegments: [], lastChild: 0, parameters: {} };
    }
    var matcher = route.matcher || defaultUrlMatcher;
    var res = matcher(segments, segmentGroup, route);
    if (!res)
        throw new NoMatch$1();
    var posParams = {};
    forEach(res.posParams, function (v, k) { posParams[k] = v.path; });
    var parameters = res.consumed.length > 0 ? __assign({}, posParams, res.consumed[res.consumed.length - 1].parameters) :
        posParams;
    return { consumedSegments: res.consumed, lastChild: res.consumed.length, parameters: parameters };
}
function checkOutletNameUniqueness(nodes) {
    var names = {};
    nodes.forEach(function (n) {
        var routeWithSameOutletName = names[n.value.outlet];
        if (routeWithSameOutletName) {
            var p = routeWithSameOutletName.url.map(function (s) { return s.toString(); }).join('/');
            var c = n.value.url.map(function (s) { return s.toString(); }).join('/');
            throw new Error("Two segments cannot have the same outlet name: '" + p + "' and '" + c + "'.");
        }
        names[n.value.outlet] = n.value;
    });
}
function getSourceSegmentGroup(segmentGroup) {
    var s = segmentGroup;
    while (s._sourceSegment) {
        s = s._sourceSegment;
    }
    return s;
}
function getPathIndexShift(segmentGroup) {
    var s = segmentGroup;
    var res = (s._segmentIndexShift ? s._segmentIndexShift : 0);
    while (s._sourceSegment) {
        s = s._sourceSegment;
        res += (s._segmentIndexShift ? s._segmentIndexShift : 0);
    }
    return res - 1;
}
function split$1(segmentGroup, consumedSegments, slicedSegments, config, relativeLinkResolution) {
    if (slicedSegments.length > 0 &&
        containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, config)) {
        var s_1 = new UrlSegmentGroup(consumedSegments, createChildrenForEmptyPaths(segmentGroup, consumedSegments, config, new UrlSegmentGroup(slicedSegments, segmentGroup.children)));
        s_1._sourceSegment = segmentGroup;
        s_1._segmentIndexShift = consumedSegments.length;
        return { segmentGroup: s_1, slicedSegments: [] };
    }
    if (slicedSegments.length === 0 &&
        containsEmptyPathMatches(segmentGroup, slicedSegments, config)) {
        var s_2 = new UrlSegmentGroup(segmentGroup.segments, addEmptyPathsToChildrenIfNeeded(segmentGroup, consumedSegments, slicedSegments, config, segmentGroup.children, relativeLinkResolution));
        s_2._sourceSegment = segmentGroup;
        s_2._segmentIndexShift = consumedSegments.length;
        return { segmentGroup: s_2, slicedSegments: slicedSegments };
    }
    var s = new UrlSegmentGroup(segmentGroup.segments, segmentGroup.children);
    s._sourceSegment = segmentGroup;
    s._segmentIndexShift = consumedSegments.length;
    return { segmentGroup: s, slicedSegments: slicedSegments };
}
function addEmptyPathsToChildrenIfNeeded(segmentGroup, consumedSegments, slicedSegments, routes, children, relativeLinkResolution) {
    var e_2, _a;
    var res = {};
    try {
        for (var routes_1 = __values(routes), routes_1_1 = routes_1.next(); !routes_1_1.done; routes_1_1 = routes_1.next()) {
            var r = routes_1_1.value;
            if (emptyPathMatch(segmentGroup, slicedSegments, r) && !children[getOutlet$1(r)]) {
                var s = new UrlSegmentGroup([], {});
                s._sourceSegment = segmentGroup;
                if (relativeLinkResolution === 'legacy') {
                    s._segmentIndexShift = segmentGroup.segments.length;
                }
                else {
                    s._segmentIndexShift = consumedSegments.length;
                }
                res[getOutlet$1(r)] = s;
            }
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (routes_1_1 && !routes_1_1.done && (_a = routes_1.return)) _a.call(routes_1);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return __assign({}, children, res);
}
function createChildrenForEmptyPaths(segmentGroup, consumedSegments, routes, primarySegment) {
    var e_3, _a;
    var res = {};
    res[PRIMARY_OUTLET] = primarySegment;
    primarySegment._sourceSegment = segmentGroup;
    primarySegment._segmentIndexShift = consumedSegments.length;
    try {
        for (var routes_2 = __values(routes), routes_2_1 = routes_2.next(); !routes_2_1.done; routes_2_1 = routes_2.next()) {
            var r = routes_2_1.value;
            if (r.path === '' && getOutlet$1(r) !== PRIMARY_OUTLET) {
                var s = new UrlSegmentGroup([], {});
                s._sourceSegment = segmentGroup;
                s._segmentIndexShift = consumedSegments.length;
                res[getOutlet$1(r)] = s;
            }
        }
    }
    catch (e_3_1) { e_3 = { error: e_3_1 }; }
    finally {
        try {
            if (routes_2_1 && !routes_2_1.done && (_a = routes_2.return)) _a.call(routes_2);
        }
        finally { if (e_3) throw e_3.error; }
    }
    return res;
}
function containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, routes) {
    return routes.some(function (r) { return emptyPathMatch(segmentGroup, slicedSegments, r) && getOutlet$1(r) !== PRIMARY_OUTLET; });
}
function containsEmptyPathMatches(segmentGroup, slicedSegments, routes) {
    return routes.some(function (r) { return emptyPathMatch(segmentGroup, slicedSegments, r); });
}
function emptyPathMatch(segmentGroup, slicedSegments, r) {
    if ((segmentGroup.hasChildren() || slicedSegments.length > 0) && r.pathMatch === 'full') {
        return false;
    }
    return r.path === '' && r.redirectTo === undefined;
}
function getOutlet$1(route) {
    return route.outlet || PRIMARY_OUTLET;
}
function getData(route) {
    return route.data || {};
}
function getResolve(route) {
    return route.resolve || {};
}

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
function recognize$1(rootComponentType, config, serializer, paramsInheritanceStrategy, relativeLinkResolution) {
    return function (source) {
        return source.pipe(mergeMap(function (t) { return recognize(rootComponentType, config, t.urlAfterRedirects, serializer(t.urlAfterRedirects), paramsInheritanceStrategy, relativeLinkResolution)
            .pipe(map(function (targetSnapshot) { return (__assign({}, t, { targetSnapshot: targetSnapshot })); })); }));
    };
}

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
function resolveData(paramsInheritanceStrategy, moduleInjector) {
    return function (source) {
        return source.pipe(mergeMap(function (t) {
            var targetSnapshot = t.targetSnapshot, canActivateChecks = t.guards.canActivateChecks;
            if (!canActivateChecks.length) {
                return of(t);
            }
            return from(canActivateChecks)
                .pipe(concatMap(function (check) { return runResolve(check.route, targetSnapshot, paramsInheritanceStrategy, moduleInjector); }), reduce(function (_, __) { return _; }), map(function (_) { return t; }));
        }));
    };
}
function runResolve(futureARS, futureRSS, paramsInheritanceStrategy, moduleInjector) {
    var resolve = futureARS._resolve;
    return resolveNode(resolve, futureARS, futureRSS, moduleInjector)
        .pipe(map(function (resolvedData) {
        futureARS._resolvedData = resolvedData;
        futureARS.data = __assign({}, futureARS.data, inheritedParamsDataResolve(futureARS, paramsInheritanceStrategy).resolve);
        return null;
    }));
}
function resolveNode(resolve, futureARS, futureRSS, moduleInjector) {
    var keys = Object.keys(resolve);
    if (keys.length === 0) {
        return of({});
    }
    if (keys.length === 1) {
        var key_1 = keys[0];
        return getResolver(resolve[key_1], futureARS, futureRSS, moduleInjector)
            .pipe(map(function (value) {
            var _a;
            return _a = {}, _a[key_1] = value, _a;
        }));
    }
    var data = {};
    var runningResolvers$ = from(keys).pipe(mergeMap(function (key) {
        return getResolver(resolve[key], futureARS, futureRSS, moduleInjector)
            .pipe(map(function (value) {
            data[key] = value;
            return value;
        }));
    }));
    return runningResolvers$.pipe(last(), map(function () { return data; }));
}
function getResolver(injectionToken, futureARS, futureRSS, moduleInjector) {
    var resolver = getToken(injectionToken, futureARS, moduleInjector);
    return resolver.resolve ? wrapIntoObservable(resolver.resolve(futureARS, futureRSS)) :
        wrapIntoObservable(resolver(futureARS, futureRSS));
}

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Perform a side effect through a switchMap for every emission on the source Observable,
 * but return an Observable that is identical to the source. It's essentially the same as
 * the `tap` operator, but if the side effectful `next` function returns an ObservableInput,
 * it will wait before continuing with the original value.
 */
function switchTap(next) {
    return function (source) {
        return source.pipe(switchMap(function (v) {
            var nextResult = next(v);
            if (nextResult) {
                return from(nextResult).pipe(map(function () { return v; }));
            }
            return from([v]);
        }));
    };
}

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @description
 *
 * Provides a way to customize when activated routes get reused.
 *
 * @publicApi
 */
var RouteReuseStrategy = /** @class */ (function () {
    function RouteReuseStrategy() {
    }
    return RouteReuseStrategy;
}());
/**
 * Does not detach any subtrees. Reuses routes as long as their route config is the same.
 */
var DefaultRouteReuseStrategy = /** @class */ (function () {
    function DefaultRouteReuseStrategy() {
    }
    DefaultRouteReuseStrategy.prototype.shouldDetach = function (route) { return false; };
    DefaultRouteReuseStrategy.prototype.store = function (route, detachedTree) { };
    DefaultRouteReuseStrategy.prototype.shouldAttach = function (route) { return false; };
    DefaultRouteReuseStrategy.prototype.retrieve = function (route) { return null; };
    DefaultRouteReuseStrategy.prototype.shouldReuseRoute = function (future, curr) {
        return future.routeConfig === curr.routeConfig;
    };
    return DefaultRouteReuseStrategy;
}());

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @docsNotRequired
 * @publicApi
 */
var ROUTES = new InjectionToken('ROUTES');
var RouterConfigLoader = /** @class */ (function () {
    function RouterConfigLoader(loader, compiler, onLoadStartListener, onLoadEndListener) {
        this.loader = loader;
        this.compiler = compiler;
        this.onLoadStartListener = onLoadStartListener;
        this.onLoadEndListener = onLoadEndListener;
    }
    RouterConfigLoader.prototype.load = function (parentInjector, route) {
        var _this = this;
        if (this.onLoadStartListener) {
            this.onLoadStartListener(route);
        }
        var moduleFactory$ = this.loadModuleFactory(route.loadChildren);
        return moduleFactory$.pipe(map(function (factory) {
            if (_this.onLoadEndListener) {
                _this.onLoadEndListener(route);
            }
            var module = factory.create(parentInjector);
            return new LoadedRouterConfig(flatten(module.injector.get(ROUTES)).map(standardizeConfig), module);
        }));
    };
    RouterConfigLoader.prototype.loadModuleFactory = function (loadChildren) {
        var _this = this;
        if (typeof loadChildren === 'string') {
            return from(this.loader.load(loadChildren));
        }
        else {
            return wrapIntoObservable(loadChildren()).pipe(mergeMap(function (t) {
                if (t instanceof NgModuleFactory) {
                    return of(t);
                }
                else {
                    return from(_this.compiler.compileModuleAsync(t));
                }
            }));
        }
    };
    return RouterConfigLoader;
}());

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @description
 *
 * Provides a way to migrate AngularJS applications to Angular.
 *
 * @publicApi
 */
var UrlHandlingStrategy = /** @class */ (function () {
    function UrlHandlingStrategy() {
    }
    return UrlHandlingStrategy;
}());
/**
 * @publicApi
 */
var DefaultUrlHandlingStrategy = /** @class */ (function () {
    function DefaultUrlHandlingStrategy() {
    }
    DefaultUrlHandlingStrategy.prototype.shouldProcessUrl = function (url) { return true; };
    DefaultUrlHandlingStrategy.prototype.extract = function (url) { return url; };
    DefaultUrlHandlingStrategy.prototype.merge = function (newUrlPart, wholeUrl) { return newUrlPart; };
    return DefaultUrlHandlingStrategy;
}());

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
function defaultErrorHandler(error) {
    throw error;
}
function defaultMalformedUriErrorHandler(error, urlSerializer, url) {
    return urlSerializer.parse('/');
}
/**
 * @internal
 */
function defaultRouterHook(snapshot, runExtras) {
    return of(null);
}
/**
 * @description
 *
 * An NgModule that provides navigation and URL manipulation capabilities.
 *
 * @see `Route`.
 * @see [Routing and Navigation Guide](guide/router).
 *
 * @ngModule RouterModule
 *
 * @publicApi
 */
var Router = /** @class */ (function () {
    /**
     * Creates the router service.
     */
    // TODO: vsavkin make internal after the final is out.
    function Router(rootComponentType, urlSerializer, rootContexts, location, injector, loader, compiler, config) {
        var _this = this;
        this.rootComponentType = rootComponentType;
        this.urlSerializer = urlSerializer;
        this.rootContexts = rootContexts;
        this.location = location;
        this.config = config;
        this.lastSuccessfulNavigation = null;
        this.currentNavigation = null;
        this.navigationId = 0;
        this.isNgZoneEnabled = false;
        /**
         * An event stream for routing events in this NgModule.
         */
        this.events = new Subject();
        /**
         * A handler for navigation errors in this NgModule.
         */
        this.errorHandler = defaultErrorHandler;
        /**
         * Malformed uri error handler is invoked when `Router.parseUrl(url)` throws an
         * error due to containing an invalid character. The most common case would be a `%` sign
         * that's not encoded and is not part of a percent encoded sequence.
         */
        this.malformedUriErrorHandler = defaultMalformedUriErrorHandler;
        /**
         * True if at least one navigation event has occurred,
         * false otherwise.
         */
        this.navigated = false;
        this.lastSuccessfulId = -1;
        /**
         * Hooks that enable you to pause navigation,
         * either before or after the preactivation phase.
         * Used by `RouterModule`.
         *
         * @internal
         */
        this.hooks = {
            beforePreactivation: defaultRouterHook,
            afterPreactivation: defaultRouterHook
        };
        /**
         * Extracts and merges URLs. Used for AngularJS to Angular migrations.
         */
        this.urlHandlingStrategy = new DefaultUrlHandlingStrategy();
        /**
         * The strategy for re-using routes.
         */
        this.routeReuseStrategy = new DefaultRouteReuseStrategy();
        /**
         * How to handle a navigation request to the current URL. One of:
         * - `'ignore'` :  The router ignores the request.
         * - `'reload'` : The router reloads the URL. Use to implement a "refresh" feature.
         */
        this.onSameUrlNavigation = 'ignore';
        /**
         * How to merge parameters, data, and resolved data from parent to child
         * routes. One of:
         *
         * - `'emptyOnly'` : Inherit parent parameters, data, and resolved data
         * for path-less or component-less routes.
         * - `'always'` : Inherit parent parameters, data, and resolved data
         * for all child routes.
         */
        this.paramsInheritanceStrategy = 'emptyOnly';
        /**
         * Defines when the router updates the browser URL. The default behavior is to update after
         * successful navigation. However, some applications may prefer a mode where the URL gets
         * updated at the beginning of navigation. The most common use case would be updating the
         * URL early so if navigation fails, you can show an error message with the URL that failed.
         * Available options are:
         *
         * - `'deferred'`, the default, updates the browser URL after navigation has finished.
         * - `'eager'`, updates browser URL at the beginning of navigation.
         */
        this.urlUpdateStrategy = 'deferred';
        /**
         * See {@link RouterModule} for more information.
         */
        this.relativeLinkResolution = 'legacy';
        var onLoadStart = function (r) { return _this.triggerEvent(new RouteConfigLoadStart(r)); };
        var onLoadEnd = function (r) { return _this.triggerEvent(new RouteConfigLoadEnd(r)); };
        this.ngModule = injector.get(NgModuleRef);
        this.console = injector.get(ɵConsole);
        var ngZone = injector.get(NgZone);
        this.isNgZoneEnabled = ngZone instanceof NgZone;
        this.resetConfig(config);
        this.currentUrlTree = createEmptyUrlTree();
        this.rawUrlTree = this.currentUrlTree;
        this.browserUrlTree = this.currentUrlTree;
        this.configLoader = new RouterConfigLoader(loader, compiler, onLoadStart, onLoadEnd);
        this.routerState = createEmptyState(this.currentUrlTree, this.rootComponentType);
        this.transitions = new BehaviorSubject({
            id: 0,
            currentUrlTree: this.currentUrlTree,
            currentRawUrl: this.currentUrlTree,
            extractedUrl: this.urlHandlingStrategy.extract(this.currentUrlTree),
            urlAfterRedirects: this.urlHandlingStrategy.extract(this.currentUrlTree),
            rawUrl: this.currentUrlTree,
            extras: {},
            resolve: null,
            reject: null,
            promise: Promise.resolve(true),
            source: 'imperative',
            restoredState: null,
            currentSnapshot: this.routerState.snapshot,
            targetSnapshot: null,
            currentRouterState: this.routerState,
            targetRouterState: null,
            guards: { canActivateChecks: [], canDeactivateChecks: [] },
            guardsResult: null,
        });
        this.navigations = this.setupNavigations(this.transitions);
        this.processNavigations();
    }
    Router.prototype.setupNavigations = function (transitions) {
        var _this = this;
        var eventsSubject = this.events;
        return transitions.pipe(filter(function (t) { return t.id !== 0; }), 
        // Extract URL
        map(function (t) { return (__assign({}, t, { extractedUrl: _this.urlHandlingStrategy.extract(t.rawUrl) })); }), 
        // Using switchMap so we cancel executing navigations when a new one comes in
        switchMap(function (t) {
            var completed = false;
            var errored = false;
            return of(t).pipe(
            // Store the Navigation object
            tap(function (t) {
                _this.currentNavigation = {
                    id: t.id,
                    initialUrl: t.currentRawUrl,
                    extractedUrl: t.extractedUrl,
                    trigger: t.source,
                    extras: t.extras,
                    previousNavigation: _this.lastSuccessfulNavigation ? __assign({}, _this.lastSuccessfulNavigation, { previousNavigation: null }) :
                        null
                };
            }), switchMap(function (t) {
                var urlTransition = !_this.navigated || t.extractedUrl.toString() !== _this.browserUrlTree.toString();
                var processCurrentUrl = (_this.onSameUrlNavigation === 'reload' ? true : urlTransition) &&
                    _this.urlHandlingStrategy.shouldProcessUrl(t.rawUrl);
                if (processCurrentUrl) {
                    return of(t).pipe(
                    // Fire NavigationStart event
                    switchMap(function (t) {
                        var transition = _this.transitions.getValue();
                        eventsSubject.next(new NavigationStart(t.id, _this.serializeUrl(t.extractedUrl), t.source, t.restoredState));
                        if (transition !== _this.transitions.getValue()) {
                            return EMPTY;
                        }
                        return [t];
                    }), 
                    // This delay is required to match old behavior that forced navigation to
                    // always be async
                    switchMap(function (t) { return Promise.resolve(t); }), 
                    // ApplyRedirects
                    applyRedirects$1(_this.ngModule.injector, _this.configLoader, _this.urlSerializer, _this.config), 
                    // Update the currentNavigation
                    tap(function (t) {
                        _this.currentNavigation = __assign({}, _this.currentNavigation, { finalUrl: t.urlAfterRedirects });
                    }), 
                    // Recognize
                    recognize$1(_this.rootComponentType, _this.config, function (url) { return _this.serializeUrl(url); }, _this.paramsInheritanceStrategy, _this.relativeLinkResolution), 
                    // Update URL if in `eager` update mode
                    tap(function (t) {
                        if (_this.urlUpdateStrategy === 'eager') {
                            if (!t.extras.skipLocationChange) {
                                _this.setBrowserUrl(t.urlAfterRedirects, !!t.extras.replaceUrl, t.id);
                            }
                            _this.browserUrlTree = t.urlAfterRedirects;
                        }
                    }), 
                    // Fire RoutesRecognized
                    tap(function (t) {
                        var routesRecognized = new RoutesRecognized(t.id, _this.serializeUrl(t.extractedUrl), _this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot);
                        eventsSubject.next(routesRecognized);
                    }));
                }
                else {
                    var processPreviousUrl = urlTransition && _this.rawUrlTree &&
                        _this.urlHandlingStrategy.shouldProcessUrl(_this.rawUrlTree);
                    /* When the current URL shouldn't be processed, but the previous one was, we
                     * handle this "error condition" by navigating to the previously successful URL,
                     * but leaving the URL intact.*/
                    if (processPreviousUrl) {
                        var id = t.id, extractedUrl = t.extractedUrl, source = t.source, restoredState = t.restoredState, extras = t.extras;
                        var navStart = new NavigationStart(id, _this.serializeUrl(extractedUrl), source, restoredState);
                        eventsSubject.next(navStart);
                        var targetSnapshot = createEmptyState(extractedUrl, _this.rootComponentType).snapshot;
                        return of(__assign({}, t, { targetSnapshot: targetSnapshot, urlAfterRedirects: extractedUrl, extras: __assign({}, extras, { skipLocationChange: false, replaceUrl: false }) }));
                    }
                    else {
                        /* When neither the current or previous URL can be processed, do nothing other
                         * than update router's internal reference to the current "settled" URL. This
                         * way the next navigation will be coming from the current URL in the browser.
                         */
                        _this.rawUrlTree = t.rawUrl;
                        t.resolve(null);
                        return EMPTY;
                    }
                }
            }), 
            // Before Preactivation
            switchTap(function (t) {
                var targetSnapshot = t.targetSnapshot, navigationId = t.id, appliedUrlTree = t.extractedUrl, rawUrlTree = t.rawUrl, _a = t.extras, skipLocationChange = _a.skipLocationChange, replaceUrl = _a.replaceUrl;
                return _this.hooks.beforePreactivation(targetSnapshot, {
                    navigationId: navigationId,
                    appliedUrlTree: appliedUrlTree,
                    rawUrlTree: rawUrlTree,
                    skipLocationChange: !!skipLocationChange,
                    replaceUrl: !!replaceUrl,
                });
            }), 
            // --- GUARDS ---
            tap(function (t) {
                var guardsStart = new GuardsCheckStart(t.id, _this.serializeUrl(t.extractedUrl), _this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot);
                _this.triggerEvent(guardsStart);
            }), map(function (t) { return (__assign({}, t, { guards: getAllRouteGuards(t.targetSnapshot, t.currentSnapshot, _this.rootContexts) })); }), checkGuards(_this.ngModule.injector, function (evt) { return _this.triggerEvent(evt); }), tap(function (t) {
                if (isUrlTree(t.guardsResult)) {
                    var error = navigationCancelingError("Redirecting to \"" + _this.serializeUrl(t.guardsResult) + "\"");
                    error.url = t.guardsResult;
                    throw error;
                }
            }), tap(function (t) {
                var guardsEnd = new GuardsCheckEnd(t.id, _this.serializeUrl(t.extractedUrl), _this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot, !!t.guardsResult);
                _this.triggerEvent(guardsEnd);
            }), filter(function (t) {
                if (!t.guardsResult) {
                    _this.resetUrlToCurrentUrlTree();
                    var navCancel = new NavigationCancel(t.id, _this.serializeUrl(t.extractedUrl), '');
                    eventsSubject.next(navCancel);
                    t.resolve(false);
                    return false;
                }
                return true;
            }), 
            // --- RESOLVE ---
            switchTap(function (t) {
                if (t.guards.canActivateChecks.length) {
                    return of(t).pipe(tap(function (t) {
                        var resolveStart = new ResolveStart(t.id, _this.serializeUrl(t.extractedUrl), _this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot);
                        _this.triggerEvent(resolveStart);
                    }), resolveData(_this.paramsInheritanceStrategy, _this.ngModule.injector), //
                    tap(function (t) {
                        var resolveEnd = new ResolveEnd(t.id, _this.serializeUrl(t.extractedUrl), _this.serializeUrl(t.urlAfterRedirects), t.targetSnapshot);
                        _this.triggerEvent(resolveEnd);
                    }));
                }
                return undefined;
            }), 
            // --- AFTER PREACTIVATION ---
            switchTap(function (t) {
                var targetSnapshot = t.targetSnapshot, navigationId = t.id, appliedUrlTree = t.extractedUrl, rawUrlTree = t.rawUrl, _a = t.extras, skipLocationChange = _a.skipLocationChange, replaceUrl = _a.replaceUrl;
                return _this.hooks.afterPreactivation(targetSnapshot, {
                    navigationId: navigationId,
                    appliedUrlTree: appliedUrlTree,
                    rawUrlTree: rawUrlTree,
                    skipLocationChange: !!skipLocationChange,
                    replaceUrl: !!replaceUrl,
                });
            }), map(function (t) {
                var targetRouterState = createRouterState(_this.routeReuseStrategy, t.targetSnapshot, t.currentRouterState);
                return (__assign({}, t, { targetRouterState: targetRouterState }));
            }), 
            /* Once here, we are about to activate syncronously. The assumption is this will
               succeed, and user code may read from the Router service. Therefore before
               activation, we need to update router properties storing the current URL and the
               RouterState, as well as updated the browser URL. All this should happen *before*
               activating. */
            tap(function (t) {
                _this.currentUrlTree = t.urlAfterRedirects;
                _this.rawUrlTree = _this.urlHandlingStrategy.merge(_this.currentUrlTree, t.rawUrl);
                _this.routerState = t.targetRouterState;
                if (_this.urlUpdateStrategy === 'deferred') {
                    if (!t.extras.skipLocationChange) {
                        _this.setBrowserUrl(_this.rawUrlTree, !!t.extras.replaceUrl, t.id, t.extras.state);
                    }
                    _this.browserUrlTree = t.urlAfterRedirects;
                }
            }), activateRoutes(_this.rootContexts, _this.routeReuseStrategy, function (evt) { return _this.triggerEvent(evt); }), tap({ next: function () { completed = true; }, complete: function () { completed = true; } }), finalize(function () {
                /* When the navigation stream finishes either through error or success, we set the
                 * `completed` or `errored` flag. However, there are some situations where we could
                 * get here without either of those being set. For instance, a redirect during
                 * NavigationStart. Therefore, this is a catch-all to make sure the NavigationCancel
                 * event is fired when a navigation gets cancelled but not caught by other means. */
                if (!completed && !errored) {
                    // Must reset to current URL tree here to ensure history.state is set. On a fresh
                    // page load, if a new navigation comes in before a successful navigation
                    // completes, there will be nothing in history.state.navigationId. This can cause
                    // sync problems with AngularJS sync code which looks for a value here in order
                    // to determine whether or not to handle a given popstate event or to leave it
                    // to the Angualr router.
                    _this.resetUrlToCurrentUrlTree();
                    var navCancel = new NavigationCancel(t.id, _this.serializeUrl(t.extractedUrl), "Navigation ID " + t.id + " is not equal to the current navigation id " + _this.navigationId);
                    eventsSubject.next(navCancel);
                    t.resolve(false);
                }
                // currentNavigation should always be reset to null here. If navigation was
                // successful, lastSuccessfulTransition will have already been set. Therefore we
                // can safely set currentNavigation to null here.
                _this.currentNavigation = null;
            }), catchError(function (e) {
                errored = true;
                /* This error type is issued during Redirect, and is handled as a cancellation
                 * rather than an error. */
                if (isNavigationCancelingError(e)) {
                    var redirecting = isUrlTree(e.url);
                    if (!redirecting) {
                        // Set property only if we're not redirecting. If we landed on a page and
                        // redirect to `/` route, the new navigation is going to see the `/` isn't
                        // a change from the default currentUrlTree and won't navigate. This is
                        // only applicable with initial navigation, so setting `navigated` only when
                        // not redirecting resolves this scenario.
                        _this.navigated = true;
                        _this.resetStateAndUrl(t.currentRouterState, t.currentUrlTree, t.rawUrl);
                    }
                    var navCancel = new NavigationCancel(t.id, _this.serializeUrl(t.extractedUrl), e.message);
                    eventsSubject.next(navCancel);
                    t.resolve(false);
                    if (redirecting) {
                        _this.navigateByUrl(e.url);
                    }
                    /* All other errors should reset to the router's internal URL reference to the
                     * pre-error state. */
                }
                else {
                    _this.resetStateAndUrl(t.currentRouterState, t.currentUrlTree, t.rawUrl);
                    var navError = new NavigationError(t.id, _this.serializeUrl(t.extractedUrl), e);
                    eventsSubject.next(navError);
                    try {
                        t.resolve(_this.errorHandler(e));
                    }
                    catch (ee) {
                        t.reject(ee);
                    }
                }
                return EMPTY;
            }));
            // TODO(jasonaden): remove cast once g3 is on updated TypeScript
        }));
    };
    /**
     * @internal
     * TODO: this should be removed once the constructor of the router made internal
     */
    Router.prototype.resetRootComponentType = function (rootComponentType) {
        this.rootComponentType = rootComponentType;
        // TODO: vsavkin router 4.0 should make the root component set to null
        // this will simplify the lifecycle of the router.
        this.routerState.root.component = this.rootComponentType;
    };
    Router.prototype.getTransition = function () { return this.transitions.value; };
    Router.prototype.setTransition = function (t) {
        this.transitions.next(__assign({}, this.getTransition(), t));
    };
    /**
     * Sets up the location change listener and performs the initial navigation.
     */
    Router.prototype.initialNavigation = function () {
        this.setUpLocationChangeListener();
        if (this.navigationId === 0) {
            this.navigateByUrl(this.location.path(true), { replaceUrl: true });
        }
    };
    /**
     * Sets up the location change listener.
     */
    Router.prototype.setUpLocationChangeListener = function () {
        var _this = this;
        // Don't need to use Zone.wrap any more, because zone.js
        // already patch onPopState, so location change callback will
        // run into ngZone
        if (!this.locationSubscription) {
            this.locationSubscription = this.location.subscribe(function (change) {
                var rawUrlTree = _this.parseUrl(change['url']);
                var source = change['type'] === 'popstate' ? 'popstate' : 'hashchange';
                // Navigations coming from Angular router have a navigationId state property. When this
                // exists, restore the state.
                var state = change.state && change.state.navigationId ? change.state : null;
                setTimeout(function () { _this.scheduleNavigation(rawUrlTree, source, state, { replaceUrl: true }); }, 0);
            });
        }
    };
    Object.defineProperty(Router.prototype, "url", {
        /** The current URL. */
        get: function () { return this.serializeUrl(this.currentUrlTree); },
        enumerable: true,
        configurable: true
    });
    /** The current Navigation object if one exists */
    Router.prototype.getCurrentNavigation = function () { return this.currentNavigation; };
    /** @internal */
    Router.prototype.triggerEvent = function (event) { this.events.next(event); };
    /**
     * Resets the configuration used for navigation and generating links.
     *
     * @param config The route array for the new configuration.
     *
     * @usageNotes
     *
     * ```
     * router.resetConfig([
     *  { path: 'team/:id', component: TeamCmp, children: [
     *    { path: 'simple', component: SimpleCmp },
     *    { path: 'user/:name', component: UserCmp }
     *  ]}
     * ]);
     * ```
     */
    Router.prototype.resetConfig = function (config) {
        validateConfig(config);
        this.config = config.map(standardizeConfig);
        this.navigated = false;
        this.lastSuccessfulId = -1;
    };
    /** @docsNotRequired */
    Router.prototype.ngOnDestroy = function () { this.dispose(); };
    /** Disposes of the router. */
    Router.prototype.dispose = function () {
        if (this.locationSubscription) {
            this.locationSubscription.unsubscribe();
            this.locationSubscription = null;
        }
    };
    /**
     * Applies an array of commands to the current URL tree and creates a new URL tree.
     *
     * When given an activate route, applies the given commands starting from the route.
     * When not given a route, applies the given command starting from the root.
     *
     * @param commands An array of commands to apply.
     * @param navigationExtras
     * @returns The new URL tree.
     *
     * @usageNotes
     *
     * ```
     * // create /team/33/user/11
     * router.createUrlTree(['/team', 33, 'user', 11]);
     *
     * // create /team/33;expand=true/user/11
     * router.createUrlTree(['/team', 33, {expand: true}, 'user', 11]);
     *
     * // you can collapse static segments like this (this works only with the first passed-in value):
     * router.createUrlTree(['/team/33/user', userId]);
     *
     * // If the first segment can contain slashes, and you do not want the router to split it, you
     * // can do the following:
     *
     * router.createUrlTree([{segmentPath: '/one/two'}]);
     *
     * // create /team/33/(user/11//right:chat)
     * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: 'chat'}}]);
     *
     * // remove the right secondary node
     * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: null}}]);
     *
     * // assuming the current url is `/team/33/user/11` and the route points to `user/11`
     *
     * // navigate to /team/33/user/11/details
     * router.createUrlTree(['details'], {relativeTo: route});
     *
     * // navigate to /team/33/user/22
     * router.createUrlTree(['../22'], {relativeTo: route});
     *
     * // navigate to /team/44/user/22
     * router.createUrlTree(['../../team/44/user/22'], {relativeTo: route});
     * ```
     */
    Router.prototype.createUrlTree = function (commands, navigationExtras) {
        if (navigationExtras === void 0) { navigationExtras = {}; }
        var relativeTo = navigationExtras.relativeTo, queryParams = navigationExtras.queryParams, fragment = navigationExtras.fragment, preserveQueryParams = navigationExtras.preserveQueryParams, queryParamsHandling = navigationExtras.queryParamsHandling, preserveFragment = navigationExtras.preserveFragment;
        if (isDevMode() && preserveQueryParams && console && console.warn) {
            console.warn('preserveQueryParams is deprecated, use queryParamsHandling instead.');
        }
        var a = relativeTo || this.routerState.root;
        var f = preserveFragment ? this.currentUrlTree.fragment : fragment;
        var q = null;
        if (queryParamsHandling) {
            switch (queryParamsHandling) {
                case 'merge':
                    q = __assign({}, this.currentUrlTree.queryParams, queryParams);
                    break;
                case 'preserve':
                    q = this.currentUrlTree.queryParams;
                    break;
                default:
                    q = queryParams || null;
            }
        }
        else {
            q = preserveQueryParams ? this.currentUrlTree.queryParams : queryParams || null;
        }
        if (q !== null) {
            q = this.removeEmptyProps(q);
        }
        return createUrlTree(a, this.currentUrlTree, commands, q, f);
    };
    /**
     * Navigate based on the provided URL, which must be absolute.
     *
     * @param url An absolute URL. The function does not apply any delta to the current URL.
     * @param extras An object containing properties that modify the navigation strategy.
     * The function ignores any properties in the `NavigationExtras` that would change the
     * provided URL.
     *
     * @returns A Promise that resolves to 'true' when navigation succeeds,
     * to 'false' when navigation fails, or is rejected on error.
     *
     * @usageNotes
     *
     * ### Example
     *
     * ```
     * router.navigateByUrl("/team/33/user/11");
     *
     * // Navigate without updating the URL
     * router.navigateByUrl("/team/33/user/11", { skipLocationChange: true });
     * ```
     *
     */
    Router.prototype.navigateByUrl = function (url, extras) {
        if (extras === void 0) { extras = { skipLocationChange: false }; }
        if (isDevMode() && this.isNgZoneEnabled && !NgZone.isInAngularZone()) {
            this.console.warn("Navigation triggered outside Angular zone, did you forget to call 'ngZone.run()'?");
        }
        var urlTree = isUrlTree(url) ? url : this.parseUrl(url);
        var mergedTree = this.urlHandlingStrategy.merge(urlTree, this.rawUrlTree);
        return this.scheduleNavigation(mergedTree, 'imperative', null, extras);
    };
    /**
     * Navigate based on the provided array of commands and a starting point.
     * If no starting route is provided, the navigation is absolute.
     *
     * Returns a promise that:
     * - resolves to 'true' when navigation succeeds,
     * - resolves to 'false' when navigation fails,
     * - is rejected when an error happens.
     *
     * @usageNotes
     *
     * ### Example
     *
     * ```
     * router.navigate(['team', 33, 'user', 11], {relativeTo: route});
     *
     * // Navigate without updating the URL
     * router.navigate(['team', 33, 'user', 11], {relativeTo: route, skipLocationChange: true});
     * ```
     *
     * The first parameter of `navigate()` is a delta to be applied to the current URL
     * or the one provided in the `relativeTo` property of the second parameter (the
     * `NavigationExtras`).
     *
     * In order to affect this browser's `history.state` entry, the `state`
     * parameter can be passed. This must be an object because the router
     * will add the `navigationId` property to this object before creating
     * the new history item.
     */
    Router.prototype.navigate = function (commands, extras) {
        if (extras === void 0) { extras = { skipLocationChange: false }; }
        validateCommands(commands);
        return this.navigateByUrl(this.createUrlTree(commands, extras), extras);
    };
    /** Serializes a `UrlTree` into a string */
    Router.prototype.serializeUrl = function (url) { return this.urlSerializer.serialize(url); };
    /** Parses a string into a `UrlTree` */
    Router.prototype.parseUrl = function (url) {
        var urlTree;
        try {
            urlTree = this.urlSerializer.parse(url);
        }
        catch (e) {
            urlTree = this.malformedUriErrorHandler(e, this.urlSerializer, url);
        }
        return urlTree;
    };
    /** Returns whether the url is activated */
    Router.prototype.isActive = function (url, exact) {
        if (isUrlTree(url)) {
            return containsTree(this.currentUrlTree, url, exact);
        }
        var urlTree = this.parseUrl(url);
        return containsTree(this.currentUrlTree, urlTree, exact);
    };
    Router.prototype.removeEmptyProps = function (params) {
        return Object.keys(params).reduce(function (result, key) {
            var value = params[key];
            if (value !== null && value !== undefined) {
                result[key] = value;
            }
            return result;
        }, {});
    };
    Router.prototype.processNavigations = function () {
        var _this = this;
        this.navigations.subscribe(function (t) {
            _this.navigated = true;
            _this.lastSuccessfulId = t.id;
            _this.events
                .next(new NavigationEnd(t.id, _this.serializeUrl(t.extractedUrl), _this.serializeUrl(_this.currentUrlTree)));
            _this.lastSuccessfulNavigation = _this.currentNavigation;
            _this.currentNavigation = null;
            t.resolve(true);
        }, function (e) { _this.console.warn("Unhandled Navigation Error: "); });
    };
    Router.prototype.scheduleNavigation = function (rawUrl, source, restoredState, extras) {
        var lastNavigation = this.getTransition();
        // If the user triggers a navigation imperatively (e.g., by using navigateByUrl),
        // and that navigation results in 'replaceState' that leads to the same URL,
        // we should skip those.
        if (lastNavigation && source !== 'imperative' && lastNavigation.source === 'imperative' &&
            lastNavigation.rawUrl.toString() === rawUrl.toString()) {
            return Promise.resolve(true); // return value is not used
        }
        // Because of a bug in IE and Edge, the location class fires two events (popstate and
        // hashchange) every single time. The second one should be ignored. Otherwise, the URL will
        // flicker. Handles the case when a popstate was emitted first.
        if (lastNavigation && source == 'hashchange' && lastNavigation.source === 'popstate' &&
            lastNavigation.rawUrl.toString() === rawUrl.toString()) {
            return Promise.resolve(true); // return value is not used
        }
        // Because of a bug in IE and Edge, the location class fires two events (popstate and
        // hashchange) every single time. The second one should be ignored. Otherwise, the URL will
        // flicker. Handles the case when a hashchange was emitted first.
        if (lastNavigation && source == 'popstate' && lastNavigation.source === 'hashchange' &&
            lastNavigation.rawUrl.toString() === rawUrl.toString()) {
            return Promise.resolve(true); // return value is not used
        }
        var resolve = null;
        var reject = null;
        var promise = new Promise(function (res, rej) {
            resolve = res;
            reject = rej;
        });
        var id = ++this.navigationId;
        this.setTransition({
            id: id,
            source: source,
            restoredState: restoredState,
            currentUrlTree: this.currentUrlTree,
            currentRawUrl: this.rawUrlTree, rawUrl: rawUrl, extras: extras, resolve: resolve, reject: reject, promise: promise,
            currentSnapshot: this.routerState.snapshot,
            currentRouterState: this.routerState
        });
        // Make sure that the error is propagated even though `processNavigations` catch
        // handler does not rethrow
        return promise.catch(function (e) { return Promise.reject(e); });
    };
    Router.prototype.setBrowserUrl = function (url, replaceUrl, id, state) {
        var path = this.urlSerializer.serialize(url);
        state = state || {};
        if (this.location.isCurrentPathEqualTo(path) || replaceUrl) {
            // TODO(jasonaden): Remove first `navigationId` and rely on `ng` namespace.
            this.location.replaceState(path, '', __assign({}, state, { navigationId: id }));
        }
        else {
            this.location.go(path, '', __assign({}, state, { navigationId: id }));
        }
    };
    Router.prototype.resetStateAndUrl = function (storedState, storedUrl, rawUrl) {
        this.routerState = storedState;
        this.currentUrlTree = storedUrl;
        this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, rawUrl);
        this.resetUrlToCurrentUrlTree();
    };
    Router.prototype.resetUrlToCurrentUrlTree = function () {
        this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree), '', { navigationId: this.lastSuccessfulId });
    };
    return Router;
}());
function validateCommands(commands) {
    for (var i = 0; i < commands.length; i++) {
        var cmd = commands[i];
        if (cmd == null) {
            throw new Error("The requested path contains " + cmd + " segment at index " + i);
        }
    }
}

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @description
 *
 * Lets you link to specific routes in your app.
 *
 * Consider the following route configuration:
 * `[{ path: 'user/:name', component: UserCmp }]`.
 * When linking to this `user/:name` route, you use the `RouterLink` directive.
 *
 * If the link is static, you can use the directive as follows:
 * `<a routerLink="/user/bob">link to user component</a>`
 *
 * If you use dynamic values to generate the link, you can pass an array of path
 * segments, followed by the params for each segment.
 *
 * For instance `['/team', teamId, 'user', userName, {details: true}]`
 * means that we want to generate a link to `/team/11/user/bob;details=true`.
 *
 * Multiple static segments can be merged into one
 * (e.g., `['/team/11/user', userName, {details: true}]`).
 *
 * The first segment name can be prepended with `/`, `./`, or `../`:
 * * If the first segment begins with `/`, the router will look up the route from the root of the
 *   app.
 * * If the first segment begins with `./`, or doesn't begin with a slash, the router will
 *   instead look in the children of the current activated route.
 * * And if the first segment begins with `../`, the router will go up one level.
 *
 * You can set query params and fragment as follows:
 *
 * ```
 * <a [routerLink]="['/user/bob']" [queryParams]="{debug: true}" fragment="education">
 *   link to user component
 * </a>
 * ```
 * RouterLink will use these to generate this link: `/user/bob#education?debug=true`.
 *
 * (Deprecated in v4.0.0 use `queryParamsHandling` instead) You can also tell the
 * directive to preserve the current query params and fragment:
 *
 * ```
 * <a [routerLink]="['/user/bob']" preserveQueryParams preserveFragment>
 *   link to user component
 * </a>
 * ```
 *
 * You can tell the directive how to handle queryParams. Available options are:
 *  - `'merge'`: merge the queryParams into the current queryParams
 *  - `'preserve'`: preserve the current queryParams
 *  - default/`''`: use the queryParams only
 *
 * Same options for {@link NavigationExtras#queryParamsHandling
 * NavigationExtras#queryParamsHandling}.
 *
 * ```
 * <a [routerLink]="['/user/bob']" [queryParams]="{debug: true}" queryParamsHandling="merge">
 *   link to user component
 * </a>
 * ```
 *
 * You can provide a `state` value to be persisted to the browser's History.state
 * property (See https://developer.mozilla.org/en-US/docs/Web/API/History#Properties). It's
 * used as follows:
 *
 * ```
 * <a [routerLink]="['/user/bob']" [state]="{tracingId: 123}">
 *   link to user component
 * </a>
 * ```
 *
 * And later the value can be read from the router through `router.getCurrentNavigation`.
 * For example, to capture the `tracingId` above during the `NavigationStart` event:
 *
 * ```
 * // Get NavigationStart events
 * router.events.pipe(filter(e => e instanceof NavigationStart)).subscribe(e => {
 *   const navigation = router.getCurrentNavigation();
 *   tracingService.trace({id: navigation.extras.state.tracingId});
 * });
 * ```
 *
 * The router link directive always treats the provided input as a delta to the current url.
 *
 * For instance, if the current url is `/user/(box//aux:team)`.
 *
 * Then the following link `<a [routerLink]="['/user/jim']">Jim</a>` will generate the link
 * `/user/(jim//aux:team)`.
 *
 * See {@link Router#createUrlTree createUrlTree} for more information.
 *
 * @ngModule RouterModule
 *
 * @publicApi
 */
var RouterLink = /** @class */ (function () {
    function RouterLink(router, route, tabIndex, renderer, el) {
        this.router = router;
        this.route = route;
        this.commands = [];
        if (tabIndex == null) {
            renderer.setAttribute(el.nativeElement, 'tabindex', '0');
        }
    }
    Object.defineProperty(RouterLink.prototype, "routerLink", {
        set: function (commands) {
            if (commands != null) {
                this.commands = Array.isArray(commands) ? commands : [commands];
            }
            else {
                this.commands = [];
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RouterLink.prototype, "preserveQueryParams", {
        /**
         * @deprecated 4.0.0 use `queryParamsHandling` instead.
         */
        set: function (value) {
            if (isDevMode() && console && console.warn) {
                console.warn('preserveQueryParams is deprecated!, use queryParamsHandling instead.');
            }
            this.preserve = value;
        },
        enumerable: true,
        configurable: true
    });
    RouterLink.prototype.onClick = function () {
        var extras = {
            skipLocationChange: attrBoolValue(this.skipLocationChange),
            replaceUrl: attrBoolValue(this.replaceUrl),
        };
        this.router.navigateByUrl(this.urlTree, extras);
        return true;
    };
    Object.defineProperty(RouterLink.prototype, "urlTree", {
        get: function () {
            return this.router.createUrlTree(this.commands, {
                relativeTo: this.route,
                queryParams: this.queryParams,
                fragment: this.fragment,
                preserveQueryParams: attrBoolValue(this.preserve),
                queryParamsHandling: this.queryParamsHandling,
                preserveFragment: attrBoolValue(this.preserveFragment),
            });
        },
        enumerable: true,
        configurable: true
    });
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], RouterLink.prototype, "queryParams", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], RouterLink.prototype, "fragment", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], RouterLink.prototype, "queryParamsHandling", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], RouterLink.prototype, "preserveFragment", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], RouterLink.prototype, "skipLocationChange", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], RouterLink.prototype, "replaceUrl", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], RouterLink.prototype, "state", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], RouterLink.prototype, "routerLink", null);
    __decorate([
        Input(),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [Boolean])
    ], RouterLink.prototype, "preserveQueryParams", null);
    __decorate([
        HostListener('click'),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", Boolean)
    ], RouterLink.prototype, "onClick", null);
    RouterLink = __decorate([
        Directive({ selector: ':not(a):not(area)[routerLink]' }),
        __param(2, Attribute('tabindex')),
        __metadata("design:paramtypes", [Router, ActivatedRoute, String, Renderer2, ElementRef])
    ], RouterLink);
    return RouterLink;
}());
/**
 * @description
 *
 * Lets you link to specific routes in your app.
 *
 * See `RouterLink` for more information.
 *
 * @ngModule RouterModule
 *
 * @publicApi
 */
var RouterLinkWithHref = /** @class */ (function () {
    function RouterLinkWithHref(router, route, locationStrategy) {
        var _this = this;
        this.router = router;
        this.route = route;
        this.locationStrategy = locationStrategy;
        this.commands = [];
        this.subscription = router.events.subscribe(function (s) {
            if (s instanceof NavigationEnd) {
                _this.updateTargetUrlAndHref();
            }
        });
    }
    Object.defineProperty(RouterLinkWithHref.prototype, "routerLink", {
        set: function (commands) {
            if (commands != null) {
                this.commands = Array.isArray(commands) ? commands : [commands];
            }
            else {
                this.commands = [];
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RouterLinkWithHref.prototype, "preserveQueryParams", {
        set: function (value) {
            if (isDevMode() && console && console.warn) {
                console.warn('preserveQueryParams is deprecated, use queryParamsHandling instead.');
            }
            this.preserve = value;
        },
        enumerable: true,
        configurable: true
    });
    RouterLinkWithHref.prototype.ngOnChanges = function (changes) { this.updateTargetUrlAndHref(); };
    RouterLinkWithHref.prototype.ngOnDestroy = function () { this.subscription.unsubscribe(); };
    RouterLinkWithHref.prototype.onClick = function (button, ctrlKey, metaKey, shiftKey) {
        if (button !== 0 || ctrlKey || metaKey || shiftKey) {
            return true;
        }
        if (typeof this.target === 'string' && this.target != '_self') {
            return true;
        }
        var extras = {
            skipLocationChange: attrBoolValue(this.skipLocationChange),
            replaceUrl: attrBoolValue(this.replaceUrl),
            state: this.state
        };
        this.router.navigateByUrl(this.urlTree, extras);
        return false;
    };
    RouterLinkWithHref.prototype.updateTargetUrlAndHref = function () {
        this.href = this.locationStrategy.prepareExternalUrl(this.router.serializeUrl(this.urlTree));
    };
    Object.defineProperty(RouterLinkWithHref.prototype, "urlTree", {
        get: function () {
            return this.router.createUrlTree(this.commands, {
                relativeTo: this.route,
                queryParams: this.queryParams,
                fragment: this.fragment,
                preserveQueryParams: attrBoolValue(this.preserve),
                queryParamsHandling: this.queryParamsHandling,
                preserveFragment: attrBoolValue(this.preserveFragment),
            });
        },
        enumerable: true,
        configurable: true
    });
    __decorate([
        HostBinding('attr.target'), Input(),
        __metadata("design:type", String)
    ], RouterLinkWithHref.prototype, "target", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], RouterLinkWithHref.prototype, "queryParams", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], RouterLinkWithHref.prototype, "fragment", void 0);
    __decorate([
        Input(),
        __metadata("design:type", String)
    ], RouterLinkWithHref.prototype, "queryParamsHandling", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], RouterLinkWithHref.prototype, "preserveFragment", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], RouterLinkWithHref.prototype, "skipLocationChange", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Boolean)
    ], RouterLinkWithHref.prototype, "replaceUrl", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], RouterLinkWithHref.prototype, "state", void 0);
    __decorate([
        HostBinding(),
        __metadata("design:type", String)
    ], RouterLinkWithHref.prototype, "href", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], RouterLinkWithHref.prototype, "routerLink", null);
    __decorate([
        Input(),
        __metadata("design:type", Boolean),
        __metadata("design:paramtypes", [Boolean])
    ], RouterLinkWithHref.prototype, "preserveQueryParams", null);
    __decorate([
        HostListener('click', ['$event.button', '$event.ctrlKey', '$event.metaKey', '$event.shiftKey']),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", [Number, Boolean, Boolean, Boolean]),
        __metadata("design:returntype", Boolean)
    ], RouterLinkWithHref.prototype, "onClick", null);
    RouterLinkWithHref = __decorate([
        Directive({ selector: 'a[routerLink],area[routerLink]' }),
        __metadata("design:paramtypes", [Router, ActivatedRoute,
            LocationStrategy])
    ], RouterLinkWithHref);
    return RouterLinkWithHref;
}());
function attrBoolValue(s) {
    return s === '' || !!s;
}

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 *
 * @description
 *
 * Lets you add a CSS class to an element when the link's route becomes active.
 *
 * This directive lets you add a CSS class to an element when the link's route
 * becomes active.
 *
 * Consider the following example:
 *
 * ```
 * <a routerLink="/user/bob" routerLinkActive="active-link">Bob</a>
 * ```
 *
 * When the url is either '/user' or '/user/bob', the active-link class will
 * be added to the `a` tag. If the url changes, the class will be removed.
 *
 * You can set more than one class, as follows:
 *
 * ```
 * <a routerLink="/user/bob" routerLinkActive="class1 class2">Bob</a>
 * <a routerLink="/user/bob" [routerLinkActive]="['class1', 'class2']">Bob</a>
 * ```
 *
 * You can configure RouterLinkActive by passing `exact: true`. This will add the classes
 * only when the url matches the link exactly.
 *
 * ```
 * <a routerLink="/user/bob" routerLinkActive="active-link" [routerLinkActiveOptions]="{exact:
 * true}">Bob</a>
 * ```
 *
 * You can assign the RouterLinkActive instance to a template variable and directly check
 * the `isActive` status.
 * ```
 * <a routerLink="/user/bob" routerLinkActive #rla="routerLinkActive">
 *   Bob {{ rla.isActive ? '(already open)' : ''}}
 * </a>
 * ```
 *
 * Finally, you can apply the RouterLinkActive directive to an ancestor of a RouterLink.
 *
 * ```
 * <div routerLinkActive="active-link" [routerLinkActiveOptions]="{exact: true}">
 *   <a routerLink="/user/jim">Jim</a>
 *   <a routerLink="/user/bob">Bob</a>
 * </div>
 * ```
 *
 * This will set the active-link class on the div tag if the url is either '/user/jim' or
 * '/user/bob'.
 *
 * @ngModule RouterModule
 *
 * @publicApi
 */
var RouterLinkActive = /** @class */ (function () {
    function RouterLinkActive(router, element, renderer, cdr) {
        var _this = this;
        this.router = router;
        this.element = element;
        this.renderer = renderer;
        this.cdr = cdr;
        this.classes = [];
        this.isActive = false;
        this.routerLinkActiveOptions = { exact: false };
        this.subscription = router.events.subscribe(function (s) {
            if (s instanceof NavigationEnd) {
                _this.update();
            }
        });
    }
    RouterLinkActive.prototype.ngAfterContentInit = function () {
        var _this = this;
        this.links.changes.subscribe(function (_) { return _this.update(); });
        this.linksWithHrefs.changes.subscribe(function (_) { return _this.update(); });
        this.update();
    };
    Object.defineProperty(RouterLinkActive.prototype, "routerLinkActive", {
        set: function (data) {
            var classes = Array.isArray(data) ? data : data.split(' ');
            this.classes = classes.filter(function (c) { return !!c; });
        },
        enumerable: true,
        configurable: true
    });
    RouterLinkActive.prototype.ngOnChanges = function (changes) { this.update(); };
    RouterLinkActive.prototype.ngOnDestroy = function () { this.subscription.unsubscribe(); };
    RouterLinkActive.prototype.update = function () {
        var _this = this;
        if (!this.links || !this.linksWithHrefs || !this.router.navigated)
            return;
        Promise.resolve().then(function () {
            var hasActiveLinks = _this.hasActiveLinks();
            if (_this.isActive !== hasActiveLinks) {
                _this.isActive = hasActiveLinks;
                _this.classes.forEach(function (c) {
                    if (hasActiveLinks) {
                        _this.renderer.addClass(_this.element.nativeElement, c);
                    }
                    else {
                        _this.renderer.removeClass(_this.element.nativeElement, c);
                    }
                });
            }
        });
    };
    RouterLinkActive.prototype.isLinkActive = function (router) {
        var _this = this;
        return function (link) {
            return router.isActive(link.urlTree, _this.routerLinkActiveOptions.exact);
        };
    };
    RouterLinkActive.prototype.hasActiveLinks = function () {
        return this.links.some(this.isLinkActive(this.router)) ||
            this.linksWithHrefs.some(this.isLinkActive(this.router));
    };
    __decorate([
        ContentChildren(RouterLink, { descendants: true }),
        __metadata("design:type", QueryList)
    ], RouterLinkActive.prototype, "links", void 0);
    __decorate([
        ContentChildren(RouterLinkWithHref, { descendants: true }),
        __metadata("design:type", QueryList)
    ], RouterLinkActive.prototype, "linksWithHrefs", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], RouterLinkActive.prototype, "routerLinkActiveOptions", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], RouterLinkActive.prototype, "routerLinkActive", null);
    RouterLinkActive = __decorate([
        Directive({
            selector: '[routerLinkActive]',
            exportAs: 'routerLinkActive',
        }),
        __metadata("design:paramtypes", [Router, ElementRef, Renderer2,
            ChangeDetectorRef])
    ], RouterLinkActive);
    return RouterLinkActive;
}());

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Store contextual information about a `RouterOutlet`
 *
 * @publicApi
 */
var OutletContext = /** @class */ (function () {
    function OutletContext() {
        this.outlet = null;
        this.route = null;
        this.resolver = null;
        this.children = new ChildrenOutletContexts();
        this.attachRef = null;
    }
    return OutletContext;
}());
/**
 * Store contextual information about the children (= nested) `RouterOutlet`
 *
 * @publicApi
 */
var ChildrenOutletContexts = /** @class */ (function () {
    function ChildrenOutletContexts() {
        // contexts for child outlets, by name.
        this.contexts = new Map();
    }
    /** Called when a `RouterOutlet` directive is instantiated */
    ChildrenOutletContexts.prototype.onChildOutletCreated = function (childName, outlet) {
        var context = this.getOrCreateContext(childName);
        context.outlet = outlet;
        this.contexts.set(childName, context);
    };
    /**
     * Called when a `RouterOutlet` directive is destroyed.
     * We need to keep the context as the outlet could be destroyed inside a NgIf and might be
     * re-created later.
     */
    ChildrenOutletContexts.prototype.onChildOutletDestroyed = function (childName) {
        var context = this.getContext(childName);
        if (context) {
            context.outlet = null;
        }
    };
    /**
     * Called when the corresponding route is deactivated during navigation.
     * Because the component get destroyed, all children outlet are destroyed.
     */
    ChildrenOutletContexts.prototype.onOutletDeactivated = function () {
        var contexts = this.contexts;
        this.contexts = new Map();
        return contexts;
    };
    ChildrenOutletContexts.prototype.onOutletReAttached = function (contexts) { this.contexts = contexts; };
    ChildrenOutletContexts.prototype.getOrCreateContext = function (childName) {
        var context = this.getContext(childName);
        if (!context) {
            context = new OutletContext();
            this.contexts.set(childName, context);
        }
        return context;
    };
    ChildrenOutletContexts.prototype.getContext = function (childName) { return this.contexts.get(childName) || null; };
    return ChildrenOutletContexts;
}());

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @description
 *
 * Acts as a placeholder that Angular dynamically fills based on the current router state.
 *
 * ```
 * <router-outlet></router-outlet>
 * <router-outlet name='left'></router-outlet>
 * <router-outlet name='right'></router-outlet>
 * ```
 *
 * A router outlet will emit an activate event any time a new component is being instantiated,
 * and a deactivate event when it is being destroyed.
 *
 * ```
 * <router-outlet
 *   (activate)='onActivate($event)'
 *   (deactivate)='onDeactivate($event)'></router-outlet>
 * ```
 * @ngModule RouterModule
 *
 * @publicApi
 */
var RouterOutlet = /** @class */ (function () {
    function RouterOutlet(parentContexts, location, resolver, name, changeDetector) {
        this.parentContexts = parentContexts;
        this.location = location;
        this.resolver = resolver;
        this.changeDetector = changeDetector;
        this.activated = null;
        this._activatedRoute = null;
        this.activateEvents = new EventEmitter();
        this.deactivateEvents = new EventEmitter();
        this.name = name || PRIMARY_OUTLET;
        parentContexts.onChildOutletCreated(this.name, this);
    }
    RouterOutlet.prototype.ngOnDestroy = function () { this.parentContexts.onChildOutletDestroyed(this.name); };
    RouterOutlet.prototype.ngOnInit = function () {
        if (!this.activated) {
            // If the outlet was not instantiated at the time the route got activated we need to populate
            // the outlet when it is initialized (ie inside a NgIf)
            var context = this.parentContexts.getContext(this.name);
            if (context && context.route) {
                if (context.attachRef) {
                    // `attachRef` is populated when there is an existing component to mount
                    this.attach(context.attachRef, context.route);
                }
                else {
                    // otherwise the component defined in the configuration is created
                    this.activateWith(context.route, context.resolver || null);
                }
            }
        }
    };
    Object.defineProperty(RouterOutlet.prototype, "isActivated", {
        get: function () { return !!this.activated; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RouterOutlet.prototype, "component", {
        get: function () {
            if (!this.activated)
                throw new Error('Outlet is not activated');
            return this.activated.instance;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RouterOutlet.prototype, "activatedRoute", {
        get: function () {
            if (!this.activated)
                throw new Error('Outlet is not activated');
            return this._activatedRoute;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RouterOutlet.prototype, "activatedRouteData", {
        get: function () {
            if (this._activatedRoute) {
                return this._activatedRoute.snapshot.data;
            }
            return {};
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Called when the `RouteReuseStrategy` instructs to detach the subtree
     */
    RouterOutlet.prototype.detach = function () {
        if (!this.activated)
            throw new Error('Outlet is not activated');
        this.location.detach();
        var cmp = this.activated;
        this.activated = null;
        this._activatedRoute = null;
        return cmp;
    };
    /**
     * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree
     */
    RouterOutlet.prototype.attach = function (ref, activatedRoute) {
        this.activated = ref;
        this._activatedRoute = activatedRoute;
        this.location.insert(ref.hostView);
    };
    RouterOutlet.prototype.deactivate = function () {
        if (this.activated) {
            var c = this.component;
            this.activated.destroy();
            this.activated = null;
            this._activatedRoute = null;
            this.deactivateEvents.emit(c);
        }
    };
    RouterOutlet.prototype.activateWith = function (activatedRoute, resolver) {
        if (this.isActivated) {
            throw new Error('Cannot activate an already activated outlet');
        }
        this._activatedRoute = activatedRoute;
        var snapshot = activatedRoute._futureSnapshot;
        var component = snapshot.routeConfig.component;
        resolver = resolver || this.resolver;
        var factory = resolver.resolveComponentFactory(component);
        var childContexts = this.parentContexts.getOrCreateContext(this.name).children;
        var injector = new OutletInjector(activatedRoute, childContexts, this.location.injector);
        this.activated = this.location.createComponent(factory, this.location.length, injector);
        // Calling `markForCheck` to make sure we will run the change detection when the
        // `RouterOutlet` is inside a `ChangeDetectionStrategy.OnPush` component.
        this.changeDetector.markForCheck();
        this.activateEvents.emit(this.activated.instance);
    };
    __decorate([
        Output('activate'),
        __metadata("design:type", Object)
    ], RouterOutlet.prototype, "activateEvents", void 0);
    __decorate([
        Output('deactivate'),
        __metadata("design:type", Object)
    ], RouterOutlet.prototype, "deactivateEvents", void 0);
    RouterOutlet = __decorate([
        Directive({ selector: 'router-outlet', exportAs: 'outlet' }),
        __param(3, Attribute('name')),
        __metadata("design:paramtypes", [ChildrenOutletContexts, ViewContainerRef,
            ComponentFactoryResolver, String, ChangeDetectorRef])
    ], RouterOutlet);
    return RouterOutlet;
}());
var OutletInjector = /** @class */ (function () {
    function OutletInjector(route, childContexts, parent) {
        this.route = route;
        this.childContexts = childContexts;
        this.parent = parent;
    }
    OutletInjector.prototype.get = function (token, notFoundValue) {
        if (token === ActivatedRoute) {
            return this.route;
        }
        if (token === ChildrenOutletContexts) {
            return this.childContexts;
        }
        return this.parent.get(token, notFoundValue);
    };
    return OutletInjector;
}());

/**
*@license
*Copyright Google Inc. All Rights Reserved.
*
*Use of this source code is governed by an MIT-style license that can be
*found in the LICENSE file at https://angular.io/license
*/
/**
 * @description
 *
 * Provides a preloading strategy.
 *
 * @publicApi
 */
var PreloadingStrategy = /** @class */ (function () {
    function PreloadingStrategy() {
    }
    return PreloadingStrategy;
}());
/**
 * @description
 *
 * Provides a preloading strategy that preloads all modules as quickly as possible.
 *
 * ```
 * RouteModule.forRoot(ROUTES, {preloadingStrategy: PreloadAllModules})
 * ```
 *
 * @publicApi
 */
var PreloadAllModules = /** @class */ (function () {
    function PreloadAllModules() {
    }
    PreloadAllModules.prototype.preload = function (route, fn) {
        return fn().pipe(catchError(function () { return of(null); }));
    };
    return PreloadAllModules;
}());
/**
 * @description
 *
 * Provides a preloading strategy that does not preload any modules.
 *
 * This strategy is enabled by default.
 *
 * @publicApi
 */
var NoPreloading = /** @class */ (function () {
    function NoPreloading() {
    }
    NoPreloading.prototype.preload = function (route, fn) { return of(null); };
    return NoPreloading;
}());
/**
 * The preloader optimistically loads all router configurations to
 * make navigations into lazily-loaded sections of the application faster.
 *
 * The preloader runs in the background. When the router bootstraps, the preloader
 * starts listening to all navigation events. After every such event, the preloader
 * will check if any configurations can be loaded lazily.
 *
 * If a route is protected by `canLoad` guards, the preloaded will not load it.
 *
 * @publicApi
 */
var RouterPreloader = /** @class */ (function () {
    function RouterPreloader(router, moduleLoader, compiler, injector, preloadingStrategy) {
        this.router = router;
        this.injector = injector;
        this.preloadingStrategy = preloadingStrategy;
        var onStartLoad = function (r) { return router.triggerEvent(new RouteConfigLoadStart(r)); };
        var onEndLoad = function (r) { return router.triggerEvent(new RouteConfigLoadEnd(r)); };
        this.loader = new RouterConfigLoader(moduleLoader, compiler, onStartLoad, onEndLoad);
    }
    RouterPreloader.prototype.setUpPreloading = function () {
        var _this = this;
        this.subscription =
            this.router.events
                .pipe(filter(function (e) { return e instanceof NavigationEnd; }), concatMap(function () { return _this.preload(); }))
                .subscribe(function () { });
    };
    RouterPreloader.prototype.preload = function () {
        var ngModule = this.injector.get(NgModuleRef);
        return this.processRoutes(ngModule, this.router.config);
    };
    // TODO(jasonaden): This class relies on code external to the class to call setUpPreloading. If
    // this hasn't been done, ngOnDestroy will fail as this.subscription will be undefined. This
    // should be refactored.
    RouterPreloader.prototype.ngOnDestroy = function () { this.subscription.unsubscribe(); };
    RouterPreloader.prototype.processRoutes = function (ngModule, routes) {
        var e_1, _a;
        var res = [];
        try {
            for (var routes_1 = __values(routes), routes_1_1 = routes_1.next(); !routes_1_1.done; routes_1_1 = routes_1.next()) {
                var route = routes_1_1.value;
                // we already have the config loaded, just recurse
                if (route.loadChildren && !route.canLoad && route._loadedConfig) {
                    var childConfig = route._loadedConfig;
                    res.push(this.processRoutes(childConfig.module, childConfig.routes));
                    // no config loaded, fetch the config
                }
                else if (route.loadChildren && !route.canLoad) {
                    res.push(this.preloadConfig(ngModule, route));
                    // recurse into children
                }
                else if (route.children) {
                    res.push(this.processRoutes(ngModule, route.children));
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (routes_1_1 && !routes_1_1.done && (_a = routes_1.return)) _a.call(routes_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return from(res).pipe(mergeAll(), map(function (_) { return void 0; }));
    };
    RouterPreloader.prototype.preloadConfig = function (ngModule, route) {
        var _this = this;
        return this.preloadingStrategy.preload(route, function () {
            var loaded$ = _this.loader.load(ngModule.injector, route);
            return loaded$.pipe(mergeMap(function (config) {
                route._loadedConfig = config;
                return _this.processRoutes(config.module, config.routes);
            }));
        });
    };
    RouterPreloader = __decorate([
        Injectable(),
        __metadata("design:paramtypes", [Router, NgModuleFactoryLoader, Compiler,
            Injector, PreloadingStrategy])
    ], RouterPreloader);
    return RouterPreloader;
}());

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var RouterScroller = /** @class */ (function () {
    function RouterScroller(router, 
    /** @docsNotRequired */ viewportScroller, options) {
        if (options === void 0) { options = {}; }
        this.router = router;
        this.viewportScroller = viewportScroller;
        this.options = options;
        this.lastId = 0;
        this.lastSource = 'imperative';
        this.restoredId = 0;
        this.store = {};
        // Default both options to 'disabled'
        options.scrollPositionRestoration = options.scrollPositionRestoration || 'disabled';
        options.anchorScrolling = options.anchorScrolling || 'disabled';
    }
    RouterScroller.prototype.init = function () {
        // we want to disable the automatic scrolling because having two places
        // responsible for scrolling results race conditions, especially given
        // that browser don't implement this behavior consistently
        if (this.options.scrollPositionRestoration !== 'disabled') {
            this.viewportScroller.setHistoryScrollRestoration('manual');
        }
        this.routerEventsSubscription = this.createScrollEvents();
        this.scrollEventsSubscription = this.consumeScrollEvents();
    };
    RouterScroller.prototype.createScrollEvents = function () {
        var _this = this;
        return this.router.events.subscribe(function (e) {
            if (e instanceof NavigationStart) {
                // store the scroll position of the current stable navigations.
                _this.store[_this.lastId] = _this.viewportScroller.getScrollPosition();
                _this.lastSource = e.navigationTrigger;
                _this.restoredId = e.restoredState ? e.restoredState.navigationId : 0;
            }
            else if (e instanceof NavigationEnd) {
                _this.lastId = e.id;
                _this.scheduleScrollEvent(e, _this.router.parseUrl(e.urlAfterRedirects).fragment);
            }
        });
    };
    RouterScroller.prototype.consumeScrollEvents = function () {
        var _this = this;
        return this.router.events.subscribe(function (e) {
            if (!(e instanceof Scroll))
                return;
            // a popstate event. The pop state event will always ignore anchor scrolling.
            if (e.position) {
                if (_this.options.scrollPositionRestoration === 'top') {
                    _this.viewportScroller.scrollToPosition([0, 0]);
                }
                else if (_this.options.scrollPositionRestoration === 'enabled') {
                    _this.viewportScroller.scrollToPosition(e.position);
                }
                // imperative navigation "forward"
            }
            else {
                if (e.anchor && _this.options.anchorScrolling === 'enabled') {
                    _this.viewportScroller.scrollToAnchor(e.anchor);
                }
                else if (_this.options.scrollPositionRestoration !== 'disabled') {
                    _this.viewportScroller.scrollToPosition([0, 0]);
                }
            }
        });
    };
    RouterScroller.prototype.scheduleScrollEvent = function (routerEvent, anchor) {
        this.router.triggerEvent(new Scroll(routerEvent, this.lastSource === 'popstate' ? this.store[this.restoredId] : null, anchor));
    };
    RouterScroller.prototype.ngOnDestroy = function () {
        if (this.routerEventsSubscription) {
            this.routerEventsSubscription.unsubscribe();
        }
        if (this.scrollEventsSubscription) {
            this.scrollEventsSubscription.unsubscribe();
        }
    };
    return RouterScroller;
}());

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @description
 *
 * Contains a list of directives
 *
 *
 */
var ROUTER_DIRECTIVES = [RouterOutlet, RouterLink, RouterLinkWithHref, RouterLinkActive, EmptyOutletComponent];
/**
 * @description
 *
 * Is used in DI to configure the router.
 *
 * @publicApi
 */
var ROUTER_CONFIGURATION = new InjectionToken('ROUTER_CONFIGURATION');
/**
 * @docsNotRequired
 */
var ROUTER_FORROOT_GUARD = new InjectionToken('ROUTER_FORROOT_GUARD');
var ROUTER_PROVIDERS = [
    Location,
    { provide: UrlSerializer, useClass: DefaultUrlSerializer },
    {
        provide: Router,
        useFactory: setupRouter,
        deps: [
            ApplicationRef, UrlSerializer, ChildrenOutletContexts, Location, Injector,
            NgModuleFactoryLoader, Compiler, ROUTES, ROUTER_CONFIGURATION,
            [UrlHandlingStrategy, new Optional()], [RouteReuseStrategy, new Optional()]
        ]
    },
    ChildrenOutletContexts,
    { provide: ActivatedRoute, useFactory: rootRoute, deps: [Router] },
    { provide: NgModuleFactoryLoader, useClass: SystemJsNgModuleLoader },
    RouterPreloader,
    NoPreloading,
    PreloadAllModules,
    { provide: ROUTER_CONFIGURATION, useValue: { enableTracing: false } },
];
function routerNgProbeToken() {
    return new NgProbeToken('Router', Router);
}
/**
 * @usageNotes
 *
 * RouterModule can be imported multiple times: once per lazily-loaded bundle.
 * Since the router deals with a global shared resource--location, we cannot have
 * more than one router service active.
 *
 * That is why there are two ways to create the module: `RouterModule.forRoot` and
 * `RouterModule.forChild`.
 *
 * * `forRoot` creates a module that contains all the directives, the given routes, and the router
 *   service itself.
 * * `forChild` creates a module that contains all the directives and the given routes, but does not
 *   include the router service.
 *
 * When registered at the root, the module should be used as follows
 *
 * ```
 * @NgModule({
 *   imports: [RouterModule.forRoot(ROUTES)]
 * })
 * class MyNgModule {}
 * ```
 *
 * For submodules and lazy loaded submodules the module should be used as follows:
 *
 * ```
 * @NgModule({
 *   imports: [RouterModule.forChild(ROUTES)]
 * })
 * class MyNgModule {}
 * ```
 *
 * @description
 *
 * Adds router directives and providers.
 *
 * Managing state transitions is one of the hardest parts of building applications. This is
 * especially true on the web, where you also need to ensure that the state is reflected in the URL.
 * In addition, we often want to split applications into multiple bundles and load them on demand.
 * Doing this transparently is not trivial.
 *
 * The Angular router solves these problems. Using the router, you can declaratively specify
 * application states, manage state transitions while taking care of the URL, and load bundles on
 * demand.
 *
 * [Read this developer guide](https://angular.io/docs/ts/latest/guide/router.html) to get an
 * overview of how the router should be used.
 *
 * @publicApi
 */
var RouterModule = /** @class */ (function () {
    // Note: We are injecting the Router so it gets created eagerly...
    function RouterModule(guard, router) {
    }
    RouterModule_1 = RouterModule;
    /**
     * Creates a module with all the router providers and directives. It also optionally sets up an
     * application listener to perform an initial navigation.
     *
     * Configuration Options:
     *
     * * `enableTracing` Toggles whether the router should log all navigation events to the console.
     * * `useHash` Enables the location strategy that uses the URL fragment instead of the history
     * API.
     * * `initialNavigation` Disables the initial navigation.
     * * `errorHandler` Defines a custom error handler for failed navigations.
     * * `preloadingStrategy` Configures a preloading strategy. See `PreloadAllModules`.
     * * `onSameUrlNavigation` Define what the router should do if it receives a navigation request to
     * the current URL.
     * * `scrollPositionRestoration` Configures if the scroll position needs to be restored when
     * navigating back.
     * * `anchorScrolling` Configures if the router should scroll to the element when the url has a
     * fragment.
     * * `scrollOffset` Configures the scroll offset the router will use when scrolling to an element.
     * * `paramsInheritanceStrategy` Defines how the router merges params, data and resolved data from
     * parent to child routes.
     * * `malformedUriErrorHandler` Defines a custom malformed uri error handler function. This
     * handler is invoked when encodedURI contains invalid character sequences.
     * * `urlUpdateStrategy` Defines when the router updates the browser URL. The default behavior is
     * to update after successful navigation.
     * * `relativeLinkResolution` Enables the correct relative link resolution in components with
     * empty paths.
     *
     * See `ExtraOptions` for more details about the above options.
    */
    RouterModule.forRoot = function (routes, config) {
        return {
            ngModule: RouterModule_1,
            providers: [
                ROUTER_PROVIDERS,
                provideRoutes(routes),
                {
                    provide: ROUTER_FORROOT_GUARD,
                    useFactory: provideForRootGuard,
                    deps: [[Router, new Optional(), new SkipSelf()]]
                },
                { provide: ROUTER_CONFIGURATION, useValue: config ? config : {} },
                {
                    provide: LocationStrategy,
                    useFactory: provideLocationStrategy,
                    deps: [
                        PlatformLocation, [new Inject(APP_BASE_HREF), new Optional()], ROUTER_CONFIGURATION
                    ]
                },
                {
                    provide: RouterScroller,
                    useFactory: createRouterScroller,
                    deps: [Router, ViewportScroller, ROUTER_CONFIGURATION]
                },
                {
                    provide: PreloadingStrategy,
                    useExisting: config && config.preloadingStrategy ? config.preloadingStrategy :
                        NoPreloading
                },
                { provide: NgProbeToken, multi: true, useFactory: routerNgProbeToken },
                provideRouterInitializer(),
            ],
        };
    };
    /**
     * Creates a module with all the router directives and a provider registering routes.
     */
    RouterModule.forChild = function (routes) {
        return { ngModule: RouterModule_1, providers: [provideRoutes(routes)] };
    };
    var RouterModule_1;
    RouterModule = RouterModule_1 = __decorate([
        NgModule({
            declarations: ROUTER_DIRECTIVES,
            exports: ROUTER_DIRECTIVES,
            entryComponents: [EmptyOutletComponent]
        }),
        __param(0, Optional()), __param(0, Inject(ROUTER_FORROOT_GUARD)), __param(1, Optional()),
        __metadata("design:paramtypes", [Object, Router])
    ], RouterModule);
    return RouterModule;
}());
function createRouterScroller(router, viewportScroller, config) {
    if (config.scrollOffset) {
        viewportScroller.setOffset(config.scrollOffset);
    }
    return new RouterScroller(router, viewportScroller, config);
}
function provideLocationStrategy(platformLocationStrategy, baseHref, options) {
    if (options === void 0) { options = {}; }
    return options.useHash ? new HashLocationStrategy(platformLocationStrategy, baseHref) :
        new PathLocationStrategy(platformLocationStrategy, baseHref);
}
function provideForRootGuard(router) {
    if (router) {
        throw new Error("RouterModule.forRoot() called twice. Lazy loaded modules should use RouterModule.forChild() instead.");
    }
    return 'guarded';
}
/**
 * @description
 *
 * Registers routes.
 *
 * @usageNotes
 * ### Example
 *
 * ```
 * @NgModule({
 *   imports: [RouterModule.forChild(ROUTES)],
 *   providers: [provideRoutes(EXTRA_ROUTES)]
 * })
 * class MyNgModule {}
 * ```
 *
 * @publicApi
 */
function provideRoutes(routes) {
    return [
        { provide: ANALYZE_FOR_ENTRY_COMPONENTS, multi: true, useValue: routes },
        { provide: ROUTES, multi: true, useValue: routes },
    ];
}
function setupRouter(ref, urlSerializer, contexts, location, injector, loader, compiler, config, opts, urlHandlingStrategy, routeReuseStrategy) {
    if (opts === void 0) { opts = {}; }
    var router = new Router(null, urlSerializer, contexts, location, injector, loader, compiler, flatten(config));
    if (urlHandlingStrategy) {
        router.urlHandlingStrategy = urlHandlingStrategy;
    }
    if (routeReuseStrategy) {
        router.routeReuseStrategy = routeReuseStrategy;
    }
    if (opts.errorHandler) {
        router.errorHandler = opts.errorHandler;
    }
    if (opts.malformedUriErrorHandler) {
        router.malformedUriErrorHandler = opts.malformedUriErrorHandler;
    }
    if (opts.enableTracing) {
        var dom_1 = ɵgetDOM();
        router.events.subscribe(function (e) {
            dom_1.logGroup("Router Event: " + e.constructor.name);
            dom_1.log(e.toString());
            dom_1.log(e);
            dom_1.logGroupEnd();
        });
    }
    if (opts.onSameUrlNavigation) {
        router.onSameUrlNavigation = opts.onSameUrlNavigation;
    }
    if (opts.paramsInheritanceStrategy) {
        router.paramsInheritanceStrategy = opts.paramsInheritanceStrategy;
    }
    if (opts.urlUpdateStrategy) {
        router.urlUpdateStrategy = opts.urlUpdateStrategy;
    }
    if (opts.relativeLinkResolution) {
        router.relativeLinkResolution = opts.relativeLinkResolution;
    }
    return router;
}
function rootRoute(router) {
    return router.routerState.root;
}
/**
 * To initialize the router properly we need to do in two steps:
 *
 * We need to start the navigation in a APP_INITIALIZER to block the bootstrap if
 * a resolver or a guards executes asynchronously. Second, we need to actually run
 * activation in a BOOTSTRAP_LISTENER. We utilize the afterPreactivation
 * hook provided by the router to do that.
 *
 * The router navigation starts, reaches the point when preactivation is done, and then
 * pauses. It waits for the hook to be resolved. We then resolve it only in a bootstrap listener.
 */
var RouterInitializer = /** @class */ (function () {
    function RouterInitializer(injector) {
        this.injector = injector;
        this.initNavigation = false;
        this.resultOfPreactivationDone = new Subject();
    }
    RouterInitializer.prototype.appInitializer = function () {
        var _this = this;
        var p = this.injector.get(LOCATION_INITIALIZED, Promise.resolve(null));
        return p.then(function () {
            var resolve = null;
            var res = new Promise(function (r) { return resolve = r; });
            var router = _this.injector.get(Router);
            var opts = _this.injector.get(ROUTER_CONFIGURATION);
            if (_this.isLegacyDisabled(opts) || _this.isLegacyEnabled(opts)) {
                resolve(true);
            }
            else if (opts.initialNavigation === 'disabled') {
                router.setUpLocationChangeListener();
                resolve(true);
            }
            else if (opts.initialNavigation === 'enabled') {
                router.hooks.afterPreactivation = function () {
                    // only the initial navigation should be delayed
                    if (!_this.initNavigation) {
                        _this.initNavigation = true;
                        resolve(true);
                        return _this.resultOfPreactivationDone;
                        // subsequent navigations should not be delayed
                    }
                    else {
                        return of(null);
                    }
                };
                router.initialNavigation();
            }
            else {
                throw new Error("Invalid initialNavigation options: '" + opts.initialNavigation + "'");
            }
            return res;
        });
    };
    RouterInitializer.prototype.bootstrapListener = function (bootstrappedComponentRef) {
        var opts = this.injector.get(ROUTER_CONFIGURATION);
        var preloader = this.injector.get(RouterPreloader);
        var routerScroller = this.injector.get(RouterScroller);
        var router = this.injector.get(Router);
        var ref = this.injector.get(ApplicationRef);
        if (bootstrappedComponentRef !== ref.components[0]) {
            return;
        }
        if (this.isLegacyEnabled(opts)) {
            router.initialNavigation();
        }
        else if (this.isLegacyDisabled(opts)) {
            router.setUpLocationChangeListener();
        }
        preloader.setUpPreloading();
        routerScroller.init();
        router.resetRootComponentType(ref.componentTypes[0]);
        this.resultOfPreactivationDone.next(null);
        this.resultOfPreactivationDone.complete();
    };
    RouterInitializer.prototype.isLegacyEnabled = function (opts) {
        return opts.initialNavigation === 'legacy_enabled' || opts.initialNavigation === true ||
            opts.initialNavigation === undefined;
    };
    RouterInitializer.prototype.isLegacyDisabled = function (opts) {
        return opts.initialNavigation === 'legacy_disabled' || opts.initialNavigation === false;
    };
    RouterInitializer = __decorate([
        Injectable(),
        __metadata("design:paramtypes", [Injector])
    ], RouterInitializer);
    return RouterInitializer;
}());
function getAppInitializer(r) {
    return r.appInitializer.bind(r);
}
function getBootstrapListener(r) {
    return r.bootstrapListener.bind(r);
}
/**
 * A token for the router initializer that will be called after the app is bootstrapped.
 *
 * @publicApi
 */
var ROUTER_INITIALIZER = new InjectionToken('Router Initializer');
function provideRouterInitializer() {
    return [
        RouterInitializer,
        {
            provide: APP_INITIALIZER,
            multi: true,
            useFactory: getAppInitializer,
            deps: [RouterInitializer]
        },
        { provide: ROUTER_INITIALIZER, useFactory: getBootstrapListener, deps: [RouterInitializer] },
        { provide: APP_BOOTSTRAP_LISTENER, multi: true, useExisting: ROUTER_INITIALIZER },
    ];
}

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @publicApi
 */
var VERSION = new Version('7.2.16');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DisplayFieldService {
    constructor() { }
    /**
     * @param {?} dataIndex
     * @param {?} data
     * @return {?}
     */
    findValue(dataIndex, data) {
        this.rowData = data;
        if (dataIndex != null) {
            /** @type {?} */
            const index = dataIndex.split('.');
            if (index.includes('')) {
                index.splice(1);
            }
            for (const ir of index) {
                this.rowData = this.rowData[ir];
            }
            return this.rowData;
        }
    }
}
DisplayFieldService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] },
];
/** @nocollapse */
DisplayFieldService.ctorParameters = () => [];
/** @nocollapse */ DisplayFieldService.ngInjectableDef = defineInjectable({ factory: function DisplayFieldService_Factory() { return new DisplayFieldService(); }, token: DisplayFieldService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DisplayFieldComponent {
    /**
     * @param {?} displayFieldService
     */
    constructor(displayFieldService) {
        this.displayFieldService = displayFieldService;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.findDisplayValues();
    }
    /**
     * @return {?}
     */
    findDisplayValues() {
        this.rowData = this.displayFieldService.findValue(this.dataIndex, this.data);
    }
}
DisplayFieldComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-display-field',
                template: `
    {{rowData}}
  `,
            },] },
];
/** @nocollapse */
DisplayFieldComponent.ctorParameters = () => [
    { type: DisplayFieldService }
];
DisplayFieldComponent.propDecorators = {
    data: [{ type: Input }],
    dataIndex: [{ type: Input, args: ['data-index',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
class DropDownListComponent {
    /**
     * @param {?} elementRef
     */
    constructor(elementRef) {
        this.elementRef = elementRef;
        this.itemclick = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onDropDownListClick(event) {
        this.itemclick.emit(event);
    }
    /**
     * @param {?} rowindex
     * @return {?}
     */
    scroll(rowindex) {
        /** @type {?} */
        const listitems = this.elementRef.nativeElement.getElementsByClassName('list-items')[rowindex];
        if (listitems) {
            listitems.scrollIntoView({ behavior: 'smooth' });
        }
    }
    /**
     * @return {?}
     */
    selectedItem() {
        return this.elementRef.nativeElement.getElementsByClassName('list-items list-items-selected');
    }
}
DropDownListComponent.decorators = [
    { type: Component, args: [{
                selector: 'dropdown-list-item',
                template: `
          <ul role="list"  class="dropdown-list">
              <li role="listitem" [ngClass]="{'list-items-selected': (i === highlightrow)}" 
                   class="list-items" 
                   [attr.valuefield]="item[valuefield]" 
                   [attr.displayfield]="item[displayfield]" 
                   *ngFor="let item of viewdata | async | filterpipe : displayfield : displayValue ; index as i"  
                  (mousedown)="onDropDownListClick(item)"
                  id="{{item.index}}">
                  <ng-container *ngIf="!template">
                      <div><amexio-display-field [data]="item" [data-index]="displayfield"></amexio-display-field></div>    
                  </ng-container>

                  <ng-container *ngIf="template">
                      <ng-template [ngTemplateOutlet]="template" [ngTemplateOutletContext]="{ text : item }">
                      </ng-template>
                  </ng-container>
    
              </li>
          </ul>
    `,
            },] },
];
/** @nocollapse */
DropDownListComponent.ctorParameters = () => [
    { type: ElementRef }
];
DropDownListComponent.propDecorators = {
    viewdata: [{ type: Input, args: ['data',] }],
    highlightrow: [{ type: Input, args: ['highlight-row',] }],
    valuefield: [{ type: Input, args: ['value-field',] }],
    displayfield: [{ type: Input, args: ['display-field',] }],
    displayValue: [{ type: Input, args: ['display-value',] }],
    itemclick: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/
class FilterPipe {
    /**
     * @param {?} items
     * @param {?} field
     * @param {?} value
     * @return {?}
     */
    transform(items, field, value) {
        if (!items) {
            return [];
        }
        if (!field || !value) {
            return items;
        }
        return items.filter((/**
         * @param {?} singleItem
         * @return {?}
         */
        (singleItem) => singleItem[field].toLowerCase().startsWith(value.toLowerCase())));
    }
}
FilterPipe.decorators = [
    { type: Pipe, args: [{
                name: 'filterpipe',
            },] },
    { type: Injectable },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by pratik on 21/12/17
*/
/** @type {?} */
const faFaCaretIcon = 'fa fa-caret-down';
/** @type {?} */
const faFaTimesIcon = 'fa fa-times';
/** @type {?} */
const faExpand = 'fa fa-expand';
/** @type {?} */
const faCompress = 'fa fa-compress';
/** @type {?} */
const ICON_MAPPING = [
    {
        component: 'datepicker_previous',
        fa: 'fa fa-chevron-left',
        mat: 'keyboard_arrow_left',
    },
    {
        component: 'datepicker_calendar',
        fa: 'fa fa-calendar',
        mat: 'date_range',
    },
    {
        component: 'datepicker_next',
        fa: 'fa fa-chevron-right',
        mat: 'keyboard_arrow_right',
    },
    {
        component: 'datepicker_previous_fast',
        fa: 'fa fa-step-backward',
        mat: 'fast_rewind',
    },
    {
        component: 'datepicker_next_fast',
        fa: 'fa fa-step-forward',
        mat: 'fast_forward',
    },
    {
        component: 'accordion_expand',
        fa: 'fa fa-plus',
        mat: 'add',
    },
    {
        component: 'accordion_collapse',
        fa: 'fa fa-minus',
        mat: 'remove',
    },
    {
        component: 'tree_expand',
        fa: 'fa fa-chevron-down',
        mat: 'keyboard_arrow_down',
    },
    {
        component: 'tree_collapse',
        fa: 'fa fa-chevron-right',
        mat: 'keyboard_arrow_right',
    },
    {
        component: 'dropdown_caret',
        fa: faFaCaretIcon,
        mat: 'arrow_drop_down',
    },
    {
        component: 'tab_close',
        fa: faFaTimesIcon,
        mat: 'close',
    },
    {
        component: 'window_minimize',
        fa: 'fa fa-window-minimize',
        mat: 'minimize',
    },
    {
        component: 'window_close',
        fa: faFaTimesIcon,
        mat: 'close',
    },
    {
        component: 'window_maximize',
        fa: 'fa fa-window-maximize',
        mat: 'open_with',
    },
    {
        component: 'window_restore',
        fa: 'fa fa-window-restore',
        mat: 'indeterminate_check_box',
    },
    {
        component: 'paginator_previous',
        fa: 'fa fa-angle-left',
        mat: 'keyboard_arrow_left',
    },
    {
        component: 'paginator_next',
        fa: 'fa fa-angle-right',
        mat: 'keyboard_arrow_right',
    },
    {
        component: 'paginator_first',
        fa: 'fa fa-angle-double-left',
        mat: 'first_page',
    },
    {
        component: 'paginator_last',
        fa: 'fa fa-angle-double-right',
        mat: 'last_page',
    },
    {
        component: 'itemselector_caretup',
        fa: 'fa fa-caret-up',
        mat: 'arrow_drop_up',
    },
    {
        component: 'itemselector_caretdown',
        fa: faFaCaretIcon,
        mat: 'arrow_drop_down',
    },
    {
        component: 'itemselector_arrowup',
        fa: 'fa fa-arrow-up',
        mat: 'arrow_upward',
    },
    {
        component: 'itemselector_arrowdown',
        fa: 'fa fa-arrow-down',
        mat: 'arrow_downward',
    },
    {
        component: 'itemselector_arrowleft',
        fa: 'fa fa-arrow-left',
        mat: 'keyboard_arrow_left',
    },
    {
        component: 'itemselector_arrowright',
        fa: 'fa fa-arrow-right',
        mat: 'keyboard_arrow_right',
    },
    {
        component: 'tab_previous',
        fa: 'fa fa-angle-left fa-2x',
        mat: 'keyboard_arrow_left',
    },
    {
        component: 'tab_next',
        fa: 'fa fa-angle-right  fa-2x',
    },
    {
        component: 'tab_close',
        fa: faFaTimesIcon,
        mat: 'close',
    },
    {
        component: 'fieldset_expand',
        fa: 'fa fa-plus',
        mat: 'add',
    },
    {
        component: 'fieldset_collpase',
        fa: 'fa fa-minus',
        mat: 'remove',
    },
    {
        component: 'carousel_previous',
        fa: 'fa fa-angle-left fa-2x',
        mat: 'keyboard_arrow_left',
    },
    {
        component: 'carousel_next',
        fa: 'fa fa-angle-right  fa-2x',
    },
    {
        component: 'dockbar_close',
        fa: faFaTimesIcon,
        mat: 'close',
    },
    {
        component: 'notify_close',
        fa: faFaTimesIcon,
        mat: 'close',
    },
    {
        component: 'sidenav_bar',
        fa: 'fa fa-bars fa-2x',
        mat: 'menu',
    },
    {
        component: 'sidenav_close',
        fa: faFaTimesIcon,
        mat: 'close',
    },
    {
        component: 'datagrid_arrowdown',
        fa: 'fa fa-arrow-down',
        mat: 'arrow_downward',
    },
    {
        component: 'datagrid_arrowup',
        fa: 'fa fa-arrow-up',
        mat: 'arrow_upward',
    },
    {
        component: 'datagrid_list',
        fa: 'fa fa-th-list',
        mat: 'view_list',
    },
    {
        component: 'datagrid_expand',
        fa: 'fa fa-caret-right',
        mat: '',
    },
    {
        component: 'datagrid_collapse',
        fa: faFaCaretIcon,
        mat: 'arrow_drop_down',
    },
    {
        component: 'datagrid_collapse',
        fa: faFaCaretIcon,
        mat: 'arrow_drop_down',
    },
    {
        component: 'datagrid_filter',
        fa: 'fa fa-filter',
        mat: 'filter_list',
    },
    {
        component: 'tree_filter',
        fa: 'fa fa-filter',
        mat: 'filter_list',
    },
    {
        component: 'data_check',
        fa: 'fa fa-check',
        mat: 'check',
    },
    {
        component: 'button_caret-down',
        fa: faFaCaretIcon,
        mat: 'arrow_drop_down',
    },
    {
        component: 'button_angle-right',
        fa: 'fa fa-angle-right',
        mat: 'arrow_drop_right',
    },
    {
        component: 'button_angle-down',
        fa: 'fa fa-angle-down',
        mat: 'arrow_drop_down',
    },
    {
        component: 'menubar_ravelry',
        fa: 'fa fa-ravelry',
        mat: 'done',
    },
    {
        component: 'sidenav-angle-up',
        fa: 'fa fa-angle-up',
        mat: 'keyboard_arrow_up',
    },
    {
        component: 'sidenav-angle-down',
        fa: 'fa fa-angle-down',
        mat: 'keyboard_arrow_down',
    },
    {
        component: 'window-msgtype-error',
        fa: 'fa fa-exclamation-triangle fa-2x fa-fw',
        mat: 'keyboard_arrow_down',
    },
    {
        component: 'window-msgtype-warning',
        fa: 'fa fa-exclamation-triangle fa-2x fa-fw',
        mat: 'keyboard_arrow_down',
    },
    {
        component: 'window-msgtype-help',
        fa: 'fa fa-question-circle fa-2x fa-fw',
        mat: 'keyboard_arrow_down',
    },
    {
        component: 'window-msgtype-confirm',
        fa: 'fa fa-check-circle fa-2x fa-fw',
        mat: 'keyboard_arrow_down',
    },
    {
        component: 'horizontal-tree-expanded',
        fa: 'fa fa-caret-right fa-fw',
        mat: 'keyboard_arrow_right',
    },
    {
        component: 'horizontal-tree-collapse',
        fa: 'fa fa-caret-left fa-fw',
        mat: 'keyboard_arrow_left',
    },
    {
        component: 'button-loading-icon',
        fa: 'fa fa-refresh fa-spin',
        mat: 'cached',
    },
    {
        component: 'datepicker-clock-icon',
        fa: 'fa fa-clock-o',
        mat: 'access_time',
    },
    {
        component: 'sidenavnode-icon',
        fa: 'fa fa-user-circle',
        mat: 'person_pin',
    },
    {
        component: 'full-screen-max-icon',
        fa: faExpand,
        mat: '',
    },
    {
        component: 'full-screen-min-icon',
        fa: faCompress,
        mat: '',
    },
];
class IconLoaderService {
    constructor() {
        this.iconMappings = ICON_MAPPING;
    }
    /**
     * @return {?}
     */
    get iconToUse() {
        if (this._iconToUse == null) {
            return 'fa';
        }
        else {
            return this._iconToUse;
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set iconToUse(value) {
        this._iconToUse = value;
    }
    /**
     * @param {?} componentKey
     * @param {?} newValue
     * @return {?}
     */
    modifyIconClass(componentKey, newValue) {
        if (this.iconMappings != null) {
            this.iconMappings.forEach((/**
             * @param {?} icon
             * @return {?}
             */
            (icon) => {
                if (icon.component === componentKey) {
                    icon[this._iconToUse.toString()] = newValue;
                }
            }));
        }
    }
    // TO GET ICON OBJECT
    /**
     * @param {?} componentName
     * @return {?}
     */
    getIconObject(componentName) {
        /** @type {?} */
        let obj = null;
        if (this.iconMappings !== null) {
            this.iconMappings.forEach((/**
             * @param {?} object
             * @return {?}
             */
            (object) => {
                if (object.component === componentName) {
                    obj = object;
                }
            }));
        }
        return obj;
    }
}
IconLoaderService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
IconLoaderService.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by  Pratik on 21/12/17.
*/
class CommonIconComponent {
    /**
     * @param {?} iconLoaderService
     */
    constructor(iconLoaderService) {
        this.iconLoaderService = iconLoaderService;
        /*
        Properties
        name : label
        datatype : string
        version : 5.5.5 onwards
        default : none
        description : sets the key for icon
        */
        this.label = '';
        /*
        Events
        name : onClick
        datatype : any
        version : none
        default : none
        description : Event is fired when button is click
        */
        this.onClick = new EventEmitter();
        this.faiconcolor = '';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.iconClass = this.getIconClass();
    }
    /**
     * @return {?}
     */
    getIconClass() {
        if (this.iconLoaderService.iconMappings != null) {
            /** @type {?} */
            const iconObject = this.iconLoaderService.iconMappings.find((/**
             * @param {?} obj
             * @return {?}
             */
            (obj) => obj.component === this.key));
            if (iconObject != null) {
                return iconObject[this.iconLoaderService.iconToUse.toString()];
            }
            else {
                return '';
            }
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes['key']) {
            this.key = changes.key.currentValue;
            this.iconClass = this.getIconClass();
        }
    }
}
CommonIconComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-c-icon',
                template: `
   <ng-container *ngIf="iconLoaderService.iconToUse == 'fa'">

   <ng-container *ngIf="customclass != null">
     <span [ngStyle]="{'color':color}" class="{{customclass}}" aria-hidden="true"
     (click)="onClick.emit($event)">
     <ng-container *ngIf="label != ''">
     <span class="font-with-label" >
     {{label}}</span>
     </ng-container>
     </span>
   </ng-container>
   <ng-container *ngIf="customclass == null">
     <span [ngStyle]="{'color':color}" class="{{iconClass}}" aria-hidden="true"
     (click)="onClick.emit($event)">
     <ng-container *ngIf="label != ''">
     <span class="font-with-label">
     {{label}}
     </span>
     </ng-container>
     </span>
   </ng-container>

 </ng-container>

 <ng-container *ngIf="iconLoaderService.iconToUse == 'mat'">

   <ng-container *ngIf="customclass != null">
     <i [ngStyle]="{'color':color}" class="material-icons"
     (click)="onClick.emit($event)">{{customclass}}</i>
<ng-container *ngIf="label != ''">
     <span class="font-with-label"> {{label}}</span>
</ng-container>
   </ng-container>

   <ng-container *ngIf="customclass == null">
     <i [ngStyle]="{'color':color}" class="material-icons"
     (click)="onClick.emit($event)">{{iconClass}}</i>
     <ng-container *ngIf="label != ''">
     <span class="font-with-label"> {{label}}</span>
     </ng-container>
   </ng-container>


 </ng-container>
  `,
                styles: [`
  .fa-2x,.fa-3x, .fa-4x, .fa-5x {
    margin-top:0px!important;
  }

  `],
            },] },
];
/** @nocollapse */
CommonIconComponent.ctorParameters = () => [
    { type: IconLoaderService }
];
CommonIconComponent.propDecorators = {
    key: [{ type: Input }],
    label: [{ type: Input }],
    onClick: [{ type: Output }],
    customclass: [{ type: Input }],
    color: [{ type: Input }],
    faiconcolor: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ColorPaletteConstants {
}
ColorPaletteConstants.card = 'amexio-card';
ColorPaletteConstants.cardce = 'amexio-card-ce';
ColorPaletteConstants.navbar = 'amexio-navbar';
ColorPaletteConstants.accordion = 'amexio-accordion';
ColorPaletteConstants.panel = 'amexio-panel';
ColorPaletteConstants.window = 'amexio-window';
ColorPaletteConstants.dialogue = 'amexio-dialogue';
ColorPaletteConstants.grid = 'amexio-grid';
ColorPaletteConstants.box = 'amexio-box';
ColorPaletteConstants.tab = 'amexio-tab';
ColorPaletteConstants.banner = 'amexio-banner';
ColorPaletteConstants.floatingpanel = 'amexio-floating-panel';
ColorPaletteConstants.amexioPrimaryDarkerTheme = 'amexio-primary-darker-color';
ColorPaletteConstants.amexioPrimaryDarkerGradient = 'amexio-primary-darker-color-Gradient';
ColorPaletteConstants.amexioClassicTheme = 'amexio-theme-color1';
ColorPaletteConstants.amexioClassicThemeGradient = 'amexio-theme-color1-Gradient';
ColorPaletteConstants.amexioTheme2 = 'amexio-theme-color2';
ColorPaletteConstants.amexioThemeGradient2 = 'amexio-theme-color2-Gradient';
ColorPaletteConstants.amexioTheme3 = 'amexio-theme-color3';
ColorPaletteConstants.amexioThemeGradient3 = 'amexio-theme-color3-Gradient';
ColorPaletteConstants.amexioTheme4 = 'amexio-theme-color4';
ColorPaletteConstants.amexioThemeGradient4 = 'amexio-theme-color4-Gradient';
ColorPaletteConstants.amexioTheme5 = 'amexio-theme-color5';
ColorPaletteConstants.amexioThemeGradient5 = 'amexio-theme-color5-Gradient';
ColorPaletteConstants.amexioTheme6 = 'amexio-theme-color6';
ColorPaletteConstants.amexioThemeGradient6 = 'amexio-theme-color6-Gradient';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ColorPaletteDirective {
    /**
     * @param {?} _viewContainerRef
     * @param {?} _httpClient
     */
    constructor(_viewContainerRef, _httpClient) {
        this._viewContainerRef = _viewContainerRef;
        this._httpClient = _httpClient;
        this.gradient = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.themejson = [
            {
                themeName: 'amexio-primary-darker-color',
            },
            {
                themeName: 'amexio-theme-color1',
            },
            {
                themeName: 'amexio-theme-color2',
            },
            {
                themeName: 'amexio-theme-color3',
            },
            {
                themeName: 'amexio-theme-color4',
            },
            {
                themeName: 'amexio-theme-color5',
            },
            {
                themeName: 'amexio-theme-color6',
            }
        ];
        this.gradientThemeJson = [
            {
                themeName: 'amexio-primary-darker-color-Gradient',
            },
            {
                themeName: 'amexio-theme-color1-Gradient',
            },
            {
                themeName: 'amexio-theme-color2-Gradient',
            },
            {
                themeName: 'amexio-theme-color3-Gradient',
            },
            {
                themeName: 'amexio-theme-color4-Gradient',
            },
            {
                themeName: 'amexio-theme-color5-Gradient',
            },
            {
                themeName: 'amexio-theme-color6-Gradient',
            },
        ];
        this.hostComponent = this._viewContainerRef['_data'].componentView.component;
        if (this.colorPalette === 'classic' && !this.gradient) {
            this.hostComponent.setColorPalette(ColorPaletteConstants.amexioClassicTheme);
        }
        else if (this.colorPalette === 'classic' && this.gradient) {
            this.hostComponent.setColorPalette(ColorPaletteConstants.amexioClassicThemeGradient);
        }
        if (this.colorPalette !== 'classic' && this.colorPalette !== 'vibrant' && this.colorPalette !== 'random' && !this.gradient) {
            this.hostComponent.setColorPalette(this.colorPalette);
        }
        else if (this.colorPalette !== 'classic' && this.colorPalette !== 'vibrant' && this.colorPalette !== 'random' && this.gradient) {
            this.hostComponent.setColorPalette(this.colorPalette + '-Gradient');
        }
        if (this.colorPalette === 'vibrant') {
            this.vibrantThemeCall();
        }
        if (this.colorPalette === 'random') {
            this.randomThemeCall();
        }
        if ((this.hostComponent.amexioComponentId === ColorPaletteConstants.floatingpanel ||
            this.hostComponent.amexioComponentId === ColorPaletteConstants.accordion ||
            this.hostComponent.amexioComponentId === ColorPaletteConstants.panel) && this.gradient) {
            this.hostComponent.changeHeaderColor();
        }
    }
    /**
     * @param {?} hostComponent
     * @return {?}
     */
    getBGColorStyles(hostComponent) {
        switch (hostComponent.amexioComponentId) {
            case (ColorPaletteConstants.card || ColorPaletteConstants.cardce): {
                hostComponent.setColorPalette(ColorPaletteConstants.amexioTheme4);
                break;
            }
            case (ColorPaletteConstants.banner): {
                hostComponent.setColorPalette(ColorPaletteConstants.amexioPrimaryDarkerTheme);
                break;
            }
            case (ColorPaletteConstants.navbar): {
                hostComponent.setColorPalette(ColorPaletteConstants.amexioClassicTheme);
                break;
            }
            case (ColorPaletteConstants.accordion): {
                hostComponent.setColorPalette(ColorPaletteConstants.amexioTheme3);
                break;
            }
            case (ColorPaletteConstants.panel): {
                hostComponent.setColorPalette(ColorPaletteConstants.amexioTheme2);
                break;
            }
            case (ColorPaletteConstants.floatingpanel): {
                hostComponent.setColorPalette(ColorPaletteConstants.amexioTheme2);
                break;
            }
            case (ColorPaletteConstants.window): {
                hostComponent.setColorPalette(ColorPaletteConstants.amexioTheme6);
                break;
            }
            case (ColorPaletteConstants.dialogue): {
                hostComponent.setColorPalette(ColorPaletteConstants.amexioTheme6);
                break;
            }
            case (ColorPaletteConstants.box): {
                hostComponent.setColorPalette(ColorPaletteConstants.amexioTheme6);
                break;
            }
            case (ColorPaletteConstants.grid): {
                hostComponent.setColorPalette(ColorPaletteConstants.amexioTheme5);
                break;
            }
            case (ColorPaletteConstants.tab): {
                hostComponent.setColorPalette(ColorPaletteConstants.amexioTheme3);
                break;
            }
        }
    }
    /**
     * @param {?} hostComponent
     * @return {?}
     */
    getGradientStyles(hostComponent) {
        switch (hostComponent.amexioComponentId) {
            case (ColorPaletteConstants.card || ColorPaletteConstants.cardce): {
                hostComponent.setColorPalette(ColorPaletteConstants.amexioThemeGradient4);
                break;
            }
            case (ColorPaletteConstants.banner): {
                hostComponent.setColorPalette(ColorPaletteConstants.amexioPrimaryDarkerGradient);
                break;
            }
            case (ColorPaletteConstants.navbar): {
                hostComponent.setColorPalette(ColorPaletteConstants.amexioClassicThemeGradient);
                break;
            }
            case (ColorPaletteConstants.accordion): {
                hostComponent.setColorPalette(ColorPaletteConstants.amexioThemeGradient3);
                break;
            }
            case (ColorPaletteConstants.panel): {
                hostComponent.setColorPalette(ColorPaletteConstants.amexioThemeGradient2);
                break;
            }
            case (ColorPaletteConstants.floatingpanel): {
                hostComponent.setColorPalette(ColorPaletteConstants.amexioThemeGradient2);
                break;
            }
            case (ColorPaletteConstants.window): {
                hostComponent.setColorPalette(ColorPaletteConstants.amexioThemeGradient6);
                break;
            }
            case (ColorPaletteConstants.dialogue): {
                hostComponent.setColorPalette(ColorPaletteConstants.amexioThemeGradient6);
                break;
            }
            case (ColorPaletteConstants.box): {
                hostComponent.setColorPalette(ColorPaletteConstants.amexioThemeGradient6);
                break;
            }
            case (ColorPaletteConstants.grid): {
                hostComponent.setColorPalette(ColorPaletteConstants.amexioThemeGradient5);
                break;
            }
            case (ColorPaletteConstants.tab): {
                hostComponent.setColorPalette(ColorPaletteConstants.amexioThemeGradient3);
                break;
            }
        }
    }
    /**
     * @return {?}
     */
    randomFloat() {
        /** @type {?} */
        const int = window.crypto.getRandomValues(new Uint32Array(1))[0];
        return int / Math.pow(2, 32);
    }
    /**
     * @param {?} min
     * @param {?} max
     * @return {?}
     */
    randomInt(min, max) {
        /** @type {?} */
        const range = max - min;
        return Math.floor(this.randomFloat() * range + min);
    }
    /**
     * @param {?} length
     * @param {?} min
     * @param {?} max
     * @return {?}
     */
    getRandomNumber(length, min, max) {
        /** @type {?} */
        const arr = (new Array(length).fill(0).map((/**
         * @return {?}
         */
        () => this.randomInt(min, max))));
        return arr[0];
    }
    /**
     * @return {?}
     */
    randomThemeCall() {
        if (!this.gradient) {
            /** @type {?} */
            const randomIndex = this.getRandomNumber(1, 0, this.themejson.length);
            this.hostComponent.setColorPalette(this.themejson[randomIndex].themeName);
        }
        else {
            /** @type {?} */
            const randomIndex = this.getRandomNumber(1, 0, this.gradientThemeJson.length);
            this.hostComponent.setColorPalette(this.gradientThemeJson[randomIndex].themeName);
        }
    }
    /**
     * @return {?}
     */
    vibrantThemeCall() {
        if (!this.gradient) {
            setTimeout((/**
             * @return {?}
             */
            () => {
                this.getBGColorStyles(this.hostComponent);
            }), 1000);
        }
        else if (this.gradient) {
            setTimeout((/**
             * @return {?}
             */
            () => {
                this.getGradientStyles(this.hostComponent);
            }), 1000);
        }
    }
}
ColorPaletteDirective.decorators = [
    { type: Directive, args: [{
                selector: '[amexioColorPalette]',
            },] },
];
/** @nocollapse */
ColorPaletteDirective.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: HttpClient }
];
ColorPaletteDirective.propDecorators = {
    colorPalette: [{ type: Input, args: ['color-palette',] }],
    themeColor: [{ type: Input, args: ['amexio-color',] }],
    gradient: [{ type: Input, args: ['gradient',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const COMMON_COMPONENTS = [
    DisplayFieldComponent,
    DropDownListComponent,
    FilterPipe,
    CommonIconComponent,
    ColorPaletteDirective,
];
class AmexioCommonModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: AmexioCommonModule,
            providers: [IconLoaderService, DisplayFieldService],
        };
    }
}
AmexioCommonModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    FormsModule,
                    HttpClientModule,
                ],
                exports: COMMON_COMPONENTS,
                declarations: COMMON_COMPONENTS,
                providers: [],
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const defaultclass = class {
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AmexioRuntimeComponent {
    /**
     * @param {?} _compiler
     * @param {?} _injector
     * @param {?} _m
     */
    constructor(_compiler, _injector, _m) {
        this._compiler = _compiler;
        this._injector = _injector;
        this._m = _m;
        this.oninit = new EventEmitter();
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set htmltemplate(v) {
        if (v != null && v.length > 0) {
            this._htmlTemplate = v;
            this.render();
        }
    }
    /**
     * @return {?}
     */
    get htmltemplate() {
        return this._htmlTemplate;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set tsclass(v) {
        if (v != null) {
            this._tsclass = v;
            this.render();
        }
    }
    /**
     * @return {?}
     */
    get tsclass() {
        return this._tsclass;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @return {?}
     */
    render() {
        if (!this.htmltemplate || this.htmltemplate.length === 0) {
            return;
        }
        if (!this.tsclass) {
            this.tsclass = defaultclass;
        }
        /** @type {?} */
        const tmpCmp = Component({ template: this.htmltemplate })(this.tsclass);
        /** @type {?} */
        const tmpModule = NgModule({
            providers: [HttpClientModule], imports: [FormsModule, AmexioWidgetModule, HttpClientModule],
            declarations: [tmpCmp],
            entryComponents: [tmpCmp],
        })(defaultclass);
        this._compiler.compileModuleAsync(tmpModule)
            .then((/**
         * @param {?} moduleFactory
         * @return {?}
         */
        (moduleFactory) => {
            /** @type {?} */
            const resolver = moduleFactory.create(this._injector).componentFactoryResolver;
            /** @type {?} */
            const f = resolver.resolveComponentFactory(tmpCmp);
            /** @type {?} */
            const cmpRef = f.create(this._injector, [], null, this._m);
            this._container.insert(cmpRef.hostView);
            /** @type {?} */
            const object = { reference: cmpRef, instance: cmpRef.instance };
            this.oninit.emit(object);
        }));
    }
}
AmexioRuntimeComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-runtime',
                template: '<div #vc></div>',
            },] },
];
/** @nocollapse */
AmexioRuntimeComponent.ctorParameters = () => [
    { type: Compiler },
    { type: Injector },
    { type: NgModuleRef }
];
AmexioRuntimeComponent.propDecorators = {
    _container: [{ type: ViewChild, args: ['vc', { read: ViewContainerRef },] }],
    htmltemplate: [{ type: Input, args: ['html-template',] }],
    tsclass: [{ type: Input, args: ['ts-class',] }],
    oninit: [{ type: Output, args: ['onInit',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by pratik on 21/12/17
*/
class CommonDataService {
    /**
     * @param {?} _http
     */
    constructor(_http) {
        this._http = _http;
        this.filteredObject = [];
        this.zindex = 600;
    }
    /**
     * @param {?} serviceUrl
     * @param {?} methodType
     * @return {?}
     */
    fetchData(serviceUrl, methodType) {
        /** @type {?} */
        const requestJson = {};
        /** @type {?} */
        const headers = new HttpHeaders().append('Content-Type', 'application/json;charset=UTF-8');
        if (methodType === 'post') {
            return this._http.post(serviceUrl, requestJson, { headers });
        }
        else if (methodType === 'get') {
            return this._http.get(serviceUrl, { headers });
        }
    }
    /**
     * @param {?} serviceUrl
     * @param {?} methodType
     * @param {?} requestData
     * @return {?}
     */
    uploadFile(serviceUrl, methodType, requestData) {
        /** @type {?} */
        const requestJson = requestData;
        /** @type {?} */
        const headers = new HttpHeaders().append('Access-Control-Allow-Origin', '*');
        if (methodType.toUpperCase() === 'POST') {
            return this._http.post(serviceUrl, requestJson, { headers });
        }
    }
}
CommonDataService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
CommonDataService.ctorParameters = () => [
    { type: HttpClient }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Created by Ketan Gote on 22/02/2019
 */
/** @type {?} */
const FORM_COMPONENTS = [
    AmexioRuntimeComponent,
];
class AmexioRuntimeModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: AmexioRuntimeModule,
            providers: [],
        };
    }
}
AmexioRuntimeModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    FormsModule,
                    HttpClientModule,
                    AmexioCommonModule.forRoot(),
                ],
                exports: FORM_COMPONENTS,
                declarations: FORM_COMPONENTS,
                providers: [],
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
class AmexioContextMenuComponent {
    /**
     * @param {?} renderer
     */
    constructor(renderer) {
        this.renderer = renderer;
        this.onRightClick = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() { }
    /**
     * @return {?}
     */
    ngOnChanges() {
        this.isflagshow = true;
        this.contextStyle = this.getContextMenuStyle();
    }
    /**
     * @return {?}
     */
    getContextMenuStyle() {
        return {
            'cursor': 'default',
            'position': 'fixed',
            'display': this.isflagshow ? 'block' : 'none',
            'left': this.mouseLocationLeft + 'px',
            'top': this.mouseLocationTop + 'px',
            'box-shadow': '1px 1px 2px #000000',
            'width': '15%',
        };
    }
    /**
     * @param {?} itemConfig
     * @return {?}
     */
    onContextNodeClick(itemConfig) {
        if (!itemConfig.disabled) {
            /** @type {?} */
            const obj = {
                menuData: itemConfig,
                nodeData: this.rightClickData,
            };
            this.isflagshow = false;
            this.onRightClick.emit(obj);
        }
    }
}
AmexioContextMenuComponent.decorators = [
    { type: Component, args: [{
                selector: 'base-contextmenu',
                template: `
    <span [ngStyle]="contextStyle"> 
        <ul class="context-menu-list" [ngClass]="{'dropdown-up' : posixUp}">
            <li (click)="onContextNodeClick(itemConfig)" class="context-menu-list-items"
             [ngStyle]="{'cursor': itemConfig.disabled ? 'not-allowed':'pointer'}"
                [ngClass]="{'context-menu-separator':itemConfig.seperator}" *ngFor="let itemConfig of contextmenu">
                <em [ngStyle]="{'padding-left': itemConfig.icon ? '5px':'19px'}" [ngClass]="itemConfig.icon"></em>
                <span style="white-space: nowrap;display: inline ; padding-left:5px">{{itemConfig.text}}
                </span>
            </li>
        </ul>
    </span>
  `,
                styles: [`
    .context-menu-list{display:block;position:absolute;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;min-width:180px;cursor:pointer;max-height:150px;z-index:1;padding:10px 0;overflow-y:auto;-webkit-box-shadow:0 5px 5px -3px rgba(0,0,0,.2),0 8px 10px 1px rgba(0,0,0,.14),0 3px 14px 2px rgba(0,0,0,.12);box-shadow:0 5px 5px -3px rgba(0,0,0,.2),0 8px 10px 1px rgba(0,0,0,.14),0 3px 14px 2px rgba(0,0,0,.12)}
  `],
            },] },
];
/** @nocollapse */
AmexioContextMenuComponent.ctorParameters = () => [
    { type: Renderer2 }
];
AmexioContextMenuComponent.propDecorators = {
    isflagshow: [{ type: Input, args: ['is-FlagShow',] }],
    contextmenu: [{ type: Input, args: ['base-context-menu',] }],
    posixUp: [{ type: Input, args: ['position-up',] }],
    onRightClick: [{ type: Output }],
    rightClickData: [{ type: Input, args: ['right-click-data',] }],
    mouseLocationLeft: [{ type: Input, args: ['mouse-location-left',] }],
    mouseLocationTop: [{ type: Input, args: ['mouse-location-top',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const CONTEXTMENU_COMPONENTS = [
    AmexioContextMenuComponent,
];
class AmexioBaseContextMenuModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: AmexioBaseContextMenuModule,
            providers: [CommonDataService, IconLoaderService],
        };
    }
}
AmexioBaseContextMenuModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    FormsModule,
                    HttpClientModule,
                ],
                exports: CONTEXTMENU_COMPONENTS,
                declarations: CONTEXTMENU_COMPONENTS,
                providers: [CommonDataService, IconLoaderService],
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/
class DeviceQueryService {
    /**
     * @param {?} platformId
     */
    constructor(platformId) {
        this.platformId = platformId;
        this.rules = {
            print: 'print',
            screen: 'screen',
            phone: '(max-width: 767px)',
            tablet: '(min-width: 768px) and (max-width: 1024px)',
            desktop: '(min-width: 1025px)',
            portrait: '(orientation: portrait)',
            landscape: '(orientation: landscape)',
            retina: '(-webkit-min-device-pixel-ratio: 2) and (min-resolution: 192dpi)',
        };
        this.Check = (/**
         * @param {?} mq
         * @return {?}
         */
        function (mq) {
            if (isPlatformBrowser(this.platformId)) {
                if (!mq) {
                    return;
                }
                return window.matchMedia(mq).matches;
            }
            else {
                return;
            }
        });
        this.IsTablet = (/**
         * @return {?}
         */
        function () {
            if (isPlatformBrowser(this.platformId)) {
                return window.matchMedia(this.rules.tablet).matches;
            }
            else {
                return null;
            }
        });
        this.IsDesktop = (/**
         * @return {?}
         */
        function () {
            if (isPlatformBrowser(this.platformId)) {
                return window.matchMedia(this.rules.desktop).matches;
            }
            else {
                return null;
            }
        });
        this.IsPortrait = (/**
         * @return {?}
         */
        function () {
            if (isPlatformBrowser(this.platformId)) {
                return window.matchMedia(this.rules.portrait).matches;
            }
            else {
                return null;
            }
        });
        this.IsLandscape = (/**
         * @return {?}
         */
        function () {
            if (isPlatformBrowser(this.platformId)) {
                return window.matchMedia(this.rules.landscape).matches;
            }
            else {
                return null;
            }
        });
        this.IsRetina = (/**
         * @return {?}
         */
        function () {
            if (isPlatformBrowser(this.platformId)) {
                return window.matchMedia(this.rules.retina).matches;
            }
            else {
                return null;
            }
        });
        this.browserWindow = (/**
         * @return {?}
         */
        () => {
            return window;
        });
    }
    /**
     * *******************************************
     * METHODS FOR CHECKING TYPE
     * ********************************************
     * @return {?}
     */
    IsPhone() {
        if (isPlatformBrowser(this.platformId)) {
            return window.matchMedia(this.rules.phone).matches;
        }
        else {
            return null;
        }
    }
    /**
     * *******************************************
     * EVENT LISTENERS BY TYPE
     * ********************************************
     * @param {?} callBack
     * @return {?}
     */
    OnPhone(callBack) {
        if (typeof callBack === 'function' && isPlatformBrowser(this.platformId)) {
            /** @type {?} */
            const mql = window.matchMedia(this.rules.phone);
            this.mqlMethod(callBack, mql);
        }
    }
    /**
     * @param {?} callBack
     * @return {?}
     */
    OnTablet(callBack) {
        if (typeof callBack === 'function' && isPlatformBrowser(this.platformId)) {
            /** @type {?} */
            const mql = window.matchMedia(this.rules.tablet);
            this.mqlMethod(callBack, mql);
        }
    }
    /**
     * @param {?} callBack
     * @return {?}
     */
    OnDesktop(callBack) {
        if (typeof callBack === 'function' && isPlatformBrowser(this.platformId)) {
            /** @type {?} */
            const mql = window.matchMedia(this.rules.desktop);
            this.mqlMethod(callBack, mql);
        }
    }
    /**
     * @param {?} callBack
     * @return {?}
     */
    OnPortrait(callBack) {
        if (typeof callBack === 'function' && isPlatformBrowser(this.platformId)) {
            /** @type {?} */
            const mql = window.matchMedia(this.rules.portrait);
            this.mqlMethod(callBack, mql);
        }
    }
    /**
     * @param {?} callBack
     * @return {?}
     */
    OnLandscape(callBack) {
        if (typeof callBack === 'function' && isPlatformBrowser(this.platformId)) {
            /** @type {?} */
            const mql = window.matchMedia(this.rules.landscape);
            this.mqlMethod(callBack, mql);
        }
    }
    /**
     * @param {?} callBack
     * @param {?} mql
     * @return {?}
     */
    mqlMethod(callBack, mql) {
        mql.addListener((/**
         * @param {?} mql1
         * @return {?}
         */
        (mql1) => {
            if (mql1.matches) {
                callBack(mql);
            }
        }));
    }
}
DeviceQueryService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
DeviceQueryService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Created by dattaram on 28/5/19.
 */
class AmexioBannerComponent {
    /**
     * @param {?} document
     * @param {?} renderer
     * @param {?} el
     * @param {?} matchMediaService
     */
    constructor(document, renderer, el, matchMediaService) {
        this.document = document;
        this.renderer = renderer;
        this.el = el;
        this.matchMediaService = matchMediaService;
        this.closeable = false;
        this.showBanner = true;
        this.interval = 0;
        this.title = '';
        this.icon = '';
        this.hideBanner = new EventEmitter();
        this.alignment = 'center';
        this.closeOnScroll = false;
        this.amexioComponentId = 'amexio-banner';
        this.callWindowScroll();
    }
    /**
     * @return {?}
     */
    onWindowScroll() {
        if (this.closeOnScroll) {
            /** @type {?} */
            const h = document.documentElement;
            /** @type {?} */
            const b = document.body;
            /** @type {?} */
            const st = 'scrollTop';
            /** @type {?} */
            const sh = 'scrollHeight';
            /** @type {?} */
            const percent = (h[st] || b[st]) / ((h[sh] || b[sh]) - h.clientHeight) * 100;
            if (percent > 15) {
                this.onCloseCommon();
            }
            else {
                this.onShowClick();
            }
        }
    }
    /**
     * @return {?}
     */
    callWindowScroll() {
        /** @type {?} */
        const clicks = fromEvent(window, 'scroll');
        clicks.subscribe((/**
         * @param {?} x
         * @return {?}
         */
        (x) => this.onWindowScroll()));
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.interval !== 0) {
            setTimeout((/**
             * @return {?}
             */
            () => {
                this.hideBanner.emit(false);
                this.showBanner = false;
            }), this.interval);
        }
        if (this.alignment === 'end') {
            this.alignment = 'flex-end';
        }
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.responsiveMethod();
    }
    /**
     * @return {?}
     */
    onCloseCommon() {
        this.hideBanner.emit(false);
        this.showBanner = false;
    }
    /**
     * @return {?}
     */
    onCloseClick() {
        this.hideBanner.emit(false);
        this.showBanner = false;
        this.closeOnScroll = false;
    }
    /**
     * @param {?} themeClass
     * @return {?}
     */
    setColorPalette(themeClass) {
        this.renderer.addClass(this.el.nativeElement, themeClass);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    resize(event) {
        this.responsiveMethod();
    }
    /**
     * @return {?}
     */
    responsiveMethod() {
        if (this.matchMediaService.IsPhone() || this.matchMediaService.IsTablet()) {
            this.mobileMode = true;
        }
        else {
            this.mobileMode = false;
        }
    }
    /**
     * @return {?}
     */
    onShowClick() {
        this.hideBanner.emit(true);
        this.showBanner = true;
    }
}
AmexioBannerComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-banner',
                template: `
    <ng-container *ngIf="showBanner">

        <span class="bannerContent" [style.justify-content]="alignment" [ngStyle]="{'flex-direction': mobileMode ? 'column': 'unset'}" (window:resize)="resize($event)">
            <amexio-image style="padding-left: 10px;" [icon-class]="icon"></amexio-image>
            <amexio-label [word-wrap] = "false" style="padding-left: 10px;">{{title}}</amexio-label>
        </span>
        <amexio-c-icon style="padding-bottom: 4px" *ngIf="closeable" [key]="'window_close'" (onClick)="onCloseClick()">
        </amexio-c-icon>
    </ng-container>
  `,
                styles: [
                    `
      :host{
        display: inline-flex;
        justify-content: space-between;
        width: 100%;
        align-items: center;
      }

      amexio-c-icon {
        margin: 0 10px;
        cursor: pointer;
      }

      .bannerContent {
        flex-grow: 1;
        display: inline-flex;
        width: 100px;
      }

    `,
                ],
            },] },
];
/** @nocollapse */
AmexioBannerComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: Renderer2 },
    { type: ElementRef },
    { type: DeviceQueryService }
];
AmexioBannerComponent.propDecorators = {
    closeable: [{ type: Input, args: ['closable',] }],
    interval: [{ type: Input }],
    title: [{ type: Input }],
    icon: [{ type: Input }],
    hideBanner: [{ type: Output }],
    alignment: [{ type: Input }],
    closeOnScroll: [{ type: Input, args: ['close-on-scroll',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the 'License');
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an 'AS IS' BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by ketangote on 1/4/18.
*/
class AmexioNavMenuComponent {
    constructor() {
        /*
           Events
           name : navLinkClick
           datatype : any
           version : none
           default : none
           description : Fire when nav item is clicked, This event is fired when nav item type is defined as 'link/button/menu'
           */
        this.navLinkClick = new EventEmitter();
        this.onNavItemClick = new EventEmitter();
        this.subMenuPadding = '10px';
        this.mobilemode = false;
        this.issubmenu = false;
        this.position = 'right';
        this.ishovered = true;
        // for internal use
        this.submenupos = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        setTimeout((/**
         * @return {?}
         */
        () => {
            if ((window.innerWidth - this.navmenu.nativeElement.getBoundingClientRect().right) < 150) {
                this.position = 'right';
            }
            else {
                this.position = 'left';
            }
        }), 100);
    }
    /**
     * @param {?} flag
     * @return {?}
     */
    setMobileMode(flag) {
        this.mobilemode = flag;
    }
    /**
     * @param {?} n
     * @param {?} _event
     * @return {?}
     */
    dataObject(n, _event) {
        return { data: n, event: _event };
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onHeaderClick(event) {
        /** @type {?} */
        const node = {
            header: true,
            title: this.title,
            icon: this.icon,
        };
        this.mobileToggleModel = !this.mobileToggleModel;
        if (this.mobilemode) {
            this.showMenus = !this.showMenus;
        }
        this.onClick(node, event);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onMouseOver(event) {
        if (this.mobilemode) {
            return;
        }
        this.showMenus = true;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onMouseLeave(event) {
        if (this.mobilemode) {
            return;
        }
        this.showMenus = false;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    toggleMenu(event) {
        if (this.mobilemode) {
            this.showMenus = !this.showMenus;
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    getMenuPosition(event) {
        /** @type {?} */
        const remainingleft = event.currentTarget.getBoundingClientRect().left;
        /** @type {?} */
        const remainingright = window.screen.width - event.currentTarget.getBoundingClientRect().right;
        /** @type {?} */
        let directionflag;
        if (remainingright > remainingleft) {
            directionflag = 'right';
        }
        else {
            directionflag = 'left';
        }
        return directionflag;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onMouseoverTitle(event) {
        this.position = this.getMenuPosition(event);
    }
    /**
     * @param {?} _node
     * @param {?} _event
     * @return {?}
     */
    onClick(_node, _event) {
        /** @type {?} */
        const n = {
            title: this.title,
            data: this.data,
            icon: this.icon,
            node: _node,
            mobileToggleModel: this.mobileToggleModel,
            mobilemode: this.mobilemode,
        };
        this.onNavItemClick.emit(this.dataObject(n, _event));
        this.onIconClick(_event, _node);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    navItemClick(event) {
        event.event.stopPropagation();
        this.onNavItemClick.emit(event);
    }
    /**
     * @param {?} event
     * @param {?} node
     * @return {?}
     */
    onIconClick(event, node) {
        event.stopPropagation();
        if (node.hasOwnProperty('isExpanded')) {
            node.isExpanded = !node.isExpanded;
        }
        else {
            node['isExpanded'] = true;
        }
    }
}
AmexioNavMenuComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-nav-menu',
                template: `
    <div #navmenu class="nav-dropdown" (mouseover)="onMouseOver($event)" (mouseleave)="onMouseLeave($event)" >
      <a class="nav-dropbtn" style="white-space: nowrap" [ngStyle]="{'color':color}" 
        (click)="onHeaderClick($event)">
        <span [style.padding-left.px]="icon ? 0 : 10">
          <em *ngIf="icon" [ngClass]="icon"></em>
        </span>
        <span>{{title}}</span>
        <span>
          <em *ngIf="!mobilemode" class="dropdownicon fa fa-angle-down"></em>
          <em *ngIf="mobilemode && showMenus" class="dropdownicon fa fa-angle-up"></em>
          <em *ngIf="mobilemode && !showMenus" class="dropdownicon fa fa-angle-down"></em>
        </span>
      </a>
      <div *ngIf="(type==='menucontainer' && showMenus) "
        class="dropdownData">
        <ng-content></ng-content>
      </div>
      <amexio-nav-desktop  *ngIf=" (type !='menucontainer') && showMenus && !mobilemode" (onNavItemClick)="navItemClick($event)"  class="amexio-nav-desktop amexio-nav-submenus amexio-nav-desktop-submenus"  [nodes]="data" [ngStyle]="{'right': (position === 'right') ? '10px':null}"></amexio-nav-desktop>

      <amexio-nav-mobile  *ngIf=" (type !='menucontainer') && showMenus && mobilemode"  (onNavItemClick)="navItemClick($event)"   class="amexio-nav-mobile amexio-nav-submenus amexio-nav-mobile-submenus"  [nodes]="data"></amexio-nav-mobile>
  
    </div>
  `,
            },] },
];
/** @nocollapse */
AmexioNavMenuComponent.ctorParameters = () => [];
AmexioNavMenuComponent.propDecorators = {
    type: [{ type: Input }],
    title: [{ type: Input }],
    data: [{ type: Input }],
    icon: [{ type: Input }],
    navLinkClick: [{ type: Output }],
    onNavItemClick: [{ type: Output }],
    subMenuPadding: [{ type: Input, args: ['sub-menu-height-padding',] }],
    mobilemode: [{ type: Input }],
    rightflag: [{ type: Input }],
    color: [{ type: Input, args: ['color',] }],
    submenupos: [{ type: Input, args: ['submenupos',] }],
    navmenu: [{ type: ViewChild, args: ['navmenu', { read: ElementRef },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by ketangote on 1/4/18.
*/
/** @type {?} */
const noop$1 = (/**
 * @return {?}
 */
() => {
});
class AmexioNavItemComponent {
    /**
     * @param {?} elementref
     */
    constructor(elementref) {
        this.elementref = elementref;
        /*
          Events
          name : onNavItemClick
          datatype : any
          version : none
          default : none
          description : Fire when nav item is clicked, This event is fired when nav item type is defined as 'link/button/menu'
          */
        this.onNavItemClick = new EventEmitter();
        this.mobilemode = false;
        this.subMenuPadding = '10px';
        // For Internal Use
        this.submenupos = false;
        this.isAction = false;
        this.isTextField = false;
        this.isMenu = false;
        this.isMenuContainer = false;
        this.innerValue = '';
        this.onTouchedCallback = noop$1;
        this.onChangeCallback = noop$1;
        this.componentId = '';
        this.offsetWidth = 0;
        this.componentId = Math.floor(window.crypto.getRandomValues(new Uint32Array(1))[0]) + '_navctyt';
        this.offsetWidth = this.elementref.nativeElement.offsetWidth;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.type === 'link' || this.type === 'button' || this.type === 'toggle' || this.type === 'slider') {
            this.isAction = true;
        }
        else if (this.type === 'textfield') {
            this.isTextField = true;
        }
        else if (this.type === 'menu') {
            this.isMenu = true;
        }
        else if (this.type === 'menucontainer') {
            this.isMenuContainer = true;
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        setTimeout((/**
         * @return {?}
         */
        () => {
            this.right = this.elementref.nativeElement.getBoundingClientRect().right;
        }), 100);
    }
    /**
     * @param {?} node
     * @return {?}
     */
    setSubmenuIcon(node) {
        if (node.submenus && (node.submenus.length > 0)) {
            node.submenus['iconposition'] = 'left';
            this.setSubmenuIcon(node.submenus);
        }
    }
    /**
     * @param {?} node
     * @return {?}
     */
    setHoverattr(node) {
        node['ishover'] = false;
        if (node.submenus && (node.submenus.length > 0)) {
            this.setHoverattr(node.submenus);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    navItemClick(event) {
        this.onNavItemClick.emit(event);
    }
    /**
     * @param {?} flag
     * @return {?}
     */
    setMobileMode(flag) {
        this.mobilemode = flag;
    }
    /**
     * @param {?} navbarwidth
     * @return {?}
     */
    setNavbarWidth(navbarwidth) {
        setTimeout((/**
         * @return {?}
         */
        () => {
            this.navbarwidth = navbarwidth;
            if ((this.navbarwidth - this.elementref.nativeElement.getBoundingClientRect().left) < 165) {
                this.enablerightclass = true;
            }
        }), 0);
    }
    //  MODEL BINDING FOR TEXT FIELD
    // The internal dataviews model
    // Placeholders for the callbacks which are later provided
    // by the Control Value Accessor
    // get accessor
    /**
     * @return {?}
     */
    get value() {
        return this.innerValue;
    }
    // set accessor including call the onchange callback
    /**
     * @param {?} v
     * @return {?}
     */
    set value(v) {
        if (v !== this.innerValue) {
            this.innerValue = v;
            this.onChangeCallback(v);
        }
    }
    // From ControlValueAccessor interface
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (value !== this.innerValue) {
            this.innerValue = value;
        }
    }
    // From ControlValueAccessor interface
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChangeCallback = fn;
    }
    // From ControlValueAccessor interface
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouchedCallback = fn;
    }
    /**
     * @return {?}
     */
    hoverfun() {
        this.data.forEach((/**
         * @param {?} node
         * @return {?}
         */
        (node) => {
            this.ResetHoverattr(node);
        }));
    }
    /**
     * @param {?} node
     * @return {?}
     */
    ResetHoverattr(node) {
        node.ishover = false;
        if (node.submenus && (node.submenus.length > 0)) {
            node.submenus.forEach((/**
             * @param {?} element
             * @return {?}
             */
            (element) => {
                this.ResetHoverattr(node.submenus);
            }));
        }
    }
}
AmexioNavItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-nav-item',
                template: `
    <div [attr.id]="componentId" class="topnavmainbarinneritems" [ngClass]="{'topnavmainbarinneritems-mobile':mobilemode,
     'nav-dropdown-content-right':enablerightclass}">
        <amexio-nav-action *ngIf="isAction" [color]="itemcolor" [type]="type" [title]="title" [icon]="icon" (navLinkClick)="navItemClick($event)"></amexio-nav-action>
        <amexio-nav-textfield *ngIf="isTextField" [color]="itemcolor" [(ngModel)]="value" [title]="title"></amexio-nav-textfield>
        <amexio-nav-menu *ngIf="isMenu" [submenupos]="submenupos" [sub-menu-height-padding]="subMenuPadding" [mobilemode]="mobilemode" [color]="itemcolor" [title]="title" [icon]="icon" [data]="data" (onNavItemClick)="navItemClick($event)">
        </amexio-nav-menu>
        <amexio-nav-menu *ngIf="isMenuContainer" [sub-menu-height-padding]="subMenuPadding" [mobilemode]="mobilemode" [color]="itemcolor" [title]="title" [icon]="icon" [type]="type" (navLinkClick)="navItemClick($event)">
            <ng-content></ng-content>
        </amexio-nav-menu>
    </div>
  `,
                providers: [{
                        provide: NG_VALUE_ACCESSOR, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => AmexioNavItemComponent)), multi: true,
                    }],
                encapsulation: ViewEncapsulation.None,
            },] },
];
/** @nocollapse */
AmexioNavItemComponent.ctorParameters = () => [
    { type: ElementRef }
];
AmexioNavItemComponent.propDecorators = {
    type: [{ type: Input }],
    title: [{ type: Input }],
    icon: [{ type: Input }],
    data: [{ type: Input }],
    onNavItemClick: [{ type: Output }],
    navmenus: [{ type: ContentChildren, args: [AmexioNavMenuComponent,] }],
    mobilemode: [{ type: Input }],
    subMenuPadding: [{ type: Input, args: ['sub-menu-height-padding',] }],
    submenupos: [{ type: Input, args: ['submenupos',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*  Created by ketangote on 12/8/17.
*/
class AmexioNavBarComponent {
    /**
     * @param {?} matchMediaService
     */
    constructor(matchMediaService) {
        this.matchMediaService = matchMediaService;
        /*
           Properties
           name : logo
           datatype : string
           version : 4.0 onwards
           default : none
           description : Logo of navbar.
           */
        this.logo = '';
        /*
           Properties
           name : enable-side-nav-position
           datatype : boolean
           version : 4.0 onwards
           default : none
           description : Indicate if side-nav-bar is present
           */
        this.sidenav = false;
        /*
           Properties
           name : enable-side-nav-position
           datatype : boolean
           version : 4.0 onwards
           default : none
           description : transparent nav bar
           */
        this.transparent = false;
        this.enableMoreMode = false;
        this.amexioComponentId = 'amexio-navbar';
        this.onNavLogoClick = new EventEmitter();
        this.onNavTitleClick = new EventEmitter();
        this.onIconArrowClick = new EventEmitter();
        this.onIconClick = new EventEmitter();
        this.navSubmenuClick = new EventEmitter();
        this.onNavLoad = new EventEmitter();
        this.toggle = true;
        this.mobilemode = false;
        this.isIconLeft = true;
        this.isLHSHide = false;
        this.lhsWidth = '5%';
        this.isExpand = false;
        this.isPhone = false;
        this.navItemPresent = false;
        this.moreBucket = [];
        this.resizeItemCollection = [];
        this.isItemRemoved = false;
        this.morePadding = 0;
        this.moreCheckWidth = 0;
        this.showBanner = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (!this.logo) {
            this.loadNavItems();
        }
        this.navOnLoad();
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (this.bannerItem) {
            /** @type {?} */
            const bItem = this.bannerItem.toArray();
            if (bItem.length > 0) {
                this.showBanner = true;
                bItem[0].hideBanner.subscribe((/**
                 * @param {?} flag
                 * @return {?}
                 */
                (flag) => {
                    this.showBanner = flag;
                    this.resizeAfterBannerClose();
                    this.navOnLoad();
                }));
            }
        }
        this.navItemComponents = this.navitems.toArray();
        if (this.navItemComponents && this.navItemComponents.length > 0) {
            this.navItemPresent = true;
            this.navItemComponents.forEach((/**
             * @param {?} element
             * @return {?}
             */
            (element) => {
                element.itemcolor = this.color;
            }));
        }
    }
    /**
     * @return {?}
     */
    onImageLoad() {
        this.loadNavItems();
    }
    /**
     * @return {?}
     */
    loadNavItems() {
        this.handleNavItems();
        if (this.navbaritems2.nativeElement) {
            this.navitemwidth = (5 +
                (this.navbaritems2.nativeElement.offsetWidth) +
                (this.navbaritems2.nativeElement.offsetWidth) +
                (this.navbaritems3.nativeElement.offsetWidth));
        }
        if (this.navbarfixed && this.navbarfixed.nativeElement) {
            this.moreCheckWidth = this.moreCheckWidth + this.navbarfixed.nativeElement.offsetWidth;
        }
        if (this.navbaritems1 && this.navbaritems1.nativeElement) {
            this.moreCheckWidth = this.moreCheckWidth + this.navbarfixed.nativeElement.offsetWidth;
        }
        if (this.navbaritems2 && this.navbaritems2.nativeElement) {
            this.moreCheckWidth = this.moreCheckWidth + this.navbarfixed.nativeElement.offsetWidth;
        }
        if (!this.enableMoreMode) {
            this.handleDeviceSetting();
        }
        else {
            this.checkMobileMode();
            this.createMoreContent();
        }
        this.navOnLoad();
    }
    /**
     * @return {?}
     */
    checkMobileMode() {
        if (this.matchMediaService.IsPhone()) {
            this.mobilemode = true;
            this.isPhone = true;
        }
        else {
            this.mobilemode = false;
            this.isPhone = false;
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    toggleDrawerPanel(event) {
        this.toggle = !this.toggle;
    }
    /**
     * @return {?}
     */
    handleNavItems() {
        this.navItemComponents = this.navitems.toArray();
        this.navItemComponents.forEach((/**
         * @param {?} node
         * @return {?}
         */
        (node) => node.onNavItemClick.subscribe((/**
         * @param {?} eventdata
         * @return {?}
         */
        (eventdata) => this.handleNavItemEvent(eventdata)))));
    }
    /**
     * @param {?} event
     * @return {?}
     */
    handleNavItemEvent(event) {
        if (event && event.data && event.data.node && !event.data.node.header && this.mobilemode) {
            this.toggle = true;
        }
    }
    /**
     * @param {?} navbarwidth
     * @return {?}
     */
    notifyNavItems(navbarwidth) {
        if (this.navItemComponents) {
            this.navItemComponents.forEach((/**
             * @param {?} node
             * @return {?}
             */
            (node) => {
                node.setMobileMode(this.mobilemode);
                node.setNavbarWidth(navbarwidth);
            }));
        }
    }
    /**
     * @return {?}
     */
    handleDeviceSetting() {
        if (this.matchMediaService.IsTablet() || this.matchMediaService.IsPhone()) {
            this.mobilemode = true;
            this.toggle = false;
            this.isPhone = true;
        }
        else {
            this.mobilemode = false;
            this.isPhone = false;
            this.toggle = true;
        }
        if (this.navbar) {
            this.notifyNavItems(this.navbar.nativeElement.offsetWidth);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    resize(event) {
        if (!this.enableMoreMode) {
            this.handleDeviceSetting();
        }
        else {
            if (this.matchMediaService.IsPhone()) {
                this.mobilemode = true;
                this.isPhone = true;
                this.toggle = false;
            }
            else {
                this.mobilemode = false;
                this.isPhone = false;
                this.toggle = true;
            }
            this.createMoreContent();
            if (this.navbar) {
                this.notifyNavItems(this.navbar.nativeElement.offsetWidth);
            }
        }
        if (this.homepageType === '3') {
            if (!this.isExpand) {
                this.lhsWidth = '0 0 19%';
            }
            else {
                this.isLHSHide = true;
                this.lhsWidth = '0 0 5%';
            }
            this.isExpand = !this.isExpand;
        }
        this.navOnLoad();
    }
    /**
     * @return {?}
     */
    resizeAfterBannerClose() {
        if (!this.enableMoreMode) {
            this.handleDeviceSetting();
        }
        else {
            if (this.navbar) {
                this.notifyNavItems(this.navbar.nativeElement.offsetWidth);
            }
        }
        this.navOnLoad();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onArrowClick(event) {
        this.onIconArrowClick.emit();
        this.navOnLoad();
        this.isIconLeft = !this.isIconLeft;
    }
    // THIS EVENT IS HOME COMPOENNT USE.NOT EXPOSED
    /**
     * @return {?}
     */
    onExpandIconClick() {
        if (this.homepageType === '3') {
            if (!this.isExpand) {
                this.lhsWidth = '0 0 19%';
            }
            else {
                this.isLHSHide = true;
                this.lhsWidth = '0 0 5%';
            }
            this.onIconClick.emit(!this.isExpand);
            this.isExpand = !this.isExpand;
        }
    }
    /**
     * @param {?} themeClass
     * @return {?}
     */
    setColorPalette(themeClass) {
        this.themeCss = themeClass;
    }
    /**
     * @return {?}
     */
    createMoreContent() {
        this.resizeItemCollection = [];
        this.moreBucket = [];
        this.notifyNavItems(this.navbar.nativeElement.offsetWidth);
        if (!this.mobilemode) {
            this.removeNodeFromDom();
            if (this.navItemComponents && this.navItemComponents.length > 0) {
                this.createMoreData();
            }
        }
        else {
            this.toggle = false;
            this.mobileModePresent();
        }
        if (this.moreBucket.length > 0) {
            this.morePadding = 50;
        }
        else {
            this.morePadding = 0;
        }
    }
    /**
     * @return {?}
     */
    mobileModePresent() {
        this.removeNodeFromDom();
        this.navItemComponents.forEach((/**
         * @param {?} nvitem
         * @return {?}
         */
        (nvitem) => {
            if (nvitem.type === 'menu') {
                this.resizeItemCollection.push(nvitem);
            }
        }));
    }
    /**
     * @return {?}
     */
    createMoreData() {
        /** @type {?} */
        let itemsWidth = 0;
        if (this.moreCheckWidth !== 0 || this.moreCheckWidth > 200) {
            itemsWidth = this.moreCheckWidth;
        }
        this.navItemComponents.forEach((/**
         * @param {?} nvitem
         * @return {?}
         */
        (nvitem) => {
            if (nvitem.type === 'menu') {
                if (this.navbar.nativeElement.offsetWidth > (itemsWidth + 400) ||
                    ((this.navbar.nativeElement.offsetWidth - itemsWidth) > 200)) {
                    itemsWidth = (itemsWidth + nvitem.offsetWidth);
                    this.resizeItemCollection.push(nvitem);
                }
                else {
                    /** @type {?} */
                    const dd = {
                        text: nvitem.title,
                        submenus: nvitem.data,
                        subMenuPadding: nvitem.subMenuPadding,
                    };
                    this.moreBucket.push(dd);
                }
            }
        }));
    }
    /**
     * @return {?}
     */
    removeNodeFromDom() {
        if (!this.isItemRemoved && this.navItemComponents && this.navItemComponents.length > 0) {
            this.navItemComponents.forEach((/**
             * @param {?} nvitem
             * @return {?}
             */
            (nvitem) => {
                if (nvitem.type === 'menu') {
                    nvitem.offsetWidth = nvitem.elementref.nativeElement.offsetWidth;
                    /** @type {?} */
                    const node = document.getElementById(nvitem.componentId);
                    if (node) {
                        node.parentNode.removeChild(node);
                    }
                }
            }));
            this.isItemRemoved = true;
        }
    }
    // external link
    /**
     * @param {?} event
     * @return {?}
     */
    externalLink(event) {
        if (this.navItemComponents && this.navItemComponents.length > 0) {
            /** @type {?} */
            let isFound = false;
            this.navItemComponents.forEach((/**
             * @param {?} element
             * @return {?}
             */
            (element) => {
                if (!isFound && element.type === 'menu') {
                    element.navItemClick(event);
                    isFound = true;
                }
            }));
        }
    }
    /**
     * @return {?}
     */
    navOnLoad() {
        setTimeout((/**
         * @return {?}
         */
        () => {
            this.onNavLoad.emit({ offsetHeight: this.navbar.nativeElement.offsetHeight });
        }), 0);
    }
}
AmexioNavBarComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-nav', template: `
    <nav #navbar style="flex-direction: column" class="topnav {{themeCss}}" [ngStyle]="{'color': color, 'top': top, 'opacity': opacity}"
        [ngClass]="{'topnav-mobile':mobilemode, 'transparentNav':transparent}" (window:resize)="resize($event)">
        <div [style.display]="showBanner ? 'block': 'none'">
            <ng-content select="amexio-banner"></ng-content>
        </div>
        <div [ngClass]="{'flex-col': mobilemode, 'flex-inline': !mobilemode}">

            <div #navbarfixed [ngClass]="{'lhs-mobile':mobilemode}" [ngStyle]="{'flex': !title || !logo ? 'none':''}" style="padding-bottom:0.2%">
                <div class="topnav-lhs-inner" [ngClass]="{'topnav-lhs-inner-mobile':mobilemode, 'topnav-lhs-nologo': logo==''}">
                    <span style="white-space:nowrap">

                        <span *ngIf="((sidenav && homepageType ==='1') || (mobilemode && homepageType ==='2'))" class="homepage-bar-collapse" (click)="onArrowClick($event)">
                            <amexio-image [icon-class]=" 'fa fa-bars' "></amexio-image> &nbsp;
                        </span>

                        <img alt="title " style="cursor: pointer " (click)="onNavLogoClick.emit($event) " (load)="onImageLoad() " *ngIf="logo " [attr.src]="logo "
                            class="navbar-logo ">
                        <a (click)="onNavTitleClick.emit($event)" [ngStyle]="{'color': color}">{{title}}</a>


                        <ng-container *ngIf="homepageType=='2' && !mobilemode">
                            <ng-container *ngIf="!isIconLeft">
                                <span class="collaspe-icon-style" (click)="onArrowClick($event)">
                                    <amexio-image [icon-class]=" 'fa fa-chevron-right' "></amexio-image>
                                </span>
                            </ng-container>
                            <ng-container *ngIf="isIconLeft">
                                <span class="collaspe-icon-style" (click)="onArrowClick($event)">
                                    <amexio-image [icon-class]=" 'fa fa-chevron-left' "></amexio-image>
                                </span>
                            </ng-container>
                        </ng-container>

                    </span>

                    <span *ngIf="mobilemode && navItemPresent" class="float-right mobilebar" (click)="toggleDrawerPanel($event)">
                        <em *ngIf="!toggle" class="fa fa-caret-down fa-2x"></em>
                        <em *ngIf="toggle" class="fa fa-caret-up fa-2x"></em>
                    </span>
                </div>
            </div>


        <div #navbaritems *ngIf="toggle" class="topnav-rhs" [ngClass]="{'rhs-mobile':mobilemode, 'transparentNav1':transparent && mobilemode}">
            <div class="topnavmainbar" [ngClass]="{'topnavmainbar-mobile':mobilemode}">
                <div #navbaritems1 class="topnavmainbaritems" [ngClass]="{'topnavmainbaritems-mobile':mobilemode}">
                    <ng-content select="[position-left]"></ng-content>
                </div>
                <div #navbaritems2 class="topnavmainbaritems" [ngClass]="{'topnavmainbaritems-mobile':mobilemode}">
                    <ng-content select="[position-center]"></ng-content>
                </div>
              <div #navbaritems3 class="topnavmainbaritems" [ngClass]="{'topnavmainbaritems-mobile':mobilemode}">
                <ng-content select="[position-right]"></ng-content>
                <amexio-nav-item  *ngFor="let node of resizeItemCollection" [type]="node.type" (onNavItemClick)="externalLink($event)"
                                 [sub-menu-height-padding]="node.subMenuPadding" [title]="node.title" [mobilemode]="mobilemode"  [data]="node.data" [icon]="node.icon">
                </amexio-nav-item>

                <ng-container *ngIf="enableMoreMode && moreBucket.length > 0">
                         <span class="testClass">
                            <amexio-nav-item [sub-menu-height-padding]="moreBucket[0].subMenuPadding"
                             [type]="'menu'"
                             [submenupos]="true"
                                              [mobilemode]="mobilemode"
                                              (onNavItemClick)="externalLink($event)"
                                              [data]="moreBucket"
                                              [title]="'More'">
                          </amexio-nav-item>
                         </span>
                </ng-container>
              </div>
            </div>
        </div>
    </div>
    </nav>
  `,
            },] },
];
/** @nocollapse */
AmexioNavBarComponent.ctorParameters = () => [
    { type: DeviceQueryService }
];
AmexioNavBarComponent.propDecorators = {
    title: [{ type: Input }],
    logo: [{ type: Input }],
    sidenav: [{ type: Input, args: ['enable-side-nav-position',] }],
    transparent: [{ type: Input, args: ['transparent',] }],
    color: [{ type: Input, args: ['color',] }],
    enableMoreMode: [{ type: Input, args: ['enable-more-mode',] }],
    homepageType: [{ type: Input, args: ['home-page-type',] }],
    onNavLogoClick: [{ type: Output }],
    onNavTitleClick: [{ type: Output }],
    onIconArrowClick: [{ type: Output }],
    onIconClick: [{ type: Output }],
    navSubmenuClick: [{ type: Output }],
    navitems: [{ type: ContentChildren, args: [AmexioNavItemComponent,] }],
    bannerItem: [{ type: ContentChildren, args: [AmexioBannerComponent,] }],
    onNavLoad: [{ type: Output }],
    navbar: [{ type: ViewChild, args: ['navbar', { read: ElementRef },] }],
    navbarfixed: [{ type: ViewChild, args: ['navbarfixed', { read: ElementRef },] }],
    navbaritems: [{ type: ViewChild, args: ['navbaritems', { read: ElementRef },] }],
    navbaritems1: [{ type: ViewChild, args: ['navbaritems1', { read: ElementRef },] }],
    navbaritems2: [{ type: ViewChild, args: ['navbaritems2', { read: ElementRef },] }],
    navbaritems3: [{ type: ViewChild, args: ['navbaritems3', { read: ElementRef },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by ketangote on 12/1/17.
*/
class SideNavNodeComponent {
    /**
     * @param {?} matchMediaService
     * @param {?} iconService
     */
    constructor(matchMediaService, iconService) {
        this.matchMediaService = matchMediaService;
        this.iconService = iconService;
        /*
           Events
           name : nodeClick
           datatype : none
           version : none
           default : none
           description : Fire when sidenav bar menu click
           */
        this.nodeClick = new EventEmitter();
        /*
           Events
           name : onDrag
           datatype : none
           version : 4.2.9
           default : none
           description : Fire when you drag node
           */
        this.onDrag = new EventEmitter();
        this.nodeEmitToSideNav = new EventEmitter();
        this.expand = false;
        this.isMobile = false;
        this.isDefaultUserIcon = false;
        this.displaykey = 'text';
        this.childarraykey = 'children';
        if (this.matchMediaService.IsTablet() || this.matchMediaService.IsPhone()) {
            this.isMobile = true;
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (!this.node && !this.label) {
            this.expand = true;
            this.collapsable = false;
        }
    }
    /**
     * @param {?} node
     * @return {?}
     */
    onClick(node) {
        this.expand = !this.expand;
        if (this.nodedata) {
            if (this.nodedata.children && this.expand === false) {
                this.nodedata.children.forEach((/**
                 * @param {?} element
                 * @return {?}
                 */
                (element) => {
                    element['tabindex'] = '-1';
                }));
            }
            else if (this.nodedata.children && this.expand === true) {
                this.nodedata.children.forEach((/**
                 * @param {?} element
                 * @return {?}
                 */
                (element) => {
                    element['tabindex'] = '1';
                }));
            }
        }
        this.nodeClick.emit(node);
    }
    /**
     * @param {?} node
     * @return {?}
     */
    onNodeClick(node) {
        this.nodeClick.emit(node);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    dragStartEvent(event) {
        if (this.enabledrag) {
            event.event.dataTransfer.setData('dragData', JSON.stringify(event.data));
            this.onDrag.emit(event);
        }
    }
    /**
     * @param {?} allNodeData
     * @return {?}
     */
    emittednodedata(allNodeData) {
        this.nodeEmitToSideNav.emit(allNodeData);
    }
    /**
     * @param {?} divref
     * @param {?} nodedata
     * @return {?}
     */
    onenterClick(divref, nodedata) {
        if (divref.tabIndex === 1 && nodedata.children) {
            nodedata.expand = !nodedata.expand;
        }
        if (nodedata.children && nodedata.expand === true) {
            nodedata.children.forEach((/**
             * @param {?} element
             * @param {?} index
             * @return {?}
             */
            (element, index) => {
                element['tabindex'] = '1';
            }));
        }
        this.onClick(nodedata);
    }
    /**
     * @param {?} isIcon
     * @return {?}
     */
    setShowOnlyIconFlag(isIcon) {
        /** @type {?} */
        let icon = '';
        /** @type {?} */
        const iconObject = this.iconService.getIconObject('sidenavnode-icon');
        if (this.iconService.iconToUse === 'fa') {
            icon = iconObject.fa;
        }
        else {
            icon = iconObject.mat;
        }
        if (this.isDefaultUserIcon && this.icon === 'fa fa-user-circle') {
            this.icon = '';
            this.isDefaultUserIcon = false;
        }
        else if ((!this.icon || this.icon === '') && !this.isDefaultUserIcon) {
            this.icon = icon;
            this.isDefaultUserIcon = true;
        }
        this.isShowOnlyIcon = isIcon;
    }
}
SideNavNodeComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-sidenav-node', template: `
     <ul>
     <li>
        <div *ngIf="enableborder" class="border"></div>
        <div tabindex="1" (keyup.enter)="onenterClick(currentdivref,nodedata)" *ngIf="label || badge || icon"
            [attr.draggable]="enabledrag" (dragstart)="dragStartEvent({event:$event,data:node})" class="headernode"
            [ngClass]="{'activenode':active}" (click)="onClick(nodedata)">

            <ng-container *ngIf="icon">
                <amexio-c-icon class="node-icon" [customclass]="icon" [color]="iconcolor"></amexio-c-icon>
                <ng-container *ngIf="!isShowOnlyIcon || isMobile">
                    <span class="sideInnerNodeFlex"><span style="padding-right: 10px">{{label}}</span>
                        <span *ngIf="badge" class="nav-badge">{{badge}}</span>
                    </span>

                </ng-container>
            </ng-container>

            <ng-container *ngIf="!icon">
                <amexio-c-icon class="node-icon" [customclass]="icon" [color]="iconcolor"></amexio-c-icon>
                <ng-container *ngIf="!isShowOnlyIcon || isMobile">
                  <span class="sideInnerNodeFlex"><span style="padding-right: 10px">{{label}}</span>
                        <span *ngIf="badge" class="nav-badge">{{badge}}</span>
                    </span>

                </ng-container>
            </ng-container>

            <ng-container *ngIf="(node && (node.length>0)) || collapsable">
                <span style="padding-right: 10px; float: right" *ngIf="expand">
                    <amexio-c-icon key="sidenav-angle-up"></amexio-c-icon>
                </span>
                <span style="padding-right: 10px;float: right" *ngIf="!expand">
                    <amexio-c-icon key="sidenav-angle-down"></amexio-c-icon>
                </span>
            </ng-container>
        </div>
 
        <div *ngIf="node && !isShowOnlyIcon" class="sidenav-submenu-details sidenav-submenu-expanded" [ngClass]="{'sidenav-submenu-expanded':expand}">
            <amexio-sidenav-innernode *ngIf="node && (node.length>0)" (onClick)="onNodeClick($event)" [display-key]="displaykey"
                [child-array-key]="childarraykey" [enable-drag]="enabledrag" (emitNode)="emittednodedata($event)" (onDrag)="dragStartEvent($event)"
                [data]="node">
            </amexio-sidenav-innernode>
        </div>
        <!-- ng content block-->
        <div class="sidenav-submenu-details" style="width: 100%" [ngClass]="{'sidenav-submenu-expanded':expand}">
            <ng-content *ngIf="!isShowOnlyIcon"></ng-content>
        </div>
    </li>
    </ul>
  `,
            },] },
];
/** @nocollapse */
SideNavNodeComponent.ctorParameters = () => [
    { type: DeviceQueryService },
    { type: IconLoaderService }
];
SideNavNodeComponent.propDecorators = {
    nodedata: [{ type: Input, args: ['node',] }],
    currentdivref: [{ type: Input, args: ['currentdivref',] }],
    badge: [{ type: Input, args: ['badge',] }],
    icon: [{ type: Input, args: ['icon',] }],
    label: [{ type: Input, args: ['label',] }],
    enableborder: [{ type: Input, args: ['enable-border',] }],
    active: [{ type: Input, args: ['active',] }],
    collapsable: [{ type: Input, args: ['collapsable',] }],
    node: [{ type: Input, args: ['data',] }],
    enabledrag: [{ type: Input, args: ['enable-drag',] }],
    nodeClick: [{ type: Output }],
    onDrag: [{ type: Output }],
    nodeEmitToSideNav: [{ type: Output }],
    displaykey: [{ type: Input, args: ['display-key',] }],
    childarraykey: [{ type: Input, args: ['child-array-key',] }],
    expand: [{ type: Input }],
    iconcolor: [{ type: Input, args: ['icon-color',] }],
    isShowOnlyIcon: [{ type: Input, args: ['show-only-icon',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by ketangote on 12/1/17.
*/
class AmexioSideNavComponent {
    /**
     * @param {?} dataService
     * @param {?} matchMediaService
     * @param {?} element
     * @param {?} cd
     */
    constructor(dataService, matchMediaService, element, cd) {
        this.dataService = dataService;
        this.matchMediaService = matchMediaService;
        this.element = element;
        this.cd = cd;
        /*
           Events
           name : nodeClick
           datatype : none
           version : none
           default : none
           description : Fire when sidenav bar menu click
           */
        this.nodeClick = new EventEmitter();
        /*
           Events
           name : onDrag
           datatype : none
           version : 4.2.9
           default : none
           description : Fire when you drag node
           */
        this.onDrag = new EventEmitter();
        /*
           Properties
           name : enable-border
           datatype : boolean
           version : 5.5.5 onwards
           default : true
           description : By default enable-border is enabled
           */
        this.enableborder = true;
        this.onMouseLeave = new EventEmitter();
        this.onMouseOver = new EventEmitter();
        this.handleMobileDevice = true;
        this.nodes = [];
        this.isShowOnlyIcon = false;
        this.isSideNavEnable = true;
        this.position = 'left';
        this.smalldevice = false;
        this.sidenavexpandedinsmalldevice = false;
        this.width = '0%';
        /** @type {?} */
        const that = this;
        this.displaykey = 'text';
        this.childarraykey = 'children';
        if (this.matchMediaService.IsTablet() || this.matchMediaService.IsPhone()) {
            this.smalldevice = true;
            this.width = '0%';
        }
        else {
            this.width = '19%';
        }
        /*---------------------------------------------------
         TAP INTO LISTENERS FOR WHEN DEVICE WIDTH CHANGES
         ---------------------------------------------------*/
        this.matchMediaService.OnPhone((/**
         * @param {?} mediaQueryList
         * @return {?}
         */
        (mediaQueryList) => {
            that.handleDeviceSettings(false);
        }));
        this.matchMediaService.OnTablet((/**
         * @param {?} mediaQueryList
         * @return {?}
         */
        (mediaQueryList) => {
            that.handleDeviceSettings(false);
        }));
        this.matchMediaService.OnDesktop((/**
         * @param {?} mediaQueryList
         * @return {?}
         */
        (mediaQueryList) => {
            that.handleDeviceSettings(false);
        }));
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.httpmethod && this.httpurl) {
            this.dataService.fetchData(this.httpurl, this.httpmethod).subscribe((/**
             * @param {?} response
             * @return {?}
             */
            (response) => {
                this.responseData = response;
            }), (/**
             * @param {?} error
             * @return {?}
             */
            (error) => {
            }), (/**
             * @return {?}
             */
            () => {
                this.setData(this.responseData);
            }));
        }
        if (this.data && (!this.httpmethod || !this.httpurl)) {
            this.setData(this.data);
        }
        if (this.position == null) {
            this.position = 'left';
        }
        if (!this.height) {
            this.height = '100%';
        }
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.nodearray = this.sidennavnodearray.toArray();
        this.nodearray.forEach((/**
         * @param {?} element
         * @return {?}
         */
        (element) => {
            element.nodeEmitToSideNav.subscribe((/**
             * @param {?} node
             * @return {?}
             */
            (node) => {
                node.forEach((/**
                 * @param {?} nodeelement
                 * @return {?}
                 */
                (nodeelement) => {
                    if (nodeelement.active === true) {
                        this.activenode = nodeelement;
                    }
                }));
                this.activateNode = JSON.parse(JSON.stringify(node));
                this.findObj(node);
            }));
        }));
    }
    /**
     * @return {?}
     */
    toggle() {
        this.handleDeviceSettings(true);
    }
    /**
     * @param {?} currentnode
     * @return {?}
     */
    findObj(currentnode) {
        this.nodearray.forEach((/**
         * @param {?} element
         * @return {?}
         */
        (element) => {
            if (element.node && (element.node.length > 0)) {
                (element.node).forEach((/**
                 * @param {?} individualnode
                 * @return {?}
                 */
                (individualnode) => {
                    if ((this.activenode.text === individualnode.text)
                        && (this.activenode.active === individualnode.active)) {
                        individualnode.active = true;
                    }
                    else {
                        individualnode.active = false;
                    }
                }));
            }
        }));
    }
    /**
     * @param {?} node
     * @return {?}
     */
    onClick(node) {
        this.activateNode(this.data, node);
        if (this.matchMediaService.IsTablet() || this.matchMediaService.IsPhone()) {
            this.smalldevice = true;
        }
        else {
            this.smalldevice = false;
        }
        this.nodeClick.emit(node);
        if (this.smalldevice && (!node.children || node.children === null || node.children === '')) {
            this.isSideNavExpand = false;
        }
        else {
            this.isSideNavEnable = true;
        }
    }
    /**
     * @return {?}
     */
    collapseSidenav() {
        this.width = '0%';
        this.isSideNavExpand = false;
        this.sidenavexpandedinsmalldevice = false;
    }
    /**
     * @param {?} data
     * @return {?}
     */
    generateIndex(data) {
        data.forEach((/**
         * @param {?} element
         * @param {?} index
         * @return {?}
         */
        (element, index) => {
            if (element[this.childarraykey]) {
                element[this.childarraykey].forEach((/**
                 * @param {?} innerelement
                 * @return {?}
                 */
                (innerelement) => {
                    innerelement['tabindex'] = '-1';
                    if (innerelement[this.childarraykey]) {
                        innerelement[this.childarraykey].forEach((/**
                         * @param {?} innerelement2
                         * @return {?}
                         */
                        (innerelement2) => {
                            innerelement2['tabindex'] = '-1';
                        }));
                    }
                }));
            }
        }));
    }
    /**
     * @param {?} httpResponse
     * @return {?}
     */
    setData(httpResponse) {
        // Check if key is added?
        /** @type {?} */
        let responsedata = httpResponse;
        if (this.datareader != null) {
            /** @type {?} */
            const dr = this.datareader.split('.');
            for (const ir of dr) {
                responsedata = responsedata[ir];
            }
        }
        else {
            responsedata = httpResponse;
        }
        this.data = responsedata;
        this.generateIndex(this.data);
        this.activateNode(this.data, null);
        this.handleDeviceSettings(false);
    }
    /**
     * @param {?} data
     * @param {?} node
     * @return {?}
     */
    activateNode(data, node) {
        for (const i of data) {
            if (node === i && !i[this.childarraykey]) {
                i['active'] = true;
            }
            else {
                i['active'] = false;
            }
            if (i[this.childarraykey]) {
                this.activateNode(i[this.childarraykey], node);
            }
        }
    }
    /**
     * @return {?}
     */
    toggleSideNav() {
        this.isSideNavEnable = true;
        this.handleDeviceSettings(!this.isSideNavExpand);
    }
    /**
     * @return {?}
     */
    close() {
        this.handleDeviceSettings(false);
    }
    /**
     * @param {?} expand
     * @return {?}
     */
    handleDeviceSettings(expand) {
        if (this.position !== 'relative') {
            if (this.matchMediaService.IsTablet() || this.matchMediaService.IsPhone()) {
                this.smalldevice = true;
                if (expand) {
                    this.width = '80%';
                    this.isSideNavExpand = true;
                    this.sidenavexpandedinsmalldevice = true;
                }
                else {
                    this.width = '0%';
                    this.isSideNavExpand = false;
                    this.sidenavexpandedinsmalldevice = false;
                }
            }
            else {
                if (this.isShowOnlyIcon) {
                    this.width = '5%';
                }
                else {
                    this.width = '19%';
                }
                this.smalldevice = false;
            }
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    getNodeDragEvent(event) {
        this.onDrag.emit(event);
    }
    // THIS METHOD IS USED FOR SETTING HOMEPAGE TYPE
    /**
     * @param {?} type
     * @return {?}
     */
    setHomePageType(type) {
        this.homepageType = type;
        if (this.homepageType === '3') {
            this.nodearray.forEach((/**
             * @param {?} element
             * @return {?}
             */
            (element) => {
                element.setShowOnlyIconFlag(this.isShowOnlyIcon);
            }));
        }
        this.cd.detectChanges();
    }
}
AmexioSideNavComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-side-nav', template: `
    <div *ngIf="handleMobileDevice && (position !='relative' && smalldevice )" [ngClass]="{'sidenav-mobile-bar-left':(position=='left' && position!='relative'),'sidenav-mobile-bar-right':(position=='right' && position!='relative')}" class="sidenav-mobile-bar"
        (click)="toggleSideNav()">
        <amexio-c-icon class="homepage3-bar" key="sidenav_bar" [color]=""></amexio-c-icon>
    </div>
    <div *ngIf="isSideNavEnable" style="height: 100%" [style.width]="width" [ngStyle]="{'background': bgimage ? 'url(' + bgimage + ') center/cover no-repeat' : null}" [ngClass]="{'left':(position=='left' && position!='relative'),'right':(position=='right' && position!='relative')}">
        <div class="sidenav" [ngClass]="{'sidenav-color': !background}" [style.color]="color" [style.background]="background" [style.height]="height">
            <ul>
                <li>
                    <div *ngIf="sidenavtitle" class="title">
                        <ng-container *ngIf="titleimage">
                            <p>
                                <img [attr.src]="titleimage" alt=" Title image" style="width: 60px;height: 60px;padding-left: 80px;" />
                            </p>
                        </ng-container>
                        <ng-container *ngIf="sidenavtitle">
                            <p>{{sidenavtitle}}</p>
                        </ng-container>
                        <span *ngIf="sidenavexpandedinsmalldevice" style="padding-right: 10px; float: right" (click)="close()">
                        <amexio-c-icon key="sidenav_close"></amexio-c-icon>
                    </span>
                    </div>
                </li>
                 <div #currentdivref role="option" *ngFor="let node of data" id="{{node.index}}">
                    <amexio-sidenav-node [show-only-icon]="isShowOnlyIcon"
                    [display-key]="displaykey"
                    [child-array-key]="childarraykey" 
                
                    [enable-border]="enableborder && (node && node[childarraykey] && (node[childarraykey].length>0))" [currentdivref]="currentdivref" [active]="(node && node.active)" [icon]="node.icon" [badge]="node.badge"
                        [enable-drag]="enabledrag" (nodeClick)="onClick($event)" (onDrag)="getNodeDragEvent($event)" [expand]="node?.expand" [label]="node[displaykey]" [node]="node" [icon-color]="node.iconcolor" [data]="node[childarraykey]">
                    </amexio-sidenav-node>
                </div>

                <ng-content></ng-content>
            </ul>
        </div>
    </div>
  `,
            },] },
];
/** @nocollapse */
AmexioSideNavComponent.ctorParameters = () => [
    { type: CommonDataService },
    { type: DeviceQueryService },
    { type: ElementRef },
    { type: ChangeDetectorRef }
];
AmexioSideNavComponent.propDecorators = {
    data: [{ type: Input }],
    httpurl: [{ type: Input, args: ['http-url',] }],
    httpmethod: [{ type: Input, args: ['http-method',] }],
    datareader: [{ type: Input, args: ['data-reader',] }],
    position: [{ type: Input }],
    titleimage: [{ type: Input }],
    nodeClick: [{ type: Output }],
    onDrag: [{ type: Output }],
    width: [{ type: Input }],
    height: [{ type: Input }],
    sidenavtitle: [{ type: Input, args: ['title',] }],
    enabledrag: [{ type: Input, args: ['enable-drag',] }],
    displaykey: [{ type: Input, args: ['display-key',] }],
    childarraykey: [{ type: Input, args: ['child-array-key',] }],
    enableborder: [{ type: Input, args: ['enable-border',] }],
    background: [{ type: Input, args: ['background',] }],
    color: [{ type: Input, args: ['color',] }],
    bgimage: [{ type: Input, args: ['bg-image',] }],
    onMouseLeave: [{ type: Output }],
    onMouseOver: [{ type: Output }],
    sidennavnodearray: [{ type: ContentChildren, args: [SideNavNodeComponent,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AmexioHomePageNorthPanelComponent {
    /**
     * @param {?} matchMediaService
     */
    constructor(matchMediaService) {
        this.matchMediaService = matchMediaService;
        this.enableIcon = false;
        this.nothPanelIconClick = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (this.amexioNavBarComponent && this.type === '2' && !(this.matchMediaService.IsTablet() || this.matchMediaService.IsPhone())) {
            this.amexioNavBarComponent.homepageType = this.type;
        }
        this.amexioNavBarComponent.onIconArrowClick.subscribe((/**
         * @param {?} eventdata
         * @return {?}
         */
        (eventdata) => this.westPanelShowHideClick(eventdata)));
    }
    /**
     * @param {?} data
     * @return {?}
     */
    westPanelShowHideClick(data) {
        this.nothPanelIconClick.emit();
    }
}
AmexioHomePageNorthPanelComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-homepage-northpanel',
                template: `
    <ng-content></ng-content>
  `,
            },] },
];
/** @nocollapse */
AmexioHomePageNorthPanelComponent.ctorParameters = () => [
    { type: DeviceQueryService }
];
AmexioHomePageNorthPanelComponent.propDecorators = {
    enableIcon: [{ type: Input, args: ['enable-icon',] }],
    type: [{ type: Input, args: ['type',] }],
    nothPanelIconClick: [{ type: Output }],
    amexioNavBarComponent: [{ type: ContentChild, args: [AmexioNavBarComponent,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AmexioHomePageWestPanelComponent {
    /**
     * @param {?} matchMediaService
     */
    constructor(matchMediaService) {
        this.matchMediaService = matchMediaService;
        this.padding = 50;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @param {?} paddding
     * @return {?}
     */
    setPadding(paddding) {
        this.padding = paddding;
    }
}
AmexioHomePageWestPanelComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-homepage-westpanel',
                template: `
    <div class="homepage-westpanel" [style.padding-top.px]="padding">
        <ng-content></ng-content>
    </div>
  `,
            },] },
];
/** @nocollapse */
AmexioHomePageWestPanelComponent.ctorParameters = () => [
    { type: DeviceQueryService }
];
AmexioHomePageWestPanelComponent.propDecorators = {
    type: [{ type: Input, args: ['type',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AmexioHomePageComponent {
    /**
     * @param {?} matchMediaService
     */
    constructor(matchMediaService) {
        this.matchMediaService = matchMediaService;
        this.type = '1';
        this.isDisableWestPanel = true;
        this.isPhone = false;
        this.westPanelWidth = '0 0 19%';
        this.northPanelHeight = 50;
        if (this.matchMediaService.IsTablet() || this.matchMediaService.IsPhone()) {
            this.isPhone = true;
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() { }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        setTimeout((/**
         * @return {?}
         */
        () => {
            this.sideNavComponents = this.sideNavList.toArray();
            this.setTimeoutMethodSeoerate();
            this.sideNavComponents[0].handleMobileDevice = false;
            if (this.type === '3') {
                this.sideNavComponents[0].isShowOnlyIcon = true;
                this.sideNavComponents[0].width = '5%';
                this.westPanelWidth = '0 0 5%';
                this.sideNavComponents[0].setHomePageType(this.type);
                // NAVBAR
                this.amexioNavBarComponent.isLHSHide = true;
                this.amexioNavBarComponent.lhsWidth = '0 0 5%';
                this.amexioNavBarComponent.onIconClick.subscribe((/**
                 * @param {?} eventdata
                 * @return {?}
                 */
                (eventdata) => this.northPanelClick(eventdata)));
            }
            if (this.amexoHomePageNorthpanel) {
                this.amexoHomePageNorthpanel.type = this.type;
                this.amexoHomePageNorthpanel.nothPanelIconClick.subscribe((/**
                 * @param {?} eventdata
                 * @return {?}
                 */
                (eventdata) => this.showHideWestPanel()));
            }
            this.amexioNavBarComponent.homepageType = this.type;
            if (this.amexioHomePageWestPanelComponent) {
                this.amexioNavBarComponent.onNavLoad.subscribe((/**
                 * @param {?} onLoadData
                 * @return {?}
                 */
                (onLoadData) => {
                    this.northPanelHeight = onLoadData.offsetHeight;
                    if (this.sideNavComponents[0].sidenavexpandedinsmalldevice) {
                        this.amexioHomePageWestPanelComponent.setPadding(this.northPanelHeight);
                    }
                    else if (this.matchMediaService.IsTablet() || this.matchMediaService.IsPhone()) {
                        this.amexioHomePageWestPanelComponent.setPadding(0);
                    }
                    else {
                        this.amexioHomePageWestPanelComponent.setPadding(this.northPanelHeight);
                    }
                }));
            }
        }), 0);
    }
    /**
     * @return {?}
     */
    setTimeoutMethodSeoerate() {
        this.sideNavComponents.forEach((/**
         * @param {?} sidenav
         * @return {?}
         */
        (sidenav) => {
            sidenav.nodeClick.subscribe((/**
             * @param {?} node
             * @return {?}
             */
            (node) => {
                if (sidenav.smalldevice && (!node.children || node.children === null || node.children === '')) {
                    this.sideNavComponents[0].collapseSidenav();
                    if (this.sideNavComponents[0].sidenavexpandedinsmalldevice) {
                        this.amexioHomePageWestPanelComponent.setPadding(this.northPanelHeight);
                    }
                    else {
                        this.amexioHomePageWestPanelComponent.setPadding(0);
                    }
                }
                else {
                    this.sideNavComponents[0].isSideNavEnable = true;
                }
            }));
        }));
    }
    // tslint:disable-next-line:no-identical-functions
    /**
     * @param {?} event
     * @return {?}
     */
    resize(event) {
        if (this.matchMediaService.IsTablet() || this.matchMediaService.IsPhone()) {
            this.isPhone = true;
        }
        else {
            this.isPhone = false;
        }
    }
    /**
     * @return {?}
     */
    showHideWestPanel() {
        this.isDisableWestPanel = !this.isDisableWestPanel;
        if (this.matchMediaService.IsTablet() || this.matchMediaService.IsPhone()) {
            this.isPhone = true;
            this.sideNavComponents[0].toggle();
            if (this.sideNavComponents[0].sidenavexpandedinsmalldevice) {
                this.amexioHomePageWestPanelComponent.setPadding(this.northPanelHeight);
            }
            else {
                this.amexioHomePageWestPanelComponent.setPadding(0);
            }
        }
    }
    // ON NORTH PANEL CLICK
    /**
     * @param {?} isExpand
     * @return {?}
     */
    northPanelClick(isExpand) {
        if (isExpand) {
            this.amexioNavBarComponent.isLHSHide = false;
            // SIDE NAV
            this.sideNavComponents[0].isShowOnlyIcon = false;
            this.sideNavComponents[0].width = '19%';
            this.westPanelWidth = '0 0 19%';
        }
        else {
            this.amexioNavBarComponent.isLHSHide = true;
            // SIDE NAV
            this.sideNavComponents[0].isShowOnlyIcon = true;
            this.sideNavComponents[0].width = '5%';
            this.westPanelWidth = '0 0 5%';
        }
        this.sideNavComponents[0].setHomePageType(this.type);
    }
}
AmexioHomePageComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-homepage-ce',
                template: `
    <div class="{{'homepage-'+type}}" (window:resize)="resize($event)">
        <div class="homepage-northpanel-flex">
            <ng-content select="amexio-homepage-northpanel">
            </ng-content>
        </div>
        <div [ngStyle]="{'display': !isPhone ? 'flex':'','flex-direction': isDisableWestPanel ? 'row' : 'column'}">
            <div [ngStyle]="{'flex':isPhone ? '0 0 0%':westPanelWidth}">
                <ng-content *ngIf="isDisableWestPanel" select="amexio-homepage-westpanel">
                </ng-content>
            </div>
            <div [ngClass]="{'homepage-centerpanel-flex':!isPhone || (isDisableWestPanel && !isPhone), 'homepage-centerpanel-flex-fullview':(!isDisableWestPanel && !isPhone) }"
                [style.padding-top.px]="northPanelHeight">
                <ng-content select="amexio-homepage-centerpanel">
                </ng-content>
            </div>
        </div>
    </div>
  `,
            },] },
];
/** @nocollapse */
AmexioHomePageComponent.ctorParameters = () => [
    { type: DeviceQueryService }
];
AmexioHomePageComponent.propDecorators = {
    type: [{ type: Input, args: ['type',] }],
    amexoHomePageNorthpanel: [{ type: ContentChild, args: [AmexioHomePageNorthPanelComponent,] }],
    sideNavList: [{ type: ContentChildren, args: [AmexioSideNavComponent, { descendants: true },] }],
    amexioHomePageWestPanelComponent: [{ type: ContentChild, args: [AmexioHomePageWestPanelComponent,] }],
    amexioNavBarComponent: [{ type: ContentChild, args: [AmexioNavBarComponent,] }]
};

/**
 * @license Angular v7.2.16
 * (c) 2010-2019 Google LLC. https://angular.io/
 * License: MIT
 */

/**
 * An injectable service that produces an animation sequence programmatically within an
 * Angular component or directive.
 * Provided by the `BrowserAnimationsModule` or `NoopAnimationsModule`.
 *
 * @usageNotes
 *
 * To use this service, add it to your component or directive as a dependency.
 * The service is instantiated along with your component.
 *
 * Apps do not typically need to create their own animation players, but if you
 * do need to, follow these steps:
 *
 * 1. Use the `build()` method to create a programmatic animation using the
 * `animate()` function. The method returns an `AnimationFactory` instance.
 *
 * 2. Use the factory object to create an `AnimationPlayer` and attach it to a DOM element.
 *
 * 3. Use the player object to control the animation programmatically.
 *
 * For example:
 *
 * ```ts
 * // import the service from BrowserAnimationsModule
 * import {AnimationBuilder} from '@angular/animations';
 * // require the service as a dependency
 * class MyCmp {
 *   constructor(private _builder: AnimationBuilder) {}
 *
 *   makeAnimation(element: any) {
 *     // first define a reusable animation
 *     const myAnimation = this._builder.build([
 *       style({ width: 0 }),
 *       animate(1000, style({ width: '100px' }))
 *     ]);
 *
 *     // use the returned factory object to create a player
 *     const player = myAnimation.create(element);
 *
 *     player.play();
 *   }
 * }
 * ```
 *
 * @publicApi
 */
/**
 * Creates a named animation trigger, containing a  list of `state()`
 * and `transition()` entries to be evaluated when the expression
 * bound to the trigger changes.
 *
 * @param name An identifying string.
 * @param definitions  An animation definition object, containing an array of `state()`
 * and `transition()` declarations.
 *
 * @return An object that encapsulates the trigger data.
 *
 * @usageNotes
 * Define an animation trigger in the `animations` section of `@Component` metadata.
 * In the template, reference the trigger by name and bind it to a trigger expression that
 * evaluates to a defined animation state, using the following format:
 *
 * `[@triggerName]="expression"`
 *
 * Animation trigger bindings convert all values to strings, and then match the
 * previous and current values against any linked transitions.
 * Booleans can be specified as `1` or `true` and `0` or `false`.
 *
 * ### Usage Example
 *
 * The following example creates an animation trigger reference based on the provided
 * name value.
 * The provided animation value is expected to be an array consisting of state and
 * transition declarations.
 *
 * ```typescript
 * @Component({
 *   selector: "my-component",
 *   templateUrl: "my-component-tpl.html",
 *   animations: [
 *     trigger("myAnimationTrigger", [
 *       state(...),
 *       state(...),
 *       transition(...),
 *       transition(...)
 *     ])
 *   ]
 * })
 * class MyComponent {
 *   myStatusExp = "something";
 * }
 * ```
 *
 * The template associated with this component makes use of the defined trigger
 * by binding to an element within its template code.
 *
 * ```html
 * <!-- somewhere inside of my-component-tpl.html -->
 * <div [@myAnimationTrigger]="myStatusExp">...</div>
 * ```
 *
 * ### Using an inline function
 * The `transition` animation method also supports reading an inline function which can decide
 * if its associated animation should be run.
 *
 * ```typescript
 * // this method is run each time the `myAnimationTrigger` trigger value changes.
 * function myInlineMatcherFn(fromState: string, toState: string, element: any, params: {[key:
 string]: any}): boolean {
 *   // notice that `element` and `params` are also available here
 *   return toState == 'yes-please-animate';
 * }
 *
 * @Component({
 *   selector: 'my-component',
 *   templateUrl: 'my-component-tpl.html',
 *   animations: [
 *     trigger('myAnimationTrigger', [
 *       transition(myInlineMatcherFn, [
 *         // the animation sequence code
 *       ]),
 *     ])
 *   ]
 * })
 * class MyComponent {
 *   myStatusExp = "yes-please-animate";
 * }
 * ```
 *
 * ### Disabling Animations
 * When true, the special animation control binding `@.disabled` binding prevents
 * all animations from rendering.
 * Place the  `@.disabled` binding on an element to disable
 * animations on the element itself, as well as any inner animation triggers
 * within the element.
 *
 * The following example shows how to use this feature:
 *
 * ```typescript
 * @Component({
 *   selector: 'my-component',
 *   template: `
 *     <div [@.disabled]="isDisabled">
 *       <div [@childAnimation]="exp"></div>
 *     </div>
 *   `,
 *   animations: [
 *     trigger("childAnimation", [
 *       // ...
 *     ])
 *   ]
 * })
 * class MyComponent {
 *   isDisabled = true;
 *   exp = '...';
 * }
 * ```
 *
 * When `@.disabled` is true, it prevents the `@childAnimation` trigger from animating,
 * along with any inner animations.
 *
 * ### Disable animations application-wide
 * When an area of the template is set to have animations disabled,
 * **all** inner components have their animations disabled as well.
 * This means that you can disable all animations for an app
 * by placing a host binding set on `@.disabled` on the topmost Angular component.
 *
 * ```typescript
 * import {Component, HostBinding} from '@angular/core';
 *
 * @Component({
 *   selector: 'app-component',
 *   templateUrl: 'app.component.html',
 * })
 * class AppComponent {
 *   @HostBinding('@.disabled')
 *   public animationsDisabled = true;
 * }
 * ```
 *
 * ### Overriding disablement of inner animations
 * Despite inner animations being disabled, a parent animation can `query()`
 * for inner elements located in disabled areas of the template and still animate
 * them if needed. This is also the case for when a sub animation is
 * queried by a parent and then later animated using `animateChild()`.
 *
 * ### Detecting when an animation is disabled
 * If a region of the DOM (or the entire application) has its animations disabled, the animation
 * trigger callbacks still fire, but for zero seconds. When the callback fires, it provides
 * an instance of an `AnimationEvent`. If animations are disabled,
 * the `.disabled` flag on the event is true.
 *
 * @publicApi
 */
function trigger(name, definitions) {
    return { type: 7 /* Trigger */, name: name, definitions: definitions, options: {} };
}
/**
 * Defines an animation step that combines styling information with timing information.
 *
 * @param timings Sets `AnimateTimings` for the parent animation.
 * A string in the format "duration [delay] [easing]".
 *  - Duration and delay are expressed as a number and optional time unit,
 * such as "1s" or "10ms" for one second and 10 milliseconds, respectively.
 * The default unit is milliseconds.
 *  - The easing value controls how the animation accelerates and decelerates
 * during its runtime. Value is one of  `ease`, `ease-in`, `ease-out`,
 * `ease-in-out`, or a `cubic-bezier()` function call.
 * If not supplied, no easing is applied.
 *
 * For example, the string "1s 100ms ease-out" specifies a duration of
 * 1000 milliseconds, and delay of 100 ms, and the "ease-out" easing style,
 * which decelerates near the end of the duration.
 * @param styles Sets AnimationStyles for the parent animation.
 * A function call to either `style()` or `keyframes()`
 * that returns a collection of CSS style entries to be applied to the parent animation.
 * When null, uses the styles from the destination state.
 * This is useful when describing an animation step that will complete an animation;
 * see "Animating to the final state" in `transitions()`.
 * @returns An object that encapsulates the animation step.
 *
 * @usageNotes
 * Call within an animation `sequence()`, `{@link animations/group group()}`, or
 * `transition()` call to specify an animation step
 * that applies given style data to the parent animation for a given amount of time.
 *
 * ### Syntax Examples
 * **Timing examples**
 *
 * The following examples show various `timings` specifications.
 * - `animate(500)` : Duration is 500 milliseconds.
 * - `animate("1s")` : Duration is 1000 milliseconds.
 * - `animate("100ms 0.5s")` : Duration is 100 milliseconds, delay is 500 milliseconds.
 * - `animate("5s ease-in")` : Duration is 5000 milliseconds, easing in.
 * - `animate("5s 10ms cubic-bezier(.17,.67,.88,.1)")` : Duration is 5000 milliseconds, delay is 10
 * milliseconds, easing according to a bezier curve.
 *
 * **Style examples**
 *
 * The following example calls `style()` to set a single CSS style.
 * ```typescript
 * animate(500, style({ background: "red" }))
 * ```
 * The following example calls `keyframes()` to set a CSS style
 * to different values for successive keyframes.
 * ```typescript
 * animate(500, keyframes(
 *  [
 *   style({ background: "blue" })),
 *   style({ background: "red" }))
 *  ])
 * ```
 *
 * @publicApi
 */
function animate(timings, styles) {
    if (styles === void 0) { styles = null; }
    return { type: 4 /* Animate */, styles: styles, timings: timings };
}
/**
 * Declares a key/value object containing CSS properties/styles that
 * can then be used for an animation `state`, within an animation `sequence`,
 * or as styling data for calls to `animate()` and `keyframes()`.
 *
 * @param tokens A set of CSS styles or HTML styles associated with an animation state.
 * The value can be any of the following:
 * - A key-value style pair associating a CSS property with a value.
 * - An array of key-value style pairs.
 * - An asterisk (*), to use auto-styling, where styles are derived from the element
 * being animated and applied to the animation when it starts.
 *
 * Auto-styling can be used to define a state that depends on layout or other
 * environmental factors.
 *
 * @return An object that encapsulates the style data.
 *
 * @usageNotes
 * The following examples create animation styles that collect a set of
 * CSS property values:
 *
 * ```typescript
 * // string values for CSS properties
 * style({ background: "red", color: "blue" })
 *
 * // numerical pixel values
 * style({ width: 100, height: 0 })
 * ```
 *
 * The following example uses auto-styling to allow a component to animate from
 * a height of 0 up to the height of the parent element:
 *
 * ```
 * style({ height: 0 }),
 * animate("1s", style({ height: "*" }))
 * ```
 *
 * @publicApi
 **/
function style(tokens) {
    return { type: 6 /* Style */, styles: tokens, offset: null };
}
/**
 * Declares an animation state within a trigger attached to an element.
 *
 * @param name One or more names for the defined state in a comma-separated string.
 * The following reserved state names can be supplied to define a style for specific use
 * cases:
 *
 * - `void` You can associate styles with this name to be used when
 * the element is detached from the application. For example, when an `ngIf` evaluates
 * to false, the state of the associated element is void.
 *  - `*` (asterisk) Indicates the default state. You can associate styles with this name
 * to be used as the fallback when the state that is being animated is not declared
 * within the trigger.
 *
 * @param styles A set of CSS styles associated with this state, created using the
 * `style()` function.
 * This set of styles persists on the element once the state has been reached.
 * @param options Parameters that can be passed to the state when it is invoked.
 * 0 or more key-value pairs.
 * @return An object that encapsulates the new state data.
 *
 * @usageNotes
 * Use the `trigger()` function to register states to an animation trigger.
 * Use the `transition()` function to animate between states.
 * When a state is active within a component, its associated styles persist on the element,
 * even when the animation ends.
 *
 * @publicApi
 **/
function state(name, styles, options) {
    return { type: 0 /* State */, name: name, styles: styles, options: options };
}
/**
 * Declares an animation transition as a sequence of animation steps to run when a given
 * condition is satisfied. The condition is a Boolean expression or function that compares
 * the previous and current animation states, and returns true if this transition should occur.
 * When the state criteria of a defined transition are met, the associated animation is
 * triggered.
 *
 * @param stateChangeExpr A Boolean expression or function that compares the previous and current
 * animation states, and returns true if this transition should occur. Note that  "true" and "false"
 * match 1 and 0, respectively. An expression is evaluated each time a state change occurs in the
 * animation trigger element.
 * The animation steps run when the expression evaluates to true.
 *
 * - A state-change string takes the form "state1 => state2", where each side is a defined animation
 * state, or an asterix (*) to refer to a dynamic start or end state.
 *   - The expression string can contain multiple comma-separated statements;
 * for example "state1 => state2, state3 => state4".
 *   - Special values `:enter` and `:leave` initiate a transition on the entry and exit states,
 * equivalent to  "void => *"  and "* => void".
 *   - Special values `:increment` and `:decrement` initiate a transition when a numeric value has
 * increased or decreased in value.
 * - A function is executed each time a state change occurs in the animation trigger element.
 * The animation steps run when the function returns true.
 *
 * @param steps One or more animation objects, as returned by the `animate()` or
 * `sequence()` function, that form a transformation from one state to another.
 * A sequence is used by default when you pass an array.
 * @param options An options object that can contain a delay value for the start of the animation,
 * and additional developer-defined parameters. Provided values for additional parameters are used
 * as defaults, and override values can be passed to the caller on invocation.
 * @returns An object that encapsulates the transition data.
 *
 * @usageNotes
 * The template associated with a component binds an animation trigger to an element.
 *
 * ```HTML
 * <!-- somewhere inside of my-component-tpl.html -->
 * <div [@myAnimationTrigger]="myStatusExp">...</div>
 * ```
 *
 * All transitions are defined within an animation trigger,
 * along with named states that the transitions change to and from.
 *
 * ```typescript
 * trigger("myAnimationTrigger", [
 *  // define states
 *  state("on", style({ background: "green" })),
 *  state("off", style({ background: "grey" })),
 *  ...]
 * ```
 *
 * Note that when you call the `sequence()` function within a `{@link animations/group group()}`
 * or a `transition()` call, execution does not continue to the next instruction
 * until each of the inner animation steps have completed.
 *
 * ### Syntax examples
 *
 * The following examples define transitions between the two defined states (and default states),
 * using various options:
 *
 * ```typescript
 * // Transition occurs when the state value
 * // bound to "myAnimationTrigger" changes from "on" to "off"
 * transition("on => off", animate(500))
 * // Run the same animation for both directions
 * transition("on <=> off", animate(500))
 * // Define multiple state-change pairs separated by commas
 * transition("on => off, off => void", animate(500))
 * ```
 *
 * ### Special values for state-change expressions
 *
 * - Catch-all state change for when an element is inserted into the page and the
 * destination state is unknown:
 *
 * ```typescript
 * transition("void => *", [
 *  style({ opacity: 0 }),
 *  animate(500)
 *  ])
 * ```
 *
 * - Capture a state change between any states:
 *
 *  `transition("* => *", animate("1s 0s"))`
 *
 * - Entry and exit transitions:
 *
 * ```typescript
 * transition(":enter", [
 *   style({ opacity: 0 }),
 *   animate(500, style({ opacity: 1 }))
 *   ]),
 * transition(":leave", [
 *   animate(500, style({ opacity: 0 }))
 *   ])
 * ```
 *
 * - Use `:increment` and `:decrement` to initiate transitions:
 *
 * ```typescript
 * transition(":increment", group([
 *  query(':enter', [
 *     style({ left: '100%' }),
 *     animate('0.5s ease-out', style('*'))
 *   ]),
 *  query(':leave', [
 *     animate('0.5s ease-out', style({ left: '-100%' }))
 *  ])
 * ]))
 *
 * transition(":decrement", group([
 *  query(':enter', [
 *     style({ left: '100%' }),
 *     animate('0.5s ease-out', style('*'))
 *   ]),
 *  query(':leave', [
 *     animate('0.5s ease-out', style({ left: '-100%' }))
 *  ])
 * ]))
 * ```
 *
 * ### State-change functions
 *
 * Here is an example of a `fromState` specified as a state-change function that invokes an
 * animation when true:
 *
 * ```typescript
 * transition((fromState, toState) =>
 *  {
 *   return fromState == "off" && toState == "on";
 *  },
 *  animate("1s 0s"))
 * ```
 *
 * ### Animating to the final state
 *
 * If the final step in a transition is a call to `animate()` that uses a timing value
 * with no style data, that step is automatically considered the final animation arc,
 * for the element to reach the final state. Angular automatically adds or removes
 * CSS styles to ensure that the element is in the correct final state.
 *
 * The following example defines a transition that starts by hiding the element,
 * then makes sure that it animates properly to whatever state is currently active for trigger:
 *
 * ```typescript
 * transition("void => *", [
 *   style({ opacity: 0 }),
 *   animate(500)
 *  ])
 * ```
 * ### Boolean value matching
 * If a trigger binding value is a Boolean, it can be matched using a transition expression
 * that compares true and false or 1 and 0. For example:
 *
 * ```
 * // in the template
 * <div [@openClose]="open ? true : false">...</div>
 * // in the component metadata
 * trigger('openClose', [
 *   state('true', style({ height: '*' })),
 *   state('false', style({ height: '0px' })),
 *   transition('false <=> true', animate(500))
 * ])
 * ```
 *
 * @publicApi
 **/
function transition(stateChangeExpr, steps, options) {
    if (options === void 0) { options = null; }
    return { type: 1 /* Transition */, expr: stateChangeExpr, animation: steps, options: options };
}
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
function scheduleMicroTask(cb) {
    Promise.resolve(null).then(cb);
}

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * An empty programmatic controller for reusable animations.
 * Used internally when animations are disabled, to avoid
 * checking for the null case when an animation player is expected.
 *
 * @see `animate()`
 * @see `AnimationPlayer`
 * @see `GroupPlayer`
 *
 * @publicApi
 */
var NoopAnimationPlayer = /** @class */ (function () {
    function NoopAnimationPlayer(duration, delay) {
        if (duration === void 0) { duration = 0; }
        if (delay === void 0) { delay = 0; }
        this._onDoneFns = [];
        this._onStartFns = [];
        this._onDestroyFns = [];
        this._started = false;
        this._destroyed = false;
        this._finished = false;
        this.parentPlayer = null;
        this.totalTime = duration + delay;
    }
    NoopAnimationPlayer.prototype._onFinish = function () {
        if (!this._finished) {
            this._finished = true;
            this._onDoneFns.forEach(function (fn) { return fn(); });
            this._onDoneFns = [];
        }
    };
    NoopAnimationPlayer.prototype.onStart = function (fn) { this._onStartFns.push(fn); };
    NoopAnimationPlayer.prototype.onDone = function (fn) { this._onDoneFns.push(fn); };
    NoopAnimationPlayer.prototype.onDestroy = function (fn) { this._onDestroyFns.push(fn); };
    NoopAnimationPlayer.prototype.hasStarted = function () { return this._started; };
    NoopAnimationPlayer.prototype.init = function () { };
    NoopAnimationPlayer.prototype.play = function () {
        if (!this.hasStarted()) {
            this._onStart();
            this.triggerMicrotask();
        }
        this._started = true;
    };
    /** @internal */
    NoopAnimationPlayer.prototype.triggerMicrotask = function () {
        var _this = this;
        scheduleMicroTask(function () { return _this._onFinish(); });
    };
    NoopAnimationPlayer.prototype._onStart = function () {
        this._onStartFns.forEach(function (fn) { return fn(); });
        this._onStartFns = [];
    };
    NoopAnimationPlayer.prototype.pause = function () { };
    NoopAnimationPlayer.prototype.restart = function () { };
    NoopAnimationPlayer.prototype.finish = function () { this._onFinish(); };
    NoopAnimationPlayer.prototype.destroy = function () {
        if (!this._destroyed) {
            this._destroyed = true;
            if (!this.hasStarted()) {
                this._onStart();
            }
            this.finish();
            this._onDestroyFns.forEach(function (fn) { return fn(); });
            this._onDestroyFns = [];
        }
    };
    NoopAnimationPlayer.prototype.reset = function () { };
    NoopAnimationPlayer.prototype.setPosition = function (position) { };
    NoopAnimationPlayer.prototype.getPosition = function () { return 0; };
    /** @internal */
    NoopAnimationPlayer.prototype.triggerCallback = function (phaseName) {
        var methods = phaseName == 'start' ? this._onStartFns : this._onDoneFns;
        methods.forEach(function (fn) { return fn(); });
        methods.length = 0;
    };
    return NoopAnimationPlayer;
}());

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * A programmatic controller for a group of reusable animations.
 * Used internally to control animations.
 *
 * @see `AnimationPlayer`
 * @see `{@link animations/group group()}`
 *
 */
var AnimationGroupPlayer = /** @class */ (function () {
    function AnimationGroupPlayer(_players) {
        var _this = this;
        this._onDoneFns = [];
        this._onStartFns = [];
        this._finished = false;
        this._started = false;
        this._destroyed = false;
        this._onDestroyFns = [];
        this.parentPlayer = null;
        this.totalTime = 0;
        this.players = _players;
        var doneCount = 0;
        var destroyCount = 0;
        var startCount = 0;
        var total = this.players.length;
        if (total == 0) {
            scheduleMicroTask(function () { return _this._onFinish(); });
        }
        else {
            this.players.forEach(function (player) {
                player.onDone(function () {
                    if (++doneCount == total) {
                        _this._onFinish();
                    }
                });
                player.onDestroy(function () {
                    if (++destroyCount == total) {
                        _this._onDestroy();
                    }
                });
                player.onStart(function () {
                    if (++startCount == total) {
                        _this._onStart();
                    }
                });
            });
        }
        this.totalTime = this.players.reduce(function (time, player) { return Math.max(time, player.totalTime); }, 0);
    }
    AnimationGroupPlayer.prototype._onFinish = function () {
        if (!this._finished) {
            this._finished = true;
            this._onDoneFns.forEach(function (fn) { return fn(); });
            this._onDoneFns = [];
        }
    };
    AnimationGroupPlayer.prototype.init = function () { this.players.forEach(function (player) { return player.init(); }); };
    AnimationGroupPlayer.prototype.onStart = function (fn) { this._onStartFns.push(fn); };
    AnimationGroupPlayer.prototype._onStart = function () {
        if (!this.hasStarted()) {
            this._started = true;
            this._onStartFns.forEach(function (fn) { return fn(); });
            this._onStartFns = [];
        }
    };
    AnimationGroupPlayer.prototype.onDone = function (fn) { this._onDoneFns.push(fn); };
    AnimationGroupPlayer.prototype.onDestroy = function (fn) { this._onDestroyFns.push(fn); };
    AnimationGroupPlayer.prototype.hasStarted = function () { return this._started; };
    AnimationGroupPlayer.prototype.play = function () {
        if (!this.parentPlayer) {
            this.init();
        }
        this._onStart();
        this.players.forEach(function (player) { return player.play(); });
    };
    AnimationGroupPlayer.prototype.pause = function () { this.players.forEach(function (player) { return player.pause(); }); };
    AnimationGroupPlayer.prototype.restart = function () { this.players.forEach(function (player) { return player.restart(); }); };
    AnimationGroupPlayer.prototype.finish = function () {
        this._onFinish();
        this.players.forEach(function (player) { return player.finish(); });
    };
    AnimationGroupPlayer.prototype.destroy = function () { this._onDestroy(); };
    AnimationGroupPlayer.prototype._onDestroy = function () {
        if (!this._destroyed) {
            this._destroyed = true;
            this._onFinish();
            this.players.forEach(function (player) { return player.destroy(); });
            this._onDestroyFns.forEach(function (fn) { return fn(); });
            this._onDestroyFns = [];
        }
    };
    AnimationGroupPlayer.prototype.reset = function () {
        this.players.forEach(function (player) { return player.reset(); });
        this._destroyed = false;
        this._finished = false;
        this._started = false;
    };
    AnimationGroupPlayer.prototype.setPosition = function (p) {
        var timeAtPosition = p * this.totalTime;
        this.players.forEach(function (player) {
            var position = player.totalTime ? Math.min(1, timeAtPosition / player.totalTime) : 1;
            player.setPosition(position);
        });
    };
    AnimationGroupPlayer.prototype.getPosition = function () {
        var min = 0;
        this.players.forEach(function (player) {
            var p = player.getPosition();
            min = Math.min(p, min);
        });
        return min;
    };
    AnimationGroupPlayer.prototype.beforeDestroy = function () {
        this.players.forEach(function (player) {
            if (player.beforeDestroy) {
                player.beforeDestroy();
            }
        });
    };
    /** @internal */
    AnimationGroupPlayer.prototype.triggerCallback = function (phaseName) {
        var methods = phaseName == 'start' ? this._onStartFns : this._onDoneFns;
        methods.forEach(function (fn) { return fn(); });
        methods.length = 0;
    };
    return AnimationGroupPlayer;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 * Copyright [2019] [Metamagic]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Created by pratik on 18/12/17.
 */
class AmexioFooterComponent {
    constructor() {
        this.className = 'modal-window-footer';
        this.footer = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.setFooterAlignment(this.footeralign);
    }
    /**
     * @param {?} footeralign
     * @return {?}
     */
    setFooterAlignment(footeralign) {
        switch (footeralign) {
            case 'right': {
                this.alignClass = 'flex-end';
                break;
            }
            case 'center': {
                this.alignClass = 'center';
                break;
            }
            case 'left': {
                this.alignClass = 'flex-start';
                break;
            }
            default: {
                this.alignClass = 'flex-end';
                break;
            }
        }
    }
}
AmexioFooterComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-action', template: `
    <ng-container *ngIf="footer">
      <ng-content></ng-content>
    </ng-container>
  `,
            },] },
];
/** @nocollapse */
AmexioFooterComponent.ctorParameters = () => [];
AmexioFooterComponent.propDecorators = {
    className: [{ type: HostBinding, args: ['attr.class',] }],
    footeralign: [{ type: Input, args: ['footer-align',] }],
    alignClass: [{ type: HostBinding, args: ['style.justify-content',] }],
    padding: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 * Copyright [2019] [Metamagic]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Created by pratik on 18/12/17.
 */
class AmexioBodyComponent {
    constructor() {
        this.className = 'window-middle';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.height = this.bodyHeight + '%';
    }
}
AmexioBodyComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-body', template: `
    <ng-content></ng-content>
  `
            },] },
];
/** @nocollapse */
AmexioBodyComponent.ctorParameters = () => [];
AmexioBodyComponent.propDecorators = {
    height: [{ type: HostBinding, args: ['style.height',] }],
    className: [{ type: HostBinding, args: ['attr.class',] }],
    bodyHeight: [{ type: Input, args: ['body-height',] }],
    padding: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 Component Name : Amexio Carousel
 Component Selector : <[amexioTemplate]>
 Component Description : Amexio CarouselView displays a collection of
 images or other content in a horizontal layout with built-in navigation between the items.

*/
class AmexioTemplateDirective {
    /**
     * @param {?} template
     */
    constructor(template) {
        this.template = template;
    }
    /**
     * @return {?}
     */
    getType() {
        return this.name;
    }
}
AmexioTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: '[amexioTemplate]',
            },] },
];
/** @nocollapse */
AmexioTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
AmexioTemplateDirective.propDecorators = {
    type: [{ type: Input }],
    name: [{ type: Input, args: ['amexioTemplate',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by pratik on 28/12/17.
*/
class AmexioCarouselComponent {
    constructor() {
        // @ViewChild('kk') kk: ElementRef;
        this.prevImage = -1;
        this.nextImage = -1;
        this.currImage = 0;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.startTimeInterval();
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.templates.forEach((/**
         * @param {?} item
         * @return {?}
         */
        (item) => {
            this.itemTemplate = item.template;
        }));
    }
    /**
     * @return {?}
     */
    scrollData() {
    }
    /**
     * @return {?}
     */
    next() {
        /** @type {?} */
        const nxt = this.tabs.nativeElement;
        nxt.scrollLeft = nxt.scrollLeft + 200;
    }
    /**
     * @return {?}
     */
    previous() {
        /** @type {?} */
        const prev = this.tabs.nativeElement;
        prev.scrollLeft = prev.scrollLeft - 200;
    }
    /**
     * @return {?}
     */
    shuffle() {
    }
    /**
     * @param {?} item
     * @return {?}
     */
    onArrowRight(item) {
        if (this.data.length - 1 > item) {
            /** @type {?} */
            const currentitem = item + 1;
            /** @type {?} */
            const itemId = this.header + currentitem;
            document.getElementById(itemId).focus();
        }
    }
    /**
     * @param {?} item
     * @return {?}
     */
    onArrowLeft(item) {
        if (item > 0) {
            /** @type {?} */
            const currentitem = item - 1;
            /** @type {?} */
            const itemId = this.header + currentitem;
            document.getElementById(itemId).focus();
        }
    }
    /**
     * @return {?}
     */
    startTimeInterval() {
        if (this.shuffleinterval != null) {
            this.timeInterval = setInterval((/**
             * @return {?}
             */
            () => {
                /** @type {?} */
                const carouselItemPosix = this.tabs.nativeElement;
                if (((carouselItemPosix.scrollWidth - carouselItemPosix.offsetWidth - carouselItemPosix.scrollLeft) > 0)) {
                    // go next
                    carouselItemPosix.scrollLeft = carouselItemPosix.scrollLeft + 200;
                }
                else if (carouselItemPosix.scrollLeft > 0) {
                    // go previous
                    carouselItemPosix.scrollLeft = 0;
                }
            }), this.shuffleinterval);
        }
    }
    /**
     * @return {?}
     */
    stopTimeInterval() {
        clearTimeout(this.timeInterval);
    }
}
AmexioCarouselComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-carousel',
                template: `
    <h4>{{header}}</h4>
    <div class="tabwrapper">
      <div class="carouselnavigation float-left" (click)="previous()">
        <amexio-c-icon key="carousel_previous"></amexio-c-icon>
      </div>
      <div class="carouselnavigation float-right" (click)="next()">
        <amexio-c-icon key="carousel_next"></amexio-c-icon>
      </div>
      <ul #tab class="tab">
        <li attr.aria-label="'carousel {{rowno}}'" tabindex="1" id="{{header}}{{rowno}}" class="tablistitems" *ngFor="let item of data let rowno= index" [ngClass]="{'list-carousel-items':item.isSelected}"
          (mouseover)="stopTimeInterval()" (mouseleave)="startTimeInterval()" (keyup.arrowleft)="onArrowLeft(rowno)"
          (keyup.arrowright)="onArrowRight(rowno)">
          <ng-template tabindex="1" [amexioTemplateWrapper]="itemTemplate" [item]="item"></ng-template>
        </li>
      </ul>
    </div>
  `,
            },] },
];
/** @nocollapse */
AmexioCarouselComponent.ctorParameters = () => [];
AmexioCarouselComponent.propDecorators = {
    header: [{ type: Input }],
    data: [{ type: Input }],
    shuffleinterval: [{ type: Input, args: ['shuffle-interval',] }],
    templates: [{ type: ContentChildren, args: [AmexioTemplateDirective,] }],
    tabs: [{ type: ViewChild, args: ['tab', { read: ElementRef },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AmexioTemplateWrapperDirective {
    /**
     * @param {?} viewContainer
     */
    constructor(viewContainer) {
        this.viewContainer = viewContainer;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.render();
    }
    /**
     * @param {?} item
     * @return {?}
     */
    set item(item) {
        this._item = item;
        if (this.view) {
            this.view.destroy();
            this.render();
        }
    }
    /*
      Properties
      name : get item
      datatype :   any
      version : 4.0 onwards
      default : none
      description : gets the carousel item
      */
    /**
     * @return {?}
     */
    get item() {
        return this._item;
    }
    /**
     * @return {?}
     */
    render() {
        this.view = this.viewContainer.createEmbeddedView(this.templateRef, {
            $implicit: this.item, index: this.index,
        });
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.view.destroy();
    }
}
AmexioTemplateWrapperDirective.decorators = [
    { type: Directive, args: [{
                selector: '[amexioTemplateWrapper]',
            },] },
];
/** @nocollapse */
AmexioTemplateWrapperDirective.ctorParameters = () => [
    { type: ViewContainerRef }
];
AmexioTemplateWrapperDirective.propDecorators = {
    index: [{ type: Input }],
    templateRef: [{ type: Input, args: ['amexioTemplateWrapper',] }],
    item: [{ type: Input }]
};

var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};



function unwrapExports (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var isFunction_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function isFunction(x) {
    return typeof x === 'function';
}
exports.isFunction = isFunction;

});

unwrapExports(isFunction_1);

var config$1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _enable_super_gross_mode_that_will_cause_bad_things = false;
exports.config = {
    Promise: undefined,
    set useDeprecatedSynchronousErrorHandling(value) {
        if (value) {
            var error = new Error();
            console.warn('DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n' + error.stack);
        }
        else if (_enable_super_gross_mode_that_will_cause_bad_things) {
            console.log('RxJS: Back to a better error behavior. Thank you. <3');
        }
        _enable_super_gross_mode_that_will_cause_bad_things = value;
    },
    get useDeprecatedSynchronousErrorHandling() {
        return _enable_super_gross_mode_that_will_cause_bad_things;
    },
};

});

unwrapExports(config$1);

var hostReportError_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function hostReportError(err) {
    setTimeout(function () { throw err; }, 0);
}
exports.hostReportError = hostReportError;

});

unwrapExports(hostReportError_1);

var Observer = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });


exports.empty = {
    closed: true,
    next: function (value) { },
    error: function (err) {
        if (config$1.config.useDeprecatedSynchronousErrorHandling) {
            throw err;
        }
        else {
            hostReportError_1.hostReportError(err);
        }
    },
    complete: function () { }
};

});

unwrapExports(Observer);

var isArray$1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isArray = (function () { return Array.isArray || (function (x) { return x && typeof x.length === 'number'; }); })();

});

unwrapExports(isArray$1);

var isObject_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function isObject(x) {
    return x !== null && typeof x === 'object';
}
exports.isObject = isObject;

});

unwrapExports(isObject_1);

var UnsubscriptionError$1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var UnsubscriptionErrorImpl = (function () {
    function UnsubscriptionErrorImpl(errors) {
        Error.call(this);
        this.message = errors ?
            errors.length + " errors occurred during unsubscription:\n" + errors.map(function (err, i) { return i + 1 + ") " + err.toString(); }).join('\n  ') : '';
        this.name = 'UnsubscriptionError';
        this.errors = errors;
        return this;
    }
    UnsubscriptionErrorImpl.prototype = Object.create(Error.prototype);
    return UnsubscriptionErrorImpl;
})();
exports.UnsubscriptionError = UnsubscriptionErrorImpl;

});

unwrapExports(UnsubscriptionError$1);

var Subscription_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });




var Subscription = (function () {
    function Subscription(unsubscribe) {
        this.closed = false;
        this._parentOrParents = null;
        this._subscriptions = null;
        if (unsubscribe) {
            this._unsubscribe = unsubscribe;
        }
    }
    Subscription.prototype.unsubscribe = function () {
        var errors;
        if (this.closed) {
            return;
        }
        var _a = this, _parentOrParents = _a._parentOrParents, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
        this.closed = true;
        this._parentOrParents = null;
        this._subscriptions = null;
        if (_parentOrParents instanceof Subscription) {
            _parentOrParents.remove(this);
        }
        else if (_parentOrParents !== null) {
            for (var index = 0; index < _parentOrParents.length; ++index) {
                var parent_1 = _parentOrParents[index];
                parent_1.remove(this);
            }
        }
        if (isFunction_1.isFunction(_unsubscribe)) {
            try {
                _unsubscribe.call(this);
            }
            catch (e) {
                errors = e instanceof UnsubscriptionError$1.UnsubscriptionError ? flattenUnsubscriptionErrors(e.errors) : [e];
            }
        }
        if (isArray$1.isArray(_subscriptions)) {
            var index = -1;
            var len = _subscriptions.length;
            while (++index < len) {
                var sub = _subscriptions[index];
                if (isObject_1.isObject(sub)) {
                    try {
                        sub.unsubscribe();
                    }
                    catch (e) {
                        errors = errors || [];
                        if (e instanceof UnsubscriptionError$1.UnsubscriptionError) {
                            errors = errors.concat(flattenUnsubscriptionErrors(e.errors));
                        }
                        else {
                            errors.push(e);
                        }
                    }
                }
            }
        }
        if (errors) {
            throw new UnsubscriptionError$1.UnsubscriptionError(errors);
        }
    };
    Subscription.prototype.add = function (teardown) {
        var subscription = teardown;
        if (!teardown) {
            return Subscription.EMPTY;
        }
        switch (typeof teardown) {
            case 'function':
                subscription = new Subscription(teardown);
            case 'object':
                if (subscription === this || subscription.closed || typeof subscription.unsubscribe !== 'function') {
                    return subscription;
                }
                else if (this.closed) {
                    subscription.unsubscribe();
                    return subscription;
                }
                else if (!(subscription instanceof Subscription)) {
                    var tmp = subscription;
                    subscription = new Subscription();
                    subscription._subscriptions = [tmp];
                }
                break;
            default: {
                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
            }
        }
        var _parentOrParents = subscription._parentOrParents;
        if (_parentOrParents === null) {
            subscription._parentOrParents = this;
        }
        else if (_parentOrParents instanceof Subscription) {
            if (_parentOrParents === this) {
                return subscription;
            }
            subscription._parentOrParents = [_parentOrParents, this];
        }
        else if (_parentOrParents.indexOf(this) === -1) {
            _parentOrParents.push(this);
        }
        else {
            return subscription;
        }
        var subscriptions = this._subscriptions;
        if (subscriptions === null) {
            this._subscriptions = [subscription];
        }
        else {
            subscriptions.push(subscription);
        }
        return subscription;
    };
    Subscription.prototype.remove = function (subscription) {
        var subscriptions = this._subscriptions;
        if (subscriptions) {
            var subscriptionIndex = subscriptions.indexOf(subscription);
            if (subscriptionIndex !== -1) {
                subscriptions.splice(subscriptionIndex, 1);
            }
        }
    };
    Subscription.EMPTY = (function (empty) {
        empty.closed = true;
        return empty;
    }(new Subscription()));
    return Subscription;
}());
exports.Subscription = Subscription;
function flattenUnsubscriptionErrors(errors) {
    return errors.reduce(function (errs, err) { return errs.concat((err instanceof UnsubscriptionError$1.UnsubscriptionError) ? err.errors : err); }, []);
}

});

unwrapExports(Subscription_1);

var rxSubscriber$1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.rxSubscriber = (function () {
    return typeof Symbol === 'function'
        ? Symbol('rxSubscriber')
        : '@@rxSubscriber_' + Math.random();
})();
exports.$$rxSubscriber = exports.rxSubscriber;

});

unwrapExports(rxSubscriber$1);

var Subscriber_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });






var Subscriber = (function (_super) {
    __extends(Subscriber, _super);
    function Subscriber(destinationOrNext, error, complete) {
        var _this = _super.call(this) || this;
        _this.syncErrorValue = null;
        _this.syncErrorThrown = false;
        _this.syncErrorThrowable = false;
        _this.isStopped = false;
        switch (arguments.length) {
            case 0:
                _this.destination = Observer.empty;
                break;
            case 1:
                if (!destinationOrNext) {
                    _this.destination = Observer.empty;
                    break;
                }
                if (typeof destinationOrNext === 'object') {
                    if (destinationOrNext instanceof Subscriber) {
                        _this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;
                        _this.destination = destinationOrNext;
                        destinationOrNext.add(_this);
                    }
                    else {
                        _this.syncErrorThrowable = true;
                        _this.destination = new SafeSubscriber(_this, destinationOrNext);
                    }
                    break;
                }
            default:
                _this.syncErrorThrowable = true;
                _this.destination = new SafeSubscriber(_this, destinationOrNext, error, complete);
                break;
        }
        return _this;
    }
    Subscriber.prototype[rxSubscriber$1.rxSubscriber] = function () { return this; };
    Subscriber.create = function (next, error, complete) {
        var subscriber = new Subscriber(next, error, complete);
        subscriber.syncErrorThrowable = false;
        return subscriber;
    };
    Subscriber.prototype.next = function (value) {
        if (!this.isStopped) {
            this._next(value);
        }
    };
    Subscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            this.isStopped = true;
            this._error(err);
        }
    };
    Subscriber.prototype.complete = function () {
        if (!this.isStopped) {
            this.isStopped = true;
            this._complete();
        }
    };
    Subscriber.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
    };
    Subscriber.prototype._next = function (value) {
        this.destination.next(value);
    };
    Subscriber.prototype._error = function (err) {
        this.destination.error(err);
        this.unsubscribe();
    };
    Subscriber.prototype._complete = function () {
        this.destination.complete();
        this.unsubscribe();
    };
    Subscriber.prototype._unsubscribeAndRecycle = function () {
        var _parentOrParents = this._parentOrParents;
        this._parentOrParents = null;
        this.unsubscribe();
        this.closed = false;
        this.isStopped = false;
        this._parentOrParents = _parentOrParents;
        return this;
    };
    return Subscriber;
}(Subscription_1.Subscription));
exports.Subscriber = Subscriber;
var SafeSubscriber = (function (_super) {
    __extends(SafeSubscriber, _super);
    function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
        var _this = _super.call(this) || this;
        _this._parentSubscriber = _parentSubscriber;
        var next;
        var context = _this;
        if (isFunction_1.isFunction(observerOrNext)) {
            next = observerOrNext;
        }
        else if (observerOrNext) {
            next = observerOrNext.next;
            error = observerOrNext.error;
            complete = observerOrNext.complete;
            if (observerOrNext !== Observer.empty) {
                context = Object.create(observerOrNext);
                if (isFunction_1.isFunction(context.unsubscribe)) {
                    _this.add(context.unsubscribe.bind(context));
                }
                context.unsubscribe = _this.unsubscribe.bind(_this);
            }
        }
        _this._context = context;
        _this._next = next;
        _this._error = error;
        _this._complete = complete;
        return _this;
    }
    SafeSubscriber.prototype.next = function (value) {
        if (!this.isStopped && this._next) {
            var _parentSubscriber = this._parentSubscriber;
            if (!config$1.config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                this.__tryOrUnsub(this._next, value);
            }
            else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            var useDeprecatedSynchronousErrorHandling = config$1.config.useDeprecatedSynchronousErrorHandling;
            if (this._error) {
                if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(this._error, err);
                    this.unsubscribe();
                }
                else {
                    this.__tryOrSetError(_parentSubscriber, this._error, err);
                    this.unsubscribe();
                }
            }
            else if (!_parentSubscriber.syncErrorThrowable) {
                this.unsubscribe();
                if (useDeprecatedSynchronousErrorHandling) {
                    throw err;
                }
                hostReportError_1.hostReportError(err);
            }
            else {
                if (useDeprecatedSynchronousErrorHandling) {
                    _parentSubscriber.syncErrorValue = err;
                    _parentSubscriber.syncErrorThrown = true;
                }
                else {
                    hostReportError_1.hostReportError(err);
                }
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.complete = function () {
        var _this = this;
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            if (this._complete) {
                var wrappedComplete = function () { return _this._complete.call(_this._context); };
                if (!config$1.config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(wrappedComplete);
                    this.unsubscribe();
                }
                else {
                    this.__tryOrSetError(_parentSubscriber, wrappedComplete);
                    this.unsubscribe();
                }
            }
            else {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
        try {
            fn.call(this._context, value);
        }
        catch (err) {
            this.unsubscribe();
            if (config$1.config.useDeprecatedSynchronousErrorHandling) {
                throw err;
            }
            else {
                hostReportError_1.hostReportError(err);
            }
        }
    };
    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
        if (!config$1.config.useDeprecatedSynchronousErrorHandling) {
            throw new Error('bad call');
        }
        try {
            fn.call(this._context, value);
        }
        catch (err) {
            if (config$1.config.useDeprecatedSynchronousErrorHandling) {
                parent.syncErrorValue = err;
                parent.syncErrorThrown = true;
                return true;
            }
            else {
                hostReportError_1.hostReportError(err);
                return true;
            }
        }
        return false;
    };
    SafeSubscriber.prototype._unsubscribe = function () {
        var _parentSubscriber = this._parentSubscriber;
        this._context = null;
        this._parentSubscriber = null;
        _parentSubscriber.unsubscribe();
    };
    return SafeSubscriber;
}(Subscriber));
exports.SafeSubscriber = SafeSubscriber;

});

unwrapExports(Subscriber_1);

var canReportError_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

function canReportError(observer) {
    while (observer) {
        var _a = observer, closed_1 = _a.closed, destination = _a.destination, isStopped = _a.isStopped;
        if (closed_1 || isStopped) {
            return false;
        }
        else if (destination && destination instanceof Subscriber_1.Subscriber) {
            observer = destination;
        }
        else {
            observer = null;
        }
    }
    return true;
}
exports.canReportError = canReportError;

});

unwrapExports(canReportError_1);

var toSubscriber_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });



function toSubscriber(nextOrObserver, error, complete) {
    if (nextOrObserver) {
        if (nextOrObserver instanceof Subscriber_1.Subscriber) {
            return nextOrObserver;
        }
        if (nextOrObserver[rxSubscriber$1.rxSubscriber]) {
            return nextOrObserver[rxSubscriber$1.rxSubscriber]();
        }
    }
    if (!nextOrObserver && !error && !complete) {
        return new Subscriber_1.Subscriber(Observer.empty);
    }
    return new Subscriber_1.Subscriber(nextOrObserver, error, complete);
}
exports.toSubscriber = toSubscriber;

});

unwrapExports(toSubscriber_1);

var observable$1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.observable = (function () { return typeof Symbol === 'function' && Symbol.observable || '@@observable'; })();

});

unwrapExports(observable$1);

var noop_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function noop() { }
exports.noop = noop;

});

unwrapExports(noop_1);

var pipe_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

function pipe() {
    var fns = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        fns[_i] = arguments[_i];
    }
    return pipeFromArray(fns);
}
exports.pipe = pipe;
function pipeFromArray(fns) {
    if (!fns) {
        return noop_1.noop;
    }
    if (fns.length === 1) {
        return fns[0];
    }
    return function piped(input) {
        return fns.reduce(function (prev, fn) { return fn(prev); }, input);
    };
}
exports.pipeFromArray = pipeFromArray;

});

unwrapExports(pipe_1);

var Observable_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });





var Observable = (function () {
    function Observable(subscribe) {
        this._isScalar = false;
        if (subscribe) {
            this._subscribe = subscribe;
        }
    }
    Observable.prototype.lift = function (operator) {
        var observable = new Observable();
        observable.source = this;
        observable.operator = operator;
        return observable;
    };
    Observable.prototype.subscribe = function (observerOrNext, error, complete) {
        var operator = this.operator;
        var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);
        if (operator) {
            sink.add(operator.call(sink, this.source));
        }
        else {
            sink.add(this.source || (config$1.config.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable) ?
                this._subscribe(sink) :
                this._trySubscribe(sink));
        }
        if (config$1.config.useDeprecatedSynchronousErrorHandling) {
            if (sink.syncErrorThrowable) {
                sink.syncErrorThrowable = false;
                if (sink.syncErrorThrown) {
                    throw sink.syncErrorValue;
                }
            }
        }
        return sink;
    };
    Observable.prototype._trySubscribe = function (sink) {
        try {
            return this._subscribe(sink);
        }
        catch (err) {
            if (config$1.config.useDeprecatedSynchronousErrorHandling) {
                sink.syncErrorThrown = true;
                sink.syncErrorValue = err;
            }
            if (canReportError_1.canReportError(sink)) {
                sink.error(err);
            }
            else {
                console.warn(err);
            }
        }
    };
    Observable.prototype.forEach = function (next, promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function (resolve, reject) {
            var subscription;
            subscription = _this.subscribe(function (value) {
                try {
                    next(value);
                }
                catch (err) {
                    reject(err);
                    if (subscription) {
                        subscription.unsubscribe();
                    }
                }
            }, reject, resolve);
        });
    };
    Observable.prototype._subscribe = function (subscriber) {
        var source = this.source;
        return source && source.subscribe(subscriber);
    };
    Observable.prototype[observable$1.observable] = function () {
        return this;
    };
    Observable.prototype.pipe = function () {
        var operations = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            operations[_i] = arguments[_i];
        }
        if (operations.length === 0) {
            return this;
        }
        return pipe_1.pipeFromArray(operations)(this);
    };
    Observable.prototype.toPromise = function (promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function (resolve, reject) {
            var value;
            _this.subscribe(function (x) { return value = x; }, function (err) { return reject(err); }, function () { return resolve(value); });
        });
    };
    Observable.create = function (subscribe) {
        return new Observable(subscribe);
    };
    return Observable;
}());
exports.Observable = Observable;
function getPromiseCtor(promiseCtor) {
    if (!promiseCtor) {
        promiseCtor = config$1.config.Promise || Promise;
    }
    if (!promiseCtor) {
        throw new Error('no Promise impl found');
    }
    return promiseCtor;
}

});

unwrapExports(Observable_1);

var ObjectUnsubscribedError$1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ObjectUnsubscribedErrorImpl = (function () {
    function ObjectUnsubscribedErrorImpl() {
        Error.call(this);
        this.message = 'object unsubscribed';
        this.name = 'ObjectUnsubscribedError';
        return this;
    }
    ObjectUnsubscribedErrorImpl.prototype = Object.create(Error.prototype);
    return ObjectUnsubscribedErrorImpl;
})();
exports.ObjectUnsubscribedError = ObjectUnsubscribedErrorImpl;

});

unwrapExports(ObjectUnsubscribedError$1);

var SubjectSubscription_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });

var SubjectSubscription = (function (_super) {
    __extends(SubjectSubscription, _super);
    function SubjectSubscription(subject, subscriber) {
        var _this = _super.call(this) || this;
        _this.subject = subject;
        _this.subscriber = subscriber;
        _this.closed = false;
        return _this;
    }
    SubjectSubscription.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.closed = true;
        var subject = this.subject;
        var observers = subject.observers;
        this.subject = null;
        if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
            return;
        }
        var subscriberIndex = observers.indexOf(this.subscriber);
        if (subscriberIndex !== -1) {
            observers.splice(subscriberIndex, 1);
        }
    };
    return SubjectSubscription;
}(Subscription_1.Subscription));
exports.SubjectSubscription = SubjectSubscription;

});

unwrapExports(SubjectSubscription_1);

var Subject_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });






var SubjectSubscriber = (function (_super) {
    __extends(SubjectSubscriber, _super);
    function SubjectSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        return _this;
    }
    return SubjectSubscriber;
}(Subscriber_1.Subscriber));
exports.SubjectSubscriber = SubjectSubscriber;
var Subject = (function (_super) {
    __extends(Subject, _super);
    function Subject() {
        var _this = _super.call(this) || this;
        _this.observers = [];
        _this.closed = false;
        _this.isStopped = false;
        _this.hasError = false;
        _this.thrownError = null;
        return _this;
    }
    Subject.prototype[rxSubscriber$1.rxSubscriber] = function () {
        return new SubjectSubscriber(this);
    };
    Subject.prototype.lift = function (operator) {
        var subject = new AnonymousSubject(this, this);
        subject.operator = operator;
        return subject;
    };
    Subject.prototype.next = function (value) {
        if (this.closed) {
            throw new ObjectUnsubscribedError$1.ObjectUnsubscribedError();
        }
        if (!this.isStopped) {
            var observers = this.observers;
            var len = observers.length;
            var copy = observers.slice();
            for (var i = 0; i < len; i++) {
                copy[i].next(value);
            }
        }
    };
    Subject.prototype.error = function (err) {
        if (this.closed) {
            throw new ObjectUnsubscribedError$1.ObjectUnsubscribedError();
        }
        this.hasError = true;
        this.thrownError = err;
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].error(err);
        }
        this.observers.length = 0;
    };
    Subject.prototype.complete = function () {
        if (this.closed) {
            throw new ObjectUnsubscribedError$1.ObjectUnsubscribedError();
        }
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].complete();
        }
        this.observers.length = 0;
    };
    Subject.prototype.unsubscribe = function () {
        this.isStopped = true;
        this.closed = true;
        this.observers = null;
    };
    Subject.prototype._trySubscribe = function (subscriber) {
        if (this.closed) {
            throw new ObjectUnsubscribedError$1.ObjectUnsubscribedError();
        }
        else {
            return _super.prototype._trySubscribe.call(this, subscriber);
        }
    };
    Subject.prototype._subscribe = function (subscriber) {
        if (this.closed) {
            throw new ObjectUnsubscribedError$1.ObjectUnsubscribedError();
        }
        else if (this.hasError) {
            subscriber.error(this.thrownError);
            return Subscription_1.Subscription.EMPTY;
        }
        else if (this.isStopped) {
            subscriber.complete();
            return Subscription_1.Subscription.EMPTY;
        }
        else {
            this.observers.push(subscriber);
            return new SubjectSubscription_1.SubjectSubscription(this, subscriber);
        }
    };
    Subject.prototype.asObservable = function () {
        var observable = new Observable_1.Observable();
        observable.source = this;
        return observable;
    };
    Subject.create = function (destination, source) {
        return new AnonymousSubject(destination, source);
    };
    return Subject;
}(Observable_1.Observable));
exports.Subject = Subject;
var AnonymousSubject = (function (_super) {
    __extends(AnonymousSubject, _super);
    function AnonymousSubject(destination, source) {
        var _this = _super.call(this) || this;
        _this.destination = destination;
        _this.source = source;
        return _this;
    }
    AnonymousSubject.prototype.next = function (value) {
        var destination = this.destination;
        if (destination && destination.next) {
            destination.next(value);
        }
    };
    AnonymousSubject.prototype.error = function (err) {
        var destination = this.destination;
        if (destination && destination.error) {
            this.destination.error(err);
        }
    };
    AnonymousSubject.prototype.complete = function () {
        var destination = this.destination;
        if (destination && destination.complete) {
            this.destination.complete();
        }
    };
    AnonymousSubject.prototype._subscribe = function (subscriber) {
        var source = this.source;
        if (source) {
            return this.source.subscribe(subscriber);
        }
        else {
            return Subscription_1.Subscription.EMPTY;
        }
    };
    return AnonymousSubject;
}(Subject));
exports.AnonymousSubject = AnonymousSubject;

});

unwrapExports(Subject_1);

var refCount_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });

function refCount() {
    return function refCountOperatorFunction(source) {
        return source.lift(new RefCountOperator(source));
    };
}
exports.refCount = refCount;
var RefCountOperator = (function () {
    function RefCountOperator(connectable) {
        this.connectable = connectable;
    }
    RefCountOperator.prototype.call = function (subscriber, source) {
        var connectable = this.connectable;
        connectable._refCount++;
        var refCounter = new RefCountSubscriber(subscriber, connectable);
        var subscription = source.subscribe(refCounter);
        if (!refCounter.closed) {
            refCounter.connection = connectable.connect();
        }
        return subscription;
    };
    return RefCountOperator;
}());
var RefCountSubscriber = (function (_super) {
    __extends(RefCountSubscriber, _super);
    function RefCountSubscriber(destination, connectable) {
        var _this = _super.call(this, destination) || this;
        _this.connectable = connectable;
        return _this;
    }
    RefCountSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (!connectable) {
            this.connection = null;
            return;
        }
        this.connectable = null;
        var refCount = connectable._refCount;
        if (refCount <= 0) {
            this.connection = null;
            return;
        }
        connectable._refCount = refCount - 1;
        if (refCount > 1) {
            this.connection = null;
            return;
        }
        var connection = this.connection;
        var sharedConnection = connectable._connection;
        this.connection = null;
        if (sharedConnection && (!connection || sharedConnection === connection)) {
            sharedConnection.unsubscribe();
        }
    };
    return RefCountSubscriber;
}(Subscriber_1.Subscriber));

});

unwrapExports(refCount_1);

var ConnectableObservable_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });





var ConnectableObservable = (function (_super) {
    __extends(ConnectableObservable, _super);
    function ConnectableObservable(source, subjectFactory) {
        var _this = _super.call(this) || this;
        _this.source = source;
        _this.subjectFactory = subjectFactory;
        _this._refCount = 0;
        _this._isComplete = false;
        return _this;
    }
    ConnectableObservable.prototype._subscribe = function (subscriber) {
        return this.getSubject().subscribe(subscriber);
    };
    ConnectableObservable.prototype.getSubject = function () {
        var subject = this._subject;
        if (!subject || subject.isStopped) {
            this._subject = this.subjectFactory();
        }
        return this._subject;
    };
    ConnectableObservable.prototype.connect = function () {
        var connection = this._connection;
        if (!connection) {
            this._isComplete = false;
            connection = this._connection = new Subscription_1.Subscription();
            connection.add(this.source
                .subscribe(new ConnectableSubscriber(this.getSubject(), this)));
            if (connection.closed) {
                this._connection = null;
                connection = Subscription_1.Subscription.EMPTY;
            }
        }
        return connection;
    };
    ConnectableObservable.prototype.refCount = function () {
        return refCount_1.refCount()(this);
    };
    return ConnectableObservable;
}(Observable_1.Observable));
exports.ConnectableObservable = ConnectableObservable;
exports.connectableObservableDescriptor = (function () {
    var connectableProto = ConnectableObservable.prototype;
    return {
        operator: { value: null },
        _refCount: { value: 0, writable: true },
        _subject: { value: null, writable: true },
        _connection: { value: null, writable: true },
        _subscribe: { value: connectableProto._subscribe },
        _isComplete: { value: connectableProto._isComplete, writable: true },
        getSubject: { value: connectableProto.getSubject },
        connect: { value: connectableProto.connect },
        refCount: { value: connectableProto.refCount }
    };
})();
var ConnectableSubscriber = (function (_super) {
    __extends(ConnectableSubscriber, _super);
    function ConnectableSubscriber(destination, connectable) {
        var _this = _super.call(this, destination) || this;
        _this.connectable = connectable;
        return _this;
    }
    ConnectableSubscriber.prototype._error = function (err) {
        this._unsubscribe();
        _super.prototype._error.call(this, err);
    };
    ConnectableSubscriber.prototype._complete = function () {
        this.connectable._isComplete = true;
        this._unsubscribe();
        _super.prototype._complete.call(this);
    };
    ConnectableSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (connectable) {
            this.connectable = null;
            var connection = connectable._connection;
            connectable._refCount = 0;
            connectable._subject = null;
            connectable._connection = null;
            if (connection) {
                connection.unsubscribe();
            }
        }
    };
    return ConnectableSubscriber;
}(Subject_1.SubjectSubscriber));
var RefCountOperator = (function () {
    function RefCountOperator(connectable) {
        this.connectable = connectable;
    }
    RefCountOperator.prototype.call = function (subscriber, source) {
        var connectable = this.connectable;
        connectable._refCount++;
        var refCounter = new RefCountSubscriber(subscriber, connectable);
        var subscription = source.subscribe(refCounter);
        if (!refCounter.closed) {
            refCounter.connection = connectable.connect();
        }
        return subscription;
    };
    return RefCountOperator;
}());
var RefCountSubscriber = (function (_super) {
    __extends(RefCountSubscriber, _super);
    function RefCountSubscriber(destination, connectable) {
        var _this = _super.call(this, destination) || this;
        _this.connectable = connectable;
        return _this;
    }
    RefCountSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (!connectable) {
            this.connection = null;
            return;
        }
        this.connectable = null;
        var refCount = connectable._refCount;
        if (refCount <= 0) {
            this.connection = null;
            return;
        }
        connectable._refCount = refCount - 1;
        if (refCount > 1) {
            this.connection = null;
            return;
        }
        var connection = this.connection;
        var sharedConnection = connectable._connection;
        this.connection = null;
        if (sharedConnection && (!connection || sharedConnection === connection)) {
            sharedConnection.unsubscribe();
        }
    };
    return RefCountSubscriber;
}(Subscriber_1.Subscriber));

});

unwrapExports(ConnectableObservable_1);

var groupBy_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });




function groupBy(keySelector, elementSelector, durationSelector, subjectSelector) {
    return function (source) {
        return source.lift(new GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector));
    };
}
exports.groupBy = groupBy;
var GroupByOperator = (function () {
    function GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector) {
        this.keySelector = keySelector;
        this.elementSelector = elementSelector;
        this.durationSelector = durationSelector;
        this.subjectSelector = subjectSelector;
    }
    GroupByOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new GroupBySubscriber(subscriber, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector));
    };
    return GroupByOperator;
}());
var GroupBySubscriber = (function (_super) {
    __extends(GroupBySubscriber, _super);
    function GroupBySubscriber(destination, keySelector, elementSelector, durationSelector, subjectSelector) {
        var _this = _super.call(this, destination) || this;
        _this.keySelector = keySelector;
        _this.elementSelector = elementSelector;
        _this.durationSelector = durationSelector;
        _this.subjectSelector = subjectSelector;
        _this.groups = null;
        _this.attemptedToUnsubscribe = false;
        _this.count = 0;
        return _this;
    }
    GroupBySubscriber.prototype._next = function (value) {
        var key;
        try {
            key = this.keySelector(value);
        }
        catch (err) {
            this.error(err);
            return;
        }
        this._group(value, key);
    };
    GroupBySubscriber.prototype._group = function (value, key) {
        var groups = this.groups;
        if (!groups) {
            groups = this.groups = new Map();
        }
        var group = groups.get(key);
        var element;
        if (this.elementSelector) {
            try {
                element = this.elementSelector(value);
            }
            catch (err) {
                this.error(err);
            }
        }
        else {
            element = value;
        }
        if (!group) {
            group = (this.subjectSelector ? this.subjectSelector() : new Subject_1.Subject());
            groups.set(key, group);
            var groupedObservable = new GroupedObservable(key, group, this);
            this.destination.next(groupedObservable);
            if (this.durationSelector) {
                var duration = void 0;
                try {
                    duration = this.durationSelector(new GroupedObservable(key, group));
                }
                catch (err) {
                    this.error(err);
                    return;
                }
                this.add(duration.subscribe(new GroupDurationSubscriber(key, group, this)));
            }
        }
        if (!group.closed) {
            group.next(element);
        }
    };
    GroupBySubscriber.prototype._error = function (err) {
        var groups = this.groups;
        if (groups) {
            groups.forEach(function (group, key) {
                group.error(err);
            });
            groups.clear();
        }
        this.destination.error(err);
    };
    GroupBySubscriber.prototype._complete = function () {
        var groups = this.groups;
        if (groups) {
            groups.forEach(function (group, key) {
                group.complete();
            });
            groups.clear();
        }
        this.destination.complete();
    };
    GroupBySubscriber.prototype.removeGroup = function (key) {
        this.groups.delete(key);
    };
    GroupBySubscriber.prototype.unsubscribe = function () {
        if (!this.closed) {
            this.attemptedToUnsubscribe = true;
            if (this.count === 0) {
                _super.prototype.unsubscribe.call(this);
            }
        }
    };
    return GroupBySubscriber;
}(Subscriber_1.Subscriber));
var GroupDurationSubscriber = (function (_super) {
    __extends(GroupDurationSubscriber, _super);
    function GroupDurationSubscriber(key, group, parent) {
        var _this = _super.call(this, group) || this;
        _this.key = key;
        _this.group = group;
        _this.parent = parent;
        return _this;
    }
    GroupDurationSubscriber.prototype._next = function (value) {
        this.complete();
    };
    GroupDurationSubscriber.prototype._unsubscribe = function () {
        var _a = this, parent = _a.parent, key = _a.key;
        this.key = this.parent = null;
        if (parent) {
            parent.removeGroup(key);
        }
    };
    return GroupDurationSubscriber;
}(Subscriber_1.Subscriber));
var GroupedObservable = (function (_super) {
    __extends(GroupedObservable, _super);
    function GroupedObservable(key, groupSubject, refCountSubscription) {
        var _this = _super.call(this) || this;
        _this.key = key;
        _this.groupSubject = groupSubject;
        _this.refCountSubscription = refCountSubscription;
        return _this;
    }
    GroupedObservable.prototype._subscribe = function (subscriber) {
        var subscription = new Subscription_1.Subscription();
        var _a = this, refCountSubscription = _a.refCountSubscription, groupSubject = _a.groupSubject;
        if (refCountSubscription && !refCountSubscription.closed) {
            subscription.add(new InnerRefCountSubscription(refCountSubscription));
        }
        subscription.add(groupSubject.subscribe(subscriber));
        return subscription;
    };
    return GroupedObservable;
}(Observable_1.Observable));
exports.GroupedObservable = GroupedObservable;
var InnerRefCountSubscription = (function (_super) {
    __extends(InnerRefCountSubscription, _super);
    function InnerRefCountSubscription(parent) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        parent.count++;
        return _this;
    }
    InnerRefCountSubscription.prototype.unsubscribe = function () {
        var parent = this.parent;
        if (!parent.closed && !this.closed) {
            _super.prototype.unsubscribe.call(this);
            parent.count -= 1;
            if (parent.count === 0 && parent.attemptedToUnsubscribe) {
                parent.unsubscribe();
            }
        }
    };
    return InnerRefCountSubscription;
}(Subscription_1.Subscription));

});

unwrapExports(groupBy_1);

var BehaviorSubject_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });


var BehaviorSubject = (function (_super) {
    __extends(BehaviorSubject, _super);
    function BehaviorSubject(_value) {
        var _this = _super.call(this) || this;
        _this._value = _value;
        return _this;
    }
    Object.defineProperty(BehaviorSubject.prototype, "value", {
        get: function () {
            return this.getValue();
        },
        enumerable: true,
        configurable: true
    });
    BehaviorSubject.prototype._subscribe = function (subscriber) {
        var subscription = _super.prototype._subscribe.call(this, subscriber);
        if (subscription && !subscription.closed) {
            subscriber.next(this._value);
        }
        return subscription;
    };
    BehaviorSubject.prototype.getValue = function () {
        if (this.hasError) {
            throw this.thrownError;
        }
        else if (this.closed) {
            throw new ObjectUnsubscribedError$1.ObjectUnsubscribedError();
        }
        else {
            return this._value;
        }
    };
    BehaviorSubject.prototype.next = function (value) {
        _super.prototype.next.call(this, this._value = value);
    };
    return BehaviorSubject;
}(Subject_1.Subject));
exports.BehaviorSubject = BehaviorSubject;

});

unwrapExports(BehaviorSubject_1);

var Action_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });

var Action = (function (_super) {
    __extends(Action, _super);
    function Action(scheduler, work) {
        return _super.call(this) || this;
    }
    Action.prototype.schedule = function (state, delay) {
        if (delay === void 0) { delay = 0; }
        return this;
    };
    return Action;
}(Subscription_1.Subscription));
exports.Action = Action;

});

unwrapExports(Action_1);

var AsyncAction_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });

var AsyncAction = (function (_super) {
    __extends(AsyncAction, _super);
    function AsyncAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        _this.pending = false;
        return _this;
    }
    AsyncAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) { delay = 0; }
        if (this.closed) {
            return this;
        }
        this.state = state;
        var id = this.id;
        var scheduler = this.scheduler;
        if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, delay);
        }
        this.pending = true;
        this.delay = delay;
        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
        return this;
    };
    AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        return setInterval(scheduler.flush.bind(scheduler, this), delay);
    };
    AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        if (delay !== null && this.delay === delay && this.pending === false) {
            return id;
        }
        clearInterval(id);
        return undefined;
    };
    AsyncAction.prototype.execute = function (state, delay) {
        if (this.closed) {
            return new Error('executing a cancelled action');
        }
        this.pending = false;
        var error = this._execute(state, delay);
        if (error) {
            return error;
        }
        else if (this.pending === false && this.id != null) {
            this.id = this.recycleAsyncId(this.scheduler, this.id, null);
        }
    };
    AsyncAction.prototype._execute = function (state, delay) {
        var errored = false;
        var errorValue = undefined;
        try {
            this.work(state);
        }
        catch (e) {
            errored = true;
            errorValue = !!e && e || new Error(e);
        }
        if (errored) {
            this.unsubscribe();
            return errorValue;
        }
    };
    AsyncAction.prototype._unsubscribe = function () {
        var id = this.id;
        var scheduler = this.scheduler;
        var actions = scheduler.actions;
        var index = actions.indexOf(this);
        this.work = null;
        this.state = null;
        this.pending = false;
        this.scheduler = null;
        if (index !== -1) {
            actions.splice(index, 1);
        }
        if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, null);
        }
        this.delay = null;
    };
    return AsyncAction;
}(Action_1.Action));
exports.AsyncAction = AsyncAction;

});

unwrapExports(AsyncAction_1);

var QueueAction_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });

var QueueAction = (function (_super) {
    __extends(QueueAction, _super);
    function QueueAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
    }
    QueueAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) { delay = 0; }
        if (delay > 0) {
            return _super.prototype.schedule.call(this, state, delay);
        }
        this.delay = delay;
        this.state = state;
        this.scheduler.flush(this);
        return this;
    };
    QueueAction.prototype.execute = function (state, delay) {
        return (delay > 0 || this.closed) ?
            _super.prototype.execute.call(this, state, delay) :
            this._execute(state, delay);
    };
    QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        return scheduler.flush(this);
    };
    return QueueAction;
}(AsyncAction_1.AsyncAction));
exports.QueueAction = QueueAction;

});

unwrapExports(QueueAction_1);

var Scheduler_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Scheduler = (function () {
    function Scheduler(SchedulerAction, now) {
        if (now === void 0) { now = Scheduler.now; }
        this.SchedulerAction = SchedulerAction;
        this.now = now;
    }
    Scheduler.prototype.schedule = function (work, delay, state) {
        if (delay === void 0) { delay = 0; }
        return new this.SchedulerAction(this, work).schedule(state, delay);
    };
    Scheduler.now = function () { return Date.now(); };
    return Scheduler;
}());
exports.Scheduler = Scheduler;

});

unwrapExports(Scheduler_1);

var AsyncScheduler_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });

var AsyncScheduler = (function (_super) {
    __extends(AsyncScheduler, _super);
    function AsyncScheduler(SchedulerAction, now) {
        if (now === void 0) { now = Scheduler_1.Scheduler.now; }
        var _this = _super.call(this, SchedulerAction, function () {
            if (AsyncScheduler.delegate && AsyncScheduler.delegate !== _this) {
                return AsyncScheduler.delegate.now();
            }
            else {
                return now();
            }
        }) || this;
        _this.actions = [];
        _this.active = false;
        _this.scheduled = undefined;
        return _this;
    }
    AsyncScheduler.prototype.schedule = function (work, delay, state) {
        if (delay === void 0) { delay = 0; }
        if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) {
            return AsyncScheduler.delegate.schedule(work, delay, state);
        }
        else {
            return _super.prototype.schedule.call(this, work, delay, state);
        }
    };
    AsyncScheduler.prototype.flush = function (action) {
        var actions = this.actions;
        if (this.active) {
            actions.push(action);
            return;
        }
        var error;
        this.active = true;
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (action = actions.shift());
        this.active = false;
        if (error) {
            while (action = actions.shift()) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AsyncScheduler;
}(Scheduler_1.Scheduler));
exports.AsyncScheduler = AsyncScheduler;

});

unwrapExports(AsyncScheduler_1);

var QueueScheduler_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });

var QueueScheduler = (function (_super) {
    __extends(QueueScheduler, _super);
    function QueueScheduler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return QueueScheduler;
}(AsyncScheduler_1.AsyncScheduler));
exports.QueueScheduler = QueueScheduler;

});

unwrapExports(QueueScheduler_1);

var queue$1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });


exports.queue = new QueueScheduler_1.QueueScheduler(QueueAction_1.QueueAction);

});

unwrapExports(queue$1);

var empty_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

exports.EMPTY = new Observable_1.Observable(function (subscriber) { return subscriber.complete(); });
function empty(scheduler) {
    return scheduler ? emptyScheduled(scheduler) : exports.EMPTY;
}
exports.empty = empty;
function emptyScheduled(scheduler) {
    return new Observable_1.Observable(function (subscriber) { return scheduler.schedule(function () { return subscriber.complete(); }); });
}

});

unwrapExports(empty_1);

var isScheduler_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function isScheduler(value) {
    return value && typeof value.schedule === 'function';
}
exports.isScheduler = isScheduler;

});

unwrapExports(isScheduler_1);

var subscribeToArray$1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.subscribeToArray = function (array) { return function (subscriber) {
    for (var i = 0, len = array.length; i < len && !subscriber.closed; i++) {
        subscriber.next(array[i]);
    }
    subscriber.complete();
}; };

});

unwrapExports(subscribeToArray$1);

var scheduleArray_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });


function scheduleArray(input, scheduler) {
    return new Observable_1.Observable(function (subscriber) {
        var sub = new Subscription_1.Subscription();
        var i = 0;
        sub.add(scheduler.schedule(function () {
            if (i === input.length) {
                subscriber.complete();
                return;
            }
            subscriber.next(input[i++]);
            if (!subscriber.closed) {
                sub.add(this.schedule());
            }
        }));
        return sub;
    });
}
exports.scheduleArray = scheduleArray;

});

unwrapExports(scheduleArray_1);

var fromArray_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });



function fromArray(input, scheduler) {
    if (!scheduler) {
        return new Observable_1.Observable(subscribeToArray$1.subscribeToArray(input));
    }
    else {
        return scheduleArray_1.scheduleArray(input, scheduler);
    }
}
exports.fromArray = fromArray;

});

unwrapExports(fromArray_1);

var of_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });



function of() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var scheduler = args[args.length - 1];
    if (isScheduler_1.isScheduler(scheduler)) {
        args.pop();
        return scheduleArray_1.scheduleArray(args, scheduler);
    }
    else {
        return fromArray_1.fromArray(args);
    }
}
exports.of = of;

});

unwrapExports(of_1);

var throwError_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

function throwError(error, scheduler) {
    if (!scheduler) {
        return new Observable_1.Observable(function (subscriber) { return subscriber.error(error); });
    }
    else {
        return new Observable_1.Observable(function (subscriber) { return scheduler.schedule(dispatch, 0, { error: error, subscriber: subscriber }); });
    }
}
exports.throwError = throwError;
function dispatch(_a) {
    var error = _a.error, subscriber = _a.subscriber;
    subscriber.error(error);
}

});

unwrapExports(throwError_1);

var Notification_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });



var NotificationKind;
(function (NotificationKind) {
    NotificationKind["NEXT"] = "N";
    NotificationKind["ERROR"] = "E";
    NotificationKind["COMPLETE"] = "C";
})(NotificationKind = exports.NotificationKind || (exports.NotificationKind = {}));
var Notification = (function () {
    function Notification(kind, value, error) {
        this.kind = kind;
        this.value = value;
        this.error = error;
        this.hasValue = kind === 'N';
    }
    Notification.prototype.observe = function (observer) {
        switch (this.kind) {
            case 'N':
                return observer.next && observer.next(this.value);
            case 'E':
                return observer.error && observer.error(this.error);
            case 'C':
                return observer.complete && observer.complete();
        }
    };
    Notification.prototype.do = function (next, error, complete) {
        var kind = this.kind;
        switch (kind) {
            case 'N':
                return next && next(this.value);
            case 'E':
                return error && error(this.error);
            case 'C':
                return complete && complete();
        }
    };
    Notification.prototype.accept = function (nextOrObserver, error, complete) {
        if (nextOrObserver && typeof nextOrObserver.next === 'function') {
            return this.observe(nextOrObserver);
        }
        else {
            return this.do(nextOrObserver, error, complete);
        }
    };
    Notification.prototype.toObservable = function () {
        var kind = this.kind;
        switch (kind) {
            case 'N':
                return of_1.of(this.value);
            case 'E':
                return throwError_1.throwError(this.error);
            case 'C':
                return empty_1.empty();
        }
        throw new Error('unexpected notification kind value');
    };
    Notification.createNext = function (value) {
        if (typeof value !== 'undefined') {
            return new Notification('N', value);
        }
        return Notification.undefinedValueNotification;
    };
    Notification.createError = function (err) {
        return new Notification('E', undefined, err);
    };
    Notification.createComplete = function () {
        return Notification.completeNotification;
    };
    Notification.completeNotification = new Notification('C');
    Notification.undefinedValueNotification = new Notification('N', undefined);
    return Notification;
}());
exports.Notification = Notification;

});

unwrapExports(Notification_1);

var observeOn_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });


function observeOn(scheduler, delay) {
    if (delay === void 0) { delay = 0; }
    return function observeOnOperatorFunction(source) {
        return source.lift(new ObserveOnOperator(scheduler, delay));
    };
}
exports.observeOn = observeOn;
var ObserveOnOperator = (function () {
    function ObserveOnOperator(scheduler, delay) {
        if (delay === void 0) { delay = 0; }
        this.scheduler = scheduler;
        this.delay = delay;
    }
    ObserveOnOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));
    };
    return ObserveOnOperator;
}());
exports.ObserveOnOperator = ObserveOnOperator;
var ObserveOnSubscriber = (function (_super) {
    __extends(ObserveOnSubscriber, _super);
    function ObserveOnSubscriber(destination, scheduler, delay) {
        if (delay === void 0) { delay = 0; }
        var _this = _super.call(this, destination) || this;
        _this.scheduler = scheduler;
        _this.delay = delay;
        return _this;
    }
    ObserveOnSubscriber.dispatch = function (arg) {
        var notification = arg.notification, destination = arg.destination;
        notification.observe(destination);
        this.unsubscribe();
    };
    ObserveOnSubscriber.prototype.scheduleMessage = function (notification) {
        var destination = this.destination;
        destination.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));
    };
    ObserveOnSubscriber.prototype._next = function (value) {
        this.scheduleMessage(Notification_1.Notification.createNext(value));
    };
    ObserveOnSubscriber.prototype._error = function (err) {
        this.scheduleMessage(Notification_1.Notification.createError(err));
        this.unsubscribe();
    };
    ObserveOnSubscriber.prototype._complete = function () {
        this.scheduleMessage(Notification_1.Notification.createComplete());
        this.unsubscribe();
    };
    return ObserveOnSubscriber;
}(Subscriber_1.Subscriber));
exports.ObserveOnSubscriber = ObserveOnSubscriber;
var ObserveOnMessage = (function () {
    function ObserveOnMessage(notification, destination) {
        this.notification = notification;
        this.destination = destination;
    }
    return ObserveOnMessage;
}());
exports.ObserveOnMessage = ObserveOnMessage;

});

unwrapExports(observeOn_1);

var ReplaySubject_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });






var ReplaySubject = (function (_super) {
    __extends(ReplaySubject, _super);
    function ReplaySubject(bufferSize, windowTime, scheduler) {
        if (bufferSize === void 0) { bufferSize = Number.POSITIVE_INFINITY; }
        if (windowTime === void 0) { windowTime = Number.POSITIVE_INFINITY; }
        var _this = _super.call(this) || this;
        _this.scheduler = scheduler;
        _this._events = [];
        _this._infiniteTimeWindow = false;
        _this._bufferSize = bufferSize < 1 ? 1 : bufferSize;
        _this._windowTime = windowTime < 1 ? 1 : windowTime;
        if (windowTime === Number.POSITIVE_INFINITY) {
            _this._infiniteTimeWindow = true;
            _this.next = _this.nextInfiniteTimeWindow;
        }
        else {
            _this.next = _this.nextTimeWindow;
        }
        return _this;
    }
    ReplaySubject.prototype.nextInfiniteTimeWindow = function (value) {
        var _events = this._events;
        _events.push(value);
        if (_events.length > this._bufferSize) {
            _events.shift();
        }
        _super.prototype.next.call(this, value);
    };
    ReplaySubject.prototype.nextTimeWindow = function (value) {
        this._events.push(new ReplayEvent(this._getNow(), value));
        this._trimBufferThenGetEvents();
        _super.prototype.next.call(this, value);
    };
    ReplaySubject.prototype._subscribe = function (subscriber) {
        var _infiniteTimeWindow = this._infiniteTimeWindow;
        var _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();
        var scheduler = this.scheduler;
        var len = _events.length;
        var subscription;
        if (this.closed) {
            throw new ObjectUnsubscribedError$1.ObjectUnsubscribedError();
        }
        else if (this.isStopped || this.hasError) {
            subscription = Subscription_1.Subscription.EMPTY;
        }
        else {
            this.observers.push(subscriber);
            subscription = new SubjectSubscription_1.SubjectSubscription(this, subscriber);
        }
        if (scheduler) {
            subscriber.add(subscriber = new observeOn_1.ObserveOnSubscriber(subscriber, scheduler));
        }
        if (_infiniteTimeWindow) {
            for (var i = 0; i < len && !subscriber.closed; i++) {
                subscriber.next(_events[i]);
            }
        }
        else {
            for (var i = 0; i < len && !subscriber.closed; i++) {
                subscriber.next(_events[i].value);
            }
        }
        if (this.hasError) {
            subscriber.error(this.thrownError);
        }
        else if (this.isStopped) {
            subscriber.complete();
        }
        return subscription;
    };
    ReplaySubject.prototype._getNow = function () {
        return (this.scheduler || queue$1.queue).now();
    };
    ReplaySubject.prototype._trimBufferThenGetEvents = function () {
        var now = this._getNow();
        var _bufferSize = this._bufferSize;
        var _windowTime = this._windowTime;
        var _events = this._events;
        var eventsCount = _events.length;
        var spliceCount = 0;
        while (spliceCount < eventsCount) {
            if ((now - _events[spliceCount].time) < _windowTime) {
                break;
            }
            spliceCount++;
        }
        if (eventsCount > _bufferSize) {
            spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);
        }
        if (spliceCount > 0) {
            _events.splice(0, spliceCount);
        }
        return _events;
    };
    return ReplaySubject;
}(Subject_1.Subject));
exports.ReplaySubject = ReplaySubject;
var ReplayEvent = (function () {
    function ReplayEvent(time, value) {
        this.time = time;
        this.value = value;
    }
    return ReplayEvent;
}());

});

unwrapExports(ReplaySubject_1);

var AsyncSubject_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });


var AsyncSubject = (function (_super) {
    __extends(AsyncSubject, _super);
    function AsyncSubject() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.value = null;
        _this.hasNext = false;
        _this.hasCompleted = false;
        return _this;
    }
    AsyncSubject.prototype._subscribe = function (subscriber) {
        if (this.hasError) {
            subscriber.error(this.thrownError);
            return Subscription_1.Subscription.EMPTY;
        }
        else if (this.hasCompleted && this.hasNext) {
            subscriber.next(this.value);
            subscriber.complete();
            return Subscription_1.Subscription.EMPTY;
        }
        return _super.prototype._subscribe.call(this, subscriber);
    };
    AsyncSubject.prototype.next = function (value) {
        if (!this.hasCompleted) {
            this.value = value;
            this.hasNext = true;
        }
    };
    AsyncSubject.prototype.error = function (error) {
        if (!this.hasCompleted) {
            _super.prototype.error.call(this, error);
        }
    };
    AsyncSubject.prototype.complete = function () {
        this.hasCompleted = true;
        if (this.hasNext) {
            _super.prototype.next.call(this, this.value);
        }
        _super.prototype.complete.call(this);
    };
    return AsyncSubject;
}(Subject_1.Subject));
exports.AsyncSubject = AsyncSubject;

});

unwrapExports(AsyncSubject_1);

var Immediate$1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var nextHandle = 1;
var RESOLVED = (function () { return Promise.resolve(); })();
var activeHandles = {};
function findAndClearHandle(handle) {
    if (handle in activeHandles) {
        delete activeHandles[handle];
        return true;
    }
    return false;
}
exports.Immediate = {
    setImmediate: function (cb) {
        var handle = nextHandle++;
        activeHandles[handle] = true;
        RESOLVED.then(function () { return findAndClearHandle(handle) && cb(); });
        return handle;
    },
    clearImmediate: function (handle) {
        findAndClearHandle(handle);
    },
};
exports.TestTools = {
    pending: function () {
        return Object.keys(activeHandles).length;
    }
};

});

unwrapExports(Immediate$1);

var AsapAction_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });


var AsapAction = (function (_super) {
    __extends(AsapAction, _super);
    function AsapAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
    }
    AsapAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        if (delay !== null && delay > 0) {
            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        scheduler.actions.push(this);
        return scheduler.scheduled || (scheduler.scheduled = Immediate$1.Immediate.setImmediate(scheduler.flush.bind(scheduler, null)));
    };
    AsapAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
        }
        if (scheduler.actions.length === 0) {
            Immediate$1.Immediate.clearImmediate(id);
            scheduler.scheduled = undefined;
        }
        return undefined;
    };
    return AsapAction;
}(AsyncAction_1.AsyncAction));
exports.AsapAction = AsapAction;

});

unwrapExports(AsapAction_1);

var AsapScheduler_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });

var AsapScheduler = (function (_super) {
    __extends(AsapScheduler, _super);
    function AsapScheduler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AsapScheduler.prototype.flush = function (action) {
        this.active = true;
        this.scheduled = undefined;
        var actions = this.actions;
        var error;
        var index = -1;
        var count = actions.length;
        action = action || actions.shift();
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (++index < count && (action = actions.shift()));
        this.active = false;
        if (error) {
            while (++index < count && (action = actions.shift())) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AsapScheduler;
}(AsyncScheduler_1.AsyncScheduler));
exports.AsapScheduler = AsapScheduler;

});

unwrapExports(AsapScheduler_1);

var asap$1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });


exports.asap = new AsapScheduler_1.AsapScheduler(AsapAction_1.AsapAction);

});

unwrapExports(asap$1);

var async$1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });


exports.async = new AsyncScheduler_1.AsyncScheduler(AsyncAction_1.AsyncAction);

});

unwrapExports(async$1);

var AnimationFrameAction_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });

var AnimationFrameAction = (function (_super) {
    __extends(AnimationFrameAction, _super);
    function AnimationFrameAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
    }
    AnimationFrameAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        if (delay !== null && delay > 0) {
            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        scheduler.actions.push(this);
        return scheduler.scheduled || (scheduler.scheduled = requestAnimationFrame(function () { return scheduler.flush(null); }));
    };
    AnimationFrameAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
        }
        if (scheduler.actions.length === 0) {
            cancelAnimationFrame(id);
            scheduler.scheduled = undefined;
        }
        return undefined;
    };
    return AnimationFrameAction;
}(AsyncAction_1.AsyncAction));
exports.AnimationFrameAction = AnimationFrameAction;

});

unwrapExports(AnimationFrameAction_1);

var AnimationFrameScheduler_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });

var AnimationFrameScheduler = (function (_super) {
    __extends(AnimationFrameScheduler, _super);
    function AnimationFrameScheduler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AnimationFrameScheduler.prototype.flush = function (action) {
        this.active = true;
        this.scheduled = undefined;
        var actions = this.actions;
        var error;
        var index = -1;
        var count = actions.length;
        action = action || actions.shift();
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (++index < count && (action = actions.shift()));
        this.active = false;
        if (error) {
            while (++index < count && (action = actions.shift())) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AnimationFrameScheduler;
}(AsyncScheduler_1.AsyncScheduler));
exports.AnimationFrameScheduler = AnimationFrameScheduler;

});

unwrapExports(AnimationFrameScheduler_1);

var animationFrame$1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });


exports.animationFrame = new AnimationFrameScheduler_1.AnimationFrameScheduler(AnimationFrameAction_1.AnimationFrameAction);

});

unwrapExports(animationFrame$1);

var VirtualTimeScheduler_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });


var VirtualTimeScheduler = (function (_super) {
    __extends(VirtualTimeScheduler, _super);
    function VirtualTimeScheduler(SchedulerAction, maxFrames) {
        if (SchedulerAction === void 0) { SchedulerAction = VirtualAction; }
        if (maxFrames === void 0) { maxFrames = Number.POSITIVE_INFINITY; }
        var _this = _super.call(this, SchedulerAction, function () { return _this.frame; }) || this;
        _this.maxFrames = maxFrames;
        _this.frame = 0;
        _this.index = -1;
        return _this;
    }
    VirtualTimeScheduler.prototype.flush = function () {
        var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;
        var error, action;
        while ((action = actions[0]) && action.delay <= maxFrames) {
            actions.shift();
            this.frame = action.delay;
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        }
        if (error) {
            while (action = actions.shift()) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    VirtualTimeScheduler.frameTimeFactor = 10;
    return VirtualTimeScheduler;
}(AsyncScheduler_1.AsyncScheduler));
exports.VirtualTimeScheduler = VirtualTimeScheduler;
var VirtualAction = (function (_super) {
    __extends(VirtualAction, _super);
    function VirtualAction(scheduler, work, index) {
        if (index === void 0) { index = scheduler.index += 1; }
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        _this.index = index;
        _this.active = true;
        _this.index = scheduler.index = index;
        return _this;
    }
    VirtualAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) { delay = 0; }
        if (!this.id) {
            return _super.prototype.schedule.call(this, state, delay);
        }
        this.active = false;
        var action = new VirtualAction(this.scheduler, this.work);
        this.add(action);
        return action.schedule(state, delay);
    };
    VirtualAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        this.delay = scheduler.frame + delay;
        var actions = scheduler.actions;
        actions.push(this);
        actions.sort(VirtualAction.sortActions);
        return true;
    };
    VirtualAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        return undefined;
    };
    VirtualAction.prototype._execute = function (state, delay) {
        if (this.active === true) {
            return _super.prototype._execute.call(this, state, delay);
        }
    };
    VirtualAction.sortActions = function (a, b) {
        if (a.delay === b.delay) {
            if (a.index === b.index) {
                return 0;
            }
            else if (a.index > b.index) {
                return 1;
            }
            else {
                return -1;
            }
        }
        else if (a.delay > b.delay) {
            return 1;
        }
        else {
            return -1;
        }
    };
    return VirtualAction;
}(AsyncAction_1.AsyncAction));
exports.VirtualAction = VirtualAction;

});

unwrapExports(VirtualTimeScheduler_1);

var identity_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function identity(x) {
    return x;
}
exports.identity = identity;

});

unwrapExports(identity_1);

var isObservable_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

function isObservable(obj) {
    return !!obj && (obj instanceof Observable_1.Observable || (typeof obj.lift === 'function' && typeof obj.subscribe === 'function'));
}
exports.isObservable = isObservable;

});

unwrapExports(isObservable_1);

var ArgumentOutOfRangeError$1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ArgumentOutOfRangeErrorImpl = (function () {
    function ArgumentOutOfRangeErrorImpl() {
        Error.call(this);
        this.message = 'argument out of range';
        this.name = 'ArgumentOutOfRangeError';
        return this;
    }
    ArgumentOutOfRangeErrorImpl.prototype = Object.create(Error.prototype);
    return ArgumentOutOfRangeErrorImpl;
})();
exports.ArgumentOutOfRangeError = ArgumentOutOfRangeErrorImpl;

});

unwrapExports(ArgumentOutOfRangeError$1);

var EmptyError$1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var EmptyErrorImpl = (function () {
    function EmptyErrorImpl() {
        Error.call(this);
        this.message = 'no elements in sequence';
        this.name = 'EmptyError';
        return this;
    }
    EmptyErrorImpl.prototype = Object.create(Error.prototype);
    return EmptyErrorImpl;
})();
exports.EmptyError = EmptyErrorImpl;

});

unwrapExports(EmptyError$1);

var TimeoutError$1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var TimeoutErrorImpl = (function () {
    function TimeoutErrorImpl() {
        Error.call(this);
        this.message = 'Timeout has occurred';
        this.name = 'TimeoutError';
        return this;
    }
    TimeoutErrorImpl.prototype = Object.create(Error.prototype);
    return TimeoutErrorImpl;
})();
exports.TimeoutError = TimeoutErrorImpl;

});

unwrapExports(TimeoutError$1);

var map_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });

function map(project, thisArg) {
    return function mapOperation(source) {
        if (typeof project !== 'function') {
            throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
        }
        return source.lift(new MapOperator(project, thisArg));
    };
}
exports.map = map;
var MapOperator = (function () {
    function MapOperator(project, thisArg) {
        this.project = project;
        this.thisArg = thisArg;
    }
    MapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
    };
    return MapOperator;
}());
exports.MapOperator = MapOperator;
var MapSubscriber = (function (_super) {
    __extends(MapSubscriber, _super);
    function MapSubscriber(destination, project, thisArg) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.count = 0;
        _this.thisArg = thisArg || _this;
        return _this;
    }
    MapSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.project.call(this.thisArg, value, this.count++);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return MapSubscriber;
}(Subscriber_1.Subscriber));

});

unwrapExports(map_1);

var bindCallback_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });






function bindCallback(callbackFunc, resultSelector, scheduler) {
    if (resultSelector) {
        if (isScheduler_1.isScheduler(resultSelector)) {
            scheduler = resultSelector;
        }
        else {
            return function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return bindCallback(callbackFunc, scheduler).apply(void 0, args).pipe(map_1.map(function (args) { return isArray$1.isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));
            };
        }
    }
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var context = this;
        var subject;
        var params = {
            context: context,
            subject: subject,
            callbackFunc: callbackFunc,
            scheduler: scheduler,
        };
        return new Observable_1.Observable(function (subscriber) {
            if (!scheduler) {
                if (!subject) {
                    subject = new AsyncSubject_1.AsyncSubject();
                    var handler = function () {
                        var innerArgs = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            innerArgs[_i] = arguments[_i];
                        }
                        subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);
                        subject.complete();
                    };
                    try {
                        callbackFunc.apply(context, args.concat([handler]));
                    }
                    catch (err) {
                        if (canReportError_1.canReportError(subject)) {
                            subject.error(err);
                        }
                        else {
                            console.warn(err);
                        }
                    }
                }
                return subject.subscribe(subscriber);
            }
            else {
                var state = {
                    args: args, subscriber: subscriber, params: params,
                };
                return scheduler.schedule(dispatch, 0, state);
            }
        });
    };
}
exports.bindCallback = bindCallback;
function dispatch(state) {
    var _this = this;
    var args = state.args, subscriber = state.subscriber, params = state.params;
    var callbackFunc = params.callbackFunc, context = params.context, scheduler = params.scheduler;
    var subject = params.subject;
    if (!subject) {
        subject = params.subject = new AsyncSubject_1.AsyncSubject();
        var handler = function () {
            var innerArgs = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                innerArgs[_i] = arguments[_i];
            }
            var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;
            _this.add(scheduler.schedule(dispatchNext, 0, { value: value, subject: subject }));
        };
        try {
            callbackFunc.apply(context, args.concat([handler]));
        }
        catch (err) {
            subject.error(err);
        }
    }
    this.add(subject.subscribe(subscriber));
}
function dispatchNext(state) {
    var value = state.value, subject = state.subject;
    subject.next(value);
    subject.complete();
}


});

unwrapExports(bindCallback_1);

var bindNodeCallback_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });






function bindNodeCallback(callbackFunc, resultSelector, scheduler) {
    if (resultSelector) {
        if (isScheduler_1.isScheduler(resultSelector)) {
            scheduler = resultSelector;
        }
        else {
            return function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return bindNodeCallback(callbackFunc, scheduler).apply(void 0, args).pipe(map_1.map(function (args) { return isArray$1.isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));
            };
        }
    }
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var params = {
            subject: undefined,
            args: args,
            callbackFunc: callbackFunc,
            scheduler: scheduler,
            context: this,
        };
        return new Observable_1.Observable(function (subscriber) {
            var context = params.context;
            var subject = params.subject;
            if (!scheduler) {
                if (!subject) {
                    subject = params.subject = new AsyncSubject_1.AsyncSubject();
                    var handler = function () {
                        var innerArgs = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            innerArgs[_i] = arguments[_i];
                        }
                        var err = innerArgs.shift();
                        if (err) {
                            subject.error(err);
                            return;
                        }
                        subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);
                        subject.complete();
                    };
                    try {
                        callbackFunc.apply(context, args.concat([handler]));
                    }
                    catch (err) {
                        if (canReportError_1.canReportError(subject)) {
                            subject.error(err);
                        }
                        else {
                            console.warn(err);
                        }
                    }
                }
                return subject.subscribe(subscriber);
            }
            else {
                return scheduler.schedule(dispatch, 0, { params: params, subscriber: subscriber, context: context });
            }
        });
    };
}
exports.bindNodeCallback = bindNodeCallback;
function dispatch(state) {
    var _this = this;
    var params = state.params, subscriber = state.subscriber, context = state.context;
    var callbackFunc = params.callbackFunc, args = params.args, scheduler = params.scheduler;
    var subject = params.subject;
    if (!subject) {
        subject = params.subject = new AsyncSubject_1.AsyncSubject();
        var handler = function () {
            var innerArgs = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                innerArgs[_i] = arguments[_i];
            }
            var err = innerArgs.shift();
            if (err) {
                _this.add(scheduler.schedule(dispatchError, 0, { err: err, subject: subject }));
            }
            else {
                var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;
                _this.add(scheduler.schedule(dispatchNext, 0, { value: value, subject: subject }));
            }
        };
        try {
            callbackFunc.apply(context, args.concat([handler]));
        }
        catch (err) {
            this.add(scheduler.schedule(dispatchError, 0, { err: err, subject: subject }));
        }
    }
    this.add(subject.subscribe(subscriber));
}
function dispatchNext(arg) {
    var value = arg.value, subject = arg.subject;
    subject.next(value);
    subject.complete();
}
function dispatchError(arg) {
    var err = arg.err, subject = arg.subject;
    subject.error(err);
}

});

unwrapExports(bindNodeCallback_1);

var OuterSubscriber_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });

var OuterSubscriber = (function (_super) {
    __extends(OuterSubscriber, _super);
    function OuterSubscriber() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    OuterSubscriber.prototype.notifyError = function (error, innerSub) {
        this.destination.error(error);
    };
    OuterSubscriber.prototype.notifyComplete = function (innerSub) {
        this.destination.complete();
    };
    return OuterSubscriber;
}(Subscriber_1.Subscriber));
exports.OuterSubscriber = OuterSubscriber;

});

unwrapExports(OuterSubscriber_1);

var InnerSubscriber_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });

var InnerSubscriber = (function (_super) {
    __extends(InnerSubscriber, _super);
    function InnerSubscriber(parent, outerValue, outerIndex) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        _this.outerValue = outerValue;
        _this.outerIndex = outerIndex;
        _this.index = 0;
        return _this;
    }
    InnerSubscriber.prototype._next = function (value) {
        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
    };
    InnerSubscriber.prototype._error = function (error) {
        this.parent.notifyError(error, this);
        this.unsubscribe();
    };
    InnerSubscriber.prototype._complete = function () {
        this.parent.notifyComplete(this);
        this.unsubscribe();
    };
    return InnerSubscriber;
}(Subscriber_1.Subscriber));
exports.InnerSubscriber = InnerSubscriber;

});

unwrapExports(InnerSubscriber_1);

var subscribeToPromise$1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

exports.subscribeToPromise = function (promise) { return function (subscriber) {
    promise.then(function (value) {
        if (!subscriber.closed) {
            subscriber.next(value);
            subscriber.complete();
        }
    }, function (err) { return subscriber.error(err); })
        .then(null, hostReportError_1.hostReportError);
    return subscriber;
}; };

});

unwrapExports(subscribeToPromise$1);

var iterator$1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function getSymbolIterator() {
    if (typeof Symbol !== 'function' || !Symbol.iterator) {
        return '@@iterator';
    }
    return Symbol.iterator;
}
exports.getSymbolIterator = getSymbolIterator;
exports.iterator = getSymbolIterator();
exports.$$iterator = exports.iterator;

});

unwrapExports(iterator$1);

var subscribeToIterable$1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

exports.subscribeToIterable = function (iterable) { return function (subscriber) {
    var iterator = iterable[iterator$1.iterator]();
    do {
        var item = iterator.next();
        if (item.done) {
            subscriber.complete();
            break;
        }
        subscriber.next(item.value);
        if (subscriber.closed) {
            break;
        }
    } while (true);
    if (typeof iterator.return === 'function') {
        subscriber.add(function () {
            if (iterator.return) {
                iterator.return();
            }
        });
    }
    return subscriber;
}; };

});

unwrapExports(subscribeToIterable$1);

var subscribeToObservable$1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

exports.subscribeToObservable = function (obj) { return function (subscriber) {
    var obs = obj[observable$1.observable]();
    if (typeof obs.subscribe !== 'function') {
        throw new TypeError('Provided object does not correctly implement Symbol.observable');
    }
    else {
        return obs.subscribe(subscriber);
    }
}; };

});

unwrapExports(subscribeToObservable$1);

var isArrayLike$1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isArrayLike = (function (x) { return x && typeof x.length === 'number' && typeof x !== 'function'; });

});

unwrapExports(isArrayLike$1);

var isPromise_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function isPromise(value) {
    return !!value && typeof value.subscribe !== 'function' && typeof value.then === 'function';
}
exports.isPromise = isPromise;

});

unwrapExports(isPromise_1);

var subscribeTo$1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });









exports.subscribeTo = function (result) {
    if (!!result && typeof result[observable$1.observable] === 'function') {
        return subscribeToObservable$1.subscribeToObservable(result);
    }
    else if (isArrayLike$1.isArrayLike(result)) {
        return subscribeToArray$1.subscribeToArray(result);
    }
    else if (isPromise_1.isPromise(result)) {
        return subscribeToPromise$1.subscribeToPromise(result);
    }
    else if (!!result && typeof result[iterator$1.iterator] === 'function') {
        return subscribeToIterable$1.subscribeToIterable(result);
    }
    else {
        var value = isObject_1.isObject(result) ? 'an invalid object' : "'" + result + "'";
        var msg = "You provided " + value + " where a stream was expected."
            + ' You can provide an Observable, Promise, Array, or Iterable.';
        throw new TypeError(msg);
    }
};

});

unwrapExports(subscribeTo$1);

var subscribeToResult_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });



function subscribeToResult(outerSubscriber, result, outerValue, outerIndex, innerSubscriber) {
    if (innerSubscriber === void 0) { innerSubscriber = new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex); }
    if (innerSubscriber.closed) {
        return undefined;
    }
    if (result instanceof Observable_1.Observable) {
        return result.subscribe(innerSubscriber);
    }
    return subscribeTo$1.subscribeTo(result)(innerSubscriber);
}
exports.subscribeToResult = subscribeToResult;

});

unwrapExports(subscribeToResult_1);

var combineLatest_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });





var NONE = {};
function combineLatest() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    var resultSelector = null;
    var scheduler = null;
    if (isScheduler_1.isScheduler(observables[observables.length - 1])) {
        scheduler = observables.pop();
    }
    if (typeof observables[observables.length - 1] === 'function') {
        resultSelector = observables.pop();
    }
    if (observables.length === 1 && isArray$1.isArray(observables[0])) {
        observables = observables[0];
    }
    return fromArray_1.fromArray(observables, scheduler).lift(new CombineLatestOperator(resultSelector));
}
exports.combineLatest = combineLatest;
var CombineLatestOperator = (function () {
    function CombineLatestOperator(resultSelector) {
        this.resultSelector = resultSelector;
    }
    CombineLatestOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new CombineLatestSubscriber(subscriber, this.resultSelector));
    };
    return CombineLatestOperator;
}());
exports.CombineLatestOperator = CombineLatestOperator;
var CombineLatestSubscriber = (function (_super) {
    __extends(CombineLatestSubscriber, _super);
    function CombineLatestSubscriber(destination, resultSelector) {
        var _this = _super.call(this, destination) || this;
        _this.resultSelector = resultSelector;
        _this.active = 0;
        _this.values = [];
        _this.observables = [];
        return _this;
    }
    CombineLatestSubscriber.prototype._next = function (observable) {
        this.values.push(NONE);
        this.observables.push(observable);
    };
    CombineLatestSubscriber.prototype._complete = function () {
        var observables = this.observables;
        var len = observables.length;
        if (len === 0) {
            this.destination.complete();
        }
        else {
            this.active = len;
            this.toRespond = len;
            for (var i = 0; i < len; i++) {
                var observable = observables[i];
                this.add(subscribeToResult_1.subscribeToResult(this, observable, observable, i));
            }
        }
    };
    CombineLatestSubscriber.prototype.notifyComplete = function (unused) {
        if ((this.active -= 1) === 0) {
            this.destination.complete();
        }
    };
    CombineLatestSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var values = this.values;
        var oldVal = values[outerIndex];
        var toRespond = !this.toRespond
            ? 0
            : oldVal === NONE ? --this.toRespond : this.toRespond;
        values[outerIndex] = innerValue;
        if (toRespond === 0) {
            if (this.resultSelector) {
                this._tryResultSelector(values);
            }
            else {
                this.destination.next(values.slice());
            }
        }
    };
    CombineLatestSubscriber.prototype._tryResultSelector = function (values) {
        var result;
        try {
            result = this.resultSelector.apply(this, values);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return CombineLatestSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
exports.CombineLatestSubscriber = CombineLatestSubscriber;

});

unwrapExports(combineLatest_1);

var scheduleObservable_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });



function scheduleObservable(input, scheduler) {
    return new Observable_1.Observable(function (subscriber) {
        var sub = new Subscription_1.Subscription();
        sub.add(scheduler.schedule(function () {
            var observable = input[observable$1.observable]();
            sub.add(observable.subscribe({
                next: function (value) { sub.add(scheduler.schedule(function () { return subscriber.next(value); })); },
                error: function (err) { sub.add(scheduler.schedule(function () { return subscriber.error(err); })); },
                complete: function () { sub.add(scheduler.schedule(function () { return subscriber.complete(); })); },
            }));
        }));
        return sub;
    });
}
exports.scheduleObservable = scheduleObservable;

});

unwrapExports(scheduleObservable_1);

var schedulePromise_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });


function schedulePromise(input, scheduler) {
    return new Observable_1.Observable(function (subscriber) {
        var sub = new Subscription_1.Subscription();
        sub.add(scheduler.schedule(function () { return input.then(function (value) {
            sub.add(scheduler.schedule(function () {
                subscriber.next(value);
                sub.add(scheduler.schedule(function () { return subscriber.complete(); }));
            }));
        }, function (err) {
            sub.add(scheduler.schedule(function () { return subscriber.error(err); }));
        }); }));
        return sub;
    });
}
exports.schedulePromise = schedulePromise;

});

unwrapExports(schedulePromise_1);

var scheduleIterable_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });



function scheduleIterable(input, scheduler) {
    if (!input) {
        throw new Error('Iterable cannot be null');
    }
    return new Observable_1.Observable(function (subscriber) {
        var sub = new Subscription_1.Subscription();
        var iterator;
        sub.add(function () {
            if (iterator && typeof iterator.return === 'function') {
                iterator.return();
            }
        });
        sub.add(scheduler.schedule(function () {
            iterator = input[iterator$1.iterator]();
            sub.add(scheduler.schedule(function () {
                if (subscriber.closed) {
                    return;
                }
                var value;
                var done;
                try {
                    var result = iterator.next();
                    value = result.value;
                    done = result.done;
                }
                catch (err) {
                    subscriber.error(err);
                    return;
                }
                if (done) {
                    subscriber.complete();
                }
                else {
                    subscriber.next(value);
                    this.schedule();
                }
            }));
        }));
        return sub;
    });
}
exports.scheduleIterable = scheduleIterable;

});

unwrapExports(scheduleIterable_1);

var isInteropObservable_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

function isInteropObservable(input) {
    return input && typeof input[observable$1.observable] === 'function';
}
exports.isInteropObservable = isInteropObservable;

});

unwrapExports(isInteropObservable_1);

var isIterable_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

function isIterable(input) {
    return input && typeof input[iterator$1.iterator] === 'function';
}
exports.isIterable = isIterable;

});

unwrapExports(isIterable_1);

var scheduled_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });








function scheduled(input, scheduler) {
    if (input != null) {
        if (isInteropObservable_1.isInteropObservable(input)) {
            return scheduleObservable_1.scheduleObservable(input, scheduler);
        }
        else if (isPromise_1.isPromise(input)) {
            return schedulePromise_1.schedulePromise(input, scheduler);
        }
        else if (isArrayLike$1.isArrayLike(input)) {
            return scheduleArray_1.scheduleArray(input, scheduler);
        }
        else if (isIterable_1.isIterable(input) || typeof input === 'string') {
            return scheduleIterable_1.scheduleIterable(input, scheduler);
        }
    }
    throw new TypeError((input !== null && typeof input || input) + ' is not observable');
}
exports.scheduled = scheduled;

});

unwrapExports(scheduled_1);

var from_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });



function from(input, scheduler) {
    if (!scheduler) {
        if (input instanceof Observable_1.Observable) {
            return input;
        }
        return new Observable_1.Observable(subscribeTo$1.subscribeTo(input));
    }
    else {
        return scheduled_1.scheduled(input, scheduler);
    }
}
exports.from = from;

});

unwrapExports(from_1);

var mergeMap_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });





function mergeMap(project, resultSelector, concurrent) {
    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
    if (typeof resultSelector === 'function') {
        return function (source) { return source.pipe(mergeMap(function (a, i) { return from_1.from(project(a, i)).pipe(map_1.map(function (b, ii) { return resultSelector(a, b, i, ii); })); }, concurrent)); };
    }
    else if (typeof resultSelector === 'number') {
        concurrent = resultSelector;
    }
    return function (source) { return source.lift(new MergeMapOperator(project, concurrent)); };
}
exports.mergeMap = mergeMap;
var MergeMapOperator = (function () {
    function MergeMapOperator(project, concurrent) {
        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
        this.project = project;
        this.concurrent = concurrent;
    }
    MergeMapOperator.prototype.call = function (observer, source) {
        return source.subscribe(new MergeMapSubscriber(observer, this.project, this.concurrent));
    };
    return MergeMapOperator;
}());
exports.MergeMapOperator = MergeMapOperator;
var MergeMapSubscriber = (function (_super) {
    __extends(MergeMapSubscriber, _super);
    function MergeMapSubscriber(destination, project, concurrent) {
        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.concurrent = concurrent;
        _this.hasCompleted = false;
        _this.buffer = [];
        _this.active = 0;
        _this.index = 0;
        return _this;
    }
    MergeMapSubscriber.prototype._next = function (value) {
        if (this.active < this.concurrent) {
            this._tryNext(value);
        }
        else {
            this.buffer.push(value);
        }
    };
    MergeMapSubscriber.prototype._tryNext = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.active++;
        this._innerSub(result, value, index);
    };
    MergeMapSubscriber.prototype._innerSub = function (ish, value, index) {
        var innerSubscriber = new InnerSubscriber_1.InnerSubscriber(this, value, index);
        var destination = this.destination;
        destination.add(innerSubscriber);
        var innerSubscription = subscribeToResult_1.subscribeToResult(this, ish, undefined, undefined, innerSubscriber);
        if (innerSubscription !== innerSubscriber) {
            destination.add(innerSubscription);
        }
    };
    MergeMapSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
            this.destination.complete();
        }
        this.unsubscribe();
    };
    MergeMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    MergeMapSubscriber.prototype.notifyComplete = function (innerSub) {
        var buffer = this.buffer;
        this.remove(innerSub);
        this.active--;
        if (buffer.length > 0) {
            this._next(buffer.shift());
        }
        else if (this.active === 0 && this.hasCompleted) {
            this.destination.complete();
        }
    };
    return MergeMapSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
exports.MergeMapSubscriber = MergeMapSubscriber;

});

unwrapExports(mergeMap_1);

var mergeAll_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });


function mergeAll(concurrent) {
    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
    return mergeMap_1.mergeMap(identity_1.identity, concurrent);
}
exports.mergeAll = mergeAll;

});

unwrapExports(mergeAll_1);

var concatAll_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

function concatAll() {
    return mergeAll_1.mergeAll(1);
}
exports.concatAll = concatAll;

});

unwrapExports(concatAll_1);

var concat_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });


function concat() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    return concatAll_1.concatAll()(of_1.of.apply(void 0, observables));
}
exports.concat = concat;

});

unwrapExports(concat_1);

var defer_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });



function defer(observableFactory) {
    return new Observable_1.Observable(function (subscriber) {
        var input;
        try {
            input = observableFactory();
        }
        catch (err) {
            subscriber.error(err);
            return undefined;
        }
        var source = input ? from_1.from(input) : empty_1.empty();
        return source.subscribe(subscriber);
    });
}
exports.defer = defer;

});

unwrapExports(defer_1);

var forkJoin_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });





function forkJoin() {
    var sources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
    }
    if (sources.length === 1) {
        var first_1 = sources[0];
        if (isArray$1.isArray(first_1)) {
            return forkJoinInternal(first_1, null);
        }
        if (isObject_1.isObject(first_1) && Object.getPrototypeOf(first_1) === Object.prototype) {
            var keys = Object.keys(first_1);
            return forkJoinInternal(keys.map(function (key) { return first_1[key]; }), keys);
        }
    }
    if (typeof sources[sources.length - 1] === 'function') {
        var resultSelector_1 = sources.pop();
        sources = (sources.length === 1 && isArray$1.isArray(sources[0])) ? sources[0] : sources;
        return forkJoinInternal(sources, null).pipe(map_1.map(function (args) { return resultSelector_1.apply(void 0, args); }));
    }
    return forkJoinInternal(sources, null);
}
exports.forkJoin = forkJoin;
function forkJoinInternal(sources, keys) {
    return new Observable_1.Observable(function (subscriber) {
        var len = sources.length;
        if (len === 0) {
            subscriber.complete();
            return;
        }
        var values = new Array(len);
        var completed = 0;
        var emitted = 0;
        var _loop_1 = function (i) {
            var source = from_1.from(sources[i]);
            var hasValue = false;
            subscriber.add(source.subscribe({
                next: function (value) {
                    if (!hasValue) {
                        hasValue = true;
                        emitted++;
                    }
                    values[i] = value;
                },
                error: function (err) { return subscriber.error(err); },
                complete: function () {
                    completed++;
                    if (completed === len || !hasValue) {
                        if (emitted === len) {
                            subscriber.next(keys ?
                                keys.reduce(function (result, key, i) { return (result[key] = values[i], result); }, {}) :
                                values);
                        }
                        subscriber.complete();
                    }
                }
            }));
        };
        for (var i = 0; i < len; i++) {
            _loop_1(i);
        }
    });
}

});

unwrapExports(forkJoin_1);

var fromEvent_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });




function fromEvent(target, eventName, options, resultSelector) {
    if (isFunction_1.isFunction(options)) {
        resultSelector = options;
        options = undefined;
    }
    if (resultSelector) {
        return fromEvent(target, eventName, options).pipe(map_1.map(function (args) { return isArray$1.isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));
    }
    return new Observable_1.Observable(function (subscriber) {
        function handler(e) {
            if (arguments.length > 1) {
                subscriber.next(Array.prototype.slice.call(arguments));
            }
            else {
                subscriber.next(e);
            }
        }
        setupSubscription(target, eventName, handler, subscriber, options);
    });
}
exports.fromEvent = fromEvent;
function setupSubscription(sourceObj, eventName, handler, subscriber, options) {
    var unsubscribe;
    if (isEventTarget(sourceObj)) {
        var source_1 = sourceObj;
        sourceObj.addEventListener(eventName, handler, options);
        unsubscribe = function () { return source_1.removeEventListener(eventName, handler, options); };
    }
    else if (isJQueryStyleEventEmitter(sourceObj)) {
        var source_2 = sourceObj;
        sourceObj.on(eventName, handler);
        unsubscribe = function () { return source_2.off(eventName, handler); };
    }
    else if (isNodeStyleEventEmitter(sourceObj)) {
        var source_3 = sourceObj;
        sourceObj.addListener(eventName, handler);
        unsubscribe = function () { return source_3.removeListener(eventName, handler); };
    }
    else if (sourceObj && sourceObj.length) {
        for (var i = 0, len = sourceObj.length; i < len; i++) {
            setupSubscription(sourceObj[i], eventName, handler, subscriber, options);
        }
    }
    else {
        throw new TypeError('Invalid event target');
    }
    subscriber.add(unsubscribe);
}
function isNodeStyleEventEmitter(sourceObj) {
    return sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';
}
function isJQueryStyleEventEmitter(sourceObj) {
    return sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';
}
function isEventTarget(sourceObj) {
    return sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';
}

});

unwrapExports(fromEvent_1);

var fromEventPattern_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });




function fromEventPattern(addHandler, removeHandler, resultSelector) {
    if (resultSelector) {
        return fromEventPattern(addHandler, removeHandler).pipe(map_1.map(function (args) { return isArray$1.isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));
    }
    return new Observable_1.Observable(function (subscriber) {
        var handler = function () {
            var e = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                e[_i] = arguments[_i];
            }
            return subscriber.next(e.length === 1 ? e[0] : e);
        };
        var retValue;
        try {
            retValue = addHandler(handler);
        }
        catch (err) {
            subscriber.error(err);
            return undefined;
        }
        if (!isFunction_1.isFunction(removeHandler)) {
            return undefined;
        }
        return function () { return removeHandler(handler, retValue); };
    });
}
exports.fromEventPattern = fromEventPattern;

});

unwrapExports(fromEventPattern_1);

var generate_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });



function generate(initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler) {
    var resultSelector;
    var initialState;
    if (arguments.length == 1) {
        var options = initialStateOrOptions;
        initialState = options.initialState;
        condition = options.condition;
        iterate = options.iterate;
        resultSelector = options.resultSelector || identity_1.identity;
        scheduler = options.scheduler;
    }
    else if (resultSelectorOrObservable === undefined || isScheduler_1.isScheduler(resultSelectorOrObservable)) {
        initialState = initialStateOrOptions;
        resultSelector = identity_1.identity;
        scheduler = resultSelectorOrObservable;
    }
    else {
        initialState = initialStateOrOptions;
        resultSelector = resultSelectorOrObservable;
    }
    return new Observable_1.Observable(function (subscriber) {
        var state = initialState;
        if (scheduler) {
            return scheduler.schedule(dispatch, 0, {
                subscriber: subscriber,
                iterate: iterate,
                condition: condition,
                resultSelector: resultSelector,
                state: state
            });
        }
        do {
            if (condition) {
                var conditionResult = void 0;
                try {
                    conditionResult = condition(state);
                }
                catch (err) {
                    subscriber.error(err);
                    return undefined;
                }
                if (!conditionResult) {
                    subscriber.complete();
                    break;
                }
            }
            var value = void 0;
            try {
                value = resultSelector(state);
            }
            catch (err) {
                subscriber.error(err);
                return undefined;
            }
            subscriber.next(value);
            if (subscriber.closed) {
                break;
            }
            try {
                state = iterate(state);
            }
            catch (err) {
                subscriber.error(err);
                return undefined;
            }
        } while (true);
        return undefined;
    });
}
exports.generate = generate;
function dispatch(state) {
    var subscriber = state.subscriber, condition = state.condition;
    if (subscriber.closed) {
        return undefined;
    }
    if (state.needIterate) {
        try {
            state.state = state.iterate(state.state);
        }
        catch (err) {
            subscriber.error(err);
            return undefined;
        }
    }
    else {
        state.needIterate = true;
    }
    if (condition) {
        var conditionResult = void 0;
        try {
            conditionResult = condition(state.state);
        }
        catch (err) {
            subscriber.error(err);
            return undefined;
        }
        if (!conditionResult) {
            subscriber.complete();
            return undefined;
        }
        if (subscriber.closed) {
            return undefined;
        }
    }
    var value;
    try {
        value = state.resultSelector(state.state);
    }
    catch (err) {
        subscriber.error(err);
        return undefined;
    }
    if (subscriber.closed) {
        return undefined;
    }
    subscriber.next(value);
    if (subscriber.closed) {
        return undefined;
    }
    return this.schedule(state);
}

});

unwrapExports(generate_1);

var iif_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });


function iif(condition, trueResult, falseResult) {
    if (trueResult === void 0) { trueResult = empty_1.EMPTY; }
    if (falseResult === void 0) { falseResult = empty_1.EMPTY; }
    return defer_1.defer(function () { return condition() ? trueResult : falseResult; });
}
exports.iif = iif;

});

unwrapExports(iif_1);

var isNumeric_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

function isNumeric(val) {
    return !isArray$1.isArray(val) && (val - parseFloat(val) + 1) >= 0;
}
exports.isNumeric = isNumeric;

});

unwrapExports(isNumeric_1);

var interval_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });



function interval(period, scheduler) {
    if (period === void 0) { period = 0; }
    if (scheduler === void 0) { scheduler = async$1.async; }
    if (!isNumeric_1.isNumeric(period) || period < 0) {
        period = 0;
    }
    if (!scheduler || typeof scheduler.schedule !== 'function') {
        scheduler = async$1.async;
    }
    return new Observable_1.Observable(function (subscriber) {
        subscriber.add(scheduler.schedule(dispatch, period, { subscriber: subscriber, counter: 0, period: period }));
        return subscriber;
    });
}
exports.interval = interval;
function dispatch(state) {
    var subscriber = state.subscriber, counter = state.counter, period = state.period;
    subscriber.next(counter);
    this.schedule({ subscriber: subscriber, counter: counter + 1, period: period }, period);
}

});

unwrapExports(interval_1);

var merge_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });




function merge() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    var concurrent = Number.POSITIVE_INFINITY;
    var scheduler = null;
    var last = observables[observables.length - 1];
    if (isScheduler_1.isScheduler(last)) {
        scheduler = observables.pop();
        if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {
            concurrent = observables.pop();
        }
    }
    else if (typeof last === 'number') {
        concurrent = observables.pop();
    }
    if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable_1.Observable) {
        return observables[0];
    }
    return mergeAll_1.mergeAll(concurrent)(fromArray_1.fromArray(observables, scheduler));
}
exports.merge = merge;

});

unwrapExports(merge_1);

var never_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });


exports.NEVER = new Observable_1.Observable(noop_1.noop);
function never() {
    return exports.NEVER;
}
exports.never = never;

});

unwrapExports(never_1);

var onErrorResumeNext_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });




function onErrorResumeNext() {
    var sources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
    }
    if (sources.length === 0) {
        return empty_1.EMPTY;
    }
    var first = sources[0], remainder = sources.slice(1);
    if (sources.length === 1 && isArray$1.isArray(first)) {
        return onErrorResumeNext.apply(void 0, first);
    }
    return new Observable_1.Observable(function (subscriber) {
        var subNext = function () { return subscriber.add(onErrorResumeNext.apply(void 0, remainder).subscribe(subscriber)); };
        return from_1.from(first).subscribe({
            next: function (value) { subscriber.next(value); },
            error: subNext,
            complete: subNext,
        });
    });
}
exports.onErrorResumeNext = onErrorResumeNext;

});

unwrapExports(onErrorResumeNext_1);

var pairs_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });


function pairs(obj, scheduler) {
    if (!scheduler) {
        return new Observable_1.Observable(function (subscriber) {
            var keys = Object.keys(obj);
            for (var i = 0; i < keys.length && !subscriber.closed; i++) {
                var key = keys[i];
                if (obj.hasOwnProperty(key)) {
                    subscriber.next([key, obj[key]]);
                }
            }
            subscriber.complete();
        });
    }
    else {
        return new Observable_1.Observable(function (subscriber) {
            var keys = Object.keys(obj);
            var subscription = new Subscription_1.Subscription();
            subscription.add(scheduler.schedule(dispatch, 0, { keys: keys, index: 0, subscriber: subscriber, subscription: subscription, obj: obj }));
            return subscription;
        });
    }
}
exports.pairs = pairs;
function dispatch(state) {
    var keys = state.keys, index = state.index, subscriber = state.subscriber, subscription = state.subscription, obj = state.obj;
    if (!subscriber.closed) {
        if (index < keys.length) {
            var key = keys[index];
            subscriber.next([key, obj[key]]);
            subscription.add(this.schedule({ keys: keys, index: index + 1, subscriber: subscriber, subscription: subscription, obj: obj }));
        }
        else {
            subscriber.complete();
        }
    }
}
exports.dispatch = dispatch;

});

unwrapExports(pairs_1);

var not_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function not(pred, thisArg) {
    function notPred() {
        return !(notPred.pred.apply(notPred.thisArg, arguments));
    }
    notPred.pred = pred;
    notPred.thisArg = thisArg;
    return notPred;
}
exports.not = not;

});

unwrapExports(not_1);

var filter_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });

function filter(predicate, thisArg) {
    return function filterOperatorFunction(source) {
        return source.lift(new FilterOperator(predicate, thisArg));
    };
}
exports.filter = filter;
var FilterOperator = (function () {
    function FilterOperator(predicate, thisArg) {
        this.predicate = predicate;
        this.thisArg = thisArg;
    }
    FilterOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
    };
    return FilterOperator;
}());
var FilterSubscriber = (function (_super) {
    __extends(FilterSubscriber, _super);
    function FilterSubscriber(destination, predicate, thisArg) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.thisArg = thisArg;
        _this.count = 0;
        return _this;
    }
    FilterSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.predicate.call(this.thisArg, value, this.count++);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        if (result) {
            this.destination.next(value);
        }
    };
    return FilterSubscriber;
}(Subscriber_1.Subscriber));

});

unwrapExports(filter_1);

var partition_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });




function partition(source, predicate, thisArg) {
    return [
        filter_1.filter(predicate, thisArg)(new Observable_1.Observable(subscribeTo$1.subscribeTo(source))),
        filter_1.filter(not_1.not(predicate, thisArg))(new Observable_1.Observable(subscribeTo$1.subscribeTo(source)))
    ];
}
exports.partition = partition;

});

unwrapExports(partition_1);

var race_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });




function race() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    if (observables.length === 1) {
        if (isArray$1.isArray(observables[0])) {
            observables = observables[0];
        }
        else {
            return observables[0];
        }
    }
    return fromArray_1.fromArray(observables, undefined).lift(new RaceOperator());
}
exports.race = race;
var RaceOperator = (function () {
    function RaceOperator() {
    }
    RaceOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RaceSubscriber(subscriber));
    };
    return RaceOperator;
}());
exports.RaceOperator = RaceOperator;
var RaceSubscriber = (function (_super) {
    __extends(RaceSubscriber, _super);
    function RaceSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.hasFirst = false;
        _this.observables = [];
        _this.subscriptions = [];
        return _this;
    }
    RaceSubscriber.prototype._next = function (observable) {
        this.observables.push(observable);
    };
    RaceSubscriber.prototype._complete = function () {
        var observables = this.observables;
        var len = observables.length;
        if (len === 0) {
            this.destination.complete();
        }
        else {
            for (var i = 0; i < len && !this.hasFirst; i++) {
                var observable = observables[i];
                var subscription = subscribeToResult_1.subscribeToResult(this, observable, observable, i);
                if (this.subscriptions) {
                    this.subscriptions.push(subscription);
                }
                this.add(subscription);
            }
            this.observables = null;
        }
    };
    RaceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (!this.hasFirst) {
            this.hasFirst = true;
            for (var i = 0; i < this.subscriptions.length; i++) {
                if (i !== outerIndex) {
                    var subscription = this.subscriptions[i];
                    subscription.unsubscribe();
                    this.remove(subscription);
                }
            }
            this.subscriptions = null;
        }
        this.destination.next(innerValue);
    };
    return RaceSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
exports.RaceSubscriber = RaceSubscriber;

});

unwrapExports(race_1);

var range_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

function range(start, count, scheduler) {
    if (start === void 0) { start = 0; }
    return new Observable_1.Observable(function (subscriber) {
        if (count === undefined) {
            count = start;
            start = 0;
        }
        var index = 0;
        var current = start;
        if (scheduler) {
            return scheduler.schedule(dispatch, 0, {
                index: index, count: count, start: start, subscriber: subscriber
            });
        }
        else {
            do {
                if (index++ >= count) {
                    subscriber.complete();
                    break;
                }
                subscriber.next(current++);
                if (subscriber.closed) {
                    break;
                }
            } while (true);
        }
        return undefined;
    });
}
exports.range = range;
function dispatch(state) {
    var start = state.start, index = state.index, count = state.count, subscriber = state.subscriber;
    if (index >= count) {
        subscriber.complete();
        return;
    }
    subscriber.next(start);
    if (subscriber.closed) {
        return;
    }
    state.index = index + 1;
    state.start = start + 1;
    this.schedule(state);
}
exports.dispatch = dispatch;

});

unwrapExports(range_1);

var timer_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });




function timer(dueTime, periodOrScheduler, scheduler) {
    if (dueTime === void 0) { dueTime = 0; }
    var period = -1;
    if (isNumeric_1.isNumeric(periodOrScheduler)) {
        period = Number(periodOrScheduler) < 1 && 1 || Number(periodOrScheduler);
    }
    else if (isScheduler_1.isScheduler(periodOrScheduler)) {
        scheduler = periodOrScheduler;
    }
    if (!isScheduler_1.isScheduler(scheduler)) {
        scheduler = async$1.async;
    }
    return new Observable_1.Observable(function (subscriber) {
        var due = isNumeric_1.isNumeric(dueTime)
            ? dueTime
            : (+dueTime - scheduler.now());
        return scheduler.schedule(dispatch, due, {
            index: 0, period: period, subscriber: subscriber
        });
    });
}
exports.timer = timer;
function dispatch(state) {
    var index = state.index, period = state.period, subscriber = state.subscriber;
    subscriber.next(index);
    if (subscriber.closed) {
        return;
    }
    else if (period === -1) {
        return subscriber.complete();
    }
    state.index = index + 1;
    this.schedule(state, period);
}

});

unwrapExports(timer_1);

var using_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });



function using(resourceFactory, observableFactory) {
    return new Observable_1.Observable(function (subscriber) {
        var resource;
        try {
            resource = resourceFactory();
        }
        catch (err) {
            subscriber.error(err);
            return undefined;
        }
        var result;
        try {
            result = observableFactory(resource);
        }
        catch (err) {
            subscriber.error(err);
            return undefined;
        }
        var source = result ? from_1.from(result) : empty_1.EMPTY;
        var subscription = source.subscribe(subscriber);
        return function () {
            subscription.unsubscribe();
            if (resource) {
                resource.unsubscribe();
            }
        };
    });
}
exports.using = using;

});

unwrapExports(using_1);

var zip_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });






function zip() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    var resultSelector = observables[observables.length - 1];
    if (typeof resultSelector === 'function') {
        observables.pop();
    }
    return fromArray_1.fromArray(observables, undefined).lift(new ZipOperator(resultSelector));
}
exports.zip = zip;
var ZipOperator = (function () {
    function ZipOperator(resultSelector) {
        this.resultSelector = resultSelector;
    }
    ZipOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ZipSubscriber(subscriber, this.resultSelector));
    };
    return ZipOperator;
}());
exports.ZipOperator = ZipOperator;
var ZipSubscriber = (function (_super) {
    __extends(ZipSubscriber, _super);
    function ZipSubscriber(destination, resultSelector, values) {
        if (values === void 0) { values = Object.create(null); }
        var _this = _super.call(this, destination) || this;
        _this.iterators = [];
        _this.active = 0;
        _this.resultSelector = (typeof resultSelector === 'function') ? resultSelector : null;
        _this.values = values;
        return _this;
    }
    ZipSubscriber.prototype._next = function (value) {
        var iterators = this.iterators;
        if (isArray$1.isArray(value)) {
            iterators.push(new StaticArrayIterator(value));
        }
        else if (typeof value[iterator$1.iterator] === 'function') {
            iterators.push(new StaticIterator(value[iterator$1.iterator]()));
        }
        else {
            iterators.push(new ZipBufferIterator(this.destination, this, value));
        }
    };
    ZipSubscriber.prototype._complete = function () {
        var iterators = this.iterators;
        var len = iterators.length;
        this.unsubscribe();
        if (len === 0) {
            this.destination.complete();
            return;
        }
        this.active = len;
        for (var i = 0; i < len; i++) {
            var iterator = iterators[i];
            if (iterator.stillUnsubscribed) {
                var destination = this.destination;
                destination.add(iterator.subscribe(iterator, i));
            }
            else {
                this.active--;
            }
        }
    };
    ZipSubscriber.prototype.notifyInactive = function () {
        this.active--;
        if (this.active === 0) {
            this.destination.complete();
        }
    };
    ZipSubscriber.prototype.checkIterators = function () {
        var iterators = this.iterators;
        var len = iterators.length;
        var destination = this.destination;
        for (var i = 0; i < len; i++) {
            var iterator = iterators[i];
            if (typeof iterator.hasValue === 'function' && !iterator.hasValue()) {
                return;
            }
        }
        var shouldComplete = false;
        var args = [];
        for (var i = 0; i < len; i++) {
            var iterator = iterators[i];
            var result = iterator.next();
            if (iterator.hasCompleted()) {
                shouldComplete = true;
            }
            if (result.done) {
                destination.complete();
                return;
            }
            args.push(result.value);
        }
        if (this.resultSelector) {
            this._tryresultSelector(args);
        }
        else {
            destination.next(args);
        }
        if (shouldComplete) {
            destination.complete();
        }
    };
    ZipSubscriber.prototype._tryresultSelector = function (args) {
        var result;
        try {
            result = this.resultSelector.apply(this, args);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return ZipSubscriber;
}(Subscriber_1.Subscriber));
exports.ZipSubscriber = ZipSubscriber;
var StaticIterator = (function () {
    function StaticIterator(iterator) {
        this.iterator = iterator;
        this.nextResult = iterator.next();
    }
    StaticIterator.prototype.hasValue = function () {
        return true;
    };
    StaticIterator.prototype.next = function () {
        var result = this.nextResult;
        this.nextResult = this.iterator.next();
        return result;
    };
    StaticIterator.prototype.hasCompleted = function () {
        var nextResult = this.nextResult;
        return nextResult && nextResult.done;
    };
    return StaticIterator;
}());
var StaticArrayIterator = (function () {
    function StaticArrayIterator(array) {
        this.array = array;
        this.index = 0;
        this.length = 0;
        this.length = array.length;
    }
    StaticArrayIterator.prototype[iterator$1.iterator] = function () {
        return this;
    };
    StaticArrayIterator.prototype.next = function (value) {
        var i = this.index++;
        var array = this.array;
        return i < this.length ? { value: array[i], done: false } : { value: null, done: true };
    };
    StaticArrayIterator.prototype.hasValue = function () {
        return this.array.length > this.index;
    };
    StaticArrayIterator.prototype.hasCompleted = function () {
        return this.array.length === this.index;
    };
    return StaticArrayIterator;
}());
var ZipBufferIterator = (function (_super) {
    __extends(ZipBufferIterator, _super);
    function ZipBufferIterator(destination, parent, observable) {
        var _this = _super.call(this, destination) || this;
        _this.parent = parent;
        _this.observable = observable;
        _this.stillUnsubscribed = true;
        _this.buffer = [];
        _this.isComplete = false;
        return _this;
    }
    ZipBufferIterator.prototype[iterator$1.iterator] = function () {
        return this;
    };
    ZipBufferIterator.prototype.next = function () {
        var buffer = this.buffer;
        if (buffer.length === 0 && this.isComplete) {
            return { value: null, done: true };
        }
        else {
            return { value: buffer.shift(), done: false };
        }
    };
    ZipBufferIterator.prototype.hasValue = function () {
        return this.buffer.length > 0;
    };
    ZipBufferIterator.prototype.hasCompleted = function () {
        return this.buffer.length === 0 && this.isComplete;
    };
    ZipBufferIterator.prototype.notifyComplete = function () {
        if (this.buffer.length > 0) {
            this.isComplete = true;
            this.parent.notifyInactive();
        }
        else {
            this.destination.complete();
        }
    };
    ZipBufferIterator.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.buffer.push(innerValue);
        this.parent.checkIterators();
    };
    ZipBufferIterator.prototype.subscribe = function (value, index) {
        return subscribeToResult_1.subscribeToResult(this, this.observable, this, index);
    };
    return ZipBufferIterator;
}(OuterSubscriber_1.OuterSubscriber));

});

unwrapExports(zip_1);

var rxjs = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

exports.Observable = Observable_1.Observable;

exports.ConnectableObservable = ConnectableObservable_1.ConnectableObservable;

exports.GroupedObservable = groupBy_1.GroupedObservable;

exports.observable = observable$1.observable;

exports.Subject = Subject_1.Subject;

exports.BehaviorSubject = BehaviorSubject_1.BehaviorSubject;

exports.ReplaySubject = ReplaySubject_1.ReplaySubject;

exports.AsyncSubject = AsyncSubject_1.AsyncSubject;

exports.asapScheduler = asap$1.asap;

exports.asyncScheduler = async$1.async;

exports.queueScheduler = queue$1.queue;

exports.animationFrameScheduler = animationFrame$1.animationFrame;

exports.VirtualTimeScheduler = VirtualTimeScheduler_1.VirtualTimeScheduler;
exports.VirtualAction = VirtualTimeScheduler_1.VirtualAction;

exports.Scheduler = Scheduler_1.Scheduler;

exports.Subscription = Subscription_1.Subscription;

exports.Subscriber = Subscriber_1.Subscriber;

exports.Notification = Notification_1.Notification;
exports.NotificationKind = Notification_1.NotificationKind;

exports.pipe = pipe_1.pipe;

exports.noop = noop_1.noop;

exports.identity = identity_1.identity;

exports.isObservable = isObservable_1.isObservable;

exports.ArgumentOutOfRangeError = ArgumentOutOfRangeError$1.ArgumentOutOfRangeError;

exports.EmptyError = EmptyError$1.EmptyError;

exports.ObjectUnsubscribedError = ObjectUnsubscribedError$1.ObjectUnsubscribedError;

exports.UnsubscriptionError = UnsubscriptionError$1.UnsubscriptionError;

exports.TimeoutError = TimeoutError$1.TimeoutError;

exports.bindCallback = bindCallback_1.bindCallback;

exports.bindNodeCallback = bindNodeCallback_1.bindNodeCallback;

exports.combineLatest = combineLatest_1.combineLatest;

exports.concat = concat_1.concat;

exports.defer = defer_1.defer;

exports.empty = empty_1.empty;

exports.forkJoin = forkJoin_1.forkJoin;

exports.from = from_1.from;

exports.fromEvent = fromEvent_1.fromEvent;

exports.fromEventPattern = fromEventPattern_1.fromEventPattern;

exports.generate = generate_1.generate;

exports.iif = iif_1.iif;

exports.interval = interval_1.interval;

exports.merge = merge_1.merge;

exports.never = never_1.never;

exports.of = of_1.of;

exports.onErrorResumeNext = onErrorResumeNext_1.onErrorResumeNext;

exports.pairs = pairs_1.pairs;

exports.partition = partition_1.partition;

exports.race = race_1.race;

exports.range = range_1.range;

exports.throwError = throwError_1.throwError;

exports.timer = timer_1.timer;

exports.using = using_1.using;

exports.zip = zip_1.zip;

exports.scheduled = scheduled_1.scheduled;
var empty_2 = empty_1;
exports.EMPTY = empty_2.EMPTY;
var never_2 = never_1;
exports.NEVER = never_2.NEVER;

exports.config = config$1.config;

});

unwrapExports(rxjs);
var rxjs_1 = rxjs.Observable;
var rxjs_5 = rxjs.Subject;
var rxjs_6 = rxjs.BehaviorSubject;

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*Created by ashwini on 01/03/19.
*/
// @Component({
//     selector: 'life-cycle',
//     template: './lifecycle.base.component.html',
// })
class LifeCycleBaseComponent {
    /**
     * @param {?=} document
     */
    constructor(document) {
        this.document = document;
        this.initiated = new EventEmitter();
        this.ready = new EventEmitter();
        this.minimizeWindow2 = new EventEmitter();
        this.destroy = new EventEmitter();
        this.fullscreenMax = false;
        this.maximizeBehaiourCe1 = new rxjs_6(false);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.elem = document.documentElement;
        document.addEventListener('webkitfullscreenchange', this.exitHandler.bind(this), false);
        document.addEventListener('mozfullscreenchange', this.exitHandler.bind(this), false);
        document.addEventListener('fullscreenexit', this.exitHandler.bind(this), false);
        document.addEventListener('MSFullscreenChange', this.exitHandler.bind(this), false);
        if (this.enableLifeCycleEvents === 'all' || this.enableLifeCycleEvents === 'init') {
            this.lifeCycleInit();
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (this.enableLifeCycleEvents === 'all' || this.enableLifeCycleEvents === 'ready') {
            this.lifeCycleAfterViewInit();
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.enableLifeCycleEvents === 'all' || this.enableLifeCycleEvents === 'destroy') {
            this.lifeCycleDestroy();
        }
    }
    /**
     * @return {?}
     */
    lifeCycleInit() {
        this.initiated.emit();
    }
    /**
     * @return {?}
     */
    lifeCycleAfterViewInit() {
        this.ready.emit();
    }
    /**
     * @return {?}
     */
    lifeCycleDestroy() {
        this.destroy.emit();
    }
    /**
     * @param {?} type
     * @return {?}
     */
    setRoundEdge(type) {
        if (type === 'round-edge') {
            this.roundedgeclass = 'roundEdgeCommonCss';
        }
        else if (type === 'classic') {
            this.roundedgeclass = 'classicCommonCss';
        }
    }
    /**
     * @param {?} type
     * @return {?}
     */
    setFullScreen(type) {
        this.yesFullScreen = true;
        if (type === 'browser') {
            this.desktopFlag = false;
        }
        else if (type === 'desktop') {
            this.desktopFlag = true;
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    maxScreenChange(event) {
        event.stopPropagation();
        this.fullscreenMax = !this.fullscreenMax;
        if (this.elem.requestFullscreen && this.desktopFlag) {
            this.elem.requestFullscreen();
        }
        else if (this.elem.mozRequestFullScreen && this.desktopFlag) {
            /* Firefox */
            this.elem.mozRequestFullScreen();
        }
        else if (this.elem.webkitRequestFullscreen && this.desktopFlag) {
            /* Chrome, Safari and Opera */
            this.elem.webkitRequestFullscreen();
        }
        else if (this.elem.msRequestFullscreen && this.desktopFlag) {
            /* IE/Edge */
            this.elem.msRequestFullscreen();
        }
        return this.fullscreenMax;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    minScreenChange(event) {
        event.stopPropagation();
        this.fullscreenMax = !this.fullscreenMax;
        if (this.document.exitFullscreen && this.desktopFlag) {
            this.document.exitFullscreen();
        }
        else if (this.document.mozCancelFullScreen && this.desktopFlag) {
            /* Firefox */
            this.document.mozCancelFullScreen();
        }
        else if (this.document.webkitExitFullscreen && this.desktopFlag) {
            /* Chrome, Safari and Opera */
            this.document.webkitExitFullscreen();
        }
        else if (this.document.msExitFullscreen && this.desktopFlag) {
            /* IE/Edge */
            this.document.msExitFullscreen();
        }
        return this.fullscreenMax;
    }
    /**
     * @return {?}
     */
    exitHandler() {
        if (!document['webkitIsFullScreen']) {
            this.fullscreenMax = false;
            if (this.instance !== undefined &&
                (this.instance.amexioComponentId === 'amexio-card-ce' || this.instance.amexioComponentId === 'amexio-card'
                    || this.instance.amexioComponentId === 'amexio-window')) {
                this.instance.maximizeflagchanged = false;
                if (this.instance.headerinst !== undefined) {
                    this.instance.headerinst.fullscreenMaxCard = true;
                }
            }
        }
    }
}
/** @nocollapse */
LifeCycleBaseComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
];
LifeCycleBaseComponent.propDecorators = {
    enableLifeCycleEvents: [{ type: Input, args: ['enable-lifecycle-events',] }],
    initiated: [{ type: Output }],
    ready: [{ type: Output }],
    minimizeWindow2: [{ type: Output }],
    destroy: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by dattaram on 23/1/18.
*/
// Dialogue
class AmexiodialoguePaneComponent extends LifeCycleBaseComponent {
    /**
     * @param {?} renderer
     */
    constructor(renderer) {
        super();
        this.renderer = renderer;
        /*
           Properties
           name : button-size
           datatype :  string
           version : 4.2 onwards
           default :
           description : Different Sizes of Buttons availabe : large, default, small & xsmall
           */
        this.buttonsize = 'large' || 'small' || 'default' || 'xsmall';
        this.showChange = new EventEmitter();
        /*
           Events
           name : actionStatus
           datatype :  none
           version : none
           default : none
           description : Fire when click on yes or no button
           */
        this.actionStatus = new EventEmitter();
        /*
           Events
           name : onSuccess
           datatype :  none
           version : none
           default : none
           description : Fire when click on yes or no button
           */
        this.onSuccess = new EventEmitter();
        /*
           Events
           name : onFailure
           datatype :  none
           version : none
           default : none
           description : Fire when click on yes or no button
           */
        this.onCancel = new EventEmitter();
        /*
           Events
           name : close
           datatype :  none
           version : none
           default : none
           description : Fire when user close dialogue
           */
        this.close = new EventEmitter();
        this.amexioComponentId = 'amexio-dialogue';
        this.transitionOptions = '400ms cubic-bezier(0.86, 0, 0.07, 1)';
        this.value = 0;
        this.closable = true;
        this.secondaryactionlabel = 'Cancel';
        this.primaryactionlabel = 'Ok';
        this.custom = false;
        this.buttonsize = 'default';
        this.buttontype = 'theme-color';
        this.closeonescape = true;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.showdialogue) {
            this.show = this.showdialogue;
        }
        if (this.footeralign == null) {
            this.footeralign = 'right';
        }
        if (this.contentalign == null || this.contentalign === '') {
            this.contentalign = 'center';
        }
        if (this.type == null) {
            this.type = 'confirm';
        }
        this.defaultStyle = this.getDefaultStyle();
        this.buttontype = this.getStyle();
        this.componentId = this.createCompId('dialog', this.type);
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (this.amexioFooter) {
            this.amexioFooter.toArray().forEach((/**
             * @param {?} footer
             * @return {?}
             */
            (footer) => {
                footer.footer = true;
            }));
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes['show']) {
            this.show = changes.show.currentValue;
            this.escapeMethod();
        }
        else if (changes['showdialogue']) {
            this.show = changes.showdialogue.currentValue;
            this.escapeMethod();
        }
    }
    // Method called on escape
    /**
     * @return {?}
     */
    escapeMethod() {
        if (this.show && this.closeonescape) {
            this.globalListenFunc = this.renderer.listen('document', 'keyup.esc', (/**
             * @param {?} e
             * @return {?}
             */
            (e) => {
                this.showdialogue = false;
                this.show = false;
                this.showChange.emit(false);
            }));
        }
        else if (this.globalListenFunc) {
            this.globalListenFunc();
        }
    }
    /**
     * @return {?}
     */
    onCloseClick() {
        if (this.closable) {
            this.showdialogue = false;
            this.show = false;
            this.showChange.emit(false);
            this.close.emit(false);
        }
    }
    /**
     * @param {?} v
     * @return {?}
     */
    getStatus(v) {
        this.onCloseClick();
        this.actionStatus.emit(v);
        if (v === 'ok') {
            this.onSuccess.emit(v);
        }
        else {
            this.onCancel.emit(v);
        }
    }
    /**
     * @return {?}
     */
    getDefaultStyle() {
        if (this.materialDesign) {
            return 'transparent';
        }
        else {
            return 'defualt';
        }
    }
    /**
     * @return {?}
     */
    getStyle() {
        if (this.materialDesign) {
            this.buttontype = 'transparent';
            return this.buttontype;
        }
        else {
            return this.buttontype;
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.globalListenFunc) {
            this.globalListenFunc();
        }
    }
    /**
     * @param {?} inputType
     * @param {?} name
     * @return {?}
     */
    createCompId(inputType, name) {
        return inputType + '_' + name + '_' + Math.floor(window.crypto.getRandomValues(new Uint32Array(1))[0]);
    }
    // Theme Apply
    /**
     * @param {?} themeClass
     * @return {?}
     */
    setColorPalette(themeClass) {
        this.themeCss = themeClass;
    }
}
AmexiodialoguePaneComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-dialogue',
                template: `
    <div class="root-window" *ngIf="show">
        <!-- Generate BG shade for below modal -->
    </div>

    <div class="dialogue-sm {{roundedgeclass}}" [@animation]="{value: 'visible', params: {transitionParams: transitionOptions}}" *ngIf="show">
        <div role="dialog" attr.aria-labelledby="componentId" class="dialogue-content">
            <header class="{{themeCss}}" [ngClass]="{'dialogue-material-design':materialDesign ,'dialogue-header':!materialDesign}">
                <div id="{{componentId}}" tabindex="1" class="dialogue-table">
                    <div class="tablerow">
                        <div class="tablecol">
                            {{title}}
                        </div>
                        <div tabindex="1" aria-label="close button" class="tablecol float-right">
                            <div *ngIf="closable" class="icon-style">
                                <amexio-c-icon [key]="'window_close'" (onClick)="onCloseClick()"></amexio-c-icon>
                            </div>
                        </div>
                    </div>
                </div>
            </header>
            <div class="dialogue-middle" [ngStyle]="{'text-align':custom ? contentalign :'center'}">
                <span role="dialog" attr.aria-labelledby="componentId" class="dialogue-icon">
            <span  [ngClass]="{'dialogue-success': messagetype  == 'help','dialogue-danger':messagetype  == 'error',
                          'dialogue-warning': messagetype  == 'warning'}"
              *ngIf="messagetype  || messagetype  != '' ">
              <amexio-c-icon [key]="'window-msgtype-'+ messagetype "></amexio-c-icon>
            </span>
                <ng-container *ngIf="!custom">
                    <span id="{{componentId}}" tabindex="1" class="dialogue-message">
                {{message}}
              </span>
                </ng-container>
                </span>
                <ng-container *ngIf="custom">
                    <ng-content select="amexio-body"></ng-content>
                </ng-container>

            </div>
            <footer *ngIf="custom" class="dialogue-footer" [ngClass]="{'flex-start':(footeralign=='left'),'flex-end':(footeralign=='right'),'flex-center':(footeralign=='center')}">
                <ng-content select="amexio-action"></ng-content>
            </footer>

            <footer *ngIf="!custom" class="dialogue-footer" [ngClass]="{'dialogue-material-design-footer':materialDesign ,
                            'dialogue-footer':!materialDesign, 'flex-start':(footeralign=='left'),
                            'flex-end':(footeralign=='right'),'flex-center':(footeralign=='center')}">
                <amexio-button *ngIf="type =='confirm'" [size]="buttonsize" [label]="secondaryactionlabel" [type]="defaultStyle" (onClick)="getStatus('cancel')"></amexio-button>
                <div class="custom-btn">
                    <amexio-button *ngIf="type =='confirm' || type == 'alert'" [size]="buttonsize" [label]="primaryactionlabel" [ngStyle]="{'color':materialDesign ? 'blue':'white'}" [type]="buttontype" (onClick)="getStatus('ok')">
                    </amexio-button>
                </div>

            </footer>
        </div>
    </div>
  `,
                animations: [
                    trigger('animation', [
                        state('void', style({
                            transform: 'translate3d(0, 25%, 0) scale(0.9)',
                            opacity: 0,
                        })),
                        state('visible', style({
                            transform: 'none',
                            opacity: 1,
                        })),
                        transition('* => *', animate('400ms cubic-bezier(0.25, 0.8, 0.25, 1)')),
                    ]),
                ],
            },] },
];
/** @nocollapse */
AmexiodialoguePaneComponent.ctorParameters = () => [
    { type: Renderer2 }
];
AmexiodialoguePaneComponent.propDecorators = {
    closeonescape: [{ type: Input, args: ['close-on-escape',] }],
    buttontype: [{ type: Input, args: ['button-type',] }],
    buttonsize: [{ type: Input, args: ['button-size',] }],
    footeralign: [{ type: Input, args: ['footer-align',] }],
    contentalign: [{ type: Input, args: ['content-align',] }],
    showdialogue: [{ type: Input, args: ['show-dialogue',] }],
    show: [{ type: Input }],
    showChange: [{ type: Output }],
    closable: [{ type: Input }],
    title: [{ type: Input }],
    message: [{ type: Input }],
    custom: [{ type: Input }],
    type: [{ type: Input }],
    primaryactionlabel: [{ type: Input, args: ['primary-action-label',] }],
    secondaryactionlabel: [{ type: Input, args: ['secondary-action-label',] }],
    messagetype: [{ type: Input, args: ['message-type',] }],
    materialDesign: [{ type: Input, args: ['material-design',] }],
    actionStatus: [{ type: Output }],
    onSuccess: [{ type: Output }],
    onCancel: [{ type: Output }],
    close: [{ type: Output }],
    amexioFooter: [{ type: ContentChildren, args: [AmexioFooterComponent,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by pratik on 12/12/17.
*/
class AmexioFieldSetComponent extends LifeCycleBaseComponent {
    constructor() {
        super();
        /*
        Properties
        name : expanded
        datatype : boolean
        version : 4.0 onwards
        default : true
        description : Set value true for collapsible fieldset.
        */
        this.expanded = true;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.expanded) {
            this.isActive = true;
        }
        else {
            this.isActive = false;
        }
    }
    /**
     * @return {?}
     */
    onLegendClick() {
        if (this.collapsible) {
            this.isActive = !this.isActive;
        }
    }
}
AmexioFieldSetComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-fieldset',
                template: `
    <fieldset class="{{roundedgeclass}}">
        <legend tabindex="1" (keyup.enter)="onLegendClick()" (keyup.space)="onLegendClick()" role="heading" aria-expanded=" true"
            *ngIf="(title && title.length>0) || collapsible " class="collapsible-legend" (click)="onLegendClick()">
            <ng-container *ngIf="!collapsible">
                {{title}}
            </ng-container>
            <ng-container *ngIf="collapsible && !isActive">
                <amexio-c-icon [attr.aria-exapnded]="isActive" style="padding-right:5px" key="fieldset_expand"></amexio-c-icon>{{title}}
            </ng-container>
            <ng-container *ngIf="collapsible && isActive">
                <amexio-c-icon style="padding-right:5px" key="fieldset_collpase"></amexio-c-icon>{{title}}
            </ng-container>
        </legend>
        <div class="collapsible-fieldset" [@fieldsetContent]="!isActive ? {value: 'hidden', params: {transitionParams: '400ms cubic-bezier(0.86, 0, 0.07, 1)'}} : {value: 'visible', params: {transitionParams: '400ms cubic-bezier(0.86, 0, 0.07, 1)'}}"
        [ngStyle]="{'overflow': isActive ? '': 'hidden'}">
            <ng-content></ng-content>
        </div>
    </fieldset> 
  `,
                animations: [
                    trigger('fieldsetContent', [
                        state('hidden', style({
                            height: '0px',
                        })),
                        state('visible', style({
                            height: '*',
                        })),
                        transition('visible => hidden', animate('400ms cubic-bezier(0.86, 0, 0.07, 1)')),
                        transition('hidden => visible', animate('400ms cubic-bezier(0.86, 0, 0.07, 1)')),
                    ]),
                ],
            },] },
];
/** @nocollapse */
AmexioFieldSetComponent.ctorParameters = () => [];
AmexioFieldSetComponent.propDecorators = {
    collapsible: [{ type: Input }],
    expanded: [{ type: Input }],
    title: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by ketangote on 11/23/17.
*/
/** @type {?} */
const COMPONENT_CLASS_MAP = {
    primary: 'btn-primary-badge',
    secondary: 'btn-secondary-badge',
};
class AmexioButtonComponent {
    // THIS METHOD IS USED FOR ADDING CSS CLASS DYNAMICALLY
    constructor() {
        /*
          Properties
          name : disabled
          datatype : boolean
          version : 4.0 onwards
          default : false
          description : Enable/Disables the button
          */
        this.disabled = false;
        /*
          Events
          name : onClick
          datatype :  none
          version : none
          default : none
          description : Fire when button click
          */
        this.onClick = new EventEmitter();
        /*
         Events
         name : onIconClick
         datatype :  none
         version : none
         default : none
         description : Fire when button click
         */
        this.onIconClick = new EventEmitter();
        this.closableIcon = false;
        this.bgBorderColor = '';
        this.badgeCssClass = '';
        this.ispressed = false;
        this.bgColorClass = '';
    }
    /**
     * @param {?} event
     * @return {?}
     */
    buttonClick(event) {
        this.ispressed = !this.ispressed;
        if (!this.disabled) {
            event.stopPropagation();
            this.onClick.emit(event);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    IconClick(event) {
        if (!this.disabled) {
            event.stopPropagation();
            this.onIconClick.emit(event);
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.getBGStyle() !== null) {
            this.bgColorClass = this.getBGStyle();
        }
        this.badgeCssClass = this.badgeClass();
    }
    /**
     * @return {?}
     */
    badgeClass() {
        /** @type {?} */
        let className = '';
        if (this.type === 'primary' || this.type === 'theme-color') {
            className = 'btn-primary-badge';
        }
        if (this.type === 'secondary' || this.type === 'theme-backgroundcolor') {
            className = 'btn-secondary-badge';
        }
        if (this.type === 'success' || this.type === 'green') {
            className = 'btn-success-badge';
        }
        if (this.type === 'danger' || this.type === 'red') {
            className = 'btn-danger-badge';
        }
        if (this.type === 'warning' || this.type === 'yellow') {
            className = 'btn-warning-badge';
        }
        if (this.type === 'transparent') {
            className = 'btn-transparent-badge';
        }
        return className;
    }
    // THIS METHOD SET DISABLED PROPERTY FOR BUTTON
    /**
     * @param {?} disabled
     * @return {?}
     */
    setDisabled(disabled) {
        this.disabled = disabled;
    }
    // THIS FUNCTION IS ADDING BACKGROUND AND COLOR STYTLE TO BUTTON
    /**
     * @return {?}
     */
    getBGStyle() {
        if (this.bgcolor && this.color) {
            this.type = 'default';
            this.bgBorderColor = 'none';
            return {
                'background-color': this.bgcolor,
                'color': this.color,
            };
        }
        return null;
    }
    /**
     * @param {?} type
     * @return {?}
     */
    setRoundEdge(type) {
        if (type === 'round-edge') {
            this.roundedgeclass = 'roundEdgeCommonCss';
        }
        else if (type === 'classic') {
            this.roundedgeclass = 'classicCommonCss';
        }
    }
}
AmexioButtonComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-button',
                template: `
    <button #button class="button {{roundedgeclass}}" role="button" tabindex="1" [attr.aria-pressed]="ispressed"
      [ngStyle]="{'cursor': disabled ? 'not-allowed':'pointer','background-color':bgcolor,'color':color,'box-shadow':bgBorderColor}"
      ng-disabled="disabled ? true: null" [attr.title]="tooltip" [ngClass]="{'button-default': size=='default'
            || size ==null,
            'button-small': size=='small',
            'button-large' : size=='large',
            'button-block': block==true ,
            'button-primary' : (type == 'primary' || type == 'theme-color') && disabled == false,
            'button-secondary' : type == 'secondary' || type == 'theme-backgroundcolor' && disabled == false,
            'button-success' : type == 'success' || type == 'green' && disabled == false,
            'button-danger' : type=='danger' || type == 'red' && disabled == false,
            'button-warning' : type=='warning' || type == 'yellow' && disabled == false,
            'button-transparent' : type=='transparent' && disabled == false,
            'disabled' : (type =='transparent' && disabled) || (type == 'secondary' || type == 'theme-backgroundcolor') && disabled,
            'button-primary-disabled' : (type == 'primary' || type == 'theme-color') && disabled,
            'button-success-disabled' : (type == 'success' || type == 'green') && disabled,
            'button-danger-disabled' : (type == 'danger' || type == 'red') && disabled,
            'button-warning-disabled' : (type == 'warning' || type == 'yellow') && disabled}"
      (click)="buttonClick($event)">


      <ng-container *ngIf="icon">
        <span style="padding-right: 5px;" (click)="buttonClick($event)">
          <amexio-c-icon [customclass]="icon">
          </amexio-c-icon>
        </span>
      </ng-container>
      <span class="button-text">
        <ng-container *ngIf="icon && label">
        <span style="padding-right: 5px;" >
          {{label}}
        </span>
      </ng-container>
        <span style="padding-right: 5px;" *ngIf="loading">
          <amexio-c-icon key="button-loading-icon" [label]="label"></amexio-c-icon>
        </span>
        <ng-container *ngIf="!icon">{{label}}</ng-container>

        <ng-container *ngIf="badge">
          <span [ngClass]="badgeCssClass">{{badge}}</span>
        </ng-container>
      </span>
      <ng-container *ngIf="rightIcon">
        <span style="padding-left: 5px;" *ngIf="rightIcon" (click)="buttonClick($event)">
          <amexio-c-icon [customclass]="rightIcon">
          </amexio-c-icon>
        </span>
      </ng-container>
      <ng-container *ngIf="closableIcon">
        <span style="padding-left: 5px;" *ngIf="closableIcon" (click)="IconClick($event)">
          <amexio-c-icon [customclass]="'fa fa-close'">
          </amexio-c-icon>
        </span>
      </ng-container>


    </button>
  `,
                styles: [`

  `],
            },] },
];
/** @nocollapse */
AmexioButtonComponent.ctorParameters = () => [];
AmexioButtonComponent.propDecorators = {
    label: [{ type: Input }],
    badge: [{ type: Input, args: ['badge',] }],
    icon: [{ type: Input }],
    type: [{ type: Input }],
    tooltip: [{ type: Input }],
    disabled: [{ type: Input }],
    formbind: [{ type: Input, args: ['form-bind',] }],
    size: [{ type: Input }],
    loading: [{ type: Input }],
    onClick: [{ type: Output }],
    onIconClick: [{ type: Output }],
    block: [{ type: Input }],
    bgcolor: [{ type: Input, args: ['bg-color',] }],
    color: [{ type: Input, args: ['color',] }],
    rightIcon: [{ type: Input, args: ['right-icon',] }],
    closableIcon: [{ type: Input, args: ['closable-icon',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AmexioFloatingPanelComponent extends LifeCycleBaseComponent {
    /**
     * @param {?} commanservice
     * @param {?} renderer
     * @param {?} element
     */
    constructor(commanservice, renderer, element) {
        super();
        this.commanservice = commanservice;
        this.renderer = renderer;
        this.element = element;
        this.relative = false;
        this.absolute = false;
        this.onclose = new EventEmitter();
        this.closeable = false;
        this.showPanel = false;
        this.showPanelChange = new EventEmitter();
        this.amexioComponentId = 'amexio-floating-panel';
        this.counter = 0;
        this.showfloatingButton = false;
        this.showSimpleButton = false;
        this.btnStyle = {};
        this.style = {};
        this.draggable = true;
        this.opacitiy = false;
        this.pos1 = 0;
        this.pos2 = 0;
        this.pos3 = 0;
        this.pos4 = 0;
        this.positionMapData = [];
        this.positionMapData['hpos-right'] = { position: 'right', value: '10px' };
        this.positionMapData['hpos-left'] = { position: 'left', value: '10px' };
        this.positionMapData['vpos-bottom'] = { position: 'bottom', value: '25px' };
        this.positionMapData['vpos-top'] = { position: 'top', value: '55px' };
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.absolute) {
            this.relative = false;
        }
        if (this.height === '') {
            this.height = 200;
        }
        if (this.width === '') {
            this.width = 400;
        }
        if (this.showPanel) {
            this.panelStyle();
        }
        if (this.draggable && this.arrow) {
            this.draggable = false;
        }
        if (this.relative && this.draggable) {
            this.style['position'] = 'absolute';
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes['showPanel']) {
            this.showPanel = changes.showPanel.currentValue;
            this.getZindex(this.showPanel);
            if (this.absolute) {
                this.setPanelAbsolutePostion();
            }
            else {
                this.panelStyle();
            }
        }
    }
    /**
     * @param {?} showPanel
     * @return {?}
     */
    getZindex(showPanel) {
        if (showPanel === true) {
            this.commanservice.zindex = this.commanservice.zindex + 100;
        }
    }
    /**
     * @param {?} event
     * @param {?} floatingPanel
     * @return {?}
     */
    onMouseDown(event, floatingPanel) {
        if (this.draggable && event.target.getAttribute('name') && event.target.getAttribute('name') === 'floatingheader') {
            event = event || window.event;
            event.preventDefault();
            this.pos3 = event.clientX;
            this.pos4 = event.clientY;
            if (!this.documentMouseUPListener) {
                this.documentMouseUPListener = this.renderer.listen('document', 'mouseup', (
                // tslint:disable-next-line:no-shadowed-variable
                /**
                 * @return {?}
                 */
                () => this.closeDragElement(floatingPanel)));
            }
            if (!this.documentMouseMoveListener) {
                this.documentMouseMoveListener = this.renderer.listen('document', 'mousemove', (
                // tslint:disable-next-line:no-shadowed-variable
                /**
                 * @return {?}
                 */
                () => this.elementDrag(event, floatingPanel)));
            }
        }
    }
    /**
     * @param {?} e
     * @param {?} floatingPanel
     * @return {?}
     */
    elementDrag(e, floatingPanel) {
        e = e || window.event;
        e.preventDefault();
        this.pos1 = this.pos3 - e.clientX;
        this.pos2 = this.pos4 - e.clientY;
        this.pos3 = e.clientX;
        this.pos4 = e.clientY;
        if (this.bottomPosition) {
            delete this.style['bottom'];
        }
        floatingPanel.style.top = (floatingPanel.offsetTop - this.pos2) + 'px';
        floatingPanel.style.left = (floatingPanel.offsetLeft - this.pos1) + 'px';
        floatingPanel.style.opacity = '0.7';
        this.opacitiy = true;
    }
    /**
     * @param {?} floatingPanel
     * @return {?}
     */
    closeDragElement(floatingPanel) {
        this.documentMouseMoveListener();
        this.documentMouseUPListener();
        this.documentMouseMoveListener = null;
        this.documentMouseUPListener = null;
        this.opacitiy = false;
        floatingPanel.style.opacity = 'unset';
    }
    /**
     * @return {?}
     */
    togglePanel() {
        this.showPanel = !this.showPanel;
        this.onclose.emit(this);
        this.showPanelChange.emit(this.showPanel);
    }
    /**
     * @return {?}
     */
    panelStyle() {
        this.style = {};
        this.style['position'] = (this.relative) ? 'absolute' : 'fixed';
        this.style['display'] = 'block';
        this.style['z-index'] = this.commanservice.zindex;
        this.style['opacity'] = '1';
        this.style['box-shadow'] = '0 2px 5px 0 rgba(0, 0, 0, 0.16), 0 2px 10px 0 rgba(0, 0, 0, 0.12)';
        if (this.width !== '') {
            this.style['width'] = this.width + 'px';
        }
        else {
            this.style['width'] = '400px';
        }
        if (!this.relative) {
            this.setPanelStylePostion();
        }
        this.arrowPadding();
    }
    /**
     * @return {?}
     */
    arrowPadding() {
        if (this.arrow) {
            this.style['margin-top'] = '16px';
        }
    }
    /**
     * @return {?}
     */
    setPanelAbsolutePostion() {
        this.style = {};
        this.style['position'] = 'absolute';
        this.style['display'] = 'block';
        this.style['z-index'] = this.commanservice.zindex;
        this.style['opacity'] = '1';
        this.style['box-shadow'] = '0 2px 5px 0 rgba(0, 0, 0, 0.16), 0 2px 10px 0 rgba(0, 0, 0, 0.12)';
        if (this.width !== '') {
            this.style['width'] = this.width + 'px';
        }
        else {
            this.style['width'] = '400px';
        }
        this.setPanelStylePostion();
        this.arrowPadding();
    }
    /**
     * @return {?}
     */
    setPanelStylePostion() {
        if (this.topPosition) {
            this.style['top'] = this.topPosition;
        }
        if (this.bottomPosition) {
            this.style['bottom'] = this.bottomPosition;
        }
        if (this.rightPosition) {
            this.style['right'] = this.rightPosition;
        }
        if (this.leftPosition) {
            this.style['left'] = this.leftPosition;
        }
    }
    /**
     * @return {?}
     */
    changeHeaderColor() {
        this.gradientFlag = true;
    }
    // Theme Apply
    /**
     * @param {?} themeClass
     * @return {?}
     */
    setColorPalette(themeClass) {
        this.themeCss = themeClass;
    }
}
AmexioFloatingPanelComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-floating-panel',
                template: `
      <div *ngIf="showPanel" [ngStyle]="style" [ngClass]="{floatarrow:arrow}" class="{{roundedgeclass}}" #floatingPanel (mousedown)="onMouseDown($event, floatingPanel)"
        [style.background]="'#ffffff'" [style.padding]="resizable  ? '5px':'0px'" [style.resize]="resizable  ? 'both':''" [style.overflow]="resizable ?'auto':''">

        <div class='floatingpanel-header' name="floatingheader" [ngStyle]="{'cursor': (draggable) ? 'move':null}" [style.margin]="resizable  ? '-5px -5px 0px -5px': ''"
          [ngClass]="themeCss">
          <div class="flex-spacebetween">
            <amexio-label [word-wrap]="false" style="width:90%" [size]="'medium-bold'">
              {{title}}
            </amexio-label>
            <span *ngIf="closeable" [ngStyle]="{'color': gradientFlag ? 'black':'white'}" class="creative-header-icon-div" style="padding-top: 1px">
              <span class="fa fa-times ng-star-inserted" style="cursor: pointer;" (click)="togglePanel()"></span>
            </span>
          </div>
          <br/>
        </div>
        <div class="card-container-body card-container-ce-color" style="display: block;overflow: auto;" [ngStyle]="{'height':height + 'px'}">
          <ng-content></ng-content>
        </div>
      </div>
    `,
            },] },
];
/** @nocollapse */
AmexioFloatingPanelComponent.ctorParameters = () => [
    { type: CommonDataService },
    { type: Renderer2 },
    { type: ElementRef }
];
AmexioFloatingPanelComponent.propDecorators = {
    relative: [{ type: Input, args: ['relative',] }],
    absolute: [{ type: Input, args: ['absolute',] }],
    height: [{ type: Input, args: ['height',] }],
    width: [{ type: Input, args: ['width',] }],
    title: [{ type: Input, args: ['title',] }],
    topPosition: [{ type: Input, args: ['top-position',] }],
    bottomPosition: [{ type: Input, args: ['bottom-position',] }],
    rightPosition: [{ type: Input, args: ['right-position',] }],
    leftPosition: [{ type: Input, args: ['left-position',] }],
    onclose: [{ type: Output, args: ['onClose',] }],
    closeable: [{ type: Input, args: ['closeable',] }],
    showPanel: [{ type: Input, args: ['show-panel',] }],
    showPanelChange: [{ type: Output }],
    arrow: [{ type: Input, args: ['arrow',] }],
    buttonRef: [{ type: ViewChild, args: [AmexioButtonComponent,] }],
    floatingPanelRef: [{ type: ViewChild, args: ['floatingPanel',] }],
    resizable: [{ type: Input }],
    draggable: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/
class AmexioButtonGroupComponent {
    constructor() {
        this._buttonGroupLocalData = [];
        this.ispressed = false;
        this.getButton = new EventEmitter();
        this.buttons = [];
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set buttonGroupLocalData(value) {
        this._buttonGroupLocalData = value;
        if (this.componentLoaded) {
            this.updateComponent();
        }
    }
    /**
     * @return {?}
     */
    get buttonGroupLocalData() {
        return this._buttonGroupLocalData;
    }
    /**
     * @return {?}
     */
    updateComponent() {
        if (JSON.stringify(this.buttonGroupPreviewData) !== JSON.stringify(this.buttonGroupLocalData)) {
            this.buttonGroupPreviewData = JSON.parse(JSON.stringify(this.buttonGroupLocalData));
            this.buttons = this.buttonGroupLocalData;
            this.setButtonSizes(this.buttons);
        }
    }
    /**
     * @param {?} change
     * @return {?}
     */
    ngOnChanges(change) {
        if (change.size && !change.size.isFirstChange()) {
            this.updateButtonSizes(change.size);
        }
    }
    /**
     * @param {?} clickEvent
     * @param {?} btnObj
     * @return {?}
     */
    buttonGroupClick(clickEvent, btnObj) {
        this.ispressed = !this.ispressed;
        if (this.buttonGroupLocalData && this.buttonGroupLocalData.length > 0) {
            this.getButton.emit({ event: clickEvent, buttonObject: btnObj });
        }
        else {
            btnObj.onClick.emit(clickEvent);
        }
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (this.buttonGroupLocalData && this.buttonGroupLocalData.length > 0) {
            this.buttonGroupPreviewData = JSON.parse(JSON.stringify(this.buttonGroupLocalData));
            this.buttons = this.buttonGroupLocalData;
        }
        else {
            this.buttons = this.btns.toArray();
            this.addBadgeCssClass();
        }
        this.setButtonSizes(this.buttons);
        this.componentLoaded = true;
    }
    /**
     * @return {?}
     */
    addBadgeCssClass() {
        this.buttons.forEach((/**
         * @param {?} btn
         * @return {?}
         */
        (btn) => {
            btn.badgeCssClass = this.badgeClass(btn);
        }));
    }
    /**
     * @param {?} button
     * @return {?}
     */
    badgeClass(button) {
        /** @type {?} */
        let btnStyleClass = '';
        switch (button.type) {
            case 'primary': {
                return 'btn-group-primary-badge';
            }
            case 'theme-color': {
                return 'btn-group-primary-badge';
            }
            case 'secondary': {
                return 'btn-group-secondary-badge';
            }
            case 'theme-backgroundcolor': {
                return 'btn-group-secondary-badge';
            }
            case 'success': {
                return 'btn-group-success-badge';
            }
            case 'green': {
                return 'btn-group-success-badge';
            }
        }
        btnStyleClass = this.badgeMoreClass(button);
        return btnStyleClass;
    }
    /**
     * @param {?} btnArray
     * @return {?}
     */
    setButtonSizes(btnArray) {
        if (btnArray.length > 0) {
            btnArray.forEach((/**
             * @param {?} btn
             * @return {?}
             */
            (btn) => {
                btn.size = this.size;
            }));
        }
    }
    /**
     * @param {?} button
     * @return {?}
     */
    badgeMoreClass(button) {
        /** @type {?} */
        let className = '';
        if (button.type === 'danger' || button.type === 'red') {
            className = 'btn-group-danger-badge';
        }
        if (button.type === 'warning' || button.type === 'yellow') {
            className = 'btn-group-warning-badge';
        }
        if (button.type === 'transparent') {
            className = 'btn-group-transparent-badge';
        }
        return className;
    }
    /**
     * @param {?} size
     * @return {?}
     */
    updateButtonSizes(size) {
        this.buttons.forEach((/**
         * @param {?} btn
         * @return {?}
         */
        (btn) => {
            btn.size = size;
        }));
    }
}
AmexioButtonGroupComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-btn-group',
                template: `
    <div class="btn-group">
      <ng-container *ngFor="let button of buttons">
          <button [ngStyle]="{'cursor': disabled ? 'not-allowed':'pointer','background-color':button.bgcolor,'color':button.color,'box-shadow':button.bgBorderColor}" 
          role="button" tabindex="1" [attr.aria-pressed]="ispressed" [attr.disabled]="button.disabled ? true: null" [attr.title]="button.tooltip" 
          (click)="buttonGroupClick($event,button)" 
      [ngClass]="{'button-default': button.size=='default'
      || size ==null,
      'button-small': button.size=='small',
      'button-large' : button.size=='large',
      'button-block': button.block==true ,
      'button-primary' : (button.type == 'primary' || button.type == 'theme-color') && button.disabled == false,
      'button-secondary' : button.type == 'secondary' || button.type == 'theme-backgroundcolor' && button.disabled == false,
      'button-success' : button.type == 'success' || button.type == 'green' && button.disabled == false,
      'button-danger' : button.type =='danger' || button.type == 'red' && button.disabled == false,
      'button-warning' : button.type =='warning' || button.type == 'yellow' && button.disabled == false,
      'button-transparent' : button.type=='transparent' && button.disabled == false,
      'disabled' : (button.type =='transparent' && button.disabled) || (button.type == 'secondary' || button.type == 'theme-backgroundcolor') && disabled,
      'button-primary-disabled' : (button.type == 'primary' || button.type == 'theme-color') && button.disabled,
      'button-success-disabled' : (button.type == 'success' || button.type == 'green') && button.disabled,
      'button-danger-disabled' : (button.type == 'danger' || button.type == 'red') && button.disabled,
      'button-warning-disabled' : (button.type == 'warning' || button.type == 'yellow') && button.disabled}">
        <ng-container *ngIf="button.icon!=null">
          <amexio-c-icon style="padding-right: 5px;" [customclass]="button.icon"></amexio-c-icon>
        </ng-container>

        {{button.label}}
        <ng-container *ngIf="button.badge">
          <span [ngClass]="button.badgeCssClass" >{{button.badge}}</span>
       </ng-container>
      </button>
      </ng-container>
    </div>
  `,
            },] },
];
/** @nocollapse */
AmexioButtonGroupComponent.ctorParameters = () => [];
AmexioButtonGroupComponent.propDecorators = {
    size: [{ type: Input }],
    disabled: [{ type: Input }],
    buttonGroupLocalData: [{ type: Input, args: ['buttonGroupLocalData',] }],
    badge: [{ type: Input, args: ['badge',] }],
    getButton: [{ type: Output }],
    btns: [{ type: ContentChildren, args: [AmexioButtonComponent,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Component Name : Amexio Form Action
* Component Selector : <amexio-form-action>
* Component Description : Amexio Form actions contains the action items within form
*/
class AmexioFormActionComponent {
    constructor() {
        this.buttons = [];
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (this.btns.length > 0) {
            this.buttons = this.btns.toArray();
        }
        else if (this.btngrp.length > 0) {
            this.buttons = this.btngrp.toArray()[0].buttons;
        }
    }
}
AmexioFormActionComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-form-action', template: '<ng-content></ng-content>',
            },] },
];
/** @nocollapse */
AmexioFormActionComponent.ctorParameters = () => [];
AmexioFormActionComponent.propDecorators = {
    padding: [{ type: Input }],
    btns: [{ type: ContentChildren, args: [AmexioButtonComponent,] }],
    btngrp: [{ type: ContentChildren, args: [AmexioButtonGroupComponent,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/
class AmexioFormBodyComponent {
    constructor() {
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
}
AmexioFormBodyComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-form-body', template: '<ng-content></ng-content>',
            },] },
];
/** @nocollapse */
AmexioFormBodyComponent.ctorParameters = () => [];
AmexioFormBodyComponent.propDecorators = {
    padding: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AmexioFormGroupDirective {
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.modelsarray = this.models.toArray();
    }
}
AmexioFormGroupDirective.decorators = [
    { type: Directive, args: [{
                selector: '[form-group]',
            },] },
];
AmexioFormGroupDirective.propDecorators = {
    group: [{ type: Input, args: ['form-group',] }],
    models: [{ type: ContentChildren, args: [NgModel, { descendants: true },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/
class AmexioFormHeaderComponent {
    constructor() {
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
}
AmexioFormHeaderComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-form-header', template: `
        <ng-content></ng-content>
  `,
            },] },
];
/** @nocollapse */
AmexioFormHeaderComponent.ctorParameters = () => [];
AmexioFormHeaderComponent.propDecorators = {
    padding: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/
class AmexioFormComponent extends LifeCycleBaseComponent {
    /**
     * @param {?} formBuilder
     */
    constructor(formBuilder) {
        super();
        this.formBuilder = formBuilder;
        /*
        Properties
        name : show-error
        datatype : boolean
        version : 4.2 onwards
        default : false
        description : Flag to show form invalid error messages
        */
        this.showError = false;
        /*
        Events
        name : showErrorMsg
        datatype : any
        version : none
        default :
        description : Event fired if showError msg info button is clicked
        */
        this.showErrorMsg = new EventEmitter();
        this.componentError = [];
        this.checkForm = false;
        this.isFormValid = false;
        this.showDialogue = false;
        this.headeralign = 'left';
        this.footeralign = 'right';
        this.errorMsgArray = [];
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        // FOR HEADER PADING
        this.headerComponentList = this.amexioHeader.toArray();
        this.headerComponentList.forEach((/**
         * @param {?} item
         * @param {?} currentIndex
         * @return {?}
         */
        (item, currentIndex) => {
            if (item.padding) {
                this.headerPadding = item.padding;
            }
        }));
        // FOR BODY PADDING
        this.bodyComponentList = this.amexioBody.toArray();
        this.bodyComponentList.forEach((/**
         * @param {?} item
         * @param {?} currentIndex
         * @return {?}
         */
        (item, currentIndex) => {
            if (item.padding) {
                this.bodyPadding = item.padding;
            }
        }));
        // FOR FOOTER PADDING
        this.footerComponentList = this.amexioFooter.toArray();
        this.footerComponentList.forEach((/**
         * @param {?} item
         * @param {?} currentIndex
         * @return {?}
         */
        (item, currentIndex) => {
            if (item.padding) {
                this.footerPadding = item.padding;
            }
        }));
    }
    /**
     * @return {?}
     */
    onResize() {
        if (this.bodyheight) {
            /** @type {?} */
            let h = (window.innerHeight / 100) * this.bodyheight;
            if (this.formHeader && this.formHeader.nativeElement && this.formHeader.nativeElement.offsetHeight) {
                h = h - this.formHeader.nativeElement.offsetHeight;
            }
            if (this.formFooter && this.formFooter.nativeElement && this.formFooter.nativeElement.offsetHeight) {
                h = h - this.formFooter.nativeElement.offsetHeight;
            }
            if (this.bodyheight === 100) {
                h = h - 40;
            }
            this.minHeight = h;
            this.height = h;
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.buttons = [];
        super.ngOnInit();
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        super.ngAfterViewInit();
        /** @type {?} */
        const ngContentModels = this.models.toArray();
        /** @type {?} */
        const innerModelArray = [];
        this.fb.forEach((/**
         * @param {?} fbnode
         * @return {?}
         */
        (fbnode) => {
            /** @type {?} */
            const modelarray = fbnode.modelsarray;
            /** @type {?} */
            const fgc = {};
            modelarray.forEach((/**
             * @param {?} m
             * @return {?}
             */
            (m) => {
                fgc[m.name] = m.control;
                innerModelArray.push(m);
            }));
            /** @type {?} */
            const grp = this.formBuilder.group(fgc);
            this.form.form.registerControl(fbnode.group, grp);
        }));
        ngContentModels.forEach((/**
         * @param {?} model
         * @return {?}
         */
        (model) => {
            if (!this.isFieldPresentInParentAndChildBoth(innerModelArray, model.name)) {
                if (!model.name || model.name === null) {
                    model.name = model.valueAccessor['name'];
                }
                this.form.control.registerControl(model.name, model.control);
            }
        }));
        this.clearTimeout = setTimeout((/**
         * @return {?}
         */
        () => {
            this.form.form.updateValueAndValidity();
        }), 100);
        this.btns.toArray().forEach((/**
         * @param {?} btnCom
         * @return {?}
         */
        (btnCom) => {
            if ((btnCom.formbind === this.fname) && !btnCom.disabled) {
                this.buttons.push(btnCom);
            }
        }));
        this.validateForm();
        this.onResize();
    }
    /**
     * @param {?} innerModelArray
     * @param {?} name
     * @return {?}
     */
    isFieldPresentInParentAndChildBoth(innerModelArray, name) {
        /** @type {?} */
        let isPresent = false;
        innerModelArray.forEach((/**
         * @param {?} innerModel
         * @return {?}
         */
        (innerModel) => {
            if (name === innerModel.name) {
                isPresent = true;
            }
        }));
        return isPresent;
    }
    /**
     * @return {?}
     */
    closeDialogue() {
        this.showDialogue = !this.showDialogue;
    }
    // THIS METHOD IS USED FOR ADDING MSG
    /**
     * @return {?}
     */
    addErrorMsg() {
        if (this.form && this.form.status === 'INVALID') {
            for (const [key, value] of Object.entries(this.form.controls)) {
                if (value && value.status === 'INVALID') {
                    /** @type {?} */
                    const errorObject = {};
                    errorObject['label'] = key;
                    this.errorMsgArray.push(errorObject);
                }
            }
        }
    }
    // REMOVE OBJECT FROM ARRAY
    /**
     * @param {?} event
     * @return {?}
     */
    showErrors(event) {
        this.errorMsgArray = [];
        this.addErrorMsg();
        this.showDialogue = !this.isFormValid;
        if (!this.isFormValid) {
            this.showDialogue = true;
        }
        else {
            this.showDialogue = false;
        }
    }
    // THIS METHOD IS USED FOR DISABLE BUTTON
    /**
     * @return {?}
     */
    validateForm() {
        if (this.form && this.form.status === 'INVALID') {
            this.disableButton(true);
        }
        else {
            this.disableButton(false);
        }
    }
    /**
     * @param {?} flag
     * @return {?}
     */
    disableButton(flag) {
        this.buttons.forEach((/**
         * @param {?} btn
         * @return {?}
         */
        (btn) => {
            btn.disabled = flag;
        }));
    }
    /**
     * @return {?}
     */
    ngAfterContentChecked() {
        this.validateForm();
    }
    /**
     * @return {?}
     */
    findformStyleClass() {
        if (this.headeralign === 'right') {
            return 'flex-end';
        }
        if (this.headeralign === 'left') {
            return 'flex-start';
        }
        if (this.headeralign === 'center') {
            return 'flex-center';
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        super.ngOnDestroy();
        clearTimeout(this.clearTimeout);
    }
}
AmexioFormComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-form',
                template: `
    <form name="fname" class="form-container form-group" (window:resize)="onResize()">

        <header #formHeader class="form-header" [style.padding]="headerPadding" *ngIf="header" [ngClass]="findformStyleClass()">
            <ng-content select="amexio-form-header"></ng-content>
        </header>

        <div class="form-body formbody" [style.padding]="bodyPadding" [ngStyle]="{'height.px' : height,'overflow-y' : height!= null ? 'auto' : '','min-height.px' : minHeight}">
            <ng-content select="amexio-form-body"></ng-content>
        </div>

        <footer #formFooter class="form-footer" [style.padding]="footerPadding" [ngClass]="{'flex-start':(footeralign=='left'),'flex-end':(footeralign=='right'),'flex-center':(footeralign=='center')}">
            <ng-content select="amexio-form-action"></ng-content>
            <br/>
            <div *ngIf="!form.valid" style="padding: 5px;">
                <button class="button" [attr.title]="'click'" (click)="showErrors($event)" [ngClass]="'button-warning button-small button-round'">
                            <span class="button-text">
                              <span style="padding-right: 5px;" *ngIf="icon">
                                <amexio-c-icon [customclass]="icon" >
                                </amexio-c-icon>
                              </span>
                              <span style="padding-right: 5px;">
                                <amexio-c-icon key="button-loading-icon"></amexio-c-icon>
                              </span>
                              ?
                            </span>
                    </button>
                <amexio-dialogue [close-on-escape]="true" [(show)]="showDialogue" [custom]="true" [content-align]="'left'" [closable]="false" [title]="'Invalid Fields'" [type]="'confirm'">

                    <amexio-body *ngFor="let msg of errorMsgArray let index=index">
                        <amexio-label>{{index+1}}) {{msg.label}}</amexio-label><br>
                    </amexio-body>

                    <amexio-action>
                        <amexio-button type="primary" (onClick)="closeDialogue()" [label]="'OK'">
                        </amexio-button>
                    </amexio-action>
                </amexio-dialogue>
            </div>
        </footer>
    </form>
  `,
            },] },
];
/** @nocollapse */
AmexioFormComponent.ctorParameters = () => [
    { type: FormBuilder }
];
AmexioFormComponent.propDecorators = {
    headeralign: [{ type: Input, args: ['header-align',] }],
    footeralign: [{ type: Input, args: ['footer-align',] }],
    fname: [{ type: Input, args: ['form-name',] }],
    header: [{ type: Input, args: ['header',] }],
    showError: [{ type: Input, args: ['show-error',] }],
    height: [{ type: Input }],
    minHeight: [{ type: Input, args: ['min-height',] }],
    bodyheight: [{ type: Input, args: ['body-height',] }],
    icon: [{ type: Input, args: ['icon',] }],
    formHeader: [{ type: ViewChild, args: ['formHeader', { read: ElementRef },] }],
    formFooter: [{ type: ViewChild, args: ['formFooter', { read: ElementRef },] }],
    showErrorMsg: [{ type: Output }],
    amexioHeader: [{ type: ContentChildren, args: [AmexioFormHeaderComponent,] }],
    amexioBody: [{ type: ContentChildren, args: [AmexioFormBodyComponent,] }],
    amexioFooter: [{ type: ContentChildren, args: [AmexioFormActionComponent,] }],
    btns: [{ type: ContentChildren, args: [AmexioButtonComponent, { descendants: true },] }],
    form: [{ type: ViewChild, args: [NgForm,] }],
    models: [{ type: ContentChildren, args: [NgModel, { descendants: true },] }],
    fb: [{ type: ContentChildren, args: [AmexioFormGroupDirective, { descendants: true },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 * Copyright [2019] [Metamagic]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Created by kedar on 8/8/19.
 */
class AmexioHeaderComponent {
    /**
     * @param {?} document
     */
    constructor(document) {
        this.document = document;
        this.jstyfy = 'space-between';
        this.background = '';
        this.color = '';
        this.minimizeWindow = new EventEmitter();
        this.closeDataEmit = new EventEmitter();
        this.maximizeWindow = new EventEmitter();
        this.maximizeWindow1 = new EventEmitter();
        this.minimizeWindow1 = new EventEmitter();
        this.minimize = false;
        this.closeable = false;
        this.maximize = false;
        this.isFullWindow = false;
        this.closeableBehaiour = new rxjs_6(false);
        this.maximizeBehaiour = new rxjs_6(null);
    }
    /**
     * @return {?}
     */
    get c1() { return this.aComponent; }
    /**
     * @return {?}
     */
    get c2() { return this.aComponent1; }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.textName = this.content.nativeElement.textContent;
        if (this.textName && this.minimizeIcon) {
            return this.textName;
        }
        if (this.textName && !this.minimizeIcon) {
            return this.textName;
        }
        else if (!this.textName && this.minimizeIcon) {
            return this.minimizeIcon;
        }
        else if (!this.minimizeIcon && !this.textName) {
            this.textName = [];
            this.minimizeIcon = 'fa fa-file';
        }
    }
    /**
     * @param {?} maximize
     * @param {?} isFullWindow
     * @param {?} event
     * @return {?}
     */
    setMaximizeData(maximize, isFullWindow, event) {
        this.maximize = maximize;
        this.isFullWindow = isFullWindow;
        this.maximizeBehaiour.next({ isFullWindow: this.isFullWindow, event1: event });
    }
    /**
     * @param {?} materialDesign
     * @return {?}
     */
    setMaterialDesignStatus(materialDesign) {
        if (materialDesign) {
            this.background = 'white';
            this.color = 'black';
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    sizeChange(event) {
        this.isFullWindow = !this.isFullWindow;
        this.maximizeBehaiour.next({ isFullWindow: this.isFullWindow, event1: event });
    }
    /**
     * @return {?}
     */
    onCloseClick() {
        this.isFullWindow = true;
        this.closeableBehaiour.next(false);
        this.closeDataEmit.emit(this);
    }
    /**
     * @return {?}
     */
    onMinimizeClick() {
        this.closeableBehaiour.next(false);
        this.minimizeWindow.emit(this);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    maxScreenChangeCard(event) {
        this.maximizeWindow1.emit({ tempEvent: event, tempThis: this });
    }
    /**
     * @param {?} event
     * @return {?}
     */
    minScreenChangeCard(event) {
        this.minimizeWindow1.emit({ tempEvent: event, tempThis: this });
    }
}
AmexioHeaderComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-header', template: `
  <span style=" flex: auto;"   #contentWrapper>
  <ng-content ></ng-content>
  </span>
  <span>
  <em  *ngIf="minimize" class="fa fa-window-minimize" (click)="onMinimizeClick($event)"
  style = "cursor: pointer"></em>

  <amexio-c-icon style = "padding-left: 10px" class="cursor-style" *ngIf="(isFullWindow && maximize )"
  [key]="'window_maximize'" (onClick)="sizeChange($event)"></amexio-c-icon>
  <amexio-c-icon style = "padding-left: 10px" class="cursor-style"
  *ngIf="(!isFullWindow && maximize )"
  [key]="'window_restore'" (click)="sizeChange($event)"></amexio-c-icon>

  <amexio-c-icon style = "padding-left: 10px" class="cursor-style" *ngIf="(fullScreenFlag && fullscreenMaxCard)"
  [key]="'full-screen-max-icon'" (onClick)="maxScreenChangeCard($event)"></amexio-c-icon>
  <amexio-c-icon style = "padding-left: 10px" class="cursor-style"
  *ngIf="(fullScreenFlag && !fullscreenMaxCard)"
  [key]="'full-screen-min-icon'" (click)="minScreenChangeCard($event)"></amexio-c-icon>

  <amexio-c-icon class="cursor-style"
  style = "padding-left: 10px"
  *ngIf="closeable" [key]="'window_close'" (onClick)="onCloseClick()">
  </amexio-c-icon>

  </span>
  `,
                styles: [
                    `
  .cursor-style {
  cursor:pointer;
  }
  `,
                ],
            },] },
];
/** @nocollapse */
AmexioHeaderComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
];
AmexioHeaderComponent.propDecorators = {
    c1: [{ type: HostBinding, args: ['class.modal-card-header',] }],
    c2: [{ type: HostBinding, args: ['class.modal-window-header',] }],
    jstyfy: [{ type: HostBinding, args: ['style.justify-content',] }],
    background: [{ type: HostBinding, args: ['style.background',] }],
    content: [{ type: ViewChild, args: ['contentWrapper',] }],
    color: [{ type: HostBinding, args: ['style.color',] }],
    padding: [{ type: Input }],
    minimizeWindow: [{ type: Output }],
    closeDataEmit: [{ type: Output }],
    maximizeWindow: [{ type: Output }],
    maximizeWindow1: [{ type: Output }],
    minimizeWindow1: [{ type: Output }],
    minimizeIcon: [{ type: Input, args: ['minimized-icon',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*Created by pratik on 14/12/17.
*/
class AmexioPanelComponent extends LifeCycleBaseComponent {
    /**
     * @param {?} renderer
     * @param {?} document
     */
    constructor(renderer, document) {
        super(document);
        this.renderer = renderer;
        this.document = document;
        /*
        Properties
        name : collapsible
        datatype :  boolean
        version : 4.0 onwards
        default : false
        description : Pane will expand or collapse based on the boolean.
        */
        this.collapsible = true;
        this.contentAlign = 'left';
        this.onClick = new EventEmitter();
        this.nodeRightClick = new EventEmitter();
        this.rightClick = new EventEmitter();
        this.mouseLocation = { left: 0, top: 0 };
        this.faFaIconUPCss = 'fa fa-caret-up';
        this.faFaIconDownCss = 'fa fa-caret-down';
        this.amexioComponentId = 'amexio-panel';
        this.panelstyle = { visibility: 'visible' };
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
        this.componentId = window.crypto.getRandomValues(new Uint32Array(1))[0] + 'panel';
        if (!this.collapsible) {
            this.expanded = true;
        }
        this.iconclassKey = this.expanded ? this.faFaIconUPCss : this.faFaIconDownCss;
        if (this.height) {
            return this.height;
        }
        this.updatestyle();
        super.ngOnInit();
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        super.ngAfterViewInit();
    }
    /**
     * @param {?} btn
     * @return {?}
     */
    onTabClick(btn) {
        btn.classList.toggle('active-accordion');
        if (this.iconclassKey === this.faFaIconDownCss) {
            this.iconclassKey = this.faFaIconUPCss;
        }
        else if (this.iconclassKey === this.faFaIconUPCss) {
            this.iconclassKey = this.faFaIconDownCss;
        }
        this.expanded = !this.expanded;
        this.updatestyle();
        this.onClick.emit();
    }
    /**
     * @param {?} Data
     * @return {?}
     */
    rightClickDataEmit(Data) {
        this.rightClick.emit(Data);
    }
    /**
     * @private
     * @return {?}
     */
    updatestyle() {
        if (this.fit && this.expanded) {
            this.panelstyle = { visibility: 'visible', state: 'visible' };
        }
        else if (this.fit && !this.expanded) {
            this.panelstyle = { visibility: 'hidden', state: 'hidden' };
        }
        else if (!this.fit && this.expanded) {
            this.panelstyle = { display: 'block', state: 'block' };
        }
        else if (!this.fit && !this.expanded) {
            this.panelstyle = { display: 'none', state: 'none' };
        }
        else {
            this.panelstyle = { visibility: 'visible', state: 'visible' };
        }
    }
    // getcontextmenu
    /**
     * @return {?}
     */
    getContextMenu() {
        if (this.contextmenu && this.contextmenu.length > 0) {
            this.flag = true;
            this.addListner();
        }
    }
    /**
     * @param {?} elementRef
     * @return {?}
     */
    getListPosition(elementRef) {
        /** @type {?} */
        const height = 240;
        if ((window.screen.height - elementRef.getBoundingClientRect().bottom) < height) {
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * @param {?} rightClickData
     * @return {?}
     */
    loadContextMenu(rightClickData) {
        if (this.contextmenu && this.contextmenu.length > 0) {
            this.mouseLocation.left = rightClickData.event.clientX;
            this.mouseLocation.top = rightClickData.event.clientY;
            this.getContextMenu();
            this.posixUp = this.getListPosition(rightClickData.ref);
            rightClickData.event.preventDefault();
            rightClickData.event.stopPropagation();
            this.rightClickNodeData = rightClickData.data;
            this.nodeRightClick.emit(rightClickData);
        }
    }
    /**
     * @return {?}
     */
    addListner() {
        this.globalClickListenFunc = this.renderer.listen('document', 'click', (/**
         * @param {?} e
         * @return {?}
         */
        (e) => {
            this.flag = false;
            if (!this.flag) {
                this.removeListner();
            }
        }));
    }
    /**
     * @return {?}
     */
    removeListner() {
        if (this.globalClickListenFunc) {
            this.globalClickListenFunc();
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        super.ngOnDestroy();
        this.removeListner();
    }
    // Theme Apply
    /**
     * @param {?} themeClass
     * @return {?}
     */
    setColorPalette(themeClass) {
        this.themeCss = themeClass;
    }
    /**
     * @return {?}
     */
    changeHeaderColor() {
        this.gradientFlag = true;
    }
}
AmexioPanelComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-panel',
                template: `



    <div    #id style="width: 100%" class="{{roundedgeclass}}" [ngClass]="{'panel-full-screen': yesFullScreen && fullscreenMax}" (contextmenu)="loadContextMenu({event:$event,ref:id})"  >
        <ng-container *ngIf="collapsible; else elseBlock"> 
            <div id="{{componentId}}" [ngStyle]="{'background': bgColor, 'color': color}"
            *ngIf="header" class="panel-accordion"  [ngClass]="themeCss"
            (click)="onTabClick(id)"    >
                <amexio-toolbar
                tabindex="0" 
                role="heading"
                [attr.aria-expanded]="expanded"
                (keyup.enter)="onTabClick(id)"
                (keyup.space)="onTabClick(id)">
                    <amexio-toolbar-item [ngStyle]="{'color': gradientFlag ? 'white':''}" position-left  attr.aria-label="{{title}}">
                        <amexio-label  attr.aria-labelledby="{{componentId}}" size="small">
                            {{title}}
                        </amexio-label>
                    </amexio-toolbar-item>
                    <amexio-toolbar-item [ngStyle]="{'color': gradientFlag ? 'black':''}" position-right>
                        <ng-content select="amexio-panel-header"></ng-content>
                    </amexio-toolbar-item>
                    <amexio-toolbar-item [ngStyle]="{'color': gradientFlag ? 'black':''}" style="margin:auto" position-right>     
                        <amexio-c-icon style="padding-right:10px" class="cursor-style" *ngIf="(yesFullScreen && fullscreenMax)" [key]="'full-screen-min-icon'" (onClick)="minScreenChange($event)"></amexio-c-icon>
                    </amexio-toolbar-item>
                    <amexio-toolbar-item [ngStyle]="{'color': gradientFlag ? 'black':''}" style="margin:auto" position-right>
                                          <amexio-c-icon style="padding-right:10px" class="cursor-style" *ngIf="(yesFullScreen && !fullscreenMax)" [key]="'full-screen-max-icon'" (onClick)="maxScreenChange($event)"></amexio-c-icon>
                    </amexio-toolbar-item>
                    <amexio-toolbar-item [ngStyle]="{'color': gradientFlag ? 'black':''}" style="margin:auto" position-right>
                        <i [class]="iconclassKey" aria-hidden="true" #btn1></i>
                    </amexio-toolbar-item>
                </amexio-toolbar>
            </div>
        </ng-container>

        <ng-template #elseBlock>
            <div    id="{{componentId}}"   *ngIf="header" class="panel-accordion" (click)="onTabClick(id)">
                <amexio-toolbar
                tabindex="0" 
                [attr.aria-expanded]="expanded"
                (keyup.enter)="onTabClick(id)"
                (keyup.space)="onTabClick(id)"
            
                >
                    <amexio-toolbar-item position-left tabindex="0" [attr.aria-expanded]="expanded"  attr.aria-label="{{title}}">
                        <amexio-label  size="small"   attr.aria-labelledby="{{componentId}}" >
                            {{title}}
                        </amexio-label>
                    </amexio-toolbar-item>
                    <amexio-toolbar-item position-right>
                        <ng-content select="amexio-panel-header"></ng-content>
                    </amexio-toolbar-item>
                </amexio-toolbar>
            </div>
        </ng-template>
    
        <div tabindex="0"  id="panelpanelId" class="panel-panel" [ngStyle]="{'border-color': border && bgColor}" [ngClass]="{'panel-box-border':border, 'panel-without-header':!header}" [style.textAlign]="contentAlign" [style.height.px]="height"
            [@panelState]="panelstyle.state">
            <ng-content aria-labelledby="panelpanelId" ></ng-content>
        </div>

        <ng-container *ngIf="flag && (this.contextmenu && this.contextmenu.length > 0)">
            <base-contextmenu tabindex="0" [base-context-menu]="contextmenu" [mouse-location-top]="mouseLocation.top"
                [mouse-location-left]="mouseLocation.left" [is-FlagShow]="flag" [right-click-data]="nodeRightClick"
                (onRightClick)="rightClickDataEmit($event)" [position-up]="posixUp">
            </base-contextmenu>
        </ng-container>
    </div>
  `,
                animations: [
                    trigger('panelState', [
                        state('hidden', style({
                            visibility: 'hidden',
                            height: '0px',
                        })),
                        state('visible', style({
                            visibility: 'visible',
                            height: '*',
                        })),
                        state('block', style({
                            display: 'block',
                            height: '*',
                        })),
                        state('none', style({
                            display: 'none',
                            height: '0px',
                        })),
                        transition('*=>*', animate('200ms')),
                    ]),
                ],
            },] },
];
/** @nocollapse */
AmexioPanelComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
];
AmexioPanelComponent.propDecorators = {
    title: [{ type: Input }],
    header: [{ type: Input }],
    expanded: [{ type: Input }],
    border: [{ type: Input }],
    collapsible: [{ type: Input }],
    height: [{ type: Input }],
    contextmenu: [{ type: Input, args: ['context-menu',] }],
    color: [{ type: Input }],
    bgColor: [{ type: Input, args: ['background',] }],
    contentAlign: [{ type: Input, args: ['content-align',] }],
    parentRef: [{ type: Input }],
    fit: [{ type: Input, args: ['fit',] }],
    onClick: [{ type: Output }],
    nodeRightClick: [{ type: Output }],
    rightClick: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/
class AmexioPanelHeaderComponent {
    constructor() {
        this.role = 'amexio-panel-header';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
}
AmexioPanelHeaderComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-panel-header', template: `
    <ng-content></ng-content>
  `,
            },] },
];
/** @nocollapse */
AmexioPanelHeaderComponent.ctorParameters = () => [];
AmexioPanelHeaderComponent.propDecorators = {
    role: [{ type: HostBinding, args: ['attr.class',] }],
    padding: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*  Created by sagar on 6/9/17.
*/
class StepBlockComponent {
    constructor() {
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
}
StepBlockComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-step-block', template: `
  `,
            },] },
];
/** @nocollapse */
StepBlockComponent.ctorParameters = () => [];
StepBlockComponent.propDecorators = {
    active: [{ type: Input }],
    label: [{ type: Input }],
    icon: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*  Created by pratik on 15/12/17.
*/
class AmexioStepsComponent {
    constructor() {
        /*
        Events
        name : onClick
        datatype : none
        version : none
        default : none
        description :Event emitted on block click.
        */
        this.onClick = new EventEmitter();
        /*
        Events
        name : getStepBlockData
        datatype : none
        version : none
        default : none
        description :Gives stepblock information .
        */
        this.getStepBlockData = new EventEmitter();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set data(value) {
        this._data = value;
        if (this.componentLoaded) {
            this.updateComponent();
        }
    }
    /**
     * @return {?}
     */
    get data() {
        return this._data;
    }
    /**
     * @param {?} clickData
     * @param {?} ev
     * @return {?}
     */
    onStepClick(clickData, ev) {
        this.getStepBlockData.emit({ event: ev, data: clickData });
        this.onClick.emit(clickData);
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (this.data && this.data.length > 0) {
            this.stepPreviewData = JSON.parse(JSON.stringify(this.data));
            this.stepBlockArray = this.data;
        }
        else {
            this.stepBlockArray = this.stepBlocks.toArray();
        }
        this.componentLoaded = true;
    }
    /**
     * @return {?}
     */
    updateComponent() {
        if (JSON.stringify(this.stepPreviewData) !== JSON.stringify(this.data)) {
            this.stepPreviewData = JSON.parse(JSON.stringify(this.data));
            this.stepBlockArray = this.data;
        }
    }
}
AmexioStepsComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-steps', template: `
    <div class="stepwizard" *ngIf="(index && !block && !icon)">
        <div class="stepwizard-row setup-panel">
            <div *ngFor="let stepBlock of stepBlockArray; let i = index" class="stepwizard-step">
                <button type="button" [disabled]="!stepBlock.active" [ngClass]="{'disabled index-step-inactive':!stepBlock.active,
            'active':stepBlock.active}" class="btn-circle button button-primary" (click)="onStepClick(stepBlock,$event)">{{i + 1}}
                </button>
                <ng-container *ngIf="stepBlock.label && !stepBlock.active">
                    <p>{{stepBlock.label}}</p>
                </ng-container>
                <ng-container *ngIf="stepBlock.label && stepBlock.active">
                    <p><strong class="step-label-highlight">{{stepBlock.label}}</strong></p>
                </ng-container>
            </div>
        </div>
    </div>

    <!--this code use when user give icon true bydefault it is false-->
    <div class="stepwizard" *ngIf="(icon && !index && !block)">
        <div class="stepwizard-row setup-panel">
            <div *ngFor="let stepBlock of stepBlockArray; let i = index" class="stepwizard-step">
                <ng-container *ngIf="stepBlock.icon && stepBlock.active">
                    <span [ngClass]="{'step-box-icon-active':stepBlock.active}" (onClick)="onStepClick(stepBlock,$event)">
                        <amexio-c-icon [customclass]="stepBlock.icon"></amexio-c-icon>
                    </span>
                </ng-container>
                <ng-container *ngIf="stepBlock.icon && !stepBlock.active">
                    <span [ngClass]="{'step-block-icon-disable':!stepBlock.active}">
                        <amexio-c-icon [customclass]="stepBlock.icon" (onClick)="onStepClick(stepBlock,$event)"></amexio-c-icon>
                    </span>
                </ng-container>
                <ng-container *ngIf="stepBlock.icon=='' || !stepBlock.icon">
                    <br>
                </ng-container>
                <ng-container *ngIf="stepBlock.label && !stepBlock.active">
                    <p style="cursor:not-allowed;" (onClick)="onStepClick(stepBlock,$event)">{{stepBlock.label}}</p>
                </ng-container>
                <ng-container *ngIf="stepBlock.label && stepBlock.active">
                    <p style="cursor:pointer;"><strong class="step-label-highlight" [ngClass]="{'step-box-label-active':stepBlock.active}">{{stepBlock.label}}</strong></p>
                </ng-container>
            </div>
        </div>
    </div>

    <!--This code use for steps of boxes-->
    <div *ngIf="block">
        <div *ngIf="block" role="tablist" class="step-box-sqaure">
            <div class="step-box-table">
                <ng-container *ngFor="let stepBlock of stepBlockArray; let i = index">
                    <div role="link" class="step-box-table-item" [tabindex]="stepBlock.active ? 0 : -1" [attr.aria-labelleby]="stepBlock.label" (click)="onStepClick(stepBlock,$event)" style="padding-top: 10px;" [ngClass]="{'disabled step-box-table-item-hover ':!stepBlock.active,'active':stepBlock.active}">
                        <a>
                            <ng-container *ngIf="index">
                                {{i + 1}}<br>
                            </ng-container>
                            <ng-container *ngIf="icon && stepBlock.icon">
                                <amexio-c-icon [customclass]="stepBlock.icon"></amexio-c-icon>
                            </ng-container>
                            <ng-container *ngIf="stepBlock.label && !stepBlock.active">
                                <p style="word-wrap: break-word;">{{stepBlock.label}}</p>
                            </ng-container>
                            <ng-container *ngIf="stepBlock.label && stepBlock.active">
                                <p style="word-wrap: break-word;"><strong>{{stepBlock.label}}</strong></p>
                            </ng-container>
                        </a>
                    </div>
                </ng-container>

            </div>
        </div>

    </div>
  `,
            },] },
];
/** @nocollapse */
AmexioStepsComponent.ctorParameters = () => [];
AmexioStepsComponent.propDecorators = {
    index: [{ type: Input }],
    icon: [{ type: Input }],
    block: [{ type: Input }],
    onClick: [{ type: Output }],
    getStepBlockData: [{ type: Output }],
    stepBlocks: [{ type: ContentChildren, args: [StepBlockComponent,] }],
    data: [{ type: Input, args: ['data',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by pratik on 8/12/17.
*/
class AmexioTabPillComponent {
    constructor() {
        /*
        Properties
        name : disabled
        datatype : boolean
        version : 4.1.4 onwards
        default : false
        description : Disable property for tab
        */
        this.disabled = false;
        /*
        Properties
        name : active
        datatype : boolean
        version : 4.0 onwards
        default : false
        description : Set true for specific tab open as default tab..
        */
        this.active = false;
        /*
         Properties
         name : closable
         datatype : boolean
         version : 4.2 onwards
         default : false
         description : Font color of label
         */
        this.closable = null;
        this.tabId = Math.floor(window.crypto.getRandomValues(new Uint32Array(1))[0]);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
}
AmexioTabPillComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-tab', template: `
    <div style = "outline: none"  [style.height.px]="height" role="tabpanel" tabindex="1" class="tab-pane active" attr.aria-labelledby="{{tablk}}" [attr.id]="tabId" [hidden]="!active">
      <ng-content></ng-content>
      <ng-template #target></ng-template>
    </div>
  `,
            },] },
];
/** @nocollapse */
AmexioTabPillComponent.ctorParameters = () => [];
AmexioTabPillComponent.propDecorators = {
    title: [{ type: Input }],
    disabled: [{ type: Input }],
    active: [{ type: Input }],
    icon: [{ type: Input }],
    amexiocolor: [{ type: Input, args: ['amexio-color',] }],
    closable: [{ type: Input }],
    height: [{ type: Input, args: ['height',] }],
    target: [{ type: ViewChild, args: ['target', { read: ViewContainerRef },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// @Component({
//     selector: 'base.tab',
//     template: './base.tab.component.html',
//   })
class BaseTabComponent extends LifeCycleBaseComponent {
    /**
     * @param {?} componentFactoryResolver
     */
    constructor(componentFactoryResolver) {
        super();
        this.componentFactoryResolver = componentFactoryResolver;
        /*
        Events
        name : onClick
        datatype : none
        version : 4.0 onwards
        default :none
        description : Callback to invoke on activated tab event.
        */
        this.onClick = new EventEmitter();
        this.dummyArray = [];
        this.shownext = false;
        this.tabPosition = 'top';
    }
    /**
     * @param {?} title
     * @param {?} amexiocolor
     * @param {?} closable
     * @param {?} component
     * @return {?}
     */
    addDynamicTab(title, amexiocolor, closable, component) {
        // get a component factory for our TabComponent
        /** @type {?} */
        const tpCF = this.componentFactoryResolver.resolveComponentFactory(AmexioTabPillComponent);
        /** @type {?} */
        const tp = this.target.createComponent(tpCF);
        // set the according properties on our component instance
        /** @type {?} */
        const instance = (/** @type {?} */ (tp.instance));
        instance.title = title;
        instance.active = true;
        instance.closable = closable;
        instance['tabpillinstance'] = this.target;
        if (instance.amexiocolor === '') {
            instance.amexiocolor = 'amexio-top-tab-black';
        }
        else {
            instance.amexiocolor = 'amexio-top-tab-' + amexiocolor;
        }
        // create dynamic component
        /** @type {?} */
        const dynCF = this.componentFactoryResolver.resolveComponentFactory(component);
        /** @type {?} */
        const dynCmp = tp.instance.target.createComponent(dynCF);
        // Push new tab and select it.
        this.dummyArray.push(tp);
        this.tabCollection.push(tp.instance);
        this.selectTab(tp.instance);
        if (this.tabType === 'horizontal') {
            this.adjustWidth();
        }
        return dynCmp.instance;
    }
    /**
     * @param {?} tab
     * @return {?}
     */
    selectTab(tab) {
        // deactivate all tabs
        this.tabCollection.forEach((/**
         * @param {?} tab1
         * @return {?}
         */
        (tab1) => {
            tab1.active = false;
        }));
        tab.active = true;
        this.tabCollection.forEach((/**
         * @param {?} tab1
         * @return {?}
         */
        (tab1) => {
            this.asignTabPillClass(tab1);
        }));
    }
    /**
     * @param {?} tabNode
     * @return {?}
     */
    tabPillClose(tabNode) {
        /** @type {?} */
        const newTab = [];
        /** @type {?} */
        let index = 0;
        /** @type {?} */
        let tabHighlightIndex = 0;
        this.tabCollection.forEach((/**
         * @param {?} tab
         * @param {?} i
         * @return {?}
         */
        (tab, i) => {
            tab.active = false;
            if (tab.tabId === tabNode.tabId) {
                tabHighlightIndex = index;
                if (tab.hasOwnProperty('tabpillinstance')) {
                    tab.target.remove();
                }
                else {
                    this.tabDomRemove(tab);
                }
            }
            else {
                newTab.push(tab);
            }
            index++;
        }));
        if (tabHighlightIndex === newTab.length) {
            tabHighlightIndex--;
        }
        this.tabCollection = newTab;
        if (tabHighlightIndex > -1) {
            this.activateTab(newTab[tabHighlightIndex].tabId);
        }
        else {
            this.activateTab(null);
        }
        if (this.tabCollection.length === 1) {
            this.closable = false;
        }
        if (newTab.length === 1) {
            newTab[0].closable = false;
        }
    }
    /**
     * @param {?} tab
     * @return {?}
     */
    onVerticalTabClick(tab) {
        if (!tab.disabled && !tab.header) {
            for (const i of this.tabCollection) {
                if (i === tab) {
                    i['active'] = true;
                    this.asignTabPillClass(tab);
                    this.onClick.emit(tab);
                }
                else {
                    i['active'] = false;
                    i['tabPillClass'] = '';
                }
            }
            this.tabCollection.forEach((/**
             * @param {?} tab1
             * @return {?}
             */
            (tab1) => {
                this.asignTabPillClass(tab1);
            }));
        }
    }
    /**
     * @param {?} tabId
     * @return {?}
     */
    activateTab(tabId) {
        if (tabId !== null) {
            this.tabCollection.forEach((/**
             * @param {?} tab
             * @return {?}
             */
            (tab) => {
                tab.active = false;
                if (tab.tabId === tabId) {
                    tab.active = true;
                }
                this.asignTabPillClass(tab);
            }));
        }
    }
    /**
     * @param {?} tab
     * @return {?}
     */
    tabDomRemove(tab) {
        /** @type {?} */
        const removeNode = document.getElementById(tab.tabId).parentNode;
        /** @type {?} */
        const parentRefNode = removeNode.parentNode;
        parentRefNode.removeChild(removeNode);
    }
    /**
     * @param {?} tabData
     * @return {?}
     */
    asignTabPillClass(tabData) {
        tabData.tabPillClass = '';
        if ((!tabData.amexiocolor || tabData.amexiocolor === '') && tabData.active && (this.tabPosition === 'top')) {
            tabData.tabPillClass = 'activetab';
        }
        if ((!tabData.amexiocolor || tabData.amexiocolor === '') && (this.tabPosition === 'bottom') && tabData.active) {
            tabData.tabPillClass = 'bottomActivetab';
        }
        if (tabData.disabled) {
            tabData.tabPillClass = 'disabled-tab';
        }
        if ((tabData.amexiocolor !== '') && (this.tabPosition === 'top') && tabData.active && !this.activeBGColor) {
            tabData.tabPillClass = 'activecolortab';
        }
        if ((tabData.amexiocolor !== '') && (this.tabPosition === 'top') && tabData.active && this.activeBGColor) {
            tabData.tabPillClass = 'activebgcolortab';
        }
        if ((tabData.amexiocolor !== '') && (this.tabPosition === 'bottom') && tabData.active) {
            tabData.tabPillClass = 'activebottomcolortab';
        }
    }
    /**
     * @return {?}
     */
    adjustWidth() {
        /** @type {?} */
        const tWidth = this.tabs.nativeElement.clientWidth;
        /** @type {?} */
        const tlistWidth = this.tabslist.nativeElement.scrollWidth;
        /** @type {?} */
        const hWidth = 0;
        /** @type {?} */
        const totalElWidth = tlistWidth + hWidth;
        if (totalElWidth > tWidth) {
            this.shownext = true;
        }
        else {
            this.shownext = false;
        }
        if (this.fullPageTabs === true) {
            if (totalElWidth > tWidth) {
                this.shownext = true;
            }
            else {
                this.singleTabWidth = totalElWidth / this.totalTabs;
            }
        }
        this.onAdjustHeight();
    }
    /**
     * @return {?}
     */
    onAdjustHeight() {
        if (this.bodyheight) {
            /** @type {?} */
            let h = (window.innerHeight / 100) * this.bodyheight;
            if (this.tabs && this.tabs.nativeElement && this.tabs.nativeElement.offsetHeight) {
                h = h - this.tabs.nativeElement.offsetHeight;
            }
            if (this.bodyheight === 100) {
                h = h - 40;
            }
            this.minHeight = h;
            this.height = h;
        }
    }
}
BaseTabComponent.propDecorators = {
    target: [{ type: ViewChild, args: ['target', { read: ViewContainerRef },] }],
    queryTabs: [{ type: ContentChildren, args: [AmexioTabPillComponent,] }],
    tabPosition: [{ type: Input, args: ['tab-position',] }],
    tabs: [{ type: ViewChild, args: ['tab', { read: ElementRef },] }],
    tabslist: [{ type: ViewChild, args: ['tabslist', { read: ElementRef },] }],
    fullPageTabs: [{ type: Input, args: ['divide-header-equally',] }],
    activeBGColor: [{ type: Input, args: ['active-bg-color',] }],
    bodyheight: [{ type: Input, args: ['body-height',] }],
    closable: [{ type: Input }],
    onClick: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by ketangote on 12/1/17.
*/
class AmexioRightVerticalTabComponent extends BaseTabComponent {
    /**
     * @param {?} render
     * @param {?} componentFactoryResolver
     */
    constructor(render, componentFactoryResolver) {
        super(componentFactoryResolver);
        this.render = render;
        this.componentFactoryResolver = componentFactoryResolver;
        this.componentId = '';
        /*
         Properties
         name :rotate
         datatype : boolean
         version : 5.12.2 onwards
         default : false
         description : tab header alignment
         */
        this.rotate = false;
        this.height = 580;
        this.tabPosition = 'top';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.componentId = Math.floor(window.crypto.getRandomValues(new Uint32Array(1))[0]) + '_tabc';
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (this.tabId && this.tabId.nativeElement && this.tabId.nativeElement.offsetWidth) {
            /** @type {?} */
            const tabsheight = this.tabId.nativeElement.offsetWidth + 50;
            if (tabsheight > this.height) {
                this.height = tabsheight;
            }
        }
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.tabCollection = this.queryTabs.toArray();
    }
    /**
     * @return {?}
     */
    closeAllTabs() {
        this.tabCollection.forEach((/**
         * @param {?} tabs
         * @return {?}
         */
        (tabs) => {
            if (tabs.closable === true || this.closable === true) {
                this.tabPillClose(tabs);
            }
        }));
    }
    /**
     * @param {?} tab
     * @return {?}
     */
    tabDomRemove(tab) {
        /** @type {?} */
        const removeNode = document.getElementById(tab.tabId).parentNode;
        /** @type {?} */
        const parentRefNode = removeNode.parentNode;
        parentRefNode.removeChild(removeNode);
    }
    /**
     * @param {?} tabId
     * @return {?}
     */
    activateTab(tabId) {
        this.tabCollection.forEach((/**
         * @param {?} tab
         * @return {?}
         */
        (tab) => {
            tab.active = false;
            if (tab.tabId === tabId) {
                tab.active = true;
            }
        }));
    }
}
AmexioRightVerticalTabComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-right-vertical-tab-view',
                template: `
    <div class="righttable" style="position:relative;padding-right:10px">
        <div class="righttablerow">
            <div class="tablecol verticalalign-tabcontent" style="padding-right:30px">
                <div style="float:left" class="tabcontent" [attr.id]="componentId">
                    <ng-content></ng-content>
                    <ng-template #target></ng-template>
                </div>
            </div>
            <div #tab *ngIf="rotate;
             else elseBlock" [ngStyle]="{'height': height + 'px'}" class="verticalnavtab-right verticalalign-rotatetabright" [ngClass]="{'tabposition-rightrotate-top': (tabPosition==='top')}">
                <ul #tabId id="rightclass">
                    <li *ngFor="let tabnode of tabCollection">
                        <div class="righttabdefaultnode" [ngClass]="{'rightactivetabrotate':tabnode.active,'disabled-tab':tabnode.disabled }" (click)="onVerticalTabClick(tabnode)"
                            [ngStyle]="{'color': tabnode.amexiocolor}">
                            <span *ngIf="tabnode.icon" [ngClass]="tabnode.icon" aria-hidden="true"></span>
                            <span style="padding-left:5px">{{tabnode.title}}</span>
                            <span *ngIf="closable" class="tablecol">
                    <amexio-c-icon key="tab_close" (onClick)="tabPillClose(tabnode)" style="padding-left:5px;float:right"></amexio-c-icon>
                  </span>
                        </div>
                    </li>
                </ul>
            </div>
         <ng-template #elseBlock>
              <div style="float:right;height:580px" class="righttablecol verticalalign-tabright">
                <div #tab class="verticalnavtab verticalnavtab-right" [ngClass]="{'tabposition-right-top': (tabPosition==='top'),'tabposition-right-bottom':(tabPosition==='bottom')}">
                    <ul>
                        <li *ngFor="let tabnode of tabCollection">
                            <div class="defaultnode" [ngClass]="{'rightactivetab':tabnode.active,'disabled-tab':tabnode.disabled }" (click)="onVerticalTabClick(tabnode)" [ngStyle]="{'color': tabnode.amexiocolor}">
                                <span *ngIf="tabnode.icon" [ngClass]="tabnode.icon" aria-hidden="true"></span>
                                <span style="padding-left:5px">{{tabnode.title}}</span>
                                <span *ngIf="closable" class="tablecol">
                    <amexio-c-icon key="tab_close" (onClick)="tabPillClose(tabnode)" style="padding-left:5px;float:right"></amexio-c-icon>
                  </span>
                            </div>
                        </li>
                    </ul>
                </div>
            </div>
         </ng-template>   
        </div>
    </div>
  `,
            },] },
];
/** @nocollapse */
AmexioRightVerticalTabComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: ComponentFactoryResolver }
];
AmexioRightVerticalTabComponent.propDecorators = {
    tabs: [{ type: ViewChild, args: ['tab', { read: ElementRef },] }],
    queryTabs: [{ type: ContentChildren, args: [AmexioTabPillComponent,] }],
    target: [{ type: ViewChild, args: ['target', { read: ViewContainerRef },] }],
    tabId: [{ type: ViewChild, args: ['tabId',] }],
    closable: [{ type: Input }],
    tabPosition: [{ type: Input }],
    rotate: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
/** @type {?} */
const noop$3 = (/**
 * @return {?}
 */
() => {
});
// @Component({
//   selector: 'value-accessor',
//   template: './value-accessor.component.html',
// })
/**
 * @template T
 */
class ValueAccessorBaseComponent {
    constructor() {
        this.onTouchedCallback = noop$3;
        this.onChangeCallback = noop$3;
    }
    // get accessor
    /**
     * @return {?}
     */
    get value() {
        return this.innerValue;
    }
    // set accessor including call the onchange callback
    /**
     * @param {?} v
     * @return {?}
     */
    set value(v) {
        if (v !== this.innerValue) {
            this.innerValue = v;
            this.onChangeCallback(v);
        }
    }
    // From ControlValueAccessor interface
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (value !== this.innerValue) {
            this.innerValue = value;
        }
    }
    // From ControlValueAccessor interface
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChangeCallback = fn;
    }
    // From ControlValueAccessor interface
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouchedCallback = fn;
    }
    // THIS METHOD GENERATE RANDOM STRING
    /**
     * @param {?} name
     * @param {?} fieldlabel
     * @param {?} inputType
     * @return {?}
     */
    generateName(name, fieldlabel, inputType) {
        /** @type {?} */
        let newName = name;
        if (!name && fieldlabel) {
            newName = fieldlabel.replace(/\s/g, '');
        }
        else if (!name && !fieldlabel) {
            newName = inputType + '-' + this.getRandomString();
        }
        return newName;
    }
    /**
     * @return {?}
     */
    getRandomString() {
        /** @type {?} */
        const possibleCharacters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';
        /** @type {?} */
        let randomString = '';
        for (let i = 0; i < 6; i++) {
            randomString += possibleCharacters.charAt(window.crypto.getRandomValues(new Uint32Array(1))[0] * possibleCharacters.length);
        }
        return randomString;
    }
    /**
     * @param {?} inputType
     * @param {?} name
     * @return {?}
     */
    createCompId(inputType, name) {
        if (name === '' || name === null) {
            return inputType + '_' + window.crypto.getRandomValues(new Uint32Array(1))[0];
        }
        else {
            return inputType + '_' + name;
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/
class AmexioCheckBoxGroupComponent extends ValueAccessorBaseComponent {
    /**
     * @param {?} httpService
     */
    constructor(httpService) {
        super();
        this.httpService = httpService;
        /*
          Properties
          name : disabled
          datatype : boolean
          version : 4.0 onwards
          default : false
          description :  If true will not react on any user events and show disable icon over
          */
        this.disabled = false;
        /*
        Properties
        name : required
        datatype : boolean
        version : 4.1.7 onwards
        default : false
        description :  property to set if manditory
        */
        this.required = false;
        this.onSelection = new EventEmitter();
        this.SelectedCheckBox = [];
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set data(v) {
        this._data = v;
        this.viewdata = of(this.data);
    }
    /**
     * @return {?}
     */
    get data() {
        return this._data;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.componentId = this.createCompId('checkboxgroup', this.name);
        /** @type {?} */
        let reponseData;
        if (this.httpmethod && this.httpurl) {
            this.httpService.fetchData(this.httpurl, this.httpmethod).subscribe((/**
             * @param {?} response
             * @return {?}
             */
            (response) => {
                reponseData = response;
            }), (/**
             * @param {?} error
             * @return {?}
             */
            (error) => {
            }), (/**
             * @return {?}
             */
            () => {
                this.data = this.getResponseData(reponseData);
            }));
        }
        else if (this.data && this.datareader) {
            this.data = this.getResponseData(this.data);
        }
    }
    /**
     * @param {?} httpResponse
     * @return {?}
     */
    getResponseData(httpResponse) {
        /** @type {?} */
        let responsedata = httpResponse;
        if (this.datareader != null) {
            /** @type {?} */
            const dr = this.datareader.split('.');
            for (const ir of dr) {
                responsedata = responsedata[ir];
            }
        }
        else {
            responsedata = httpResponse;
        }
        return responsedata;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    contains(value) {
        if (this._model instanceof Array) {
            this._model.forEach((/**
             * @param {?} obj
             * @return {?}
             */
            (obj) => {
                if (obj[this.displayfield] === value[this.displayfield]) {
                    return true;
                }
            }));
        }
        return false;
    }
    /**
     * @return {?}
     */
    emitData() {
        this.SelectedCheckBox = [];
        this.data.forEach((/**
         * @param {?} node
         * @return {?}
         */
        (node) => {
            if (node.checked) {
                this.SelectedCheckBox.push(node);
            }
        }));
        this.onSelection.emit(this.SelectedCheckBox);
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return (this.required && (this._model && this._model.length > 0)) || !this.required ? null : {
            jsonParseError: {
                valid: true,
            },
        };
    }
}
AmexioCheckBoxGroupComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-checkbox-group',
                template: `
    <div role="group"
         attr.aria-labelledby="{{componentId}}"
         [attr.aria-required]="required" 
         tabindex="0"
         class="inputgroup form-group">
        <div *ngIf="fieldlabel">
            <legend id="{{componentId}}">{{fieldlabel}}</legend>
        </div>  

        <div *ngIf="horizontal" style="display: inline-flex; flex-direction :row;">
            <checkbox *ngFor="let data of viewdata | async" [checked]="data.checked" [value]="data" [disabled]="data?.disabled || disabled" [label]="data[displayfield]">
            </checkbox>    
        </div>

        <div *ngIf="!horizontal" style="display: inline-flex;flex-direction :column;">
            <checkbox *ngFor="let data of viewdata | async" [checked]="data.checked" [value]="data" [disabled]="data?.disabled || disabled" [label]="data[displayfield]">
            </checkbox>
        </div>
    </div>
  `,
                providers: [
                    { provide: NG_VALUE_ACCESSOR, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => AmexioCheckBoxGroupComponent)), multi: true },
                    { provide: NG_VALIDATORS, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => AmexioCheckBoxGroupComponent)), multi: true },
                ],
            },] },
];
/** @nocollapse */
AmexioCheckBoxGroupComponent.ctorParameters = () => [
    { type: CommonDataService }
];
AmexioCheckBoxGroupComponent.propDecorators = {
    horizontal: [{ type: Input }],
    disabled: [{ type: Input }],
    data: [{ type: Input, args: ['data',] }],
    fieldlabel: [{ type: Input, args: ['field-label',] }],
    displayfield: [{ type: Input, args: ['display-field',] }],
    valuefield: [{ type: Input, args: ['value-field',] }],
    required: [{ type: Input, args: ['required',] }],
    name: [{ type: Input, args: ['name',] }],
    datareader: [{ type: Input, args: ['data-reader',] }],
    httpmethod: [{ type: Input, args: ['http-method',] }],
    httpurl: [{ type: Input, args: ['http-url',] }],
    onSelection: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AmexioFormValidator {
    // @ViewChild(NgModel) model: NgModel;
    // public validate(c: FormControl) {
    //     return (this.model.valid ) ? null : {
    //         jsonParseError: {
    //             valid: true,
    //         },
    //     };
    // }
    /**
     * @param {?} inputType
     * @param {?} name
     * @return {?}
     */
    createCompId(inputType, name) {
        return inputType + '_' + name + '_' + window.crypto.getRandomValues(new Uint32Array(1))[0];
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by ketangote on 11/21/17.
*/
/** @type {?} */
const noop$4 = (/**
 * @return {?}
 */
() => {
});
class AmexioCheckBoxComponent extends AmexioFormValidator {
    constructor() {
        super();
        // The internal dataviews model
        this.innerValue = '';
        // Placeholders for the callbacks which are later provided
        // by the Control Value Accessor
        this.onTouchedCallback = noop$4;
        this.onChangeCallback = noop$4;
        /*
          Properties
          name : required
          datatype : boolean
          version : 4.0 onwards
          default : false
          description :  property to set if manditory
          */
        this.required = false;
        /*
          Events
          name : onSelection
          datatype : any
          version : none
          default : none
          description : Event fired on checkbox click.
          */
        this.onSelection = new EventEmitter();
        /*
          Events
          name : input
          datatype : any
          version : none
          default : none
          description : On input event field.
          */
        this.input = new EventEmitter();
        this.tabFocus = false;
        this.isComponentValid = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.componentId = this.createCompId('checkbox', this.name);
        this.generateName();
        this.isValid = !this.required;
        this.isComponentValid.emit(!this.required);
    }
    /**
     * @return {?}
     */
    onInput() {
        this.isValid = this.value;
        this.isComponentValid.emit(this.value);
        this.input.emit(this.value);
    }
    /**
     * @return {?}
     */
    onClick() {
        this.value = !this.value;
        this.isValid = this.value;
        this.isComponentValid.emit(this.value);
        this.onSelection.emit(this.value);
    }
    // get accessor
    /**
     * @return {?}
     */
    get value() {
        if (this.required) {
            this.isValid = this.innerValue;
        }
        else {
            this.isValid = true;
        }
        return this.innerValue;
    }
    // set accessor including call the onchange callback
    /**
     * @param {?} v
     * @return {?}
     */
    set value(v) {
        if (v !== this.innerValue) {
            this.innerValue = v;
            this.onChangeCallback(v);
        }
    }
    // Set touched on blur
    /**
     * @return {?}
     */
    onBlur() {
        this.tabFocus = false;
        this.onTouchedCallback();
    }
    /**
     * @return {?}
     */
    onFocus() {
        this.tabFocus = true;
    }
    // From ControlValueAccessor interface
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (value !== this.innerValue) {
            this.innerValue = value;
            this.value = this.innerValue;
        }
    }
    // From ControlValueAccessor interface
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChangeCallback = fn;
    }
    // From ControlValueAccessor interface
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouchedCallback = fn;
    }
    // THIS MEHTOD CHECK INPUT IS VALID OR NOT
    /**
     * @return {?}
     */
    checkValidity() {
        return this.isValid;
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return ((this.required && this.value) || !this.required) ? null : {
            jsonParseError: {
                valid: true,
            },
        };
    }
    // THIS METHOD GENERATE RANDOM STRING
    /**
     * @return {?}
     */
    generateName() {
        if (!this.name && this.fieldlabel) {
            this.name = this.fieldlabel.replace(/\s/g, '');
        }
        else if (!this.name && !this.fieldlabel) {
            this.name = 'textinput-' + this.getRandomString();
        }
    }
    /**
     * @return {?}
     */
    getRandomString() {
        /** @type {?} */
        const possibleCharacters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';
        /** @type {?} */
        let randomString = '';
        for (let i = 0; i < 6; i++) {
            randomString += possibleCharacters.charAt(window.crypto.getRandomValues(new Uint32Array(1))[0] * possibleCharacters.length);
        }
        return randomString;
    }
}
AmexioCheckBoxComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-checkbox',
                template: `
    <div [attr.aria-checked]="value" class="inputgroup form-group" [ngClass]="{'checkbox-disable' : disabled}">
        <label for="{{componentId}}" class="input-box-container">
            <input
            id="{{componentId}}" type="checkbox" style="top:0; left:0"
            [attr.checked]="value ? true: null"
             tabindex="1"
            (input)="onInput()" 
            (click)="onClick()"
            (focus)="onFocus()"
            (blur)="onBlur()"
            [attr.disabled] = "disabled ? true: null"
            [attr.aria-disabled]="disabled"
            [(ngModel)]="value"
            [attr.aria-required]="required"
            [required]="required" >
            {{fieldlabel}}
            <span class="input-box-checkbox-label" [ngClass]="{'focusOnCheckbox':tabFocus}">
            </span>
          </label>
    </div>
  `,
                providers: [{
                        provide: NG_VALUE_ACCESSOR, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => AmexioCheckBoxComponent)), multi: true,
                    }, {
                        provide: NG_VALIDATORS, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => AmexioCheckBoxComponent)), multi: true,
                    }],
            },] },
];
/** @nocollapse */
AmexioCheckBoxComponent.ctorParameters = () => [];
AmexioCheckBoxComponent.propDecorators = {
    fieldlabel: [{ type: Input, args: ['field-label',] }],
    disabled: [{ type: Input }],
    required: [{ type: Input }],
    onSelection: [{ type: Output }],
    input: [{ type: Output }],
    name: [{ type: Input, args: ['name',] }],
    isComponentValid: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
/**
 * @template T
 */
class EventBaseComponent extends ValueAccessorBaseComponent {
    /**
     * @param {?} renderer
     * @param {?} element
     * @param {?} cd
     */
    constructor(renderer, element, cd) {
        super();
        this.renderer = renderer;
        this.element = element;
        this.cd = cd;
        this.self = false;
        this.itemClick = false;
        this.hide();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onBaseFocusEvent(event) {
        this.self = true;
        this.dropdownstyle = { visibility: 'visible' };
        this.bindDocumentClickListener();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onBaseBlurEvent(event) {
        this.onBaseItemClicked();
        return false;
    }
    /**
     * @return {?}
     */
    onBaseItemClicked() {
        this.itemClick = true;
        this.hide();
        this.unbindDocumentClickListener();
        this.clearClicks();
    }
    /**
     * @return {?}
     */
    bindDocumentClickListener() {
        if (!this.documentClickListener) {
            this.documentClickListener = this.renderer
                .listen('document', 'click', (/**
             * @param {?} event
             * @return {?}
             */
            (event) => this.handleDocumentListener(event)));
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    handleDocumentListener(event) {
        if (!this.self && !this.itemClick) {
            this.hide();
            this.unbindDocumentClickListener();
        }
        this.clearClicks();
        this.cd.markForCheck();
    }
    /**
     * @return {?}
     */
    clearClicks() {
        this.self = false;
        this.itemClick = false;
    }
    /**
     * @return {?}
     */
    unbindDocumentClickListener() {
        if (this.documentClickListener) {
            this.documentClickListener();
            this.documentClickListener = null;
        }
    }
    /**
     * @return {?}
     */
    hide() {
        this.dropdownstyle = { visibility: 'hidden' };
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Created by pratik on 1/12/17.
 */
/*
 Component Name : Amexio Dropdown
 Component Selector :  <amexio-dropdown>
 Component Description : Drop-Down component has been created to render
 N numbers of drop-down items based on data-set configured. Data-set can be
 configured using HTTP call OR Define fix number of dropdown-items. User can configure different attributes
 for enabling filter, multi-select, maximum selection in case of multi select.
*/
class AmexioDropDownComponent extends EventBaseComponent {
    /**
     * @param {?} dataService
     * @param {?} displayFieldService
     * @param {?} element
     * @param {?} renderer
     * @param {?} _cd
     */
    constructor(dataService, displayFieldService, element, renderer, _cd) {
        super(renderer, element, _cd);
        this.dataService = dataService;
        this.displayFieldService = displayFieldService;
        this.element = element;
        this.renderer = renderer;
        this.displayValue = '';
        this.filteredOptions = [];
        /*
          Events
          name : onBlur
          datatype : any
          version : 4.0 onwards
          default :
          description : 	On blur event
          */
        this.onBlur = new EventEmitter();
        /*
        Events
        name : input
        datatype : any
        version : none
        default :
        description : 	On input event field.
        */
        this.input = new EventEmitter();
        /*
        Events
        name : focus
        datatype : any
        version : none
        default :
        description : On field focus event
        */
        this.focus = new EventEmitter();
        /*
        Events
        name : onSingleSelect
        datatype : any
        version : none
        default :
        description : Fire when drop down item selected.
        */
        this.onSingleSelect = new EventEmitter();
        /*
        Events
        name : onMultiSelect
        datatype : any
        version :none
        default :
        description : Fire when multiple record select in drop down.this event is only
        applied when multi-select=true
        */
        this.onMultiSelect = new EventEmitter();
        /*
        Events
        name : onClick
        datatype : any
        version :none
        default :
        description : On record select event.this event is only for normal dropdown.
        */
        this.onClick = new EventEmitter();
        /*
        Properties
        name : place-holder
        datatype : string
        version : 4.0 onwards
        default :
        description : Show place-holder inside dropdown component*/
        this.placeholder = '';
        /*
        Properties
        name : has-label
        datatype : boolean
        version : 4.0 onwards
        default : false
        description : flag to set label
        */
        this.haslabel = true;
        this.enablesort = false;
        this.sort = '';
        this.selectedindex = -1;
        this.multiselectValues = [];
        this.maskloader = true;
        this.activedescendant = 'aria-activedescendant';
        this.key = 'index';
        // The internal dataviews model
        this.isComponentValid = new EventEmitter();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set data(value) {
        this._data = value;
        if (this.componentLoaded) {
            this.setData(this._data);
        }
    }
    /**
     * @return {?}
     */
    get data() {
        return this._data;
    }
    /**
     * @return {?}
     */
    get errormsg() {
        return this._errormsg;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set errormsg(value) {
        this.helpInfoMsg = value + '<br/>';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.name = this.generateName(this.name, this.fieldlabel, 'dropdowninput');
        this.componentId = this.createCompId('dropdown', this.name);
        this.isValid = this.allowblank;
        this.isComponentValid.emit(this.allowblank);
        if (this.httpmethod && this.httpurl) {
            this.dataService.fetchData(this.httpurl, this.httpmethod).subscribe((/**
             * @param {?} response
             * @return {?}
             */
            (response) => {
                this.responseData = response;
            }), (/**
             * @param {?} error
             * @return {?}
             */
            (error) => {
            }), (/**
             * @return {?}
             */
            () => {
                this.setData(this.responseData);
            }));
        }
        else if (this.data) {
            this.previousData = JSON.parse(JSON.stringify(this.data));
            this.setData(this.data);
        }
        this.componentLoaded = true;
    }
    /**
     * @param {?} httpResponse
     * @return {?}
     */
    setData(httpResponse) {
        // Check if key is added?
        /** @type {?} */
        let responsedata = httpResponse;
        if (this.datareader != null) {
            this.multiselectValues = [];
            /** @type {?} */
            const dr = this.datareader.split('.');
            if (dr) {
                for (const ir of dr) {
                    responsedata = responsedata[ir];
                }
            }
        }
        else {
            responsedata = httpResponse;
        }
        this.setResponseData(responsedata);
        this.multiSelection();
        this.setUserSelection();
        this.maskloader = false;
    }
    /**
     * @param {?} responsedata
     * @return {?}
     */
    setResponseData(responsedata) {
        if (responsedata) {
            if (this.enablesort === true && (this.sort === '' || this.sort.toLowerCase() === 'asc')) {
                this.sortDataAscending(responsedata);
            }
            else if (this.enablesort === true && this.sort.toLowerCase() === 'desc') {
                this.sortDataDescending(responsedata);
            }
            else if (this.enablesort === false) {
                this.viewData = responsedata;
                this.filteredOptions = this.viewData;
                this.generateIndex(this.filteredOptions);
            }
        }
    }
    /**
     * @param {?} data
     * @return {?}
     */
    sortDataAscending(data) {
        this.viewData = data.sort((/**
         * @param {?} a
         * @param {?} b
         * @return {?}
         */
        (a, b) => this.displayFieldService.findValue(this.displayfield, a).toLowerCase()
            !== this.displayFieldService.findValue(this.displayfield, b).toLowerCase() ?
            this.displayFieldService.findValue(this.displayfield, a).toLowerCase() <
                this.displayFieldService.findValue(this.displayfield, b).toLowerCase() ? -1 : 1 : 0));
        this.filteredOptions = this.viewData;
        this.generateIndex(this.filteredOptions);
    }
    /**
     * @param {?} data
     * @return {?}
     */
    sortDataDescending(data) {
        this.viewData = data.sort((/**
         * @param {?} a
         * @param {?} b
         * @return {?}
         */
        (a, b) => this.displayFieldService.findValue(this.displayfield, a).toLowerCase()
            !== this.displayFieldService.findValue(this.displayfield, b).toLowerCase() ?
            this.displayFieldService.findValue(this.displayfield, a).toLowerCase() >
                this.displayFieldService.findValue(this.displayfield, b).toLowerCase() ? -1 : 1 : 0));
        this.filteredOptions = this.viewData;
        this.generateIndex(this.filteredOptions);
    }
    /**
     * @param {?} data
     * @return {?}
     */
    generateIndex(data) {
        data.forEach((/**
         * @param {?} element
         * @param {?} index
         * @return {?}
         */
        (element, index) => {
            element['index'] = this.componentId + 'listitem' + index;
        }));
    }
    /**
     * @return {?}
     */
    multiSelection() {
        if (this.multiselect && this.viewData) {
            /** @type {?} */
            let preSelectedMultiValues = '';
            /** @type {?} */
            const optionsChecked = [];
            this.viewData.forEach((/**
             * @param {?} row
             * @return {?}
             */
            (row) => {
                if (row.hasOwnProperty('checked')) {
                    if (row.checked) {
                        optionsChecked.push(row[this.valuefield]);
                        this.multiselectValues.push(row);
                        preSelectedMultiValues === '' ? preSelectedMultiValues +=
                            this.displayFieldService.findValue(this.displayfield, row) : preSelectedMultiValues += ', ' +
                            this.displayFieldService.findValue(this.displayfield, row);
                    }
                }
                else {
                    row['checked'] = false;
                }
            }));
            this.displayValue = this.setMultiSelect();
            this.onMultiSelect.emit(this.multiselectValues);
        }
    }
    /**
     * @return {?}
     */
    setUserSelection() {
        // Set user selection
        if (this.innerValue != null) {
            /** @type {?} */
            const valueKey = this.valuefield;
            /** @type {?} */
            const displayKey = this.displayfield;
            /** @type {?} */
            const val = this.innerValue;
            if (this.viewData.length > 0) {
                this.viewData.forEach((/**
                 * @param {?} item
                 * @return {?}
                 */
                (item) => {
                    if (item[valueKey] === val) {
                        this.isValid = true;
                        this.isComponentValid.emit(true);
                        this.displayValue = item[displayKey];
                        delete item[this.key];
                        this.onSingleSelect.emit(item);
                    }
                }));
            }
        }
    }
    /**
     * @param {?} selectedItem
     * @return {?}
     */
    onItemSelect(selectedItem) {
        if (this.multiselect) {
            /** @type {?} */
            const optionsChecked = [];
            this.multiselectValues = [];
            if (selectedItem.hasOwnProperty('checked')) {
                selectedItem.checked = !selectedItem.checked;
                this.filteredOptions.forEach((/**
                 * @param {?} row
                 * @return {?}
                 */
                (row) => {
                    if (row.checked) {
                        optionsChecked.push(row[this.valuefield]);
                        this.multiselectValues.push(row);
                    }
                }));
                this.innerValue = optionsChecked;
                this.displayValue = this.setMultiSelect();
                this.onMultiSelect.emit(this.multiselectValues);
            }
        }
        else {
            this.value = selectedItem[this.valuefield]; // Issue here?
            this.displayValue = this.displayFieldService.findValue(this.displayfield, selectedItem);
            this.multiselect ? this.showToolTip = true : this.showToolTip = false;
            delete selectedItem[this.key];
            this.onSingleSelect.emit(selectedItem);
        }
        this.isValid = true;
        this.hide();
        this.isComponentValid.emit(true);
    }
    /**
     * @return {?}
     */
    setMultiSelectData() {
        this.multiselectValues = [];
        if (this.innerValue && this.innerValue.length > 0) {
            /** @type {?} */
            const modelValue = this.innerValue;
            this.filteredOptions.forEach((/**
             * @param {?} test
             * @return {?}
             */
            (test) => {
                modelValue.forEach((/**
                 * @param {?} mdValue
                 * @return {?}
                 */
                (mdValue) => {
                    if (test[this.valuefield] === mdValue) {
                        if (test.hasOwnProperty('checked')) {
                            test.checked = true;
                        }
                        this.multiselectValues.push(test);
                    }
                }));
            }));
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    navigateKey(event) {
    }
    /**
     * @return {?}
     */
    getDisplayText() {
        if (this.innerValue != null || this.innerValue !== '') {
            if (this.multiselect) {
                this.displayValue = this.setMultiSelect();
            }
            else {
                this.displayValue = '';
                this.filteredOptions.forEach((/**
                 * @param {?} test
                 * @return {?}
                 */
                (test) => {
                    if (test[this.valuefield] === this.innerValue) {
                        this.displayValue = this.displayFieldService.findValue(this.displayfield, test);
                    }
                }));
                this.displayValue = this.displayValue === undefined ? '' : this.displayValue;
            }
        }
    }
    /**
     * @return {?}
     */
    setMultiSelect() {
        this.setMultiSelectData();
        /** @type {?} */
        let multiselectDisplayString = '';
        this.multiselectValues.forEach((/**
         * @param {?} row
         * @return {?}
         */
        (row) => {
            multiselectDisplayString === '' ? multiselectDisplayString +=
                this.displayFieldService.findValue(this.displayfield, row) : multiselectDisplayString += ', '
                + this.displayFieldService.findValue(this.displayfield, row);
        }));
        if (this.multiselectValues.length > 0) {
            return multiselectDisplayString;
        }
        else {
            return '';
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onDropDownClick(event) {
        this.onBaseFocusEvent(event);
        this.showToolTip = true;
        this.onClick.emit(event);
        if (!this.multiselect && this.selectedindex > -1) {
            this.filteredOptions[this.selectedindex].selected = false;
            this.selectedindex = -1;
            this.selectedindex = this.selectedindex + 1;
            this.filteredOptions[this.selectedindex].selected = true;
            /** @type {?} */
            const inputid = document.getElementById(this.componentId);
            inputid.setAttribute(this.activedescendant, this.filteredOptions[this.selectedindex].index);
            this.generateScroll(this.selectedindex);
        }
    }
    /**
     * @param {?} index
     * @return {?}
     */
    generateScroll(index) {
        /** @type {?} */
        const listitems = this.element.nativeElement.getElementsByClassName('list-items')[index];
        if (listitems) {
            listitems.scrollIntoView({ behavior: 'smooth' });
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    focusToLast(event) {
        if (this.selectedindex > -1) {
            this.filteredOptions[this.selectedindex].selected = false;
            this.selectedindex = this.filteredOptions.length - 1;
            this.filteredOptions[this.filteredOptions.length - 1].selected = true;
            /** @type {?} */
            const inputid = document.getElementById(this.componentId);
            inputid.setAttribute(this.activedescendant, this.filteredOptions[this.filteredOptions.length - 1].index);
            this.generateScroll(this.selectedindex);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    closeOnEScape(event) {
        this.showToolTip = false;
        this.hide();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onChange(event) {
        this.innerValue = event;
        this.isValid = true;
        this.getDisplayText();
        this.isComponentValid.emit(true);
    }
    /**
     * @param {?} input
     * @return {?}
     */
    onInput(input) {
        this.input.emit();
        this.isValid = input.valid;
        this.isComponentValid.emit(input.valid);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onDropDownSearchKeyUp(event) {
        if (this.search && this.viewData) {
            /** @type {?} */
            const keyword = event.target.value;
            if (keyword != null && keyword !== '' && keyword !== ' ') {
                this.filteredOptions = [];
                /** @type {?} */
                const search_Term = keyword.toLowerCase();
                this.viewData.forEach((/**
                 * @param {?} row
                 * @return {?}
                 */
                (row) => {
                    if (this.displayFieldService.findValue(this.displayfield, row).toLowerCase().startsWith(search_Term)) {
                        this.filteredOptions.push(row);
                    }
                }));
            }
            if (keyword === '') {
                this.filteredOptions = this.viewData;
            }
        }
        if (event.keyCode === 8) {
            this.innerValue = '';
            this.displayValue = event.target.value;
        }
        if (event.keyCode === 40 || event.keyCode === 38 || event.keyCode === 13) {
            this.navigateUsingKey(event);
        }
        this.onBaseFocusEvent({});
    }
    // navigate using keys
    /**
     * @param {?} event
     * @return {?}
     */
    navigateUsingKey(event) {
        if (!this.showToolTip) {
            this.showToolTip = true;
        }
        if (this.selectedindex > this.filteredOptions.length) {
            this.selectedindex = 0;
        }
        if (event.keyCode === 40 || event.keyCode === 38 && this.selectedindex <
            this.filteredOptions.length) {
            /** @type {?} */
            let prevselectedindex = -1;
            prevselectedindex = this.selectedindex;
            if (event.keyCode === 40) {
                this.selectedindex++;
            }
            else if (event.keyCode === 38) {
                this.selectedindex--;
            }
            this.navigateFilterOptions(prevselectedindex);
        }
        if (event.keyCode === 13 && this.filteredOptions[this.selectedindex]) {
            this.onItemSelect(this.filteredOptions[this.selectedindex]);
        }
    }
    // for highlight  navigated options
    /**
     * @param {?} previndex
     * @return {?}
     */
    navigateFilterOptions(previndex) {
        if (this.filteredOptions[this.selectedindex]) {
            this.filteredOptions[this.selectedindex].selected = true;
            /** @type {?} */
            const inputid = document.getElementById(this.componentId);
            inputid.setAttribute(this.activedescendant, this.filteredOptions[this.selectedindex].index);
        }
        if (this.filteredOptions[previndex]) {
            this.filteredOptions[previndex].selected = false;
            this.toNavigateFirstAndLastOption();
        }
        this.generateScroll(this.selectedindex);
    }
    // to navigate first and last option
    /**
     * @return {?}
     */
    toNavigateFirstAndLastOption() {
        if (this.selectedindex === -1) {
            this.selectedindex = this.filteredOptions.length - 1;
            this.filteredOptions[this.filteredOptions.length - 1].selected = true;
            /** @type {?} */
            const inputid = document.getElementById(this.componentId);
            inputid.setAttribute(this.activedescendant, this.filteredOptions[this.filteredOptions.length - 1].index);
        }
        else if (this.selectedindex === this.filteredOptions.length) {
            this.selectedindex = 0;
            this.filteredOptions[this.selectedindex].selected = true;
            /** @type {?} */
            const inputid = document.getElementById(this.componentId);
            inputid.setAttribute(this.activedescendant, this.filteredOptions[this.selectedindex].index);
        }
    }
    // get accessor
    /**
     * @return {?}
     */
    get value() {
        return this.innerValue;
    }
    // set accessor including call the onchange callback
    /**
     * @param {?} v
     * @return {?}
     */
    set value(v) {
        if (v != null && v !== this.innerValue) {
            this.innerValue = v;
            this.onChangeCallback(v);
        }
    }
    // Set touched on blur
    /**
     * @param {?} event
     * @return {?}
     */
    onblur(event) {
        if (event.target && event.target.value && this.filteredOptions &&
            this.filteredOptions.length === 1) {
            /** @type {?} */
            const fvalue = event.target.value;
            /** @type {?} */
            const row = this.filteredOptions[0];
            /** @type {?} */
            const rvalue = this.displayFieldService.findValue(this.displayfield, row);
            if (fvalue && rvalue && (fvalue.toLowerCase() === rvalue.toLowerCase())) {
                this.onItemSelect(row);
            }
            this.onBaseBlurEvent(event);
        }
        if (this.showToolTip) {
            this.showToolTip = !this.showToolTip;
        }
        this.onTouchedCallback();
        this.onBlur.emit();
    }
    /**
     * @param {?} elem
     * @return {?}
     */
    onFocus(elem) {
        this.onBaseFocusEvent(elem);
        this.showToolTip = true;
        this.posixUp = this.getListPosition(elem);
        this.focus.emit();
    }
    /**
     * @param {?} elementRef
     * @return {?}
     */
    getListPosition(elementRef) {
        /** @type {?} */
        const dropdownHeight = 325;
        if (window.screen.height - (elementRef.getBoundingClientRect().bottom) < dropdownHeight) {
            return true;
        }
        else {
            return false;
        }
    }
    // From ControlValueAccessor interface
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (value != null) {
            this.writeChangedValue(value);
        }
        else {
            this.innerValue = '';
            if (this.allowblank) {
                this.isValid = true;
            }
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeChangedValue(value) {
        if (value !== this.innerValue) {
            /** @type {?} */
            let status = false;
            if (this.viewData && this.viewData.length > 0) {
                this.viewData.forEach((/**
                 * @param {?} item
                 * @return {?}
                 */
                (item) => {
                    if (item[this.valuefield] === value) {
                        this.isValid = true;
                        this.displayValue = this.displayFieldService.findValue(this.displayfield, item);
                        status = true;
                        return;
                    }
                }));
            }
            if (!status) {
                this.displayValue = '';
            }
            this.value = value;
        }
    }
    // From ControlValueAccessor interface
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChangeCallback = fn;
    }
    // From ControlValueAccessor interface
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouchedCallback = fn;
    }
    /**
     * @return {?}
     */
    onIconClick() {
        if (this.dropdownstyle.visibility === 'hidden') {
            this.showToolTip = false;
        }
        if (!this.disabled) {
            if (this.showToolTip === undefined || this.showToolTip === false) {
                this.onBaseFocusEvent({});
            }
            else {
                this.onBaseBlurEvent({});
            }
            this.showToolTip = !this.showToolTip;
        }
    }
    // THIS MEHTOD CHECK INPUT IS VALID OR NOT
    /**
     * @return {?}
     */
    checkValidity() {
        return this.isValid;
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return ((!this.allowblank && (this.value || this.value === 0)) || this.allowblank) ? null : {
            jsonParseError: {
                valid: true,
            },
        };
    }
}
AmexioDropDownComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-dropdown',
                template: `
    <div class="inputgroup" #rootDiv (keyup.esc)="closeOnEScape($event)">

        <label id="fieldlabel" for="input" *ngIf="haslabel" [style.font-style]="fontstyle" [style.font-family]="fontfamily" [style.font-size]="fontsize">
        {{fieldlabel}}
      </label>

        <input type="hidden" [ngModel]="value" (ngModelChange)="onChange($event)" #inp="ngModel" />
        <input id="{{componentId}}" tabindex="1" aria-autocomplete="list" role="combobox" [attr.aria-expanded]="showToolTip" [attr.aria-activedescendant]="" type="text" class="input-control" [value]="displayValue" [ngClass]="{'input-control-error' : inp.invalid && !displayValue && (inp.dirty || inp.touched),
             'input-control-success' : inp.valid && displayValue && (inp.dirty || inp.touched)}" (input)="onInput(inp)" (blur)="onblur($event)" (focus)="onFocus(rootDiv)" (click)=" onDropDownClick($event)" [attr.placeholder]="placeholder" [readonly]="readonly ? true : null"
            [attr.disabled]="disabled ? true: null" [required]="!allowblank" (keyup.end)="focusToLast($event)" (keyup)="onDropDownSearchKeyUp($event)" (keyup.enter)="closeOnEScape($event)" (keydown)="navigateKey($event)" />

        <span class="drodown-caret-down" role="listbox" [attr.aria-expanded]="showToolTip" (click)="onIconClick()">
        <amexio-c-icon key="dropdown_caret" *ngIf="!maskloader"></amexio-c-icon>
        <em class="fa fa-spinner fa-spin" *ngIf="maskloader"></em>
      </span>

        <span #dropdownitems class="dropdown" [ngClass]="{'dropdown-up' : posixUp}" [ngStyle]="dropdownstyle">
        <ul aria-labelledby="fieldlabel" aria-haspopup="listbox" class="dropdown-list">

          <li role="option" tabindex="1" class="list-items" [ngClass]="{'list-items-selected':item.selected}" *ngFor="let item of filteredOptions"
            id="{{item.index}}"  (mousedown)="onItemSelect(item)">
            <ng-container *ngIf="bodyTemplate">
              <ng-template [ngTemplateOutlet]="bodyTemplate" [ngTemplateOutletContext]="{ $implicit: { text : row }, row: item }">
              </ng-template>
            </ng-container>
            <ng-container *ngIf="!bodyTemplate">
              <span>
                <amexio-display-field [data]="item" [data-index]="displayfield"></amexio-display-field>
              </span>

        </ng-container>
        <span style="float : right">{{item?.checked ? '&#10004;': ''}}</span>
        </li>
    
        <ng-template *ngIf="filteredOptions && (filteredOptions.length < 1)">
            <li class="list-items">No Options</li>
        </ng-template>
        </ul>
        <ng-content></ng-content>
        </span>
        <span class="inputfieldbar"></span>
    </div>
    <span *ngIf="showToolTip && enablepopover" class="tooltiptext">
      <div [innerHTML]="helpInfoMsg"></div>
    </span>

    <span *ngIf="iconfeedback && (inp.invalid && (inp.dirty || inp.touched) || inp.valid)" class="input-control-feedback">
      <span *ngIf="inp.invalid && (inp.dirty || inp.touched)">&#9888;</span>
    <span *ngIf="inp.valid && (inp.dirty || inp.touched)"> &#10004;</span>

    </span>
  `,
                animations: [
                    trigger('changeState', [
                        state('visible', style({
                            'max-height': '200px',
                        })),
                        state('hidden', style({
                            'max-height': '0px',
                        })),
                        transition('*=>*', animate('200ms')),
                    ]),
                ],
                providers: [{
                        provide: NG_VALUE_ACCESSOR, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => AmexioDropDownComponent)), multi: true,
                    }, {
                        provide: NG_VALIDATORS, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => AmexioDropDownComponent)), multi: true,
                    }],
            },] },
];
/** @nocollapse */
AmexioDropDownComponent.ctorParameters = () => [
    { type: CommonDataService },
    { type: DisplayFieldService },
    { type: ElementRef },
    { type: Renderer2 },
    { type: ChangeDetectorRef }
];
AmexioDropDownComponent.propDecorators = {
    fieldlabel: [{ type: Input, args: ['field-label',] }],
    allowblank: [{ type: Input, args: ['allow-blank',] }],
    data: [{ type: Input, args: ['data',] }],
    datareader: [{ type: Input, args: ['data-reader',] }],
    httpmethod: [{ type: Input, args: ['http-method',] }],
    httpurl: [{ type: Input, args: ['http-url',] }],
    displayfield: [{ type: Input, args: ['display-field',] }],
    valuefield: [{ type: Input, args: ['value-field',] }],
    search: [{ type: Input }],
    readonly: [{ type: Input }],
    multiselect: [{ type: Input, args: ['multi-select',] }],
    dropdownitems: [{ type: ViewChild, args: ['dropdownitems', { read: ElementRef },] }],
    onBlur: [{ type: Output }],
    input: [{ type: Output }],
    focus: [{ type: Output }],
    onSingleSelect: [{ type: Output }],
    onMultiSelect: [{ type: Output }],
    onClick: [{ type: Output }],
    placeholder: [{ type: Input, args: ['place-holder',] }],
    disabled: [{ type: Input }],
    iconfeedback: [{ type: Input, args: ['icon-feedback',] }],
    fontstyle: [{ type: Input, args: ['font-style',] }],
    fontfamily: [{ type: Input, args: ['font-family',] }],
    fontsize: [{ type: Input, args: ['font-size',] }],
    haslabel: [{ type: Input, args: ['has-label',] }],
    enablepopover: [{ type: Input, args: ['enable-popover',] }],
    enablesort: [{ type: Input, args: ['enable-sort',] }],
    sort: [{ type: Input, args: ['sort',] }],
    errormsg: [{ type: Input, args: ['error-msg',] }],
    bodyTemplate: [{ type: ContentChild, args: ['amexioBodyTmpl',] }],
    isComponentValid: [{ type: Output }],
    name: [{ type: Input, args: ['name',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by  Pratik on 7/2/18.
*/
class AmexioLabelComponent {
    constructor() {
        this.enableclick = false;
        this.wordwrap = true;
        // For internal use
        this.blackLabel = false;
        this.onClick = new EventEmitter();
        this.tempStyleArray = ['large', 'medium', 'small', 'bold', 'large-bold', 'medium-bold', 'small-bold',
            'large-44', 'large-24', 'large-50', 'large-54', 'large-56', 'large-60', 'large-64', 'large-68', 'large-78', 'large-9vw',
            'large-44-bold', 'large-50-bold', 'large-24-bold', 'large-4vw', 'large-4vw-bold',
            'large-54-bold', 'large-56-bold', 'large-60-bold', 'large-64-bold', 'large-68-bold', 'large-78-bold', 'large-9vw-bold'];
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.styleClass == null) {
            this.styleClass = 'small';
        }
        else {
            this.styleClass = this.tempStyleArray.find((/**
             * @param {?} x
             * @return {?}
             */
            (x) => x === this.styleClass));
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onLabel(event) {
        if (this.enableclick) {
            this.onClick.emit(event);
        }
    }
}
AmexioLabelComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-label',
                template: `
  <label [ngClass]="{'labelFontClass': blackLabel, 'eclipse' : !wordwrap}" style="outline: none"
  role="text" tabindex="1" class="label-content {{styleClass}}" (click)="onLabel($event)"
    [ngStyle]="{'color' : fontColor,'cursor': enableclick ? 'pointer': 'text'}">
    <ng-content></ng-content>
    <span class="label-badge" *ngIf="badge">{{badge}}</span>
  </label>
  `,
            },] },
];
/** @nocollapse */
AmexioLabelComponent.ctorParameters = () => [];
AmexioLabelComponent.propDecorators = {
    badge: [{ type: Input, args: ['badge',] }],
    styleClass: [{ type: Input, args: ['size',] }],
    fontColor: [{ type: Input, args: ['font-color',] }],
    enableclick: [{ type: Input, args: ['enable-click',] }],
    wordwrap: [{ type: Input, args: ['word-wrap',] }],
    blackLabel: [{ type: Input }],
    onClick: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// @Component({
//     selector: 'list.base.datepicker',
//     template: './list.base.datepicker.component.html',
//   })
class BaseInputEventComponent extends ValueAccessorBaseComponent {
    constructor() {
        super();
        this.isValid = false;
        // Emailpattern: any = /\S+@\S+\.\S+/;
        this.emailpattern = /^([0-9a-zA-Z]([-.\w]*[0-9a-zA-Z])*@([0-9a-zA-Z][-\w]*[0-9a-zA-Z]\.)+[a-zA-Z]{2,9})$/;
        this.onBlur = new EventEmitter();
        this.input = new EventEmitter();
        this.focus = new EventEmitter();
        this.change = new EventEmitter();
        this.showToolTip = false;
    }
    /**
     * @return {?}
     */
    onBlurEvent() {
        this.showToolTip = false;
        this.onBlur.emit(this.value);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onFocusEvent(event) {
        this.eventPropagationText(event);
        this.showToolTip = true;
        this.focus.emit(this.value);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onInputEvent(event) {
        this.eventPropagationText(event);
        this.isValid = this.isFieldValid();
        this.input.emit(this.value);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onChangeEvent(event) {
        this.eventPropagationText(event);
        this.change.emit(this.value);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    eventPropagationText(event) {
        event.stopPropagation();
    }
    /**
     * @return {?}
     */
    isFieldValid() {
        /** @type {?} */
        let valid;
        valid = (!this.allowblank && (this.value && ((this.value.length >= this.minlength) && this.value.length > 0)) ||
            (!this.minlength && this.value && this.value.length > 0)) || this.allowblank;
        this.isValid = valid;
        return valid;
    }
    /**
     * @return {?}
     */
    isFieldValidate() {
        if (this.minvalue && !this.maxvalue) {
            return this.innerValue && (this.innerValue >= this.minvalue);
        }
        else if (!this.minvalue && this.maxvalue) {
            return this.innerValue && (this.innerValue <= this.maxvalue);
        }
        else if (!this.minvalue && !this.maxvalue && this.innerValue) {
            return true;
        }
        else {
            return this.innerValue && (this.innerValue >= this.minvalue && this.innerValue <= this.maxvalue);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onNumberInputEvent(event) {
        this.eventPropagationText(event);
        this.isValid = this.isFieldValidate();
        this.input.emit(this.value);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onEmailInputEvent(event) {
        this.eventPropagationText(event);
        this.isValid = this.isEmailFieldValid();
        this.input.emit(this.value);
    }
    /**
     * @return {?}
     */
    isEmailFieldValid() {
        return (!this.allowblank && this.emailpattern.test(this.value)) || this.allowblank;
    }
}
BaseInputEventComponent.propDecorators = {
    allowblank: [{ type: Input, args: ['allow-blank',] }],
    minlength: [{ type: Input, args: ['min-length',] }],
    minvalue: [{ type: Input, args: ['min-value',] }],
    maxvalue: [{ type: Input, args: ['max-value',] }],
    onBlur: [{ type: Output }],
    input: [{ type: Output }],
    focus: [{ type: Output }],
    change: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/
class AmexioNumberInputComponent extends BaseInputEventComponent {
    constructor() {
        super();
        this.isValid = false;
        /*
          Events
          name : onBlur
          datatype : any
          version : 4.0 onwards
          default :
          description : On blur event
          */
        this.onBlur = new EventEmitter();
        /*
         Events
         name : input
         datatype : any
         version : none
         default :
         description : 	On input event field.
         */
        this.input = new EventEmitter();
        /*
         Events
         name : focus
         datatype : any
         version : none
         default :
         description : On focus event field.
         */
        this.focus = new EventEmitter();
        /*
         Events
         name : change
         datatype : any
         version : none
         default :
         description : On field value change event
         */
        this.change = new EventEmitter();
        /*
        Properties
        name : has-label
        datatype : boolean
        version : 4.0 onwards
        default : true
        description : Flag to set label
        */
        this.haslabel = true;
    }
    /**
     * @return {?}
     */
    get pattern() {
        return this._pattern;
    }
    /*
    Properties
    name : pattern
    datatype : string
    version : 4.0 onwards
    default :
    description : Apply Reg-ex to the field
    */
    /**
     * @param {?} value
     * @return {?}
     */
    set pattern(value) {
        if (value != null) {
            this.regEx = new RegExp(this.pattern);
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.name = this.generateName(this.name, this.fieldlabel, 'numberinput');
        this.componentId = this.createCompId('numberinput', this.name);
    }
    // THIS METHOD FOR KEYBORAD KEY HOME PRESS.
    /**
     * @param {?} event
     * @return {?}
     */
    onKeyUpHome(event) {
        this.value = this.minvalue;
    }
    // THIS METHOD FOR KEYBORAD KEY END PRESS.
    /**
     * @param {?} event
     * @return {?}
     */
    onKeyUpEnd(event) {
        this.value = this.maxvalue;
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        /** @type {?} */
        const isValid = (!this.allowblank && this.isFieldValidate()) || this.allowblank;
        return isValid ? null : {
            jsonParseError: {
                valid: true,
            },
        };
    }
}
AmexioNumberInputComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-number-input',
                template: `



    <div class="inputgroup">

      <label *ngIf="haslabel" role="number"  id="{{componentId}}"  [style.font-style]="fontstyle" [style.font-family]="fontfamily" [style.font-size]="fontsize">
          {{fieldlabel}}
      </label>

      <input type="number" 


            role="number"
            tabindex="1"
       
            aria-describedby="numberDes"
            attr.aria-labelledby="{{componentId}}"
            [attr.aria-required]="!allowblank"
            [attr.aria-invalid]="!isValid "
            (keyup.home)="onKeyUpHome($event)"
            (keyup.end)="onKeyUpEnd($event)"



             class="input-control"
             [ngClass]="model.touched ? allowblank ? '' : (isValid && model.touched) ? 'input-control-success' : 'input-control-error' :''"
             [(ngModel)]="value"
             (blur)="onBlurEvent()" 
             (focus)="onFocusEvent($event)" 
             (input)="onNumberInputEvent($event)" 
             (change)="onChangeEvent($event)"
             [name]="name" 
             [pattern]="regEx"
             [attr.placeholder]="placeholder" 
             [attr.max]="maxvalue" 
             [attr.min]="minvalue" 
             [attr.disabled]="disabled ? true: null"
             [required]="!allowblank" />


      <ng-container *ngIf="iconfeedback">
          <span class="input-control-feedback">
              <span *ngIf="!isValid && model.touched"><em class="fa fa-times"></em></span>
              <span *ngIf="isValid && model.touched"><em class="fa fa-check"></em></span>
          </span>
      </ng-container>

      <input-help *ngIf="showToolTip && enablepopover"

      id="numberDes"
      role="tooltip"

      [error-msg]="errormsg" 
      [max-error-msg]="maxerrormsg"
      [min-error-msg]="minerrormsg"
      [min-value]="minvalue"
      [max-value]="maxvalue"
      [is-number]="true"
      >
      </input-help>
  
      <span class="inputfieldbar"></span>
    </div>
  `,
                providers: [{
                        provide: NG_VALUE_ACCESSOR, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => AmexioNumberInputComponent)), multi: true,
                    }, {
                        provide: NG_VALIDATORS, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => AmexioNumberInputComponent)), multi: true,
                    }],
            },] },
];
/** @nocollapse */
AmexioNumberInputComponent.ctorParameters = () => [];
AmexioNumberInputComponent.propDecorators = {
    fieldlabel: [{ type: Input, args: ['field-label',] }],
    allowblank: [{ type: Input, args: ['allow-blank',] }],
    minerrormsg: [{ type: Input, args: ['min-error-msg',] }],
    maxerrormsg: [{ type: Input, args: ['max-error-msg',] }],
    errormsg: [{ type: Input, args: ['error-msg',] }],
    placeholder: [{ type: Input, args: ['place-holder',] }],
    disabled: [{ type: Input }],
    onBlur: [{ type: Output }],
    input: [{ type: Output }],
    focus: [{ type: Output }],
    change: [{ type: Output }],
    iconfeedback: [{ type: Input, args: ['icon-feedback',] }],
    fontstyle: [{ type: Input, args: ['font-style',] }],
    fontfamily: [{ type: Input, args: ['font-family',] }],
    fontsize: [{ type: Input, args: ['font-size',] }],
    haslabel: [{ type: Input, args: ['has-label',] }],
    name: [{ type: Input, args: ['name',] }],
    pattern: [{ type: Input, args: ['pattern',] }],
    enablepopover: [{ type: Input, args: ['enable-popover',] }],
    model: [{ type: ViewChild, args: [NgModel,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by  Pratik on 27/11/17.
*/
class AmexioRadioGroupComponent extends ValueAccessorBaseComponent {
    // The internal dataviews model
    // private innerValue: any = '';
    /**
     * @param {?} amxHttp
     * @param {?} cd
     */
    constructor(amxHttp, cd) {
        super();
        this.amxHttp = amxHttp;
        this.cd = cd;
        /*
           Properties
           name : default-value
           datatype : string
           version : 4.0 onwards
           default :
           description : Default Value to be checked
           */
        this.defaultSelectedValue = '';
        /*
           Properties
           name : data
           datatype : any
           version : 4.0 onwards
           default :
           description : 	Local data for radio group.
           */
        this.data = [];
        /*
           Events
           name : onSelection
           datatype : any
           version : 4.0 onwards
           default :
           description : Fires selection event
           */
        this.onSelection = new EventEmitter();
        this.onSelect = new EventEmitter();
        // Placeholders for the callbacks which are later provided
        // by the Control Value Accessor
        // private onTouchedCallback: () => void = noop;
        // private onChangeCallback: (_: any) => void = noop;
        this.isComponentValid = new EventEmitter();
        this.tabFocus = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.name = this.generateName(this.name, this.fieldlabel, 'radiogroup');
        this.componentId = this.createCompId('radiogroup', this.name);
        if (this.defaultSelectedValue) {
            this.value = this.defaultSelectedValue;
        }
        this.isValid = this.allowblank;
        this.isComponentValid.emit(this.allowblank);
        if (this.httpmethod && this.httpurl) {
            this.amxHttp.fetchData(this.httpurl, this.httpmethod).subscribe((/**
             * @param {?} response
             * @return {?}
             */
            (response) => {
                this.data = this.getResponseData(response);
            }));
        }
        else if (this.data != null) {
            this.data = this.getResponseData(this.data);
        }
    }
    /**
     * @param {?} viewData
     * @return {?}
     */
    checkDefaultValidation(viewData) {
        viewData.forEach((/**
         * @param {?} opt
         * @return {?}
         */
        (opt) => {
            opt['tabindex'] = '-1';
            opt['radioId'] = 'radio' + '_' + opt[this.valuefield] + '_' + this.getRandomString();
            if (opt[this.valuefield] === this.innerValue || (opt.hasOwnProperty('selected') && opt.selected)) {
                this.isValid = true;
                opt['selected'] = true;
                opt['tabindex'] = '0';
                this.isComponentValid.emit(true);
                return;
            }
            else {
                opt['selected'] = false;
                /** @type {?} */
                const tempArray = [];
                viewData.forEach((/**
                 * @param {?} option
                 * @return {?}
                 */
                (option) => {
                    if (option.selected === false) {
                        tempArray.push('0');
                        if (tempArray.length === viewData.length) {
                            viewData[0].tabindex = '0';
                        }
                    }
                }));
            }
        }));
    }
    /**
     * @param {?} viewData
     * @return {?}
     */
    checkSelectedFlag(viewData) {
        viewData.forEach((/**
         * @param {?} opt
         * @return {?}
         */
        (opt) => {
            if (this.innerValue === '' && (opt.hasOwnProperty('selected') && opt.selected)) {
                this.value = opt[this.valuefield];
                opt.tabindex = '0';
                return;
            }
        }));
    }
    /**
     * @param {?} httpResponse
     * @return {?}
     */
    getResponseData(httpResponse) {
        /** @type {?} */
        let responsedata = httpResponse;
        if (this.datareader != null) {
            /** @type {?} */
            const dr = this.datareader.split('.');
            if (dr != null) {
                for (const ir of dr) {
                    responsedata = responsedata[ir];
                }
            }
        }
        else {
            responsedata = httpResponse;
        }
        this.checkSelectedFlag(responsedata);
        if (!this.allowblank) {
            this.checkDefaultValidation(responsedata);
        }
        return responsedata;
    }
    // From ControlValueAccessor interface
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (value !== this.innerValue) {
            this.innerValue = value;
            this.checkDefaultValidation(this.data);
        }
    }
    // From ControlValueAccessor interface
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChangeCallback = fn;
    }
    // From ControlValueAccessor interface
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouchedCallback = fn;
    }
    // get accessor
    /**
     * @return {?}
     */
    get value() {
        return this.innerValue;
    }
    // set accessor including call the onchange callback
    /**
     * @param {?} v
     * @return {?}
     */
    set value(v) {
        if (v !== this.innerValue) {
            this.innerValue = v;
            this.onChangeCallback(v);
        }
    }
    /**
     * @return {?}
     */
    onBlur() {
        this.tabFocus = false;
        this.onTouchedCallback();
    }
    /**
     * @return {?}
     */
    onFocus() {
        this.tabFocus = true;
    }
    /**
     * @param {?} row
     * @param {?} event
     * @return {?}
     */
    onClick(row, event) {
        event.preventDefault();
        for (const r of this.data) {
            if (r.selected) {
                r.selected = false;
            }
        }
        for (const r of this.data) {
            if (r === row) {
                r.selected = true;
                this.isValid = true;
                this.value = row[this.valuefield];
                this.listCopy = Object.assign({}, row);
                delete this.listCopy.tabindex;
                delete this.listCopy.radioId;
                this.onSelection.emit(this.listCopy);
                delete row.tabindex;
                this.isComponentValid.emit(true);
                /** @type {?} */
                const obj = {};
                obj['row'] = row;
                obj['event'] = event;
                this.onSelect.emit(obj);
            }
            else {
                r.selected = false;
            }
        }
    }
    // THIS MEHTOD CHECK INPUT IS VALID OR NOT
    /**
     * @return {?}
     */
    checkValidity() {
        return this.isValid;
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return ((!this.allowblank && this.value) || this.allowblank) ? null : {
            jsonParseError: {
                valid: true,
            },
        };
    }
}
AmexioRadioGroupComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-radio-group',
                template: `
    <div role="radiogroup" [attr.name]="name"  attr.aria-labelledby="{{componentId}}" [attr.aria-disabled]="disabled"
      [attr.aria-required]="!allowblank" class="inputgroup from-group">
      <div *ngIf="fieldlabel">
        <legend style="margin-bottom: .6rem; margin-top: 5px;" id="{{componentId}}">{{fieldlabel}}</legend>
      </div>

      <ng-container *ngIf="horizontal">
        <ng-container *ngFor="let rData of data let index=index">
          <label for="{{name+rData[displayfield]+index}}" 
          [attr.aria-checked]="value" 
          [attr.aria-disabled]="rData.disabled"
     
            class="input-box-container" style="padding-bottom:0px !important; margin: 5px !important" (click)="onClick(rData, $event)"
            [ngClass]="{'disable-component' : rData.disabled || disabled}">
            {{rData[displayfield]}}

            <input [attr.tabindex]="disabled ? -1 : 1"
            style="top:0; left:0" id="{{name+rData[displayfield]+index}}"
             type="radio" 

              [required]="!allowblank"
               [attr.name]="name" 
               [value]="rData?.selected ? rData[valuefield] : rData[valuefield] "
              [attr.disabled]="rData?.disabled ? true: null" 
              [(ngModel)]="value"
              (focus)="onFocus()"
              (blur)="onBlur()"
              [checked]="(value === rData[valuefield] || rData.selected)">

            <span class="input-box-radiobox-label" [ngClass]="{'focusOnCheckbox':tabFocus}" ></span>
          </label>
        </ng-container>
      </ng-container>

      <ng-container *ngIf="!horizontal">
        <ng-container *ngFor="let rData of data let index=index">
          <div>
            <label for="{{name+rData[displayfield]+index}}" [attr.aria-checked]="value" [attr.aria-disabled]="rData.disabled"
              class="input-box-container" style="padding-bottom:0px !important; margin: 5px !important" (click)="onClick(rData, $event)"
              [ngClass]="{'disable-component' : rData.disabled || disabled}">{{rData[displayfield]}}
              <input style="top:0; left:0" id="{{name+rData[displayfield]+index}}" type="radio"
              [attr.tabindex]="disabled ? -1 : 1" [required]="!allowblank" [attr.name]="name" [value]="rData?.selected ? rData[valuefield] : rData[valuefield] "
              (focus)="onFocus()"
              (blur)="onBlur()"
              [attr.disabled]="rData?.disabled ? true: null" [(ngModel)]="value"
                [checked]="(value === rData[valuefield] || rData.selected)">
              <span class="input-box-radiobox-label" [ngClass]="{'focusOnCheckbox':tabFocus}"></span>
            </label>
          </div>
        </ng-container>
      </ng-container>
    </div>
  `,
                providers: [{
                        provide: NG_VALUE_ACCESSOR, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => AmexioRadioGroupComponent)), multi: true,
                    }, {
                        provide: NG_VALIDATORS, useExisting: AmexioRadioGroupComponent, multi: true,
                    }],
            },] },
];
/** @nocollapse */
AmexioRadioGroupComponent.ctorParameters = () => [
    { type: CommonDataService },
    { type: ChangeDetectorRef }
];
AmexioRadioGroupComponent.propDecorators = {
    allowblank: [{ type: Input, args: ['allow-blank',] }],
    name: [{ type: Input }],
    fieldlabel: [{ type: Input, args: ['field-label',] }],
    datareader: [{ type: Input, args: ['data-reader',] }],
    httpmethod: [{ type: Input, args: ['http-method',] }],
    httpurl: [{ type: Input, args: ['http-url',] }],
    displayfield: [{ type: Input, args: ['display-field',] }],
    valuefield: [{ type: Input, args: ['value-field',] }],
    defaultSelectedValue: [{ type: Input, args: ['default-value',] }],
    horizontal: [{ type: Input }],
    data: [{ type: Input }],
    disabled: [{ type: Input }],
    onSelection: [{ type: Output }],
    onSelect: [{ type: Output }],
    isComponentValid: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AmexioRatingComponent extends AmexioFormValidator {
    constructor() {
        super(...arguments);
        /*
          Properties
          name : icon-class
          datatype : string
          version : 4.0 onwards
          default : star-icon
          description : Sets if custom icon class is required
          */
        this.iconclass = 'star-icon';
        /*
          Properties
          name : full-icon
          datatype : string
          version : 4.0 onwards
          default :
          description : 	Icon for selected rating .This attribute is useful only
          when user have custom rating icons.example
          */
        this.fullicon = '★';
        /*
          Properties
          name : empty-icon
          datatype : string
          version : 4.0 onwards
          default :
          description : Icon for non-selected rating .This attribute is useful only
          when user have custom rating icons.example
          */
        this.emptyicon = '☆';
        /*
          Properties
          name : titles
          datatype : string array
          version : 4.0 onwards
          default : 1,2,3..
          description : Array of titles
          */
        this.titles = [];
        this.ratingRangeData = [];
        // -------------------------------------------------------------------------
        // Outputs
        // -------------------------------------------------------------------------
        /*
          Events
          name : onHover
          datatype : any
          version : 4.0 onwards
          default :
          description : Fires on hovering component
          */
        this.onHover = new EventEmitter();
        /*
          Events
          name : onLeave
          datatype : any
          version : 4.0 onwards
          default :
          description : fires on leaving component and returns its value
          */
        this.onLeave = new EventEmitter();
        this.hovered = 0;
        this.hoveredPercent = undefined;
        // -------------------------------------------------------------------------
        // Private
        // -------------------------------------------------------------------------
        this._max = 5;
    }
    /*
      Properties
      name : max
      datatype : number
      version : 4.0 onwards
      default :
      description : Number of stars for rating component.
      */
    /**
     * @param {?} max
     * @return {?}
     */
    set max(max) {
        this._max = max;
        this.buildRanges();
    }
    /**
     * @return {?}
     */
    get max() {
        return this._max;
    }
    // -------------------------------------------------------------------------
    // Implemented from ControlValueAccessor
    // -------------------------------------------------------------------------
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this.model = value;
        this.setAttribute(value);
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    // -------------------------------------------------------------------------
    // Implemented from Va..
    // -------------------------------------------------------------------------
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        if (this.required && !c.value) {
            return {
                required: true,
            };
        }
        return null;
    }
    // -------------------------------------------------------------------------
    // Lifecycle callbacks
    // -------------------------------------------------------------------------
    /**
     * @return {?}
     */
    ngOnInit() {
        this.componentId = this.createCompId('rating', this.fieldlabel);
        this.starId = 'star' + Math.floor(window.crypto.getRandomValues(new Uint32Array(1))[0]);
        for (let i = 0; i < this.ratingRange.length; i++) {
            /** @type {?} */
            const obj = {};
            obj['number'] = i + 1;
            obj['selected'] = false;
            obj['tabindex'] = '-1';
            this.ratingRangeData.push(obj);
        }
        this.buildRanges();
    }
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * @param {?} item
     * @return {?}
     */
    calculateWidth(item) {
        if (this.hovered > 0) {
            if (this.hoveredPercent !== undefined && this.hovered === item) {
                return this.hoveredPercent;
            }
            else {
                return this.hovered >= item ? 100 : 0;
            }
        }
        else {
            return this.model >= item ? 100 : 100 - Math.round((item - this.model) * 10) * 10;
        }
    }
    /**
     * @param {?} hovered
     * @return {?}
     */
    setHovered(hovered) {
        if (!this.readonly && !this.disabled) {
            this.hovered = hovered;
            this.onHover.emit(hovered);
            this.ratingMethod(hovered);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    changeHovered(event) {
        if (!this.float) {
            return;
        }
        /** @type {?} */
        const target = (/** @type {?} */ (event.target));
        /** @type {?} */
        const relativeX = event.pageX - target.offsetLeft;
        /** @type {?} */
        const percent = Math.round((relativeX * 100 / target.offsetWidth) / 10) * 10;
        this.hoveredPercent = percent > 50 ? 100 : 50;
    }
    /**
     * @return {?}
     */
    resetHovered() {
        this.hovered = 0;
        this.hoveredPercent = undefined;
        this.onLeave.emit(this.hovered);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    rate(value) {
        if (!this.readonly && !this.disabled && value >= 0 && value <= this.ratingRange.length) {
            this.setAttribute(value);
            /** @type {?} */
            const newValue = this.hoveredPercent ? (value - 1) + this.hoveredPercent / 100 : value;
            this.onChange(newValue);
            this.model = newValue;
        }
    }
    /**
     * @param {?} item
     * @return {?}
     */
    rate1(item) {
        this.ratingMethod(item);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    setAttribute(value) {
        this.ratingRangeData.forEach((/**
         * @param {?} element
         * @return {?}
         */
        (element) => {
            element.selected = false;
            element.tabindex = '-1';
            if (value >= element.number) {
                element.selected = true;
            }
            if (value === element.number) {
                element.tabindex = 0;
            }
        }));
    }
    /**
     * @param {?} item
     * @return {?}
     */
    ratingMethod(item) {
        this.ratingRangeData.forEach((/**
         * @param {?} element
         * @return {?}
         */
        (element) => {
            element.selected = false;
            if (item + 1 >= element.number) {
                element.selected = true;
            }
        }));
    }
    // -------------------------------------------------------------------------
    // Private Methods
    // -------------------------------------------------------------------------
    /**
     * @private
     * @return {?}
     */
    buildRanges() {
        this.ratingRange = this.range(1, this.max);
    }
    /**
     * @private
     * @param {?} start
     * @param {?} end
     * @return {?}
     */
    range(start, end) {
        /** @type {?} */
        const foo = [];
        for (let i = start; i <= end; i++) {
            foo.push(i);
        }
        return foo;
    }
}
AmexioRatingComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-rating-input',
                template: `
    <div tabindex="1" role="radiogroup" attr.aria-labelledby="{{componentId}}" class="inputgroup">
      <ng-container *ngIf="fieldlabel">
        <legend id="{{componentId}}">
          {{fieldlabel}}
        </legend>
      </ng-container>

      <div (mouseleave)="resetHovered()" class="rating" [class.disabled]="disabled" [class.readonly]="readonly">
        <span *ngFor="let item of ratingRangeData; let index = index">
          <input (keyup.space)="rate1(index)" style="top:0; left:0; position: absolute;
            opacity: 0;
            cursor: pointer;"
            value="{{model}}" id="{{starId}}{{index}}" [attr.aria-checked]="item.selected" type="radio" name="rating" role="radio">

          <label for="{{starId}}{{index}}" style="display: inline-flex;">
            <em [ngStyle]="{'cursor': readonly ? 'not-allowed' : 'pointer'}" role="tooltip" [attr.tabindex]="item.tabindex"
              (mouseenter)="setHovered(item.number)" attr.aria-label="Star {{index+1}}" (click)="rate(item.number)"
              [attr.data-icon]="fullicon" class="{{ iconclass }} half{{(item.selected? 100 : 0) }}" [title]="titles[index] || item.number">{{
              emptyicon }}</em>
          </label>

        </span>
      </div>
    </div>
  `,
                providers: [{
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => AmexioRatingComponent)),
                        multi: true,
                    },
                    {
                        provide: NG_VALIDATORS,
                        useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => AmexioRatingComponent)),
                        multi: true,
                    },
                ],
            },] },
];
AmexioRatingComponent.propDecorators = {
    iconclass: [{ type: Input, args: ['icon-class',] }],
    fullicon: [{ type: Input, args: ['full-icon',] }],
    emptyicon: [{ type: Input, args: ['empty-icon',] }],
    readonly: [{ type: Input, args: ['read-only',] }],
    disabled: [{ type: Input }],
    required: [{ type: Input }],
    float: [{ type: Input }],
    fieldlabel: [{ type: Input, args: ['field-label',] }],
    titles: [{ type: Input }],
    max: [{ type: Input }],
    onHover: [{ type: Output }],
    onLeave: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/
class AmexioTextInputComponent extends BaseInputEventComponent {
    constructor() {
        super();
        /*
        Properties
        name : icon-feedback
        datatype : boolean
        version : 4.0 onwards
        default :false
        description :
        */
        this.iconfeedback = false;
        /*
        Properties
        name : has-label
        datatype : boolean
        version : 4.0 onwards
        default : false
        description : Flag to set label
        */
        this.haslabel = true;
        this.isValid = false;
        /*
         Events
         name : onBlur
         datatype : any
         version : 4.0 onwards
         default :
         description : On blur event
         */
        this.onBlur = new EventEmitter();
        /*
        Events
        name : input
        datatype : any
        version : none
        default :
        description :   On input event field.
        */
        this.input = new EventEmitter();
        /*
        Events
        name : focus
        datatype : any
        version : none
        default :
        description : On focus event field.
        */
        this.focus = new EventEmitter();
        /*
        Events
        name : change
        datatype : any
        version : none
        default :
        description : On field value change event
        */
        this.change = new EventEmitter();
    }
    /**
     * @return {?}
     */
    get pattern() {
        return this._pattern;
    }
    /*
    Properties
    name : pattern
    datatype : string
    version : 4.0 onwards
    default :
    description : Apply Reg-ex to the field
    */
    /**
     * @param {?} value
     * @return {?}
     */
    set pattern(value) {
        if (value != null) {
            this._pattern = value;
            this.regEx = new RegExp(this._pattern);
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.name = this.generateName(this.name, this.fieldlabel, 'textinput');
        this.componentId = this.createCompId('textinput', this.name);
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return this.isFieldValid() ? null : {
            jsonParseError: {
                valid: true,
            },
        };
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onInputTextEvent(event) {
        super.onInputEvent(event);
    }
}
AmexioTextInputComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-text-input',
                template: `
    <div class="inputgroup">

        <label *ngIf="haslabel" role="input" id="{{componentId}}"  for="{{componentId}}" [style.font-style]="fontstyle" [style.font-family]="fontfamily" [style.font-size]="fontsize">
          {{fieldlabel}}
      </label>
        <input type="text" 

            role="text" 
            tabindex="1"
            id="{{componentId}}" 
            name="textID"
            attr.aria-labelledby="{{componentId}}"
            aria-describedby="textDec"
            [attr.aria-required]="!allowblank"
            [attr.aria-invalid]="!isValid "



            class="input-control" 
            [ngClass]="model.touched ? allowblank ? '' : (isValid && model.touched) ? 'input-control-success' : 'input-control-error' :''" 
            [(ngModel)]="value"
            (blur)="onBlurEvent()" 
            (focus)="onFocusEvent($event)" 
            (input)="onInputTextEvent($event)"
            (change)="onChangeEvent($event)"
            [name]="name" 
            [pattern]="regEx" 
            [attr.placeholder]="placeholder" 
            [maxlength]="maxlength" 
            [minlength]="minlength" 
            [attr.disabled]="disabled ? true: null"
            [required]="!allowblank" />

        <ng-container *ngIf="iconfeedback">
            <span class="input-control-feedback">
              <span *ngIf="!isValid && model.touched"><em class="fa fa-times"></em></span>
            <span *ngIf="isValid && model.touched"><em class="fa fa-check"></em></span>
            </span>
        </ng-container>

          <input-help *ngIf="showToolTip && enablepopover" 

          id="textDec"
          role="tooltip"

          [error-msg]="errormsg" 
          [max-error-msg]="maxerrormsg"
          [min-error-msg]="minerrormsg"
          [min-length]="minlength"
          [max-length]="maxlength">
          </input-help>
   
        <span class="inputfieldbar"></span>
    </div>
  `,
                providers: [{
                        provide: NG_VALUE_ACCESSOR, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => AmexioTextInputComponent)), multi: true,
                    }, {
                        provide: NG_VALIDATORS, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => AmexioTextInputComponent)), multi: true,
                    }],
                encapsulation: ViewEncapsulation.None,
            },] },
];
/** @nocollapse */
AmexioTextInputComponent.ctorParameters = () => [];
AmexioTextInputComponent.propDecorators = {
    fieldlabel: [{ type: Input, args: ['field-label',] }],
    minlength: [{ type: Input, args: ['min-length',] }],
    maxlength: [{ type: Input, args: ['max-length',] }],
    allowblank: [{ type: Input, args: ['allow-blank',] }],
    minerrormsg: [{ type: Input, args: ['min-error-msg',] }],
    maxerrormsg: [{ type: Input, args: ['max-error-msg',] }],
    errormsg: [{ type: Input, args: ['error-msg',] }],
    placeholder: [{ type: Input, args: ['place-holder',] }],
    disabled: [{ type: Input }],
    iconfeedback: [{ type: Input, args: ['icon-feedback',] }],
    fontstyle: [{ type: Input, args: ['font-style',] }],
    fontfamily: [{ type: Input, args: ['font-family',] }],
    fontsize: [{ type: Input, args: ['font-size',] }],
    haslabel: [{ type: Input, args: ['has-label',] }],
    pattern: [{ type: Input, args: ['pattern',] }],
    enablepopover: [{ type: Input, args: ['enable-popover',] }],
    model: [{ type: ViewChild, args: [NgModel,] }],
    name: [{ type: Input, args: ['name',] }],
    onBlur: [{ type: Output }],
    input: [{ type: Output }],
    focus: [{ type: Output }],
    change: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 * Copyright 2016-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Author - Pratik Kelwalkar
 *
 */
/*
 Component Name : Amexio Toggle
 Component Selector :  <amexio-toggle>
 Component Description : Toggle Button
*/
/** @type {?} */
const noop$6 = (/**
 * @return {?}
 */
() => {
});
class AmexioToggleComponent extends AmexioFormValidator {
    constructor() {
        super();
        this.onChange = new EventEmitter();
        this.isComponentValid = new EventEmitter();
        // The internal dataviews model
        this.innerValue = '';
        // Placeholders for the callbacks which are later provided
        // by the Control Value Accessor
        this.onTouchedCallback = noop$6;
        this.onChangeCallback = noop$6;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.componentId = this.createCompId('togglebtn', this.fieldlabel);
        this.toggleId = this.createCompId('toggleId', this.fieldlabel);
        if (this.shape === '' || this.shape == null) {
            this.shape = 'round';
        }
        this.isValid = !this.required;
        this.isComponentValid.emit(false);
    }
    /**
     * @return {?}
     */
    onToggle() {
        this.checked = !this.checked;
        this.value = this.checked;
        this.isValid = this.value;
        this.isComponentValid.emit(this.value);
        this.onChange.emit(this.value);
    }
    // get accessor
    /**
     * @return {?}
     */
    get value() {
        return this.innerValue;
    }
    // set accessor including call the onchange callback
    /**
     * @param {?} v
     * @return {?}
     */
    set value(v) {
        if (v !== this.innerValue) {
            this.innerValue = v;
            this.onChangeCallback(v);
        }
    }
    // Set touched on blur
    /**
     * @return {?}
     */
    onBlur() {
        this.onTouchedCallback();
    }
    // From ControlValueAccessor interface
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (value && value !== this.innerValue) {
            this.isValid = value;
        }
        if (!value && value !== this.innerValue) {
            this.isValid = value;
        }
        this.innerValue = value;
    }
    // From ControlValueAccessor interface
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChangeCallback = fn;
    }
    // From ControlValueAccessor interface
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouchedCallback = fn;
    }
    // THIS MEHTOD CHECK INPUT IS VALID OR NOT
    /**
     * @return {?}
     */
    checkValidity() {
        return this.isValid;
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return ((this.required && this.value) || !this.required) ? null : {
            jsonParseError: {
                valid: true,
            },
        };
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onEventFilter(event) {
        this.onToggle();
    }
}
AmexioToggleComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-toggle',
                template: `
    <div id="{{componentId}}" class="inputgroup">
      {{fieldlabel}}


      <label role="switch" attr.aria-labelledby="{{componentId}}" [attr.aria-checked]="checked" tabindex="1" for="{{toggleId}}"
        [ngClass]="{smallToggle:(size == 'small' && type != 2),
        smallType2Toggle:(size == 'small' && type == 2),

        mediumToggle:(size == 'medium' && type != 2),
        mediumType2Toggle:(size == 'medium' && type == 2),

        largeToggle:(size == 'large' && type != 2),
        largeType2Toggle:(size == 'large' && type == 2)

    }"
        (keyup.space)="onEventFilter($event)">

        <input id="{{toggleId}}" type="checkbox" style="top:0; left:0;display: none;" [attr.checked]="checked" data-check-switch=""
          [attr.aria-required]="required" #rangeHndl [(ngModel)]="value" (blur)="onBlur()" [attr.aria-checked]="checked"
          (change)="onToggle()">
        <span class="toggle-slider {{shape}}" [ngClass]="
        {
          smallToggleSlider :(size == 'small' && type != 2),
          smallType2ToggleSlider :(size == 'small' && type == 2),

         mediumToggleSlider : (size == 'medium' && type !=2),
         mediumType2ToggleSlider : (size == 'medium' && type ==2),

         largeToggleSlider : (size == 'large' && type !=2),
         largeType2ToggleSlider : (size == 'large' && type ==2)
      }">

        </span>
      </label>
    </div>
  `,
                providers: [{
                        provide: NG_VALUE_ACCESSOR, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => AmexioToggleComponent)), multi: true,
                    }, {
                        provide: NG_VALIDATORS, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => AmexioToggleComponent)), multi: true,
                    }],
                encapsulation: ViewEncapsulation.None,
            },] },
];
/** @nocollapse */
AmexioToggleComponent.ctorParameters = () => [];
AmexioToggleComponent.propDecorators = {
    shape: [{ type: Input }],
    fieldlabel: [{ type: Input, args: ['field-label',] }],
    required: [{ type: Input }],
    size: [{ type: Input, args: ['size',] }],
    type: [{ type: Input, args: ['type',] }],
    onChange: [{ type: Output }],
    isComponentValid: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by pratik on 18/12/17.
*/
class AmexioImageComponent {
    constructor() {
        /*
        Properties
        name : c-class
        datatype :  string
        version : 4.0 onwards
        default :
        description : Used for custom style classes
        */
        this.cclass = '';
        /*
        Events
        name : onClick
        datatype :  none
        version : none
        default : none
        description : Get image / icon click event.
        */
        this.onClick = new EventEmitter();
        /*
        Properties
        name :absolute
        datatype :  string
        version : 4.1.9 onwards
        default :
        description :sets absolute attribute  to image
        */
        this.absolute = false;
        /*
        Properties
        name :relative
        datatype :  string
        version : 4.1.9 onwards
        default :
        description :sets relative attribute  to image
        */
        this.relative = false;
        this.overlay = false;
        this.absoluteposition = false;
        this.imageCss = ' image-';
        this.overlayTextCss = 'overlay-text overlay-';
        this.textCss = '-text';
        this.imgFluidCss = ' img-fluid';
        this.overlayOverlayCss = 'overlay overlay-';
        this.imageTitleCss = 'image-title image-';
        this.imageTitleBottomCss = 'image-title image-bottom-right';
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onImageClick(event) {
        this.onClick.emit(event);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (!(this.width || this.height)) {
            this.cclass = this.cclass + this.imgFluidCss;
        }
        if (this.filter) {
            this.cclass = this.cclass + this.imageCss + this.filter;
        }
        if (this.overlayEffect) {
            this.overlay = true;
            if (!this.overlayText) {
                this.overlayText = '';
            }
            if (this.overlayText) {
                this.overlayTextClass = this.overlayTextCss + this.overlayEffect + this.textCss;
            }
            this.overlayEffect = this.overlayOverlayCss + this.overlayEffect;
        }
        if (this.position && !this.imgTitle) {
            this.imgTitle = '';
        }
        if (this.imgTitle) {
            if (this.position) {
                this.position = this.imageTitleCss + this.position;
            }
            else {
                this.position = this.imageTitleBottomCss;
            }
        }
    }
    /**
     * @return {?}
     */
    addimageCSSClass() {
        if (this.top || this.bottom || this.right || this.left) {
            this.absoluteposition = true;
        }
        this.imagepositionclass = '';
        if (this.relative && !this.absolute) {
            this.imagepositionclass = ' img-relative ';
            this.top = '';
            this.left = '';
            this.right = '';
            this.bottom = '';
        }
        else if (this.absolute) {
            this.imagepositionclass = 'img-absolute ';
        }
        return this.imagepositionclass;
    }
}
AmexioImageComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-image', template: `
    <!--Normal image-->
    <ng-container *ngIf="iconclass && (!path && !mda) && overlay || overlayText || titlePara || imgTitle ">
    <div class="img-container" [ngClass]="addimageCSSClass()"  [ngStyle]="{'top':top,'bottom':bottom,'left':left,'right':right} ">
      <ng-container *ngIf="path || (path && iconclass)">
        <ng-container *ngIf="!(width || height)">
          <img alt="title" [src]="path" [attr.class]="cclass" (click)="onImageClick($event)" [attr.title]="tooltip">
          <div *ngIf="overlay" [ngClass]="overlayEffect">
            <div *ngIf="overlayText" [ngClass]="overlayTextClass">{{overlayText}}
              <p *ngIf="titlePara">{{titlePara}}</p>
            </div>
          </div>
          <div *ngIf="imgTitle" [ngClass]="position">{{imgTitle}}</div>
        </ng-container>
        <ng-container *ngIf="width || height">
          <img alt="title" [ngStyle]="{'width':width,'height':height}" [attr.class]="cclass" [src]="path" (click)="onImageClick($event)" [attr.title]="tooltip">
           <div *ngIf="overlay" [ngClass]="overlayEffect">
            <div *ngIf="overlayText" [ngClass]="overlayTextClass">{{overlayText}}
              <p *ngIf="titlePara">{{titlePara}}</p>
            </div>
          </div>
          <div *ngIf="imgTitle" [ngClass]="position">{{imgTitle}}</div>
        </ng-container>
      </ng-container>
      </div>
    </ng-container>



    <ng-container *ngIf="!(iconclass && (!path && !mda) && overlay || overlayText || titlePara || imgTitle )">
        <ng-container *ngIf="path || (path && iconclass)">
        <ng-container *ngIf="!(width || height)">
        <img alt="title" [src]="path" [attr.class]="cclass" (click)="onImageClick($event)" [attr.title]="tooltip">
        </ng-container>
        <ng-container *ngIf="width || height">
        <img alt="title" [ngStyle]="{'width':width,'height':height}" [attr.class]="cclass" [src]="path" (click)="onImageClick($event)" [attr.title]="tooltip">
        </ng-container>
        </ng-container>
        </ng-container>
    
    <!--this is for fontawesome-->
    <ng-container *ngIf="iconclass && (!path && !mda)">
      <em [attr.class]="iconclass" [attr.title]="tooltip" (click)="onImageClick($event)"></em>
      <label class="image-title" *ngIf="title" (click)="onImageClick($event)" style="cursor: pointer">{{title}}</label>
    </ng-container>

    <!--Material icon-->
    <ng-container *ngIf="(iconclass && mda) && !path">
      <em [attr.class]="iconclass" [attr.title]="tooltip" (click)="onImageClick($event)">{{mda}}</em>
    </ng-container>

    <ng-container *ngIf=" title && !iconclass">
      <span style="font-size: medium">{{title}}</span>
    </ng-container>
  `,
            },] },
];
/** @nocollapse */
AmexioImageComponent.ctorParameters = () => [];
AmexioImageComponent.propDecorators = {
    tooltip: [{ type: Input }],
    title: [{ type: Input }],
    path: [{ type: Input }],
    iconclass: [{ type: Input, args: ['icon-class',] }],
    cclass: [{ type: Input, args: ['c-class',] }],
    mda: [{ type: Input }],
    width: [{ type: Input }],
    height: [{ type: Input }],
    onClick: [{ type: Output }],
    filter: [{ type: Input, args: ['filter',] }],
    overlayEffect: [{ type: Input, args: ['overlay-effect',] }],
    overlayText: [{ type: Input, args: ['overlay-text',] }],
    imgTitle: [{ type: Input, args: ['image-title',] }],
    position: [{ type: Input, args: ['title-position',] }],
    titlePara: [{ type: Input, args: ['para',] }],
    top: [{ type: Input, args: ['position-top',] }],
    bottom: [{ type: Input, args: ['position-bottom',] }],
    left: [{ type: Input, args: ['position-left',] }],
    right: [{ type: Input, args: ['position-right',] }],
    absolute: [{ type: Input, args: ['absolute',] }],
    relative: [{ type: Input, args: ['relative',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AmexioTabActionComponent {
    constructor() {
        this.showContent = false;
        this.actionComponent = '';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @return {?}
     */
    checkActionComponent() {
        this.textinput = this.queryTextinput.toArray();
        if (this.textinput.length > 0) {
            this.actionComponent = 'text';
            this.textinput[0].haslabel = false;
            this.textinput[0].iconfeedback = false;
        }
        this.checkbox = this.queryCheckbox.toArray();
        if (this.checkbox.length > 0) {
            this.actionComponent = 'checkbox';
            this.checkbox[0].fieldlabel = '';
        }
        this.radioGroup = this.queryRadioGroup.toArray();
        if (this.radioGroup.length > 0) {
            this.actionComponent = 'radiogroup';
            this.radioGroup[0].fieldlabel = '';
            this.radioGroup[0].horizontal = true;
        }
        this.label = this.queryLabel.toArray();
        if (this.label.length > 0) {
            this.actionComponent = 'label';
        }
        this.number = this.queryNumber.toArray();
        if (this.number.length > 0) {
            this.actionComponent = 'number';
            this.number[0].fieldlabel = '';
        }
        this.rating = this.queryRating.toArray();
        if (this.rating.length > 0) {
            this.actionComponent = 'rating';
            this.rating[0].fieldlabel = '';
        }
        this.toggle = this.queryToggle.toArray();
        if (this.toggle.length > 0) {
            this.actionComponent = 'toggle';
            this.toggle[0].fieldlabel = '';
        }
        this.button = this.queryButton.toArray();
        if (this.button.length > 0) {
            this.actionComponent = 'button';
        }
        this.image = this.queryImage.toArray();
        if (this.image.length > 0) {
            this.actionComponent = 'image';
        }
        this.dropdown = this.queryDropDown.toArray();
        if (this.dropdown.length > 0) {
            this.actionComponent = 'dropdown';
            this.dropdown[0].fieldlabel = '';
        }
        this.checkboxgroup = this.queryCheckBoxGroup.toArray();
        if (this.checkboxgroup.length > 0) {
            this.actionComponent = 'checkboxgroup';
            this.checkboxgroup[0].fieldlabel = '';
            this.checkboxgroup[0].horizontal = true;
        }
    }
}
AmexioTabActionComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-tab-action',
                template: `
   <ng-content></ng-content>
   `,
            },] },
];
/** @nocollapse */
AmexioTabActionComponent.ctorParameters = () => [];
AmexioTabActionComponent.propDecorators = {
    queryTextinput: [{ type: ContentChildren, args: [AmexioTextInputComponent, { descendants: true },] }],
    queryCheckbox: [{ type: ContentChildren, args: [AmexioCheckBoxComponent, { descendants: true },] }],
    queryRadioGroup: [{ type: ContentChildren, args: [AmexioRadioGroupComponent, { descendants: true },] }],
    queryLabel: [{ type: ContentChildren, args: [AmexioLabelComponent, { descendants: true },] }],
    queryNumber: [{ type: ContentChildren, args: [AmexioNumberInputComponent, { descendants: true },] }],
    queryRating: [{ type: ContentChildren, args: [AmexioRatingComponent, { descendants: true },] }],
    queryToggle: [{ type: ContentChildren, args: [AmexioToggleComponent, { descendants: true },] }],
    queryButton: [{ type: ContentChildren, args: [AmexioButtonComponent, { descendants: true },] }],
    queryImage: [{ type: ContentChildren, args: [AmexioImageComponent, { descendants: true },] }],
    queryDropDown: [{ type: ContentChildren, args: [AmexioDropDownComponent, { descendants: true },] }],
    queryCheckBoxGroup: [{ type: ContentChildren, args: [AmexioCheckBoxGroupComponent, { descendants: true },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by ketangote on 12/1/17.
*/
/** @type {?} */
const TOP_COMPONENT_CLASS_MAP = {
    red: 'amexio-top-tab-red',
    green: 'amexio-top-tab-green',
    purple: 'amexio-top-tab-purple',
    blue: 'amexio-top-tab-blue',
    brown: 'amexio-top-tab-brown',
    yellow: 'amexio-top-tab-yellow',
    black: 'amexio-top-tab-black',
    pink: 'amexio-top-tab-pink',
    orange: 'amexio-top-tab-orange',
};
/** @type {?} */
const BOTTOM_COMPONENT_CLASS_MAP = {
    red: 'amexio-bottom-tab-red',
    green: 'amexio-bottom-tab-green',
    purple: 'amexio-bottom-tab-purple',
    blue: 'amexio-bottom-tab-blue',
    brown: 'amexio-bottom-tab-brown',
    yellow: 'amexio-bottom-tab-yellow',
    black: 'amexio-bottom-tab-black',
    pink: 'amexio-bottom-tab-pink',
    orange: 'amexio-bottom-tab-orange',
};
class AmexioTabComponent extends BaseTabComponent {
    /**
     * @param {?} componentFactoryResolver
     * @param {?} renderer
     */
    constructor(componentFactoryResolver, renderer) {
        super(componentFactoryResolver);
        this.componentFactoryResolver = componentFactoryResolver;
        this.renderer = renderer;
        // height: any;
        // minHeight: any;
        /*
           Properties
           name : body-height
           datatype :   any
           version : 4.2 onwards
           default :
           description : Provides form body height.
           */
        // @Input('body-height') bodyheight: any;
        /*
           Properties
           name :  context-menu
           datatype : string
           version : 5.0.1 onwards
           default :
           description : Context Menu provides the list of menus on right click.
           */
        this.contextmenu = [];
        /*
        Properties
        name : active-bg-color
        datatype : boolean
        version : 5.9.3 onwards
        default : false
        description : sets background color for active tab
        */
        // @Input('active-bg-color') activeBGColor: boolean;
        /*
           Events
           name : rightClick
           datatype : none
           version : 5.0.1
           default : none
           description : It will gives you row clicked data.
           */
        this.rightClick = new EventEmitter();
        this.messageTitle = 'confirm';
        this.message = 'Are You Sure?';
        this.onCloseClick = new EventEmitter();
        /*
           Events
           name : onClick
           datatype : none
           version : none
           default : none
           description : Callback to invoke on activated tab event.
           */
        this.onClick = new EventEmitter();
        this.showprev = false;
        this.mouseLocation = { left: 0, top: 0 };
        this.closeOthersConst = 'Close Others';
        this.dummyArray = [];
        this.tabPositionClass = '';
        this.componentId = '';
        this.map = new Map();
        this.prevtabindex = -1;
        this.currtabindex = -1;
        this.amexioComponentId = 'amexio-tab';
        this.headeralign = 'left';
        this.tabType = 'horizontal';
        this.typeActionAlign = 'left';
        this.fullPageTabs = false;
        this.action = false;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set tabLocalData(value) {
        this._tabLocalData = value;
        if (this.componentLoaded) {
            this.updateTabComponent();
        }
    }
    /**
     * @return {?}
     */
    get tabLocalData() {
        return this._tabLocalData;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.componentLoaded = true;
        this.componentId = Math.floor(window.crypto.getRandomValues(new Uint32Array(1))[0]) + '_tabc';
        super.ngOnInit();
    }
    /**
     * @return {?}
     */
    updateTabComponent() {
        if (this.tabs.nativeElement.scrollWidth > this.tabs.nativeElement.clientWidth) {
            this.headeralign = 'left';
        }
        this.adjustWidth();
        if (this.tabs && this.tabs.nativeElement
            && this.headerWidth && this.headerWidth.nativeElement
            && this.tabAction && this.tabAction.nativeElement
            && this.tabWidth1 !== this.tabs.nativeElement.offsetWidth) {
            this.headWidth = (this.tabAction.nativeElement.scrollWidth + this.headerWidth.nativeElement.scrollWidth);
            this.widthTabs = this.tabs.nativeElement.offsetWidth - this.headWidth;
        }
        if (JSON.stringify(this.tabPreviewData) !== JSON.stringify(this.tabLocalData)) {
            this.tabPreviewData = JSON.parse(JSON.stringify(this.tabLocalData));
            this.tabCollection = this.tabLocalData;
        }
        this.tabPositionClass = this.findTabStyleClass();
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        // set time out
        setTimeout((/**
         * @return {?}
         */
        () => {
            this.tabWidth1 = this.tabs.nativeElement.offsetWidth;
            this.totalTabs = this.tabCollection.length;
            this.updateTabComponent();
            this.tabCollection.forEach((/**
             * @param {?} element
             * @param {?} index
             * @return {?}
             */
            (element, index) => {
                element['tablk'] = Math.floor(window.crypto.getRandomValues(new Uint32Array(1))[0]) + '_tablk';
                super.ngAfterViewInit();
            }));
        }), 500);
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (this.tabLocalData && this.tabLocalData.length > 0) {
            this.tabPreviewData = JSON.parse(JSON.stringify(this.tabLocalData));
            this.tabCollection = this.tabLocalData;
        }
        else {
            this.tabCollection = [];
            this.tabCollection = this.queryTabs.toArray();
        }
        this.tabNodeProperties();
        // To add action in tab
        this.actionComp = this.queryAction.toArray();
        if (this.actionComp.length > 0) {
            this.actionComp[0].checkActionComponent();
        }
        this.tabPositionClass = this.findTabStyleClass();
    }
    // Method to close all tab
    /**
     * @return {?}
     */
    closeAllTabs() {
        this.tabCollection.forEach((/**
         * @param {?} tabs
         * @return {?}
         */
        (tabs) => {
            if (tabs.closable || this.closable) {
                this.closeTab(tabs);
            }
        }));
    }
    /**
     * @return {?}
     */
    closeAll() {
        this.tabCollection.forEach((/**
         * @param {?} tabs
         * @return {?}
         */
        (tabs) => {
            this.closeTab(tabs);
        }));
    }
    // Method to set active tab on the basis of tab sequence or tab title
    /**
     * @param {?} input
     * @return {?}
     */
    setActiveTab(input) {
        /** @type {?} */
        let flag = false;
        if (typeof input === 'string') {
            this.tabCollection.forEach((/**
             * @param {?} tabs
             * @return {?}
             */
            (tabs) => {
                tabs.tabPillClass = '';
                if (input.trim().toLowerCase() === tabs.title.trim().toLowerCase()) {
                    tabs.active = true;
                    flag = true;
                }
                else {
                    tabs.active = false;
                }
                this.asignTabPillClass(tabs);
            }));
        }
        else if (typeof input === 'number') {
            this.tabCollection.forEach((/**
             * @param {?} tabs
             * @param {?} index
             * @return {?}
             */
            (tabs, index) => {
                tabs.tabPillClass = '';
                if (index + 1 === input) {
                    tabs.active = true;
                    flag = true;
                }
                else {
                    tabs.active = false;
                }
                this.asignTabPillClass(tabs);
            }));
        }
        return flag;
    }
    /**
     * @param {?} disabledTabInput
     * @return {?}
     */
    setDisableTabs(disabledTabInput) {
        /** @type {?} */
        const flag = false;
        if (disabledTabInput.length > 0) {
            disabledTabInput.forEach((/**
             * @param {?} ele
             * @return {?}
             */
            (ele) => {
                if (typeof ele === 'string') {
                    this.disableTabByString(flag, ele);
                }
                else if (typeof ele === 'number') {
                    this.disableTabByNumber(flag, ele);
                }
            }));
        }
        return flag;
    }
    /**
     * @param {?} flag
     * @param {?} ele
     * @return {?}
     */
    disableTabByString(flag, ele) {
        this.tabCollection.forEach((/**
         * @param {?} tabs
         * @return {?}
         */
        (tabs) => {
            tabs.tabPillClass = '';
            if (ele.trim().toLowerCase() === tabs.title.trim().toLowerCase()) {
                tabs.disabled = true;
                flag = true;
            }
            this.asignTabPillClass(tabs);
        }));
    }
    /**
     * @param {?} flag
     * @param {?} ele
     * @return {?}
     */
    disableTabByNumber(flag, ele) {
        this.tabCollection.forEach((/**
         * @param {?} tabs
         * @param {?} index
         * @return {?}
         */
        (tabs, index) => {
            tabs.tabPillClass = '';
            if (index + 1 === ele) {
                tabs.active = true;
                flag = true;
            }
            else {
                tabs.active = false;
            }
            this.asignTabPillClass(tabs);
        }));
    }
    /**
     * @param {?} disabledTabInput
     * @return {?}
     */
    setEnableTabs(disabledTabInput) {
        /** @type {?} */
        const flag = false;
        if (disabledTabInput.length > 0) {
            disabledTabInput.forEach((/**
             * @param {?} ele
             * @return {?}
             */
            (ele) => {
                if (typeof ele === 'string') {
                    this.enableTabByString(flag, ele);
                }
                else if (typeof ele === 'number') {
                    this.enableTabByNumber(flag, ele);
                }
            }));
        }
        return flag;
    }
    /**
     * @param {?} flag
     * @param {?} ele
     * @return {?}
     */
    enableTabByString(flag, ele) {
        this.tabCollection.forEach((/**
         * @param {?} tabs
         * @return {?}
         */
        (tabs) => {
            tabs.tabPillClass = '';
            if (ele.trim().toLowerCase() === tabs.title.trim().toLowerCase()) {
                tabs.disabled = false;
                flag = true;
            }
            this.asignTabPillClass(tabs);
        }));
    }
    /**
     * @param {?} flag
     * @param {?} ele
     * @return {?}
     */
    enableTabByNumber(flag, ele) {
        this.tabCollection.forEach((/**
         * @param {?} tabs
         * @param {?} index
         * @return {?}
         */
        (tabs, index) => {
            tabs.tabPillClass = '';
            if (index + 1 === ele) {
                tabs.disabled = false;
                flag = true;
            }
            this.asignTabPillClass(tabs);
        }));
    }
    /**
     * @return {?}
     */
    tabNodeProperties() {
        /** @type {?} */
        const tabWidth = this.tabCollection.length;
        for (let i = 0; i < tabWidth; i++) {
            if (this.tabPosition === 'top') {
                this.tabCollection[i].amexiocolor = TOP_COMPONENT_CLASS_MAP[this.tabCollection[i].amexiocolor];
            }
            else {
                this.tabCollection[i].amexiocolor = BOTTOM_COMPONENT_CLASS_MAP[this.tabCollection[i].amexiocolor];
            }
            if (this.closable) {
                if (this.tabCollection[i].closable === null || this.tabCollection[i].closable === true) {
                    this.tabCollection[i].closable = true;
                }
                else if (this.tabCollection[i].closable === false) {
                    this.tabCollection[i].closable = false;
                }
            }
            this.asignTabPillClass(this.tabCollection[i]);
        }
    }
    /**
     * @param {?} tab
     * @param {?} index
     * @return {?}
     */
    onTabClick(tab, index) {
        if (!tab.disabled && !tab.header) {
            for (const i of this.tabCollection) {
                if (i === tab) {
                    i['active'] = true;
                    i['index'] = index;
                    this.asignTabPillClass(tab);
                    this.onClick.emit(tab);
                }
                else {
                    i['active'] = false;
                    i['tabPillClass'] = '';
                }
            }
            this.tabCollection.forEach((/**
             * @param {?} tab1
             * @return {?}
             */
            (tab1) => {
                this.asignTabPillClass(tab1);
            }));
        }
    }
    /**
     * @return {?}
     */
    onArrowRight() {
        if (this.prevtabindex > -1) {
            this.tabCollection[this.prevtabindex]['isSelected'] = false;
        }
        this.currtabindex++;
        this.prevtabindex = this.currtabindex;
        if (this.currtabindex >= this.tabCollection.length) {
            this.currtabindex = 0;
            this.prevtabindex = 0;
        }
        /** @type {?} */
        const currentTab = this.tabCollection[this.currtabindex];
        this.commonFocus(currentTab);
    }
    /**
     * @return {?}
     */
    onArrowLeft() {
        if (this.prevtabindex > -1) {
            this.tabCollection[this.prevtabindex]['isSelected'] = false;
        }
        this.prevtabindex--;
        if (this.prevtabindex === -1) {
            this.prevtabindex = this.tabCollection.length - 1;
            this.currtabindex = -1;
        }
        this.tabCollection[this.prevtabindex]['isSelected'] = true;
        /** @type {?} */
        const currentTab = this.tabCollection[this.prevtabindex];
        this.commonFocus(currentTab);
        if (this.prevtabindex === 0) {
            this.currtabindex = 0;
        }
    }
    /**
     * @return {?}
     */
    onHomeClick() {
        /** @type {?} */
        const currentTab = this.tabCollection[0];
        this.commonFocus(currentTab);
    }
    /**
     * @return {?}
     */
    onEndClick() {
        /** @type {?} */
        const currentTab = this.tabCollection[this.tabCollection.length - 1];
        this.commonFocus(currentTab);
    }
    /**
     * @param {?} currentTab
     * @return {?}
     */
    commonFocus(currentTab) {
        currentTab['isSelected'] = true;
        /** @type {?} */
        const tablk = document.getElementById(currentTab.tablk);
        tablk.focus();
    }
    /**
     * @return {?}
     */
    next() {
        /** @type {?} */
        const nxt = this.tabs.nativeElement;
        nxt.scrollLeft = nxt.scrollLeft + 200;
        if ((nxt.scrollWidth - nxt.offsetWidth - nxt.scrollLeft) <= 0) {
            this.shownext = false;
        }
        this.showprev = true;
    }
    /**
     * @return {?}
     */
    previous() {
        /** @type {?} */
        const prev = this.tabs.nativeElement;
        prev.scrollLeft = prev.scrollLeft - 200;
        if (prev.scrollLeft === 0) {
            this.showprev = false;
        }
        this.shownext = true;
    }
    /**
     * @return {?}
     */
    onOkClick() {
        this.tabPillClose(this.tempTab);
        this.openDialogue = false;
    }
    /**
     * @return {?}
     */
    onCancelClick() {
        this.openDialogue = false;
    }
    /**
     * @param {?} tabNode
     * @return {?}
     */
    closeTab(tabNode) {
        if (this.enableConfirmBox) {
            this.openDialogue = true;
            this.tempTab = tabNode;
        }
        else {
            this.tabPillClose(tabNode);
        }
        this.onCloseClick.emit(tabNode);
    }
    /**
     * @return {?}
     */
    findTabStyleClass() {
        if (this.headeralign === 'right' && !this.fullPageTabs) {
            return 'tabposition-right';
        }
        if (this.headeralign === 'left' && !this.fullPageTabs) {
            return 'tabposition-left';
        }
        if (this.fullPageTabs === true) {
            return 'equally-align-tabs';
        }
    }
    /**
     * @param {?} event
     * @param {?} row
     * @param {?} id
     * @return {?}
     */
    loadContextMenu(event, row, id) {
        this.tempSelectedFlag(this.tabCollection);
        this.mouseLocation.left = event.clientX;
        this.mouseLocation.top = event.clientY;
        row.active = true;
        this.getContextMenu();
        this.posixUp = this.getListPosition(id);
        if (this.contextmenu && this.contextmenu.length > 0) {
            event.preventDefault();
            event.stopPropagation();
        }
        this.rightClickRowData = row;
    }
    /**
     * @param {?} tabs
     * @return {?}
     */
    tempSelectedFlag(tabs) {
        tabs.forEach((/**
         * @param {?} tab
         * @return {?}
         */
        (tab) => {
            if (tab.active) {
                tab.active = false;
            }
        }));
    }
    /**
     * @return {?}
     */
    getContextMenu() {
        if (this.defaultContextMenu) {
            /** @type {?} */
            const obj = { text: 'Close All', icon: 'fa fa-close', disable: false };
            /** @type {?} */
            const obj2 = { text: this.closeOthersConst, icon: 'fa fa-close', seperator: false, disabled: false };
            /** @type {?} */
            let tmpflag = true;
            for (const i of this.contextmenu) {
                if (i.text === 'Close All' || i.text === this.closeOthersConst) {
                    tmpflag = false;
                }
            }
            if (tmpflag) {
                this.contextmenu.push(obj, obj2);
            }
            this.contextMenuFlag = true;
            this.addListner();
        }
        else if (this.contextmenu && this.contextmenu.length > 0) {
            this.contextMenuFlag = true;
            this.addListner();
        }
    }
    /**
     * @param {?} elementRef
     * @return {?}
     */
    getListPosition(elementRef) {
        /** @type {?} */
        const height = 240;
        if ((window.screen.height - elementRef.getBoundingClientRect().bottom) < height) {
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * @param {?} Data
     * @return {?}
     */
    rightClickDataEmit(Data) {
        /** @type {?} */
        let temptab;
        this.tabCollection.forEach((/**
         * @param {?} obj
         * @return {?}
         */
        (obj) => {
            if (obj.active) {
                temptab = obj;
            }
        }));
        if (Data.nodeData.active) {
            temptab = Data;
        }
        if (Data.menuData.text === 'Close All') {
            this.closeAllTabs();
        }
        if (Data.menuData.text === this.closeOthersConst) {
            this.closeOtherTabs(temptab);
        }
        this.rightClick.emit(Data);
    }
    /**
     * @param {?} data
     * @return {?}
     */
    closeOtherTabs(data) {
        this.tabCollection.forEach((/**
         * @param {?} tabs
         * @return {?}
         */
        (tabs) => {
            if (data.nodeData.title.toLowerCase() !== tabs.title.toLowerCase() && (tabs.closable || this.closable)) {
                this.closeTab(tabs);
            }
        }));
    }
    /**
     * @return {?}
     */
    addListner() {
        this.globalClickListenFunc = this.renderer.listen('document', 'click', (/**
         * @param {?} e
         * @return {?}
         */
        (e) => {
            this.contextMenuFlag = false;
            if (!this.contextMenuFlag) {
                this.removeListner();
            }
        }));
    }
    /**
     * @return {?}
     */
    removeListner() {
        if (this.globalClickListenFunc) {
            this.globalClickListenFunc();
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.removeListner();
        super.ngOnDestroy();
    }
    /**
     * @param {?} input
     * @return {?}
     */
    showTab(input) {
        if (typeof input === 'string') {
            this.tabCollection.forEach((/**
             * @param {?} tabs
             * @return {?}
             */
            (tabs) => {
                if (input.trim().toLowerCase() !== tabs.title.trim().toLowerCase()) {
                    tabs.hide = true;
                    tabs['showflag'] = true;
                    tabs.active = false;
                }
                else {
                    tabs.hide = false;
                    tabs['showflag'] = false;
                    tabs.active = true;
                }
                this.asignTabPillClass(tabs);
            }));
        }
        else if (typeof input === 'number') {
            this.tabCollection.forEach((/**
             * @param {?} tabs
             * @param {?} index
             * @return {?}
             */
            (tabs, index) => {
                if (index !== input) {
                    tabs.hide = true;
                    tabs['showflag'] = true;
                    tabs.active = false;
                }
                else {
                    tabs.hide = false;
                    tabs['showflag'] = false;
                    tabs.active = true;
                }
            }));
        }
    }
    // Method to hide tab
    /**
     * @param {?} input
     * @return {?}
     */
    hideTab(input) {
        if (typeof input === 'string') {
            this.tabCollection.forEach((/**
             * @param {?} tabs
             * @param {?} index
             * @return {?}
             */
            (tabs, index) => {
                if (input.trim().toLowerCase() === tabs.title.trim().toLowerCase() && tabs.active) {
                    /** @type {?} */
                    const i = index + 1;
                    tabs.hide = false;
                    this.tabCollection[i].active = true;
                    /** @type {?} */
                    const newTab = this.tabCollection[i];
                    tabs.active = false;
                    tabs['showflag'] = true;
                    this.asignTabPillClass(newTab);
                }
                else if (input.trim().toLowerCase() === tabs.title.trim().toLowerCase() && !tabs.active) {
                    tabs.hide = true;
                    tabs['showflag'] = true;
                }
            }));
        }
        else if (typeof input === 'number') {
            this.tabCollection.forEach((/**
             * @param {?} tabs
             * @param {?} index
             * @return {?}
             */
            (tabs, index) => {
                if (index !== input) {
                    tabs.hide = true;
                    tabs['showflag'] = false;
                }
                else {
                    tabs.hide = false;
                    tabs['showflag'] = true;
                }
            }));
        }
    }
    /**
     * @param {?} input
     * @param {?} flag
     * @return {?}
     */
    disableTab(input, flag) {
        if (typeof input === 'string') {
            this.tabCollection.forEach((/**
             * @param {?} tabs
             * @return {?}
             */
            (tabs) => {
                if (input.trim().toLowerCase() === tabs.title.trim().toLowerCase()) {
                    tabs.disabled = true;
                    flag = true;
                }
                this.asignTabPillClass(tabs);
            }));
        }
        else if (typeof input === 'number') {
            this.tabCollection.forEach((/**
             * @param {?} tabs
             * @param {?} index
             * @return {?}
             */
            (tabs, index) => {
                if (index === input) {
                    tabs.disabled = true;
                    flag = true;
                }
                this.asignTabPillClass(tabs);
            }));
        }
        else if (typeof input === 'object') {
            this.disabledsplitmethod(input, flag);
        }
    }
    /**
     * @param {?} input
     * @param {?} flag
     * @return {?}
     */
    disabledsplitmethod(input, flag) {
        input.forEach((/**
         * @param {?} element
         * @return {?}
         */
        (element) => {
            if (typeof element === 'string') {
                this.tabCollection.forEach((/**
                 * @param {?} tabs
                 * @return {?}
                 */
                (tabs) => {
                    if (element.trim().toLowerCase() === tabs.title.trim().toLowerCase()) {
                        tabs.disabled = true;
                        flag = true;
                    }
                    this.asignTabPillClass(tabs);
                }));
            }
            else if (typeof element === 'number') {
                this.tabCollection.forEach((/**
                 * @param {?} tabs
                 * @param {?} index
                 * @return {?}
                 */
                (tabs, index) => {
                    if (index === element) {
                        tabs.disabled = true;
                        flag = true;
                    }
                    this.asignTabPillClass(tabs);
                }));
            }
        }));
    }
    /**
     * @return {?}
     */
    getCurrentTab() {
        /** @type {?} */
        let currentindex;
        this.tabCollection.forEach((/**
         * @param {?} tabs
         * @param {?} index
         * @return {?}
         */
        (tabs, index) => {
            if (tabs.active === true) {
                currentindex = index;
            }
        }));
        return currentindex;
    }
    /**
     * @param {?} input
     * @return {?}
     */
    deleteTab(input) {
        if (typeof input === 'string') {
            this.tabCollection.forEach((/**
             * @param {?} tabs
             * @return {?}
             */
            (tabs) => {
                if (input.trim().toLowerCase() === tabs.title.trim().toLowerCase()) {
                    this.closeTab(tabs);
                }
            }));
        }
        else if (typeof input === 'number') {
            this.tabCollection.forEach((/**
             * @param {?} tabs
             * @param {?} index
             * @return {?}
             */
            (tabs, index) => {
                if (index === input) {
                    this.closeTab(tabs);
                }
            }));
        }
        else if (typeof input === 'object') {
            this.deletetypeObject(input);
        }
    }
    /**
     * @param {?} input
     * @return {?}
     */
    deletetypeObject(input) {
        input.forEach((/**
         * @param {?} element
         * @return {?}
         */
        (element) => {
            if (typeof element === 'string') {
                this.tabCollection.forEach((/**
                 * @param {?} tabs
                 * @return {?}
                 */
                (tabs) => {
                    if (element.trim().toLowerCase() === tabs.title.trim().toLowerCase()) {
                        this.closeTab(tabs);
                    }
                }));
            }
            else if (typeof element === 'number') {
                this.tabCollection.forEach((/**
                 * @param {?} tabs
                 * @param {?} index
                 * @return {?}
                 */
                (tabs, index) => {
                    if (element === index) {
                        this.closeTab(tabs);
                    }
                }));
            }
        }));
    }
    /**
     * @param {?} input
     * @param {?} replacetab
     * @return {?}
     */
    replaceTab(input, replacetab) {
        this.tabCollection.forEach((/**
         * @param {?} tabs
         * @param {?} index
         * @return {?}
         */
        (tabs, index) => {
            if (input === index) {
                tabs.title = replacetab;
            }
        }));
    }
}
AmexioTabComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-tab-view',
                template: `
    <div class="tabwrapper">
        <div *ngIf="showprev" [ngClass]="{'tabnavigation float-right tabnavigation-bottom-left':tabPosition=='bottom', 'tabnavigation float-left':tabPosition=='top'}" (click)="previous()">
            <amexio-c-icon key="tab_previous"></amexio-c-icon>
        </div>
        <div *ngIf="shownext" [ngClass]="{'tabnavigation float-right tabnavigation-bottom-right':tabPosition=='bottom','tabnavigation float-right':tabPosition=='top'}" (click)="next()">
            <amexio-c-icon key="tab_next"></amexio-c-icon>
        </div>

        <div #tab class="tab"  role="tablist" aria-labelledby="Tablist" [ngClass]="{'bottomTab':tabPosition == 'bottom'}">

            <div #tabslist class="tablistitems {{tabPositionClass}}">
                <!-- HEADER -->

                <div class="tablink" style="padding-bottom:0%" *ngIf="(this.action == true || header) && (fullPageTabs == false)">
                    <div class="table">
                        <div class="tablerow">
                            <div class="tablecol">
                                {{header}}
                            </div>
                            <div class="tablecol">
                                <ng-content select="amexio-tab-action"></ng-content>
                            </div>
                        </div>
                    </div>
                </div>



                <div class="{{roundedgeclass}}">
                    <div  *ngFor="let tabnode of tabCollection, let index = index" class="tablink {{tabnode.amexiocolor+ ' '+tabnode.tabPillClass}}" 
                    [style.width.px]="singleTabWidth"  (contextmenu)="loadContextMenu($event,tabnode, tab)" (click)="onTabClick(tabnode, index)">
                        <div class="table1" tabindex="1" id="{{tabnode.tablk}}" attr.aria-controls="{{tabnode.tabId}}" role="tab"  [ngStyle]="{'display': tabnode.showflag ? 'none':'table-cell'}"
                        (keyup.arrowright)="onArrowRight()" (keyup.arrowleft)="onArrowLeft()" (keyup.enter)="onTabClick(tabnode, index)" (keyup.home)="onHomeClick()" 
                        (keyup.end)="onEndClick()">
                            <div class="tablerow">
                                <div *ngIf="tabnode.icon" class="tablecol">
                                    <amexio-c-icon *ngIf="tabnode.icon" [customclass]="tabnode.icon"></amexio-c-icon>
                                </div>
                                <div class="tablecol">
                                    {{tabnode.title}}
                                </div>
                                <div *ngIf="tabnode.closable" class="tablecol">
                                    <amexio-c-icon key="tab_close" (onClick)="closeTab(tabnode)"></amexio-c-icon>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="tabcontent" [attr.id]="componentId" [ngStyle]="{'height.px' : height,'overflow-y' : height!= null ? 'auto' : '','min-height.px' : minHeight}">
        <ng-content></ng-content>
        <ng-template #target></ng-template>
    </div>


    <ng-container *ngIf="contextMenuFlag">
        <base-contextmenu [base-context-menu]="contextmenu" [mouse-location-top]="mouseLocation.top" [mouse-location-left]="mouseLocation.left" [is-FlagShow]="contextMenuFlag" [right-click-data]="rightClickRowData" (onRightClick)="rightClickDataEmit($event)"
            [position-up]="posixUp">
        </base-contextmenu>
    </ng-container>

    <amexio-dialogue  [(show)]="openDialogue"
    [button-size]="'medium'"
    [material-design]="true"
    [title]="messageTitle"
    [message]="message"
    [message-type]="'confirm'"
    (onSuccess)="onOkClick()" 
    (onFailure)="onCancelClick()"
    >
    </amexio-dialogue>
  `,
            },] },
];
/** @nocollapse */
AmexioTabComponent.ctorParameters = () => [
    { type: ComponentFactoryResolver },
    { type: Renderer2 }
];
AmexioTabComponent.propDecorators = {
    headeralign: [{ type: Input, args: ['header-align',] }],
    action: [{ type: Input }],
    typeActionAlign: [{ type: Input, args: ['action-type-align',] }],
    header: [{ type: Input }],
    contextmenu: [{ type: Input, args: ['context-menu',] }],
    defaultContextMenu: [{ type: Input, args: ['default-context-menu',] }],
    rightClick: [{ type: Output }],
    enableConfirmBox: [{ type: Input, args: ['enable-confirm-box',] }],
    messageTitle: [{ type: Input, args: ['message-title',] }],
    message: [{ type: Input, args: ['message',] }],
    onCloseClick: [{ type: Output }],
    tabAction: [{ type: ViewChild, args: ['tabAction', { read: ElementRef },] }],
    headerWidth: [{ type: ViewChild, args: ['headerWidth', { read: ElementRef },] }],
    headerName: [{ type: ViewChild, args: ['headerName', { read: ElementRef },] }],
    actionProperty: [{ type: ViewChild, args: ['actionProperty', { read: ElementRef },] }],
    queryAction: [{ type: ContentChildren, args: [AmexioTabActionComponent, { descendants: true },] }],
    onClick: [{ type: Output }],
    tabLocalData: [{ type: Input, args: ['tabLocalData',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by ketangote on 12/1/17.
*/
class AmexioVerticalTabComponent extends BaseTabComponent {
    /**
     * @param {?} render
     * @param {?} componentFactoryResolver
     */
    constructor(render, componentFactoryResolver) {
        super(componentFactoryResolver);
        this.render = render;
        this.componentFactoryResolver = componentFactoryResolver;
        /*
           Properties
           name :rotate
           datatype : boolean
           version : 5.12.2 onwards
           default : false
           description : tab header alignment
           */
        this.rotate = false;
        this.componentId = '';
        this.height = 580;
        this.rotatedtabsHeight = '342';
        this.tabPosition = 'top';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.componentId = Math.floor(window.crypto.getRandomValues(new Uint32Array(1))[0]) + '_tabc';
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (this.tabId && this.tabId.nativeElement && this.tabId.nativeElement.offsetWidth) {
            /** @type {?} */
            const tabsheight = this.tabId.nativeElement.offsetWidth;
            if (tabsheight > this.height) {
                this.height = tabsheight;
            }
            this.rotatedtabsHeight = tabsheight;
        }
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.tabCollection = this.queryTabs.toArray();
        /** @type {?} */
        const testarray = [];
        this.tabCollection.forEach((/**
         * @param {?} element
         * @return {?}
         */
        (element) => {
            if (element.icon) {
                testarray.push(element.icon);
            }
        }));
        this.iconCount = testarray.length;
    }
    /**
     * @return {?}
     */
    closeAllTabs() {
        this.tabCollection.forEach((/**
         * @param {?} tabs
         * @return {?}
         */
        (tabs) => {
            if (tabs.closable === true || this.closable === true) {
                this.tabPillClose(tabs);
            }
        }));
    }
    /**
     * @param {?} tab
     * @return {?}
     */
    tabDomRemove(tab) {
        /** @type {?} */
        const removeNode = document.getElementById(tab.tabId).parentNode;
        /** @type {?} */
        const parentRefNode = removeNode.parentNode;
        parentRefNode.removeChild(removeNode);
    }
    /**
     * @param {?} tabId
     * @return {?}
     */
    activateTab(tabId) {
        this.tabCollection.forEach((/**
         * @param {?} tab
         * @return {?}
         */
        (tab) => {
            tab.active = false;
        }));
    }
}
AmexioVerticalTabComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-vertical-tab-view',
                template: `
    <div class="vertical-table" style="position:relative;">
        <div class="vertical-tablerow" [ngStyle]="{'height': height + 'px'}">
            <div *ngIf="rotate;else elseBlock" style="width:44px;" class="vertical-tablecol verticalalign-tableft" [ngClass]="{'tabposition-top': (tabPosition==='top')}">
                <ul #tabId id="tabclass" [ngStyle]="{'top': rotatedtabsHeight + 'px'}" style="padding:1px" class="verticalnavtab verticalnavtab-left">
                    <li *ngFor="let tabnode of tabCollection">
                        <div class="defaultnode" [ngClass]="{'leftactiverotatetab':tabnode.active,'disabled-tab':tabnode.disabled}" (click)="onVerticalTabClick(tabnode)"
                            [ngStyle]="{'color': tabnode.amexiocolor}">
                            <span #icon *ngIf="tabnode.icon" [ngClass]="tabnode.icon" style="padding-right:8px" aria-hidden="true"></span>
                            <span>{{tabnode.title}}</span>
                            <span *ngIf="closable" class="tablecol">
                     <amexio-c-icon key="tab_close" (onClick)="tabPillClose(tabnode)" style="padding-left:5px;float:right"></amexio-c-icon>
                      </span>
                        </div>
                    </li>
                </ul>
            </div>
            <ng-template #elseBlock>
                <div class="vertical-tablecol verticalalign-tableft" [ngClass]="{'tabposition-top': (tabPosition==='top'),'tabposition-bottom':(tabPosition==='bottom')}">
                    <div #tab class="verticalnavtab verticalnavtab-left">
                        <ul>
                            <li *ngFor="let tabnode of tabCollection">
                                <div class="defaultnode" [ngClass]="{'leftactivetab':tabnode.active,'disabled-tab':tabnode.disabled}" (click)="onVerticalTabClick(tabnode)"
                                    [ngStyle]="{'color': tabnode.amexiocolor}">
                                    <span *ngIf="tabnode.icon" [ngClass]="tabnode.icon" style="padding-right:8px" aria-hidden="true"></span>
                                    <span>{{tabnode.title}}</span>
                                    <span *ngIf="closable" class="tablecol">
                    <amexio-c-icon key="tab_close" (onClick)="tabPillClose(tabnode)" style="padding-left:5px;float:right"></amexio-c-icon>
                  </span>
                                </div>
                            </li>
                        </ul>
                    </div>
                </div>
            </ng-template>
            <div class="vertical-tablecol verticalalign-tabcontent">
                <div class="tabcontent" [attr.id]="componentId">
                    <ng-content></ng-content>
                    <ng-template #target></ng-template>
                </div>

            </div>
        </div>
    </div>
  `,
            },] },
];
/** @nocollapse */
AmexioVerticalTabComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: ComponentFactoryResolver }
];
AmexioVerticalTabComponent.propDecorators = {
    tabs: [{ type: ViewChild, args: ['tab', { read: ElementRef },] }],
    queryTabs: [{ type: ContentChildren, args: [AmexioTabPillComponent,] }],
    target: [{ type: ViewChild, args: ['target', { read: ViewContainerRef },] }],
    tabId: [{ type: ViewChild, args: ['tabId',] }],
    icon: [{ type: ViewChild, args: ['icon',] }],
    closable: [{ type: Input }],
    tabPosition: [{ type: Input }],
    rotate: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/
class AmexiotimelineeventComponent {
    constructor() {
        this.timelineclass = 'timeline-item';
        /*
          Properties
          name :contentborder
          datatype :string
          version : 4.2onwards
          default : false
          description : This will specify the content border in timeline.
          */
        this.contentborder = true;
        this.alignment = 'center';
    }
}
AmexiotimelineeventComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-timeline-event',
                template: `
    <div 

    tabindex="0"
    attr.aria-label="{{alignment}}"

    class="timeline-badge "  
    [ngClass]="{'timeline-badge-center': (alignment === 'center')
      , 'timeline-badge-left': (alignment === 'right')
      , 'timeline-badge-right': (alignment === 'left')}"
      >
    <amexio-c-icon [customclass]="icon"></amexio-c-icon>
    </div>
    <div 
    tabindex="1"
    attr.aria-label="{{contentalignment}}"
    class="timeline-panel" [ngClass]="{'timeline-panel-border':contentborder,
     'timeline-panel-float-right': (contentalignment == 'right'),
     'timeline-panel-float-left': (contentalignment == 'left'),
     'timeline-panel-center': (alignment === 'center'),
     'timeline-panel-right': (alignment === 'right'),
     'timeline-panel-left': (alignment === 'left')}">
    <div 
    tabindex="1"
    *ngIf="label"><strong>{{label}}</strong></div>

    <ng-content></ng-content>
    </div>
  `,
            },] },
];
/** @nocollapse */
AmexiotimelineeventComponent.ctorParameters = () => [];
AmexiotimelineeventComponent.propDecorators = {
    timelineclass: [{ type: HostBinding, args: ['attr.class',] }],
    label: [{ type: Input, args: ['label',] }],
    icon: [{ type: Input, args: ['icon',] }],
    contentborder: [{ type: Input, args: ['content-border',] }],
    contentalignment: [{ type: Input, args: ['content-alignment',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AmexioTimeLineModel {
    /**
     * @param {?} timelineevents
     * @param {?} contentalignment
     * @param {?} alignment
     */
    constructor(timelineevents, contentalignment, alignment) {
        this.timelineevents = timelineevents;
        this.alignment = alignment;
        this.contentalignment = contentalignment;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/
class AmexiotimelineComponent extends LifeCycleBaseComponent {
    /**
     * @param {?} matchMediaService
     */
    constructor(matchMediaService) {
        super();
        this.matchMediaService = matchMediaService;
        this.alignment = 'center';
        /** @type {?} */
        const that = this;
        this.matchMediaService.OnPhone((/**
         * @param {?} mediaQueryList
         * @return {?}
         */
        (mediaQueryList) => {
            that.mobileOrTabletMode();
        }));
        this.matchMediaService.OnTablet((/**
         * @param {?} mediaQueryList
         * @return {?}
         */
        (mediaQueryList) => {
            that.mobileOrTabletMode();
        }));
        this.matchMediaService.OnDesktop((/**
         * @param {?} mediaQueryList
         * @return {?}
         */
        (mediaQueryList) => {
            that.desktopMode();
        }));
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.timelineevents = this.querylist.toArray();
        this.initContentAlignment();
    }
    /**
     * @private
     * @return {?}
     */
    initContentAlignment() {
        if (this.contentalignment) {
            this.alignment = this.contentalignment;
        }
        /** @type {?} */
        let hasContentAlignment = true;
        this.timelineevents.forEach((/**
         * @param {?} timeline
         * @return {?}
         */
        (timeline) => {
            if (timeline.contentalignment) {
                hasContentAlignment = false;
            }
        }));
        if (hasContentAlignment) {
            this.timelineevents.forEach((/**
             * @param {?} timeline
             * @param {?} index
             * @return {?}
             */
            (timeline, index) => {
                if (this.contentalignment) {
                    timeline.contentalignment = this.contentalignment;
                }
                else {
                    timeline.contentalignment = ((index % 2) === 0) ? 'right' : 'left';
                }
                timeline.alignment = this.alignment;
            }));
        }
        this.timelineModel = new AmexioTimeLineModel(JSON.parse(JSON.stringify(this.timelineevents)), this.contentalignment, this.alignment);
    }
    /**
     * @private
     * @return {?}
     */
    mobileOrTabletMode() {
        this.alignment = 'right';
        this.timelineevents.forEach((/**
         * @param {?} timeline
         * @param {?} index
         * @return {?}
         */
        (timeline, index) => {
            timeline.contentalignment = 'right';
            timeline.alignment = this.alignment;
        }));
    }
    /**
     * @private
     * @return {?}
     */
    desktopMode() {
        this.alignment = this.timelineModel.alignment;
        this.contentalignment = this.timelineModel.contentalignment;
        /** @type {?} */
        this.timelineevents.forEach((/**
         * @param {?} timeline
         * @param {?} index
         * @return {?}
         */
        (timeline, index) => {
            /** @type {?} */
            const originalTimelineEvent1 = this.timelineModel.timelineevents[index];
            timeline.contentalignment = originalTimelineEvent1.contentalignment;
            timeline.alignment = originalTimelineEvent1.alignment;
        }));
    }
}
AmexiotimelineComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-timeline',
                template: `
    <div class='timeline {{roundedgeclass}}' [ngClass]="{'timelinecenter': (alignment == 'center'), 
                                    'timelineleft': (alignment == 'left'), 
                                    'timelineright': (alignment == 'right')}">
      <ng-content></ng-content>
    </div>
  `,
            },] },
];
/** @nocollapse */
AmexiotimelineComponent.ctorParameters = () => [
    { type: DeviceQueryService }
];
AmexiotimelineComponent.propDecorators = {
    querylist: [{ type: ContentChildren, args: [AmexiotimelineeventComponent,] }],
    contentalignment: [{ type: Input, args: ['content-alignment',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MinimizeService {
    constructor() {
        this.cureentWidnowData = [];
        this.messageSource = new BehaviorSubject('');
        this.currentMessage = this.messageSource.asObservable();
    }
    /**
     * @param {?} itemData
     * @return {?}
     */
    onMinimizeClick(itemData) {
        if (this.cureentWidnowData && this.cureentWidnowData.length === 0) {
            this.cureentWidnowData.push(itemData);
        }
        else {
            /** @type {?} */
            let isFlag = false;
            this.cureentWidnowData.forEach((/**
             * @param {?} item
             * @return {?}
             */
            (item) => {
                if (itemData.amexioComponentId === item.amexioComponentId) {
                    isFlag = true;
                }
            }));
            if (!isFlag) {
                this.cureentWidnowData.push(itemData);
            }
        }
        this.messageSource.next(this.cureentWidnowData);
    }
    /**
     * @param {?} data
     * @return {?}
     */
    onCloseClick(data) {
        if (this.cureentWidnowData) {
            this.cureentWidnowData.forEach((/**
             * @param {?} item
             * @param {?} index
             * @return {?}
             */
            (item, index) => {
                if (data.amexioComponentId === item.amexioComponentId) {
                    this.cureentWidnowData.splice(index, 1);
                    this.messageSource.next(this.cureentWidnowData);
                }
            }));
        }
    }
}
MinimizeService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] },
];
/** @nocollapse */
MinimizeService.ctorParameters = () => [];
/** @nocollapse */ MinimizeService.ngInjectableDef = defineInjectable({ factory: function MinimizeService_Factory() { return new MinimizeService(); }, token: MinimizeService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MinimizeWindowComponent {
    /**
     * @param {?} _minimizeService1
     */
    constructor(_minimizeService1) {
        this._minimizeService1 = _minimizeService1;
        this.localData = [];
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this._minimizeService1.currentMessage.subscribe((/**
         * @param {?} shareData
         * @return {?}
         */
        (shareData) => {
            if (shareData && shareData.length > 0) {
                this.localData = shareData;
                this.minimizeButton = true;
            }
            else {
                this.minimizeButton = false;
            }
        }));
    }
    /**
     * @param {?} data
     * @return {?}
     */
    minimizeBtnClick(data) {
        data.show = true;
        this.minimizeButton = true;
    }
}
MinimizeWindowComponent.decorators = [
    { type: Component, args: [{
                selector: 'minimize-window',
                template: `
      <div class="minimize-btn-css" [class.minimize-window-bg]="minimizeButton"
          [ngStyle]="{ 'padding': minimizeButton ? '10px  0px 10px 0px': '0px'}">

          <ng-container *ngIf="minimizeButton">
              <span *ngFor="let item of localData">
                  <amexio-button [icon]=item.amexioHeader.first.minimizeIcon [label]="item.textName" [type]="'theme-color'"
                      [tooltip]="item.textName" (onClick)="minimizeBtnClick(item)">
                  </amexio-button>
              </span>
          </ng-container>
      </div>
    `,
            },] },
];
/** @nocollapse */
MinimizeWindowComponent.ctorParameters = () => [
    { type: MinimizeService }
];
MinimizeWindowComponent.propDecorators = {
    input: [{ type: ViewChild, args: ['btnWidth',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the 'License');
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an 'AS IS' BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by ketangote on 12/18/17.
*/
class AmexioWindowPaneComponent extends LifeCycleBaseComponent {
    /**
     * @param {?} document
     * @param {?} appRef
     * @param {?} componentFactoryResolver
     * @param {?} injector
     * @param {?} renderer
     * @param {?} _miniService
     */
    constructor(document, appRef, componentFactoryResolver, injector, renderer, _miniService) {
        super();
        this.document = document;
        this.appRef = appRef;
        this.componentFactoryResolver = componentFactoryResolver;
        this.injector = injector;
        this.renderer = renderer;
        this._miniService = _miniService;
        this.amexioComponentId = 'amexio-window' + window.crypto.getRandomValues(new Uint32Array(1))[0];
        /*
           Properties
           name : vertical-position
           datatype : string
           version : 4.1 onwards
           default : none
           description : Postion of window vertically: top or bottom or center.
           This attribute is ignored if user specify position explicitly
           (using position-top/position-bottom/position-left/position-right)
           */
        this.verticalposition = 'center';
        /*
           Properties
           name : close-on-escape
           datatype : string
           version : 4.2onwards
           default : false
           description : Enables And Disables the Escape button.
           */
        this.closeonescape = true;
        this.showChange = new EventEmitter();
        /*
           Properties
           name : maximize
           datatype : boolean
           version : 4.0 onwards
           default :false
           description : User can maximize the window to full screen.
           */
        this.maximize = false;
        /*
          Properties
          name : minimize
          datatype : boolean
          version : 4.0 onwards
          default :false
          description : User can maximize the window to full screen.
          */
        this.minimize = false;
        /*
           Properties
           name : closable
           datatype : boolean
           version : 4.0 onwards
           default : false
           description : User can close the window.
           */
        this.closable = true;
        /*
           Properties
           name : header
           datatype : boolean
           version : 4.0 onwards
           default : false
           description : it is flag that decides header visibility
           */
        this.header = true;
        /*
           Events
           name : close
           datatype : none
           version : none
           default : none
           description : close the window
           */
        this.window = ' window-';
        this.width = '90%';
        this.windowModel = true;
        this.nodeRightClick = new EventEmitter();
        this.rightClick = new EventEmitter();
        this.onMinimize = new EventEmitter();
        this.onMaximize = new EventEmitter();
        this.onFullScreen = new EventEmitter();
        this.maximizeflagchanged = false;
        this.close = new EventEmitter();
        this.mouseLocation = { left: 0, top: 0 };
        this.x = 0;
        this.y = 0;
        this.px = 0;
        this.py = 0;
        this.draggingWindow = false;
    }
    /**
     * @return {?}
     */
    onCloseClick() {
        if (this.closable) {
            this.showWindow = false;
            this.show = false;
            this.isFullWindow = true;
            this.maximumWindowStyle = this.setMaximizeClass(this.isFullWindow);
            this.showChange.emit(false);
            this.close.emit(this.showWindow);
            if (this.windowposition) {
                this.x = 0;
                this.y = 0;
            }
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
        this.appendComponentToBody(MinimizeWindowComponent);
        this.setVerticlePosition();
        this.setHorizontalPosition();
        if (this.maximize) {
            this.dummyWidth = this.width;
            this.isFullWindow = true;
            this.maximumWindowStyle = this.setMaximizeClass(this.isFullWindow);
        }
        if (this.showWindow) {
            this.show = this.showWindow;
        }
        this.globalDragListenFunc = this.renderer.listen('document', 'mouseup', (/**
         * @param {?} e
         * @return {?}
         */
        (e) => {
            this.draggingWindow = false;
        }));
    }
    /**
     * @param {?} component
     * @return {?}
     */
    appendComponentToBody(component) {
        // 1. Create a component reference from the component;
        this.componentRef = this.componentFactoryResolver
            .resolveComponentFactory(MinimizeWindowComponent)
            .create(this.injector);
        // 2. Attach component to the appRef so that it's inside the ng component tree
        this.appRef.attachView(this.componentRef.hostView);
        // 3. Get DOM element from component
        /** @type {?} */
        const domElem = (/** @type {?} */ (((/** @type {?} */ (this.componentRef.hostView)))
            .rootNodes[0]));
        /** @type {?} */
        const element1 = document.getElementById('minimizeId');
        if (element1) {
            element1.parentNode.removeChild(element1);
        }
        // 4. Append DOM element to the body
        domElem.setAttribute('id', 'minimizeId');
        document.body.appendChild(domElem);
        // 5. Wait some time and remove it from the component tree and from the DOM
    }
    /**
     * @param {?} isFullWindow
     * @return {?}
     */
    setMaximizeClass(isFullWindow) {
        this.isFullWindow = isFullWindow;
        if (!isFullWindow) {
            this.width = '100%';
            return {
                'margin-top': '0', 'height': '100%',
            };
        }
        else {
            this.width = this.dummyWidth;
            return {
                'margin-top': '1%', 'height': '96%',
            };
        }
    }
    /**
     * @return {?}
     */
    setVerticlePosition() {
        switch (this.verticalposition) {
            case 'top': {
                this.verticalposition = 'flex-start';
                break;
            }
            case 'center': {
                this.verticalposition = 'center';
                break;
            }
            case 'bottom': {
                this.verticalposition = 'flex-end';
                break;
            }
            default: {
                this.verticalposition = 'center';
                break;
            }
        }
    }
    /**
     * @return {?}
     */
    setHorizontalPosition() {
        switch (this.horizontalposition) {
            case 'left': {
                this.horizontalposition = 'flex-start';
                break;
            }
            case 'center': {
                this.horizontalposition = 'center';
                break;
            }
            case 'right': {
                this.horizontalposition = 'flex-end';
                break;
            }
            default: {
                this.horizontalposition = 'center';
                break;
            }
        }
    }
    /* ASSIGN PROPERTIES TO FOOTER AND HEADER*/
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (this.amexioFooter && this.footer) {
            this.amexioFooter.toArray().forEach((/**
             * @param {?} footer
             * @return {?}
             */
            (footer) => {
                footer.footer = this.footer;
                footer.setFooterAlignment(this.footeralign);
            }));
        }
        if (this.amexioHeader && this.header) {
            if (this.minimize) {
                this.amexioHeader.toArray()[0].minimize = this.minimize;
                this.amexioHeader.toArray()[0].minimizeWindow.subscribe((/**
                 * @param {?} event
                 * @return {?}
                 */
                (event) => {
                    this.textName = event.textName;
                    this._miniService.onMinimizeClick(this);
                    this.onMinimize.emit(event);
                }));
                this.amexioHeader.toArray()[0].closeDataEmit.subscribe((/**
                 * @param {?} event
                 * @return {?}
                 */
                (event) => {
                    this._miniService.onCloseClick(this);
                }));
            }
            this.amexioHeader.toArray()[0].closeable = this.closable;
            this.amexioHeader.toArray()[0].aComponent1 = 'window';
            if (this.maximize) {
                this.amexioHeader.toArray()[0].setMaximizeData(this.maximize, this.isFullWindow, event);
                this.amexioHeader.toArray()[0].maximizeBehaiour.subscribe((/**
                 * @param {?} max
                 * @return {?}
                 */
                (max) => {
                    this.maximumWindowStyle = this.setMaximizeClass(max.isFullWindow);
                    this.onMaximize.emit(max.event1);
                }));
            }
            this.amexioHeader.toArray()[0].setMaterialDesignStatus(this.materialDesign);
            this.amexioHeader.toArray()[0].closeableBehaiour.subscribe((/**
             * @param {?} close
             * @return {?}
             */
            (close) => {
                this.onCloseClick();
            }));
        }
        if (this.amexioBody && this.bodyHeight) {
            this.amexioBody.toArray()[0].height = this.bodyHeight + '%';
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes['show']) {
            this.setShowFlag(changes.show.currentValue);
        }
        if (changes['showWindow']) {
            this.setShowFlag(changes.showWindow.currentValue);
        }
    }
    /**
     * @param {?} changedValue
     * @return {?}
     */
    setShowFlag(changedValue) {
        this.show = changedValue;
        if (this.show && this.closeonescape) {
            this.globalListenFunc = this.renderer.listen('document', 'keyup.esc', (/**
             * @param {?} e
             * @return {?}
             */
            (e) => {
                this.showWindow = false;
                this.show = false;
                this.showChange.emit(false);
                this.close.emit(this.showWindow);
            }));
        }
        else if (this.globalListenFunc) {
            this.globalListenFunc();
        }
    }
    // context menu code below
    /**
     * @return {?}
     */
    getContextMenu() {
        if (this.contextmenu && this.contextmenu.length > 0) {
            this.flag = true;
            this.addListner();
        }
    }
    /**
     * @param {?} elementRef
     * @return {?}
     */
    getListPosition(elementRef) {
        /** @type {?} */
        const height = 240;
        if ((window.screen.height - elementRef.getBoundingClientRect().bottom) < height) {
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * @param {?} rightClickData
     * @return {?}
     */
    loadContextMenu(rightClickData) {
        if (this.contextmenu && this.contextmenu.length > 0) {
            this.mouseLocation.left = rightClickData.event.clientX;
            this.mouseLocation.top = rightClickData.event.clientY;
            this.getContextMenu();
            this.posixUp = this.getListPosition(rightClickData.ref);
            rightClickData.event.preventDefault();
            rightClickData.event.stopPropagation();
            this.rightClickNodeData = rightClickData.data;
            this.nodeRightClick.emit(rightClickData);
        }
    }
    /**
     * @param {?} Data
     * @return {?}
     */
    rightClickDataEmit(Data) {
        this.rightClick.emit(Data);
    }
    /**
     * @return {?}
     */
    addListner() {
        this.globalClickListenFunc = this.renderer.listen('document', 'click', (/**
         * @param {?} e
         * @return {?}
         */
        (e) => {
            this.flag = false;
            if (!this.flag) {
                this.removeListner();
            }
        }));
    }
    /**
     * @return {?}
     */
    removeListner() {
        if (this.globalClickListenFunc) {
            this.globalClickListenFunc();
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.removeListner();
        if (this.globalListenFunc) {
            this.globalListenFunc();
        }
        if (this.globalDragListenFunc) {
            this.globalDragListenFunc();
        }
    }
    // Theme Apply
    /**
     * @param {?} themeClass
     * @return {?}
     */
    setColorPalette(themeClass) {
        this.themeCss = themeClass;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onWindowPress(event) {
        if (this.draggable) {
            this.draggingWindow = true;
            this.px = event.clientX;
            this.py = event.clientY;
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onWindowDrag(event) {
        if (this.draggable) {
            if (!this.draggingWindow) {
                return;
            }
            /** @type {?} */
            const offsetX = event.clientX - this.px;
            /** @type {?} */
            const offsetY = event.clientY - this.py;
            this.x += offsetX;
            this.y += offsetY;
            this.px = event.clientX;
            this.py = event.clientY;
        }
    }
}
AmexioWindowPaneComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-window',
                template: `
    <div #id *ngIf="show" 
    class="amexio-root-window" 

    [ngClass]="{'amexio-root-window': windowModel, 'amexio-root-window-windowModel': !windowModel}"
    [style.justify-content]="horizontalposition">
      <div class="{{roundedgeclass}}"
       (mousedown)='onWindowPress($event)' (mousemove)='onWindowDrag($event)'
        (contextmenu)="loadContextMenu({event:$event,ref:id})" 
    
        [style.justify-content]="verticalposition" [ngStyle]="maximumWindowStyle"

        [ngClass]="{'content-max-height': (maximize && !isFullWindow), 'amexio-root-window-content': windowModel, 'amexio-root-window-content-windowModel': !windowModel, 'full-screen-card': maximizeflagchanged}"
    
    
        [@animation]="{value: 'visible', params: {transitionParams: transitionOptions}}"
        [style.width]="width" [style.height]="bodyHeight" [style.top.px]='y' [style.left.px]='x' [style.cursor]="draggable ? 'all-scroll':'' " [style.resize]="resizable ? 'both':'' " [style.overflow]="resizable? 'auto':''" >
          <ng-content></ng-content>
      </div>
    </div>
    <ng-container *ngIf="flag">
      <base-contextmenu style=" z-index: 800; position: absolute;" [base-context-menu]="contextmenu" [mouse-location-top]="mouseLocation.top"
        [mouse-location-left]="mouseLocation.left" [is-FlagShow]="flag" [right-click-data]="nodeRightClick" (onRightClick)="rightClickDataEmit($event)"
        [position-up]="posixUp">
      </base-contextmenu>
    </ng-container>
  `,
                animations: [
                    trigger('animation', [
                        state('void', style({
                            transform: 'translate3d(0, 25%, 0) scale(0.9)',
                            opacity: 0,
                        })),
                        state('visible', style({
                            transform: 'none',
                            opacity: 1,
                        })),
                        transition('* => *', animate('400ms cubic-bezier(0.25, 0.8, 0.25, 1)')),
                    ]),
                ],
            },] },
];
/** @nocollapse */
AmexioWindowPaneComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: ApplicationRef },
    { type: ComponentFactoryResolver },
    { type: Injector },
    { type: Renderer2 },
    { type: MinimizeService }
];
AmexioWindowPaneComponent.propDecorators = {
    verticalposition: [{ type: Input, args: ['vertical-position',] }],
    horizontalposition: [{ type: Input, args: ['horizontal-position',] }],
    closeonescape: [{ type: Input, args: ['close-on-escape',] }],
    top: [{ type: Input, args: ['position-top',] }],
    footeralign: [{ type: Input, args: ['footer-align',] }],
    showWindow: [{ type: Input, args: ['show-window',] }],
    materialDesign: [{ type: Input, args: ['material-design',] }],
    show: [{ type: Input }],
    windowHeader: [{ type: ViewChild, args: ['windowHeader', { read: ElementRef },] }],
    showChange: [{ type: Output }],
    bodyHeight: [{ type: Input, args: ['body-height',] }],
    maximize: [{ type: Input }],
    minimize: [{ type: Input }],
    closable: [{ type: Input }],
    header: [{ type: Input }],
    footer: [{ type: Input }],
    contextmenu: [{ type: Input, args: ['context-menu',] }],
    width: [{ type: Input, args: ['width',] }],
    windowModel: [{ type: Input, args: ['window-model',] }],
    nodeRightClick: [{ type: Output }],
    rightClick: [{ type: Output }],
    onMinimize: [{ type: Output }],
    onMaximize: [{ type: Output }],
    onFullScreen: [{ type: Output }],
    amexioHeader: [{ type: ContentChildren, args: [AmexioHeaderComponent,] }],
    amexioFooter: [{ type: ContentChildren, args: [AmexioFooterComponent,] }],
    amexioBody: [{ type: ContentChildren, args: [AmexioBodyComponent,] }],
    close: [{ type: Output }],
    draggable: [{ type: Input }],
    resizable: [{ type: Input }],
    windowposition: [{ type: Input, args: ['remember-window-position',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/
class AmexioWindowHeaderComponent {
    constructor() {
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
}
AmexioWindowHeaderComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-window-header', template: `
    <ng-content></ng-content>
  `,
            },] },
];
/** @nocollapse */
AmexioWindowHeaderComponent.ctorParameters = () => [];
AmexioWindowHeaderComponent.propDecorators = {
    padding: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by manisha on 7/6/18.
*/
class AmexioSearchAdvanceComponent {
    constructor() {
        this.title = 'Advance Search';
        this.formwidth = 0;
        this.advanceSearchFlag = false;
    }
    /**
     * @return {?}
     */
    closeSearchForm() {
        this.advanceSearchFlag = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
}
AmexioSearchAdvanceComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-searchbox-options',
                template: `
  <form [attr.aria-expanded]="advanceSearchFlag" class="advancesearchform"
  *ngIf="advanceSearchFlag"  [style.width]="formwidth+'px'">
    <label tabindex = "0" class="search-form-label" [attr.aria-labellledby]="title">
        {{title}}
    </label>
    <span tabindex = "0"  aria-label="close form button"
     class="fa fa-window-close fa-1x close-icon"
     (keyup.esc)="closeSearchForm()"
     (keyup.enter)="closeSearchForm()" (click)="closeSearchForm()"></span>
    <hr class="hrclass">
             <ng-content></ng-content>
</form>
`,
            },] },
];
/** @nocollapse */
AmexioSearchAdvanceComponent.ctorParameters = () => [];
AmexioSearchAdvanceComponent.propDecorators = {
    title: [{ type: Input }],
    formwidth: [{ type: Input, args: ['form-width',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
/**
 * @template T
 */
class BaseFormValidator extends EventBaseComponent {
    // @ViewChild(NgModel) model: NgModel;
    // public validate(c: FormControl) {
    //     return (this.model.valid ) ? null : {
    //         jsonParseError: {
    //             valid: true,
    //         },
    //     };
    // }
    /**
     * @param {?} renderer
     * @param {?} element
     * @param {?} _cd
     */
    constructor(renderer, element, _cd) {
        super(renderer, element, _cd);
        this.renderer = renderer;
        this.element = element;
        this._cd = _cd;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/
class SearchboxtoolComponent extends BaseFormValidator {
    /**
     * @param {?} element
     * @param {?} dataService
     * @param {?} renderer
     * @param {?} _cd
     */
    constructor(element, dataService, renderer, _cd) {
        super(renderer, element, _cd);
        this.element = element;
        this.dataService = dataService;
        this.renderer = renderer;
        /*
           Properties
           name : title
           datatype : string
           version : 4.2 onwards
           default : none
           description : sets title to advance search form
           */
        this.title = 'Advance Search';
        /*
           Properties
           name : width
           datatype : number
           version : 4.2 onwards
           default : none
           description : Sets width to auto recommendation list.
           */
        this.width = 500;
        /*
           Events
           name : keyup
           description : Fires when keyup event occurs
           */
        this.keyup = new EventEmitter();
        /*
           Events
           name : onSearchItemClick
           description : Fires when search item is selected
           */
        this.onSearchItemClick = new EventEmitter();
        /*
           Events
           name : onSearchClick
           description : Fires when search button is clicked
           */
        this.onSearchClick = new EventEmitter();
        this.searchformString = '';
        this.caretFlag = false;
        this.isListFlag = false;
        this.searchFlag = false;
        this.searchTextBox = false;
        this.selectedValue = '';
        this.advanceSearchFlag = false;
        this.selectedindex = -1;
        this.scrollposition = 30;
        this.enableAdvanceSearch = false;
        this.keystrokeflag = false;
        this.isadvsearchbtnpressed = false;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set data(value) {
        this._data = value;
        if (this.componentLoaded) {
            this.updateComponent();
        }
    }
    /**
     * @return {?}
     */
    get data() {
        return this._data;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.advanceSearchRef.formwidth = this.width;
        this.enableAdvnSearch = this.advanceSearchRef.advanceSearchFlag;
        this.enableAdvanceSearch = true;
        if (this.advanceSearchRef) {
            this.enableAdvanceSearch = true;
            if (this.advanceSearchRef.title) {
                this.advanceButtonLabel = this.advanceSearchRef.title;
            }
            else if (!this.advanceSearchRef.title || this.advanceSearchRef.title === '') {
                this.advanceButtonLabel = 'Advance Search';
            }
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.componentId = this.displayfield + window.crypto.getRandomValues(new Uint32Array(1))[0];
        if (this.httpmethod && this.httpurl) {
            this.dataService.fetchData(this.httpurl, this.httpmethod).subscribe((/**
             * @param {?} response
             * @return {?}
             */
            (response) => {
                this.responseData = response;
            }), (/**
             * @param {?} error
             * @return {?}
             */
            (error) => {
            }), (/**
             * @return {?}
             */
            () => {
                this.setData(this.responseData);
            }));
        }
        else if (this.data) {
            this.previousData = JSON.parse(JSON.stringify(this.data));
            this.setData(this.data);
        }
        this.componentLoaded = true;
    }
    /**
     * @return {?}
     */
    updateComponent() {
        if (JSON.stringify(this.previousData) !== JSON.stringify(this.data)) {
            this.previousData = JSON.parse(JSON.stringify(this.data));
            this.setData(this.data);
        }
    }
    /**
     * @return {?}
     */
    onSelectClick() {
        this.advanceSearchFlag = false;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onInputClick(event) {
        this.searchFlag = true;
        this.onBaseFocusEvent({});
        /** @type {?} */
        const keyword = event.target.value;
        this.viewData = [];
        this.isListFlag = false;
        if (keyword != null && keyword !== ' ') {
            /** @type {?} */
            const search_term = keyword.toLowerCase();
            this.localData.forEach((/**
             * @param {?} item
             * @return {?}
             */
            (item) => {
                this.tempOnInputClick(item, search_term);
            }));
            this.keyup.emit(event);
        }
        // logic for arrow keys and enter key press
        // 40=down-arrow and 38=up-arrow and 13=enter
        if (event.keyCode === 40 || event.keyCode === 38 || event.keyCode === 13) {
            // if key pressed is up down or enter then process accordingly
            // call function for process
            this.navigateKeys(event);
        }
        if (!this.selectedValue || this.selectedValue === '') {
            this.viewData = [];
            this.isListFlag = false;
        }
    }
    /**
     * @param {?} item
     * @param {?} search_term
     * @return {?}
     */
    tempOnInputClick(item, search_term) {
        /** @type {?} */
        let filterCounter = true;
        for (const [key, value] of Object.entries(item)) {
            /** @type {?} */
            let val;
            val = value;
            this.a = key;
            // For New Input enable-filter
            if (filterCounter && item && (this.enablefilter) && (val.startsWith(search_term))
                && item !== null && item[this.displayfield]) {
                this.isListFlag = true;
                filterCounter = false;
                this.viewData.push(item);
            }
            else {
                if (filterCounter && (!this.enablefilter) && item !== null && val.startsWith(search_term)
                    && item[this.displayfield].toLowerCase().startsWith(search_term)) {
                    this.isListFlag = true;
                    filterCounter = false;
                    this.viewData.push(item);
                }
            }
        }
    }
    /**
     * @return {?}
     */
    onFocus() {
        if (this.selectedValue.length > 0) {
            /** @type {?} */
            const keyword = this.selectedValue;
            this.viewData = [];
            this.isListFlag = false;
            if (keyword != null && keyword !== ' ') {
                /** @type {?} */
                const search_term = keyword.toLowerCase();
                this.localData.forEach((/**
                 * @param {?} item1
                 * @return {?}
                 */
                (item1) => {
                    this.tempOnInputClick(item1, search_term);
                }));
                this.searchFlag = true;
                this.onBaseFocusEvent({});
                this.keyup.emit(event);
            }
            this.selectedValueOnFocus();
        }
    }
    // If Selected Value is blank, then view data will be reset
    /**
     * @return {?}
     */
    selectedValueOnFocus() {
        if (!this.selectedValue || this.selectedValue === '') {
            this.viewData = [];
            this.isListFlag = false;
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    navigateKeys(event) {
        if (this.selectedindex > this.viewData.length) {
            this.selectedindex = 0;
        }
        if (event.keyCode === 40 ||
            event.keyCode === 38
                && this.selectedindex < this.viewData.length) {
            this.navigateKeysCondition(event);
        }
        if (event.keyCode === 13 && this.viewData[this.selectedindex]) {
            this.onItemSelect(this.viewData[this.selectedindex]);
        }
    }
    // Method will be called when keycode will be 40 or 38
    /**
     * @param {?} event
     * @return {?}
     */
    navigateKeysCondition(event) {
        /** @type {?} */
        let prevselectedindex = -1;
        if (this.selectedindex === -1) {
            this.selectedindex = 0;
        }
        else {
            prevselectedindex = this.selectedindex;
            if (event.keyCode === 40) {
                // mtd 1 start
                if (this.selectedindex >= this.viewData.length - 1) {
                    this.selectedindex = 0;
                }
                else {
                    this.selectedindex++;
                }
                // mtd 1 ends
                if ((this.selectedindex > 5)) {
                    this.dropdownitems.nativeElement.scroll(0, this.scrollposition);
                    this.scrollposition = this.scrollposition + 30;
                }
            }
            else if (event.keyCode === 38) {
                this.eventKeyCodeCondition();
            }
        }
        if (this.viewData[this.selectedindex]) {
            this.viewData[this.selectedindex].selected = true;
            this.setAriaActiveDescendant(this.selectedindex);
        }
        if (this.viewData[prevselectedindex]) {
            this.viewData[prevselectedindex].selected = false;
        }
    }
    // If keycode is 38
    /**
     * @return {?}
     */
    eventKeyCodeCondition() {
        this.selectedindex--;
        if (this.selectedindex === -1) {
            this.selectedindex = this.viewData.length - 1;
            this.setAriaActiveDescendant(this.selectedindex);
        }
        if (this.scrollposition >= 0 && this.selectedindex > 1) {
            this.dropdownitems.nativeElement.scroll(1, this.scrollposition);
            this.scrollposition = this.scrollposition - 30;
        }
        if (this.selectedindex === 1) {
            this.scrollposition = 30;
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onSearchButtonClick(event) {
        this.onSearchClick.emit(event);
    }
    /**
     * @return {?}
     */
    selectCssClass() {
        if (this.viewData.length > 5) {
            return 'dropdown-list scroll';
        }
        else {
            return 'dropdown-list';
        }
    }
    /**
     * @param {?} item
     * @return {?}
     */
    onItemSelect(item) {
        this.value = item[this.valuefield];
        this.selectedValue = item[this.displayfield];
        this.searchFlag = this.onBaseBlurEvent({});
        this.onSearchItemClick.emit(item);
    }
    /**
     * @return {?}
     */
    advanceSearch() {
        this.isadvsearchbtnpressed = !this.isadvsearchbtnpressed;
        this.searchformString = 'advance search form opened';
        this.advanceSearchRef.advanceSearchFlag = true;
        this.advanceSearchFlag = true;
        this.searchFlag = this.onBaseBlurEvent({});
    }
    /**
     * @return {?}
     */
    closeSearchForm() {
        this.advanceSearchFlag = false;
    }
    /**
     * @param {?} httpResponse
     * @return {?}
     */
    getResponseData(httpResponse) {
        /** @type {?} */
        let responsedata = httpResponse;
        if (this.datareader != null) {
            /** @type {?} */
            const dr = this.datareader.split('.');
            if (dr != null) {
                for (const ir of dr) {
                    responsedata = responsedata[dr[ir]];
                }
            }
        }
        else {
            responsedata = httpResponse;
        }
        return responsedata;
    }
    /**
     * @param {?} httpResponse
     * @return {?}
     */
    setData(httpResponse) {
        /** @type {?} */
        let responsedata = httpResponse;
        // Check if key is added?
        if (this.datareader != null) {
            /** @type {?} */
            const dr = this.datareader.split('.');
            for (const ir of dr) {
                responsedata = responsedata[dr[ir]];
            }
        }
        else {
            responsedata = httpResponse;
        }
        this.viewData = responsedata;
        this.generateIndex();
        this.localData = JSON.parse(JSON.stringify(this.viewData));
    }
    /**
     * @return {?}
     */
    closeOnEscape() {
        this.viewData = [];
    }
    /**
     * @return {?}
     */
    closeFormOnEscape() {
        this.advanceSearchRef.closeSearchForm();
        this.viewData = [];
        this.advanceSearchFlag = false;
        this.selectedindex = -1;
    }
    /**
     * @return {?}
     */
    generateIndex() {
        this.viewData.forEach((/**
         * @param {?} element
         * @param {?} index
         * @return {?}
         */
        (element, index) => {
            element['index'] = this.componentId + 'listitem' + index;
        }));
    }
    /**
     * @param {?} rowindex
     * @return {?}
     */
    setAriaActiveDescendant(rowindex) {
        if (this.viewData.length > 0) {
            /** @type {?} */
            const inputid = document.getElementById(this.componentId);
            inputid.setAttribute('aria-activedescendant', this.viewData[rowindex].index);
        }
        else if (this.displayValue.length < 1) {
            /** @type {?} */
            const inputid = document.getElementById(this.componentId);
            inputid.setAttribute('aria-activedescendant', 'listitem');
        }
    }
    // will be fired on end key press
    /**
     * @return {?}
     */
    focustolast() {
        if (this.viewData.length > 0) {
            this.viewData[this.selectedindex].selected = false;
            this.selectedindex = this.viewData.length - 1;
            this.viewData[this.selectedindex].selected = true;
            this.setAriaActiveDescendant(this.selectedindex);
        }
    }
    // will be fired on home key press
    /**
     * @return {?}
     */
    focustofirst() {
        if (this.viewData.length > 0) {
            this.viewData[this.selectedindex].selected = false;
            this.selectedindex = 0;
            this.viewData[this.selectedindex].selected = true;
            this.setAriaActiveDescendant(this.selectedindex);
        }
    }
}
SearchboxtoolComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-searchbox',
                template: `
    <div (keyup.esc)="closeOnEscape()">
      <div tabindex="1" (keyup.end)="focustolast()" (keyup.home)="focustofirst()" class="input-group">
        <!-- input div -->
        <div class="input-group-prepend">
          <input id="{{componentId}}" type="text" aria-haspopup="true" aria-label="Search input box" [attr.aria-expanded]="isListFlag"
            class="form-control" (keyup)="onInputClick($event)" #inp [(ngModel)]="selectedValue" [attr.placeholder]="placeholder"
            (click)="onSelectClick()" (focus)="onFocus()">
        </div>
        <!-- search btn -->
        <div aria-label="search button" class="input-group-text-search " (click)="onSearchButtonClick($event)">
          <em class="fa fa-search iconColor">
          </em>
        </div>
      </div>
      <!-- first div ends here -->

      <!-- dropdown list and advance search btn -->
      <form [ngStyle]="dropdownstyle" class="dropdownposition">
        <ng-container *ngIf="!advanceSearchFlag">
          <ul role="menu" tabindex="1" #dropdownitems [style.width]="width+'px'" class="search-dropdown-list" [ngClass]="selectCssClass()">

            <li role="menuitem" tabindex="1" role="menuitem" class="search-list-items " [ngClass]="{'search-list-items-selected':item.selected}"
              *ngFor="let item of viewData" id="{{item.index}}" (click)="onItemSelect(item)">
              <div style="white-space: nowrap;display: inline;">{{item[displayfield]}}</div>
            </li>
          </ul>

          <div [style.width]="width+'px'" class="advancesearchbuttondiv">
            <button role="button" class="fa fa-search btncolor" [style.width]="width+'px'" class="advancesearchbtn fa fa-search" (click)="advanceSearch()"
              (keyup.enter)="advanceSearch()">
              {{advanceButtonLabel}}
            </button>
          </div>

        </ng-container>
      </form>
      <!-- advance search form with ng content -->
      <div (keyup.esc)="closeFormOnEscape()" [ngStyle]="{'block': advanceSearchRef.advanceSearchFlag ? 'block' : 'none'}">
        <ng-content></ng-content>
      </div>
    </div>
  `,
            },] },
];
/** @nocollapse */
SearchboxtoolComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: CommonDataService },
    { type: Renderer2 },
    { type: ChangeDetectorRef }
];
SearchboxtoolComponent.propDecorators = {
    data: [{ type: Input, args: ['data',] }],
    datareader: [{ type: Input, args: ['data-reader',] }],
    httpurl: [{ type: Input, args: ['http-url',] }],
    placeholder: [{ type: Input, args: ['place-holder',] }],
    displayfield: [{ type: Input, args: ['display-field',] }],
    httpmethod: [{ type: Input, args: ['http-method',] }],
    title: [{ type: Input }],
    valuefield: [{ type: Input, args: ['value-field',] }],
    width: [{ type: Input }],
    enablefilter: [{ type: Input, args: ['enable-global-filter',] }],
    keyup: [{ type: Output }],
    onSearchItemClick: [{ type: Output }],
    onSearchClick: [{ type: Output }],
    advanceSearchRef: [{ type: ContentChild, args: [AmexioSearchAdvanceComponent,] }],
    dropdownitems: [{ type: ViewChild, args: ['dropdownitems', { read: ElementRef },] }],
    inp: [{ type: ViewChild, args: ['inp', { read: ElementRef },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by pratik on 13/12/17.
*/
class AmexioButtonDropDownItemComponent {
    constructor() {
        /*
        Events
        name : onItemClick
        datatype : none
        version : none
        default : none
        description : Fire when button-dropdown item button/link click
        */
        this.onItemClick = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
}
AmexioButtonDropDownItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-btn-dropdown-item', template: '',
            },] },
];
/** @nocollapse */
AmexioButtonDropDownItemComponent.ctorParameters = () => [];
AmexioButtonDropDownItemComponent.propDecorators = {
    label: [{ type: Input }],
    badge: [{ type: Input, args: ['badge',] }],
    disabled: [{ type: Input }],
    icon: [{ type: Input }],
    onClickRoute: [{ type: Input }],
    onItemClick: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by pratik on 13/12/17.
*/
class AmexioButtonDropdownComponent extends BaseFormValidator {
    /**
     * @param {?} element
     * @param {?} renderer
     * @param {?} _cd
     */
    constructor(element, renderer, _cd) {
        super(renderer, element, _cd);
        this.element = element;
        this.dropdownItemData = [];
        /*
          Events
          name : click
          datatype :  none
          version : none
          default : none
          description : Fire when button-dropdown item button/link click
          */
        this.click = new EventEmitter();
        /*
        Events
        name : getLinkData
        datatype :  none
        version : none
        default : none
        description : Fire when button-dropdown item button/link click
        */
        this.getLinkData = new EventEmitter();
        this.ispressed = false;
        this.selected = false;
        this.flag = false;
        this.activedescendant = 'aria-activedescendant';
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set data(value) {
        this._buttonGroupLocalData = value;
        if (this.componentLoaded) {
            this.updateComponent();
        }
    }
    /**
     * @return {?}
     */
    get buttonGroupLocalData() {
        return this._buttonGroupLocalData;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.componentId = this.label + window.crypto.getRandomValues(new Uint32Array(1))[0];
    }
    /**
     * @return {?}
     */
    updateComponent() {
        if (JSON.stringify(this.buttonGroupPreviewData) !== JSON.stringify(this.buttonGroupLocalData)) {
            this.buttonGroupPreviewData = JSON.parse(JSON.stringify(this.buttonGroupLocalData));
            this.dropdownItemData = this.buttonGroupLocalData;
        }
    }
    /**
     * @param {?} array
     * @return {?}
     */
    generateIndex(array) {
        this.dropdownItemData.forEach((/**
         * @param {?} element
         * @param {?} index
         * @return {?}
         */
        (element, index) => {
            element['index'] = this.componentId + 'listitem' + index;
        }));
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (this.buttonGroupLocalData && this.buttonGroupLocalData.length > 0) {
            this.buttonGroupPreviewData = JSON.parse(JSON.stringify(this.buttonGroupLocalData));
            this.dropdownItemData = this.buttonGroupLocalData;
            this.createDropdownItemConfig(this.dropdownItemData);
        }
        else {
            this.createDropdownItemConfig(this.buttons.toArray());
        }
        this.componentLoaded = true;
    }
    /**
     * @param {?} btnCollection
     * @return {?}
     */
    createDropdownItemConfig(btnCollection) {
        /** @type {?} */
        const itemRefArray = btnCollection;
        for (const itemConfig of itemRefArray) {
            /** @type {?} */
            const data = {
                label: itemConfig.label,
                disabled: itemConfig.disabled,
                onItemClick: itemConfig.onItemClick,
                iconStyleClass: itemConfig.iconStyleClass,
                icon: itemConfig.icon,
                badge: itemConfig.badge,
                selected: false,
                onClickRoute: itemConfig.onClickRoute,
            };
            data.iconStyleClass = data.icon;
            this.dropdownItemData.push(data);
        }
        if (itemRefArray.length === this.dropdownItemData.length) {
            this.generateIndex(this.dropdownItemData);
        }
    }
    /**
     * @param {?} elem
     * @return {?}
     */
    onClick(elem) {
        this.ispressed = !this.ispressed;
        this.openContent = !this.openContent;
        if (this.openContent) {
            this.onBaseFocusEvent({});
        }
        else {
            this.openContent = this.onBaseBlurEvent(elem);
        }
        this.posixUp = this.getListPosition(elem);
        this.click.emit();
    }
    /**
     * @param {?} elem
     * @return {?}
     */
    onEnterClick(elem) {
        this.flag = true;
        this.dropdownItemData[0].selected = true;
        this.ispressed = !this.ispressed;
        if (this.openContent) {
            this.onBaseFocusEvent({});
        }
        else {
            this.openContent = this.onBaseBlurEvent(elem);
        }
        this.posixUp = this.getListPosition(elem);
        this.click.emit();
        /** @type {?} */
        const divid = document.getElementById(this.componentId);
        divid.setAttribute(this.activedescendant, this.dropdownItemData[0].index);
    }
    /**
     * @param {?} elem
     * @return {?}
     */
    onClickEscape(elem) {
        this.openContent = false;
        this.hide();
    }
    /**
     * @param {?} elem
     * @return {?}
     */
    onSpaceClick(elem) {
        this.onEnterClick(elem);
    }
    /**
     * @return {?}
     */
    onHomeClick() {
        if (this.flag) {
            this.buttonindex1 = this.findbuttonindex();
            if ((this.buttonindex1 <= (this.dropdownItemData.length - 1))) {
                this.onHomeClickSelected();
            }
        }
    }
    /**
     * @return {?}
     */
    onHomeClickSelected() {
        this.dropdownItemData[this.buttonindex1].selected = false;
        this.dropdownItemData[0].selected = true;
        /** @type {?} */
        const divid = document.getElementById(this.componentId);
        divid.setAttribute(this.activedescendant, this.dropdownItemData[0].index);
    }
    /**
     * @return {?}
     */
    onEndClick() {
        if (this.flag) {
            this.buttonindex1 = this.findbuttonindex();
            if (this.buttonindex1 <= (this.dropdownItemData.length - 1)) {
                this.onEndClickSelected();
            }
        }
    }
    /**
     * @return {?}
     */
    onEndClickSelected() {
        this.dropdownItemData[this.buttonindex1].selected = false;
        this.dropdownItemData[this.dropdownItemData.length - 1].selected = true;
        /** @type {?} */
        const divid = document.getElementById(this.componentId);
        divid.setAttribute(this.activedescendant, this.dropdownItemData[this.dropdownItemData.length - 1].index);
    }
    /**
     * @param {?} elem
     * @return {?}
     */
    onclickDown(elem) {
        if (this.flag) {
            this.buttonindex1 = this.findbuttonindex();
            if (this.buttonindex1 < (this.dropdownItemData.length - 1)) {
                this.dropdownItemData[this.buttonindex1].selected = false;
                this.dropdownItemData[this.buttonindex1 + 1].selected = true;
                /** @type {?} */
                const divid = document.getElementById(this.componentId);
                divid.setAttribute(this.activedescendant, this.dropdownItemData[this.buttonindex1 + 1].index);
            }
            else if (this.buttonindex1 === this.dropdownItemData.length - 1) {
                this.dropdownItemData[this.buttonindex1].selected = false;
                this.dropdownItemData[0].selected = true;
                /** @type {?} */
                const divid = document.getElementById(this.componentId);
                divid.setAttribute(this.activedescendant, this.dropdownItemData[0].index);
            }
        }
        else {
            this.dropdownstyle = { visibility: 'visible' };
            this.dropdownItemData[0].selected = true;
            /** @type {?} */
            const divid = document.getElementById(this.componentId);
            divid.setAttribute(this.activedescendant, this.dropdownItemData[0].index);
            this.flag = true;
        }
    }
    /**
     * @param {?} elem
     * @return {?}
     */
    onclickUp(elem) {
        if (this.flag) {
            this.buttonindex1 = this.findbuttonindex();
            if ((this.buttonindex1 < (this.dropdownItemData.length - 1)) && this.buttonindex1 !== 0) {
                this.onClickUpSelected();
            }
            else if (this.buttonindex1 === (this.dropdownItemData.length - 1)) {
                this.onClickUpSelected();
            }
            else if (this.buttonindex1 === 0) {
                this.dropdownItemData[this.dropdownItemData.length - 1].selected = true;
                this.dropdownItemData[this.buttonindex1].selected = false;
                /** @type {?} */
                const divid = document.getElementById(this.componentId);
                divid.setAttribute(this.activedescendant, this.dropdownItemData[this.dropdownItemData.length - 1].index);
            }
        }
        else {
            this.dropdownstyle = { visibility: 'visible' };
            this.dropdownItemData[this.dropdownItemData.length - 1].selected = true;
            /** @type {?} */
            const divid = document.getElementById(this.componentId);
            divid.setAttribute(this.activedescendant, this.dropdownItemData[this.dropdownItemData.length - 1].index);
            this.flag = true;
        }
    }
    /**
     * @return {?}
     */
    onClickUpSelected() {
        this.dropdownItemData[this.buttonindex1].selected = false;
        this.dropdownItemData[this.buttonindex1 - 1].selected = true;
        /** @type {?} */
        const divid = document.getElementById(this.componentId);
        divid.setAttribute(this.activedescendant, this.dropdownItemData[this.buttonindex1 - 1].index);
    }
    /**
     * @return {?}
     */
    findbuttonindex() {
        /** @type {?} */
        let buttonindex;
        this.dropdownItemData.forEach((/**
         * @param {?} element
         * @param {?} index
         * @return {?}
         */
        (element, index) => {
            if (element.selected === true) {
                buttonindex = index;
            }
        }));
        return buttonindex;
    }
    /**
     * @param {?} elementRef
     * @return {?}
     */
    getListPosition(elementRef) {
        /** @type {?} */
        const dropdownHeight = 325;
        if (window.screen.height - (elementRef.getBoundingClientRect().bottom) < dropdownHeight) {
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * @param {?} eve
     * @return {?}
     */
    onblur(eve) {
        this.openContent = this.onBaseBlurEvent(eve);
    }
    /**
     * @param {?} clickEvent
     * @param {?} itemData
     * @return {?}
     */
    btnItemClick(clickEvent, itemData) {
        if (this.buttonGroupLocalData && this.buttonGroupLocalData.length > 0) {
            this.getLinkData.emit({ event: clickEvent, parentRef: this, data: itemData });
        }
        else {
            if (!itemData.disabled) {
                itemData.onItemClick.emit(clickEvent);
                this.openContent = !this.openContent;
                this.getLinkData.emit({ event: clickEvent, parentRef: this, data: itemData });
                this.onBaseBlurEvent(event);
            }
        }
    }
}
AmexioButtonDropdownComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-btn-dropdown',
                template: `
    <div class="button-group" #rootDiv>
        <button id={{componentId}} role="button" aria-haspopup="true" aria-label="" [attr.aria-expanded]="openContent" tabindex="1"
            aria-controls="menulist" class="button-dropdown-main" (blur)="onblur($event)" (click)="onClick(rootDiv)" (keyup.enter)="onEnterClick(rootDiv)"
            (keyup.esc)="onClickEscape(rootDiv)" (keyup.end)="onEndClick()" (keyup.home)="onHomeClick()" (keyup.space)="onSpaceClick(rootDiv)"
            (keyup.arrowdown)="onclickDown(rootDiv)" (keyup.arrowup)="onclickUp(rootDiv)" #btnRef [ngClass]="{'button-default': size=='default' || size ==null,
                'button-small': size=='small',
                'button-large' : size=='large',
                'button-primary' : type == 'primary' || type == null || type == 'theme-color',
                'button-success' : type == 'success' || type == 'green',
                'button-danger' : type=='danger' || type == 'red',
                'button-warning' : type=='warning' ||  type == 'yellow'}">
            <amexio-c-icon style="float:right;" key="button_caret-down"></amexio-c-icon>
            <span [attr.disabled]="disabled ? true: null">{{label}} &nbsp;&nbsp;</span>
        </button>
        <div class="button-dropdown" role="menu" [ngClass]="{'button-dropdown-up' : posixUp}" [@changeState]="dropdownstyle.visibility"
            [ngStyle]="dropdownstyle">
            <div id="{{itemData.index}}" role="option" tabindex="1" *ngFor="let itemData of dropdownItemData let index = index">
                <div [ngClass]="{'button-default': size=='default' || size ==null,'button-small': size=='small','button-large' : size=='large'}">
                    <div [ngStyle]="{'cursor': itemData.disabled ? 'not-allowed':'pointer'}" (mousedown)="btnItemClick($event,itemData)">
                        <amexio-c-icon style="padding-right: 5px;" [customclass]="itemData.iconStyleClass"></amexio-c-icon>
                        <span [ngClass]="{'button-group-list-items':itemData.selected}" [attr.disabled]="itemData.disabled ? true: null">{{itemData.label}}&nbsp;&nbsp;</span>
                        <ng-container *ngIf="itemData.badge">
                            <span class="btn-dropdown-badge">{{itemData.badge}}</span>
                        </ng-container>
                    </div>
                </div>
            </div>
        </div>
    </div>
  `,
                animations: [
                    trigger('changeState', [
                        state('visible', style({})),
                        state('hidden', style({
                            height: '0px',
                        })),
                        transition('*=>*', animate('200ms')),
                    ]),
                ],
            },] },
];
/** @nocollapse */
AmexioButtonDropdownComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: ChangeDetectorRef }
];
AmexioButtonDropdownComponent.propDecorators = {
    btnReference: [{ type: ViewChild, args: ['btnRef',] }],
    label: [{ type: Input }],
    buttons: [{ type: ContentChildren, args: [AmexioButtonDropDownItemComponent,] }],
    data: [{ type: Input, args: ['buttonGroupLocalData',] }],
    type: [{ type: Input }],
    disabled: [{ type: Input }],
    size: [{ type: Input }],
    badge: [{ type: Input, args: ['badge',] }],
    click: [{ type: Output }],
    getLinkData: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by pratik on 13/12/17.
*/
class AmexioSpiltButtonDropdownComponent {
    constructor() {
        this.dropdownItemData = [];
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.createDropdownItemConfig();
    }
    /**
     * @return {?}
     */
    createDropdownItemConfig() {
        /** @type {?} */
        let itemRefArray = [];
        itemRefArray = this.buttons.toArray();
        for (const itemConfig of itemRefArray) {
            /** @type {?} */
            const data = {
                label: itemConfig.label,
                disabled: itemConfig.disabled,
                onItemClick: itemConfig.onItemClick,
                iconStyleClass: itemConfig.iconStyleClass,
                icon: itemConfig.icon,
                onClickRoute: itemConfig.onClickRoute,
            };
            data.iconStyleClass = data.icon;
            this.dropdownItemData.push(data);
        }
    }
    /**
     * @return {?}
     */
    onClick() {
        this.openContent = !this.openContent;
    }
    /**
     * @param {?} event
     * @param {?} itemData
     * @return {?}
     */
    itemClick(event, itemData) {
        itemData.onItemClick.emit(event);
    }
    /**
     * @return {?}
     */
    getBackgroundColor() {
        /** @type {?} */
        let colorCode;
        if (this.type === 'primary' || this.type === 'theme-color') {
            colorCode = '#0275d8';
        }
        else if (this.type === 'success' || this.type === 'green') {
            colorCode = '#5cb85c';
        }
        else if (this.type === 'danger' || this.type === 'red') {
            colorCode = '#d9534f';
        }
        else if (this.type === 'warning' || this.type === 'yellow') {
            colorCode = '#f0ad4e';
        }
        return {
            'background-color': colorCode,
        };
    }
}
AmexioSpiltButtonDropdownComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-btn-split-dropdown', template: `
    <div class="dropdown-button" [ngStyle]="getBackgroundColor()">
      <button class="button" [attr.disabled]="disabled ? true: null"
              [ngClass]="{'button-default': size=='default' || size ==null,
              'button-small': size=='small','button-large' : size=='large',
              'button-primary' : type == 'primary' || type == null,
              'button-success' : type == 'success',' button-danger' : type=='danger',
              'button-warning' : type=='warning'}">
        {{label}}
      </button>
      <button class="button"
              [ngClass]="{'button-default': size=='default' || size ==null,
              'button-small': size=='small',
              'button-large' : size=='large',
              'button-primary' : type == 'primary' || type == null || type == 'theme-color',
              'button-success' : type == 'success' || type == 'green',
              'button-danger' : type=='danger' || type == 'red',
              'button-warning' : type=='warning' ||  type == 'yellow'}">
              (click)="onClick()"><i class="fa fa-chevron-down" aria-hidden="true"></i></button>
      <div class="dropdown-button-content" [ngStyle]="{'display' : openContent ? 'block' : 'none'}">
        <ul class="dropdown-list">
          <ng-container *ngFor="let itemData of dropdownItemData">
            <li class="list-items" [ngClass]="{'disabled':itemData.disabled}" (click)="itemClick($event,itemData)">
            <ng-container *ngIf="itemData.icon!=null">
              <!--<i [class]="itemData.iconStyleClass" aria-hidden="true"></i>-->
              <amexio-c-icon style="padding-right: 5px;" [customclass]="itemData.iconStyleClass"></amexio-c-icon>
            </ng-container>{{itemData.label}}
            </li>
          </ng-container>
        </ul>
      </div>
    </div>
  `,
            },] },
];
/** @nocollapse */
AmexioSpiltButtonDropdownComponent.ctorParameters = () => [];
AmexioSpiltButtonDropdownComponent.propDecorators = {
    label: [{ type: Input }],
    badge: [{ type: Input, args: ['badge',] }],
    buttons: [{ type: ContentChildren, args: [AmexioButtonDropDownItemComponent,] }],
    type: [{ type: Input }],
    disabled: [{ type: Input }],
    size: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/
/** @type {?} */
const noop$7 = (/**
 * @return {?}
 */
() => {
});
class CheckboxComponent {
    /**
     * @param {?} checkboxGroup
     */
    constructor(checkboxGroup) {
        this.checkboxGroup = checkboxGroup;
        // Placeholders for the callbacks which are later provided
        // by the Control Value Accessor
        this.onTouchedCallback = noop$7;
        this.onChangeCallback = noop$7;
        this.tabFocus = false;
    }
    /**
     * @return {?}
     */
    toggleCheck() {
        if (this.checked) {
            this.checked = !this.checked;
            this.value.checked = this.checked;
        }
        else {
            this.value['checked'] = true;
        }
        this.checkboxGroup.emitData();
    }
    /**
     * @return {?}
     */
    isChecked() {
        return this.checked || this.checkboxGroup.contains(this.value);
    }
    /**
     * @return {?}
     */
    onBlur() {
        this.tabFocus = false;
        this.onTouchedCallback();
    }
    /**
     * @return {?}
     */
    onFocus() {
        this.tabFocus = true;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.componentId = this.createCompId('checkbox', this.name);
    }
    /**
     * @param {?} inputType
     * @param {?} name
     * @return {?}
     */
    createCompId(inputType, name) {
        return inputType + '_' + name + '_' + window.crypto.getRandomValues(new Uint32Array(1))[0];
    }
}
CheckboxComponent.decorators = [
    { type: Component, args: [{
                selector: 'checkbox',
                template: `
    <label [attr.aria-checked]="checked"
           for="{{componentId}}"
           class="input-box-container" 
           [ngClass]="{'disable-component' : disabled || disabled}">
    {{label}}
    <input type="checkbox"  
           style="top:0; left:0"
           class="form-control" 
           [attr.tabindex]="disabled ? -1 : 0"
           id="{{componentId}}"
           (focus)="onFocus()"
           (blur)="onBlur()"
           [ngClass]="{'checkbox-disable' : disabled}" 
           [checked]="checked" 
           [attr.aria-disabled]="disabled"
           (click)="toggleCheck()">
    <span class="input-box-checkbox-label"  [ngClass]="{'focusOnCheckbox':tabFocus}"></span>
    </label>
  `,
            },] },
];
/** @nocollapse */
CheckboxComponent.ctorParameters = () => [
    { type: AmexioCheckBoxGroupComponent, decorators: [{ type: Host }] }
];
CheckboxComponent.propDecorators = {
    label: [{ type: Input }],
    value: [{ type: Input }],
    name: [{ type: Input }],
    checked: [{ type: Input }],
    disabled: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/
class AmexioChipComponent {
    constructor() {
        /*
        Properties
        name : icon
        datatype :
        version : 5.3.1 onwards
        default :
        description : The icon is for determining of icon.
        */
        this.icon = '';
        /*
        Properties
        name : closeable
        datatype :
        version : 5.3.1onwards
        default :
        description : The closeable is for closing particular chip.
        */
        /*
        Properties
        name : color
        datatype :
        version : 5.3.1onwards
        default :
        description : The color is for determining color of particular chip.
        */
        this.fontcolor = 'red';
        /*
            Events
            name :  closeClick
            datatype : none
            version : none
            default : none
            description : It will fire only on selection of checkbox and gives you selected record data.
            */
        this.closeClick = new EventEmitter();
        /*
           Events
           name :  labelClick
           datatype : none
           version : none
           default : none
           description : It will fire only on selection of checkbox and gives you selected record data.
           */
        this.labelClick = new EventEmitter();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onCloseClick(event) {
        this.closeClick.emit(event);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onLabelClick(event) {
        this.labelClick.emit(event);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
}
AmexioChipComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-chip',
                template: `
    <div class="chips" id="{{index}}" attr.aria-label="{{label}}" style="cursor: pointer;" [ngStyle]="{'background-color': color,'filter': selected ? 'contrast(70%)':''}">
      <amexio-c-icon [customclass]="icon"></amexio-c-icon>
      <amexio-label (click)="onLabelClick($event)">
        <ng-container *ngIf="!label">
        <span [style.color]="fontcolor" style="cursor: pointer;" [ngStyle]="{'padding-left': icon ? '10px':'0px'}">
          {{item[displayfield]}}
        </span>
      </ng-container>
      <ng-container *ngIf="label">
        <span [style.color]="fontcolor" style="cursor: pointer;" [ngStyle]="{'padding-left': icon ? '10px':'0px'}">
          {{label}}
        </span>
      </ng-container>
      </amexio-label>
      <span class="badge" *ngIf="badge">{{badge}}</span>
      <span *ngIf="closable">
        <em class="fa fa-times" style="cursor: pointer; margin-left:10px" (click)="onCloseClick($event)"></em>
      </span>
    </div>
  `,
            },] },
];
/** @nocollapse */
AmexioChipComponent.ctorParameters = () => [];
AmexioChipComponent.propDecorators = {
    icon: [{ type: Input, args: ['icon',] }],
    label: [{ type: Input, args: ['label',] }],
    color: [{ type: Input, args: ['color',] }],
    badge: [{ type: Input, args: ['badge',] }],
    fontcolor: [{ type: Input, args: ['font-color',] }],
    displayfield: [{ type: Input, args: ['display-field',] }],
    item: [{ type: Input, args: ['item',] }],
    closable: [{ type: Input, args: ['closable',] }],
    closeClick: [{ type: Output }],
    labelClick: [{ type: Output }],
    index: [{ type: Input, args: ['index',] }],
    selected: [{ type: Input, args: ['selected',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/
class AmexioChipsComponent {
    /**
     * @param {?} renderer
     */
    constructor(renderer) {
        this.renderer = renderer;
        /*
            Events
            name : selectedRowData
            datatype : none
            version : none
            default : none
            description : It will fire only on selection of checkbox and gives you selected record data.
            */
        this.selectedchipsData = new EventEmitter();
        this.closeClick = new EventEmitter();
        this.chipindex = -1;
        this.prevchipindex = -1;
        this.obj = {};
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.chipCollection = this.queryChips.toArray();
        if (this.chipCollection.length > 0) {
            this.data = this.chipCollection;
        }
        this.generateIndex();
        this.listenChipOutClick();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.componentId = 'chips' + window.crypto.getRandomValues(new Uint32Array(1))[0];
    }
    /**
     * @return {?}
     */
    listenChipOutClick() {
        this.documentClickListener = this.renderer
            .listen('document', 'click', (/**
         * @param {?} event
         * @return {?}
         */
        (event) => {
            if (this.data.length > 0) {
                this.data.forEach((/**
                 * @param {?} element
                 * @param {?} index
                 * @return {?}
                 */
                (element, index) => {
                    if (this.data[index]['selected'] === true) {
                        this.data[index]['selected'] = false;
                        this.chipindex = -1;
                        this.prevchipindex = -1;
                    }
                }));
            }
        }));
    }
    /**
     * @param {?} item
     * @return {?}
     */
    onCloseChipsClick(item) {
        if (this.chipindex > -1) {
            this.data[this.chipindex]['selected'] = false;
        }
        if (this.data.length > 0) {
            this.data.forEach((/**
             * @param {?} element
             * @param {?} index
             * @return {?}
             */
            (element, index) => {
                if (element.label === item.label) {
                    this.data.splice(index, 1);
                }
            }));
            this.emitCloseData(item);
        }
    }
    /**
     * @param {?} item
     * @return {?}
     */
    emitCloseData(item) {
        /** @type {?} */
        const cloneNode = JSON.parse(JSON.stringify(item));
        delete cloneNode['index'];
        if (this.chipCollection.length > 0) {
            this.obj['icon'] = item.icon;
            this.obj['label'] = item.label;
            this.obj['badge'] = item.badge;
            this.obj['closable'] = item.closable;
            this.obj['color'] = item.color;
            this.closeClick.emit(this.obj);
        }
        else {
            this.closeClick.emit(cloneNode);
        }
    }
    /**
     * @param {?} item
     * @param {?} chipdata
     * @return {?}
     */
    closeFocusedChip(item, chipdata) {
        /** @type {?} */
        let closeindex;
        /** @type {?} */
        let emitdata;
        this.obj = {};
        if (this.data.length > 0) {
            chipdata.forEach((/**
             * @param {?} element
             * @param {?} index
             * @return {?}
             */
            (element, index) => {
                if (chipdata[index]['selected'] === true) {
                    emitdata = element;
                    this.chiplabel = chipdata[index]['label'] + 'closed';
                    this.data.splice(index, 1);
                    closeindex = index;
                }
            }));
            this.obj['icon'] = emitdata.icon;
            this.obj['label'] = emitdata.label;
            this.obj['badge'] = emitdata.badge;
            this.obj['closable'] = emitdata.closable;
            this.obj['color'] = emitdata.color;
            this.closeChip(closeindex);
            this.emitSelectedLabel(chipdata);
        }
    }
    /**
     * @param {?} item
     * @return {?}
     */
    emitSelectedLabel(item) {
        /** @type {?} */
        const cloneNode = JSON.parse(JSON.stringify(item));
        delete cloneNode['index'];
        if (this.chipCollection.length > 0) {
            this.obj['icon'] = item.icon;
            this.obj['label'] = item.label;
            this.obj['badge'] = item.badge;
            this.obj['closable'] = item.closable;
            this.obj['color'] = item.color;
            this.selectedchipsData.emit(this.obj);
        }
        else {
            this.selectedchipsData.emit(cloneNode);
        }
    }
    /**
     * @return {?}
     */
    generateIndex() {
        this.data.forEach((/**
         * @param {?} element
         * @param {?} index
         * @return {?}
         */
        (element, index) => {
            element['index'] = this.componentId + 'chip' + index;
            element['selected'] = false;
        }));
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onchipsKeyup(event) {
        if (this.data.length > 0) {
            this.navigateChips(event);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    navigateChips(event) {
        if (event.keyCode === 37) {
            this.leftArrowKeyNavigation(event);
        }
        else if (event.keyCode === 39) {
            this.rightArrowKeyNavigation(event);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    leftArrowKeyNavigation(event) {
        if (this.prevchipindex > -1) {
            this.data[this.prevchipindex]['selected'] = false;
        }
        this.prevchipindex--;
        if (this.prevchipindex === -1) {
            this.prevchipindex = this.data.length - 1;
            this.chipindex = -1;
        }
        this.setAriaActiveDescendant(this.prevchipindex);
        if (this.prevchipindex === 0) {
            this.chipindex = 0;
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    rightArrowKeyNavigation(event) {
        if (this.prevchipindex > -1) {
            this.data[this.prevchipindex]['selected'] = false;
        }
        this.chipindex++;
        this.prevchipindex = this.chipindex;
        if (this.chipindex >= this.data.length) {
            this.chipindex = 0;
            this.prevchipindex = 0;
        }
        this.setAriaActiveDescendant(this.chipindex);
    }
    /**
     * @param {?} rowindex
     * @return {?}
     */
    setAriaActiveDescendant(rowindex) {
        this.data[rowindex]['selected'] = true;
        /** @type {?} */
        const inputid = document.getElementById(this.componentId);
        inputid.setAttribute('aria-activedescendant', this.data[rowindex]['index']);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    focusToLastChip(event) {
        if (this.prevchipindex > -1) {
            this.data[this.prevchipindex]['selected'] = false;
        }
        this.prevchipindex = this.data.length - 1;
        this.chipindex = -1;
        this.setAriaActiveDescendant(this.prevchipindex);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    focusToFirstChip(event) {
        if (this.prevchipindex > -1) {
            this.data[this.prevchipindex]['selected'] = false;
        }
        this.chipindex = 0;
        this.prevchipindex = 0;
        this.setAriaActiveDescendant(this.chipindex);
    }
    /**
     * @param {?} closeindex
     * @return {?}
     */
    closeChip(closeindex) {
        if (closeindex !== 0) {
            this.chipindex = closeindex - 1;
            this.prevchipindex = closeindex - 1;
            this.setAriaActiveDescendant(closeindex - 1);
        }
        else {
            this.chipindex = closeindex;
            this.prevchipindex = closeindex;
            this.setAriaActiveDescendant(closeindex);
        }
    }
}
AmexioChipsComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-chips',
                template: `
    <span id="{{componentId}}" tabindex="0" role="listbox" (keyup.end)="focusToLastChip($event)" (keyup.home)="focusToFirstChip($event)"
        (keyup)="onchipsKeyup($event)" (keydown.control.x)="closeFocusedChip($event, data)">
        <span role="option" tabindex="0" *ngFor="let item of data" id="{{item.index}}" attr.aria-label="{{item.label}}">
            <amexio-chip [item]="item" [index]="item.index" [selected]="item.selected" [display-field]="displayfield"
                [icon]="item.icon" [label]="item.label" [badge]="item.badge" [closable]="item.closable" [font-color]="item.fontcolor"
                [color]="item.color" (closeClick)="onCloseChipsClick(item)" (labelClick)="emitSelectedLabel(item)">
            </amexio-chip>
        </span>
    </span>
  `,
            },] },
];
/** @nocollapse */
AmexioChipsComponent.ctorParameters = () => [
    { type: Renderer2 }
];
AmexioChipsComponent.propDecorators = {
    queryChips: [{ type: ContentChildren, args: [AmexioChipComponent,] }],
    data: [{ type: Input, args: ['data',] }],
    displayfield: [{ type: Input, args: ['display-field',] }],
    selectedchipsData: [{ type: Output }],
    closeClick: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AmexioCreditCardModel {
    constructor() {
        this.owner = '';
        this.cvv = null;
        this.cardnumber = null;
        this.expMonth = 1;
        this.expYear = new Date().getFullYear();
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by Ankita
*/
/** @type {?} */
const noop$8 = (/**
 * @return {?}
 */
() => {
});
class AmexioCreditcardComponent {
    constructor() {
        /*
          Properties
          name : yearcount
          datatype : string
          version : 5.2.3onwards
          default :
          description : the minexp will set the dropdown to user defined dropdown.
          */
        this.yearcount = 12;
        /*
         Properties
         name : showlabel
         datatype : boolean
         version : 5.2.3onwards
         default :
         description : the showlabel will set the label of creditcard.
         */
        this.showlabel = false;
        this.isNameValid = false;
        this.isCvvValid = false;
        this.visaEagerReg = /^4/;
        this.visaReg = /^4\d{12}(\d{3}|\d{6})?$/;
        this.mastropattern = /^(?:5[06789]\d\d|(?!6011[0234])(?!60117[4789])(?!60118[6789])(?!60119)(?!64[456789])(?!65)6\d{3})\d{8,15}$/;
        this.masttroeagerPattern = /^(5(018|0[23]|[68])|6[37]|60111|60115|60117([56]|7[56])|60118[0-5]|64[0-3]|66)/;
        this.masterpattern = /^5[1-5]\d{14}$/;
        this.mastereagerPattern = /^5[1-5]/;
        this.isFullCardValid = false;
        this.cvvRegex = /^[0-9]{3,4}$/;
        this.year = new Date();
        this.yearList = [];
        this.eagarValue = '';
        this.fullPatternValue = '';
        // The internal dataviews model
        // Placeholders for the callbacks which are later provided
        // by the Control Value Accessor
        this.onTouchedCallback = noop$8;
        this.onChangeCallback = noop$8;
        if (this.template === 'single-column') {
            this.templateFlag = true;
        }
        else if (this.template === 'double-column') {
            this.templateFlag = false;
        }
        this.creditCardModel = new AmexioCreditCardModel();
        this.dummyMonth = '0' + this.creditCardModel.expMonth;
        this.dateData = [
            {
                month: '01',
            },
            {
                month: '02',
            },
            {
                month: '03',
            },
            {
                month: '04',
            },
            {
                month: '05',
            },
            {
                month: '06',
            },
            {
                month: '07',
            },
            {
                month: '08',
            },
            {
                month: '09',
            },
            {
                month: '10',
            },
            {
                month: '11',
            },
            {
                month: '12',
            },
        ];
        this.cardGroupData = [
            {
                iconName: 'fa fa-cc-visa',
                key: 'eagerflagvisa',
                color: 'black',
            },
            {
                iconName: 'fa fa-cc-mastercard',
                key: 'mastereagerPattern',
                color: 'black',
            },
            {
                iconName: 'fa fa-credit-card',
                key: 'masttroeagerPattern',
                color: 'black',
            },
        ];
    }
    // From ControlValueAccessor Interface
    /**
     * @param {?} modelValue
     * @return {?}
     */
    writeValue(modelValue) {
        if (modelValue) {
            this.creditCardModel = modelValue;
            this.onChangeCardNumber(this.creditCardModel.cardnumber);
            this.onChangeMonth('0' + this.creditCardModel.expMonth);
            this.onChangeYear(this.creditCardModel.expYear);
            this.isCvvValid = this.cvvRegex.test(this.creditCardModel.cvv);
            this.cardRegexMap.forEach((/**
             * @param {?} value
             * @param {?} key
             * @return {?}
             */
            (value, key) => {
                /** @type {?} */
                const isEagarValid = value.test(this.dummyCreditCardNumber);
                if (isEagarValid) {
                    this.eagarflag = isEagarValid;
                    this.eagarValue = key;
                }
            }));
            this.validEagerCard = this.eagarValue;
            this.switchCaseMethod();
            this.onCheckValidation();
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onChangeCardNumber(event) {
        this.dummyCreditCardNumber = this.creditCardNumberSpaceRemove(event);
        /** @type {?} */
        const concatCardNumber = this.replaceSpace(this.dummyCreditCardNumber);
        this.cardPatternMap.forEach((/**
         * @param {?} value
         * @param {?} key
         * @return {?}
         */
        (value, key) => {
            // Condition for Full String Regex
            this.isValidFullString = value.test(concatCardNumber);
            if (this.isValidFullString) {
                this.fullPatternflag = this.isValidFullString;
                this.fullPatternValue = key;
            }
        }));
        this.validPatternCard = this.fullPatternValue;
        this.creditCardModel.cardnumber = +concatCardNumber;
    }
    // From ControlValueAccessor Interface
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChangeCallback = fn;
    }
    // From ControlValueAccessor Interface
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouchedCallback = fn;
    }
    // method to check owners length
    /**
     * @param {?} inp
     * @return {?}
     */
    onNameClick(inp) {
        if (inp.model.length > 0) {
            this.isNameValid = true;
        }
        else {
            this.isNameValid = false;
        }
    }
    // method to check Cvv Number
    /**
     * @param {?} inpcvv
     * @return {?}
     */
    onClick(inpcvv) {
        this.isCvvValid = this.cvvRegex.test(inpcvv.model);
    }
    // method to check Card Number
    /**
     * @param {?} inp
     * @return {?}
     */
    onInput(inp) {
        // Condition for null check
        if (inp.model !== '') {
            /** @type {?} */
            let isValidFullString;
            /** @type {?} */
            let fullPatternValue = '';
            /** @type {?} */
            const concatValue = this.replaceSpace(inp.model);
            this.cardPatternMap.forEach((/**
             * @param {?} value
             * @param {?} key
             * @return {?}
             */
            (value, key) => {
                // Condition for Full String Regex
                isValidFullString = value.test(concatValue);
                if (isValidFullString) {
                    fullPatternValue = key;
                }
            }));
            this.validPatternCard = fullPatternValue;
            /** @type {?} */
            let eagarValue = '';
            this.cardRegexMap.forEach((/**
             * @param {?} value
             * @param {?} key
             * @return {?}
             */
            (value, key) => {
                /** @type {?} */
                const isEagarValid = value.test(concatValue);
                if (isEagarValid) {
                    eagarValue = key;
                }
            }));
            this.validEagerCard = eagarValue;
        }
        else {
            this.validEagerCard = '';
        }
        this.switchCaseMethod();
        this.onCheckValidation();
        if (inp.model !== '') {
            this.cardNumberValue = this.creditCardNumberSpaceRemove(inp.model);
        }
    }
    // THIS MEHTOD IS SUED FOR REPALCE SPACE WITH STRING AND RETURN TO REGEX
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    replaceSpace(value) {
        /** @type {?} */
        let newString = '';
        if (value) {
            /** @type {?} */
            const stringArray = value.split(' ');
            if (stringArray) {
                stringArray.forEach((/**
                 * @param {?} element
                 * @return {?}
                 */
                (element) => {
                    newString = newString.concat(element);
                }));
            }
        }
        return newString;
    }
    // Map Implementation for key value pair
    /**
     * @return {?}
     */
    ngOnInit() {
        this.creditCardModel = new AmexioCreditCardModel();
        this.cardRegexMap = new Map();
        this.cardPatternMap = new Map();
        this.cardRegexMap.set('eagerflagvisa', this.visaEagerReg);
        this.cardRegexMap.set('mastereagerPattern', this.mastereagerPattern);
        this.cardRegexMap.set('masttroeagerPattern', this.masttroeagerPattern);
        this.cardPatternMap.set('visaReg', this.visaReg);
        this.cardPatternMap.set('masterpattern', this.masterpattern);
        this.cardPatternMap.set('mastropattern', this.mastropattern);
        this.cardName = '';
        this.currentYear = this.year.getFullYear();
        if (this.template === 'single-column') {
            this.templateFlag = true;
        }
        else if (this.template === 'double-column') {
            this.templateFlag = false;
        }
        for (let i = 0; i < this.yearcount; i++) {
            this.yearList.push(this.currentYear + i);
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    creditCardNumberSpaceRemove(value) {
        if (value) {
            value = value.toString();
            /** @type {?} */
            const v = value.replace(/\s+/g, '').replace(/[^0-9]/gi, '');
            /** @type {?} */
            const matches = v.match(/\d{4,16}/g);
            /** @type {?} */
            const match = matches && matches[0] || '';
            /** @type {?} */
            const parts = [];
            /** @type {?} */
            let len;
            /** @type {?} */
            let i;
            len = match.length;
            for (i = 0; i < len; i += 4) {
                parts.push(match.substring(i, i + 4));
            }
            if (parts.length) {
                return parts.join(' ');
            }
            else {
                return value;
            }
        }
    }
    /**
     * @return {?}
     */
    switchCaseMethod() {
        switch (this.validEagerCard) {
            case 'eagerflagvisa':
                this.cardName = 'fa fa-cc-visa';
                break;
            case 'mastereagerPattern':
                this.cardName = 'fa fa-cc-mastercard';
                break;
            case 'masttroeagerPattern':
                this.cardName = 'fa fa-credit-card';
                break;
            case '':
                this.cardName = '';
                break;
            default:
                this.cardName = '';
                break;
        }
    }
    /**
     * @return {?}
     */
    onCheckValidation() {
        this.cardGroupData.forEach((/**
         * @param {?} element
         * @return {?}
         */
        (element) => {
            if (element.key === this.validEagerCard) {
                element.color = 'blue';
            }
            else {
                element.color = 'black';
            }
        }));
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onChangeMonth(event) {
        this.dummyMonth = event;
        this.creditCardModel.expMonth = +this.dummyMonth;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onChangeYear(event) {
        this.creditCardModel.expYear = event;
    }
}
AmexioCreditcardComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-creditcard',
                template: `
    <ng-container *ngIf="templateFlag">

        <div class="creditCardFormSglCol">
            <div class="imageSglCol">
                <em *ngFor="let cardimage of cardGroupData" [style.color]="cardimage.color" [attr.class]="cardimage.iconName" style="font-size:50px">
                </em>
            </div>
            <div class="ownerdetailsSglCol">
                <label *ngIf="showlabel">CARD HOLDER NAME</label>
                <div class="ownerSglCol">
                    <input [ngClass]="{'input-control-success':isNameValid,'input-control-failure':(!isNameValid && inpowner.touched)}" type="text"
                        placeholder="CARD HOLDER NAME" #inpowner="ngModel" class="input-control" [(ngModel)]="creditCardModel.owner"
                        (keyup)="onNameClick(inpowner)">
                </div>
            </div>

            <div class="cardNumberSglCol">
                <label *ngIf="showlabel">CARD NUMBER</label>
                <input type="text" placeholder="CARD NUMBER" maxlength="19" class="input-control" [ngModel]="dummyCreditCardNumber" (ngModelChange)="onChangeCardNumber($event)"
                    [value]="cardNumberValue" #inp="ngModel" [ngClass]="{'input-control-success':validPatternCard,'input-control-failure':(!validPatternCard && (inp.dirty || inp.touched))}"
                    (keyup)="onInput(inp)" />
            </div>
            <label *ngIf="showlabel">EXP DATE</label>
            <div class="expiration-dateSglCol">
                <div class="monthSglCol">
                    <select [ngModel]="dummyMonth" (ngModelChange)="onChangeMonth($event)" placeholder="MM" style="padding:10px">
                        <option *ngFor="let months of dateData">{{months.month}}</option>
                    </select>
                </div>
                <div class="dateSglCol">
                    <select [(ngModel)]="creditCardModel.expYear" (ngModelChange)="onChangeYear($event)" yearControl="yearControl" style="padding:10px"
                        placeholder="YY">
                        <option *ngFor="let year of yearList">{{year}}</option>
                    </select>
                </div>
            </div>
            <div class="cvvSglCol">
                <label *ngIf="showlabel">CVV</label>
                <input #inpcvv="ngModel" [ngClass]="{'input-control-success':isCvvValid,'input-control-failure':(!isCvvValid && inpcvv.touched)}"
                    type="password" placeholder="CVV" maxlength="3" class="input-control" [(ngModel)]="creditCardModel.cvv" (keyup)="onClick(inpcvv)">
            </div>
        </div>
    </ng-container>
    <br>
    <ng-container *ngIf="!templateFlag">
        <div class="creditCardForm">
            <div class="owner">
                <label *ngIf="showlabel">CARD HOLDER NAME</label>
                <input [ngClass]="{'input-control-success':isNameValid,'input-control-failure':(!isNameValid && inpowner.touched)}" type="text"
                    placeholder="CARD HOLDER NAME" #inpowner="ngModel" class="input-control" [(ngModel)]="creditCardModel.owner"
                    (keyup)="onNameClick(inpowner)">
            </div>
            <div [ngClass]="{'image-label':showlabel==true,'image':showlabel==false}">
                <em *ngFor="let cardimage of cardGroupData" [style.color]="cardimage.color" [attr.class]="cardimage.iconName" style="font-size:40px"></em>
            </div>


            <div class="cardNumber">
                <label *ngIf="showlabel">CARD NUMBER</label>
                <input type="text" placeholder="CARD NUMBER" maxlength="19" class="input-control" [ngModel]="dummyCreditCardNumber" (ngModelChange)="onChangeCardNumber($event)"
                    [value]="cardNumberValue" #inp="ngModel" [ngClass]="{'input-control-success':validPatternCard,'input-control-failure':(!validPatternCard && (inp.dirty || inp.touched))}"
                    (keyup)="onInput(inp)" />
            </div>

            <div [ngClass]="{'expiration-date-label':showlabel==true,'expiration-date':showlabel==false}">
                <label *ngIf="showlabel">EXP DATE</label>
                <div class="exp-month-date-label">
                    <div class="month">
                        <select [ngModel]="dummyMonth" (ngModelChange)="onChangeMonth($event)" style="padding:10px" placeholder="MM">
                            <option *ngFor="let months of dateData">{{months.month}}</option>
                        </select>
                    </div>
                    <div class="date">
                        <select [(ngModel)]="creditCardModel.expYear" (ngModelChange)="onChangeYear($event)" yearControl="yearControl" style="padding:10px"
                            placeholder="YY">
                            <option *ngFor="let year of yearList">{{year}}</option>
                        </select>
                    </div>
                </div>

            </div>

            <div class="cvv">
                <label *ngIf="showlabel">CVV</label>
                <input #inpcvv="ngModel" [ngClass]="{'input-control-success':isCvvValid,'input-control-failure':(!isCvvValid && (inpcvv.dirty ||inpcvv.touched))}"
                    type="password" placeholder="CVV" maxlength="3" class="input-control" [(ngModel)]="creditCardModel.cvv" (keyup)="onClick(inpcvv)">
            </div>
        </div>
    </ng-container>
  `,
                providers: [{
                        provide: NG_VALUE_ACCESSOR, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => AmexioCreditcardComponent)), multi: true,
                    }],
            },] },
];
/** @nocollapse */
AmexioCreditcardComponent.ctorParameters = () => [];
AmexioCreditcardComponent.propDecorators = {
    yearcount: [{ type: Input, args: ['year-count',] }],
    showlabel: [{ type: Input, args: ['show-label',] }],
    template: [{ type: Input, args: ['template',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DarkmodeComponent {
    constructor() {
        this.type = 2;
        this.size = 'medium';
        this.mode = 'day-night';
        this.stepVal = 0;
        this.maxValue = 2;
        this.sepiaColorCode = '#f4ecd8';
        this.sepiaFontColor = '#020202';
        this.themesdata = [];
        this.themeStyles = [];
        this.appBackground = '--appBackground';
        this.appForeground = '--appForegroundColor';
        this.componentBackground = '--componentBGColor';
        this.componentForeground = '--componentFontColor';
        this.themesdata = [
            {
                varName: this.appBackground,
                darkValue: '#2d2d2d',
                themeValue: '#f5f5f5',
            },
            {
                varName: this.appForeground,
                darkValue: '#f5f5f5',
                themeValue: '#121212',
            },
            {
                varName: this.componentBackground,
                darkValue: '#121212',
                themeValue: '#ffffff',
            },
            {
                varName: this.componentForeground,
                darkValue: '#ffffff',
                themeValue: '#121212',
            },
        ];
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.shape === '' || this.shape == null) {
            this.shape = 'round';
        }
        if (this.mode === 'custom') {
            this.maxValue = this.colorData.length - 1;
            this.otherMode();
        }
        else {
            this.addDynamicCss('white', 'black');
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onToggleClick(event) {
        this.themeStyles = [];
        this.themesdata.forEach((/**
         * @param {?} obj
         * @return {?}
         */
        (obj) => {
            /** @type {?} */
            const varObj = {
                name: '',
                value: '',
            };
            if (event) {
                varObj.name = obj.varName;
                varObj.value = obj.darkValue;
            }
            else {
                varObj.name = obj.varName;
                varObj.value = obj.themeValue;
            }
            this.themeStyles.push(varObj);
        }));
        this.themeStyles.forEach((/**
         * @param {?} style
         * @return {?}
         */
        (style) => {
            document.documentElement.style.setProperty(style.name, style.value);
        }));
    }
    /**
     * @param {?} eventV
     * @return {?}
     */
    onChange(eventV) {
        this.stepVal = eventV;
        if (this.mode === 'sepia') {
            this.sepiaMode();
        }
        else if (this.mode === 'custom') {
            this.otherMode();
        }
    }
    /**
     * @return {?}
     */
    sepiaMode() {
        if (this.stepVal === 0) {
            this.onToggleClick(false);
            this.addDynamicCss('white', 'black');
        }
        if (this.stepVal === 1) {
            this.addDynamicCss(this.sepiaColorCode, 'black');
            document.documentElement.style.setProperty(this.appBackground, this.sepiaColorCode);
            document.documentElement.style.setProperty(this.appForeground, this.sepiaFontColor);
            document.documentElement.style.setProperty(this.componentBackground, this.sepiaColorCode);
            document.documentElement.style.setProperty(this.componentForeground, this.sepiaFontColor);
        }
        if (this.stepVal === 2) {
            this.onToggleClick(true);
            this.addDynamicCss('black', 'white');
        }
    }
    /**
     * @return {?}
     */
    otherMode() {
        if (this.colorData && this.colorData.length > 0) {
            this.colorData.forEach((/**
             * @param {?} element
             * @param {?} index
             * @return {?}
             */
            (element, index) => {
                if (this.stepVal === index) {
                    this.addDynamicCss(element.bgColor, element.fgColor);
                    document.documentElement.style.setProperty(this.appBackground, element.bgColor);
                    document.documentElement.style.setProperty(this.appForeground, element.fgColor);
                    document.documentElement.style.setProperty(this.componentBackground, element.bgColor);
                    document.documentElement.style.setProperty(this.componentForeground, element.fgColor);
                }
            }));
        }
    }
    /**
     * @param {?} ruleText
     * @return {?}
     */
    insertStyleSheetRule(ruleText) {
        /** @type {?} */
        const sheets = document.styleSheets;
        if (sheets.length === 0) {
            /** @type {?} */
            const style = document.createElement('style');
            style.appendChild(document.createTextNode(''));
            document.head.appendChild(style);
        }
        /** @type {?} */
        let isCssAdded = false;
        for (const sh of sheets) {
            /** @type {?} */
            const sheet = sh;
            if (!isCssAdded && (sheet && sheet.href === null && sheet.rules)) {
                try {
                    sheet.insertRule(ruleText, sheet.rules ? sheet.rules.length : sheet.cssRules.length);
                    isCssAdded = true;
                }
                catch (e) {
                }
            }
        }
    }
    /**
     * @param {?} circleColor
     * @param {?} borderColor
     * @return {?}
     */
    addDynamicCss(circleColor, borderColor) {
        this.insertStyleSheetRule('.slider-' + this.shape + '::-webkit-slider-thumb' +
            '{ background:' + circleColor + '!important; border: 1px solid ' + borderColor + ' !important; }');
    }
}
DarkmodeComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-darkmode',
                template: `
      <ng-container *ngIf="mode === 'day-night'">
              <amexio-toggle
              [field-label]="fieldLabel" [size]="size" [type]="type" [shape]="shape" (onChange)="onToggleClick($event)">
              </amexio-toggle>
              </ng-container>
        
              <ng-container *ngIf="mode !== 'day-night'">
              <amexio-slider (ngModelChange) ="onChange($event)" [shape]="shape" [darkmode-slider]="true" min-value="0" [max-value]="maxValue" [step-value]="1" [ngModel]="stepVal">
              </amexio-slider>
              </ng-container>
        
        
    `,
            },] },
];
/** @nocollapse */
DarkmodeComponent.ctorParameters = () => [];
DarkmodeComponent.propDecorators = {
    fieldLabel: [{ type: Input, args: ['field-label',] }],
    shape: [{ type: Input, args: ['shape',] }],
    type: [{ type: Input, args: ['type',] }],
    size: [{ type: Input, args: ['size',] }],
    mode: [{ type: Input, args: ['mode',] }],
    colorData: [{ type: Input, args: ['data',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
// @Component({
//     selector: 'list.base.datepicker',
//     template: './list.base.datepicker.component.html',
// })
/**
 * @template T
 */
class ListBaseDatepickerComponent extends AmexioFormValidator {
    /**
     * @param {?} renderer
     * @param {?} element
     * @param {?} cd
     */
    constructor(renderer, element, cd) {
        super();
        this.renderer = renderer;
        this.element = element;
        this.cd = cd;
        this.self = false;
        this.itemClick = false;
        this.listen = true;
        this.hide();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    focus(event) {
        this.self = true;
        this.dropdownstyle = { visibility: 'visible' };
        this.bindDocumentClickListener();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    blur(event) {
        this.itemClicked();
    }
    /**
     * @return {?}
     */
    itemClicked() {
        this.itemClick = true;
        this.hide();
        this.unbindDocumentClickListener();
        this.clearClicks();
    }
    /**
     * @return {?}
     */
    bindDocumentClickListener() {
        if (!this.documentClickListener && this.listen) {
            this.documentClickListener = this.renderer
                .listen('document', 'click', (/**
             * @param {?} event
             * @return {?}
             */
            (event) => this.handleDocumentListener(event)));
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    handleDocumentListener(event) {
        if (!this.self && !this.itemClick) {
            this.hide();
            this.unbindDocumentClickListener();
        }
        this.clearClicks();
        this.cd.markForCheck();
    }
    /**
     * @return {?}
     */
    clearClicks() {
        this.self = false;
        this.itemClick = false;
    }
    /**
     * @return {?}
     */
    unbindDocumentClickListener() {
        if (this.documentClickListener) {
            this.documentClickListener();
            this.documentClickListener = null;
        }
    }
    /**
     * @return {?}
     */
    hide() {
        if (this.listen) {
            this.dropdownstyle = { visibility: 'hidden' };
        }
    }
    /**
     * @return {?}
     */
    commonDeclaration() {
        this.currrentDate = new Date();
        this.yearList1 =
            [{ year: 0, flag: false, disabled: false },
                { year: 0, flag: false, disabled: false },
                { year: 0, flag: false, disabled: false },
                { year: 0, flag: false, disabled: false },
                { year: 0, flag: false, disabled: false },
            ];
        // generate yearlist1 ids
        this.yearList1.forEach((/**
         * @param {?} yearlist1element
         * @return {?}
         */
        (yearlist1element) => {
            yearlist1element['id'] = window.crypto.getRandomValues(new Uint32Array(1))[0] / 4294967295 + '_id';
        }));
        this.yearList2 = [{ year: 0, flag: false, disabled: false }, { year: 0, flag: false, disabled: false },
            { year: 0, flag: false, disabled: false }, { year: 0, flag: false, disabled: false },
            { year: 0, flag: false, disabled: false }];
        // generate yearlist2 ids
        this.yearList2.forEach((/**
         * @param {?} yearlist2element
         * @return {?}
         */
        (yearlist2element) => {
            yearlist2element['id'] = window.crypto.getRandomValues(new Uint32Array(1))[0] / 4294967295 + '_id';
        }));
        this.monthList1 = [
            { name: 'Jan', flag: false, num: 4, fullname: 'January' },
            { name: 'Feb', flag: false, fullname: 'febuary' },
            { name: 'Mar', flag: false, fullname: 'march' },
            { name: 'Apr', flag: false, fullname: 'april' },
            { name: 'May', flag: false, fullname: 'may' },
            { name: 'Jun', flag: false, fullname: 'june' },
        ];
        // generate id for monthlist1
        this.monthList1.forEach((/**
         * @param {?} monthlist1element
         * @return {?}
         */
        (monthlist1element) => {
            monthlist1element['id'] = window.crypto.getRandomValues(new Uint32Array(1))[0] / 4294967295 + '_id';
        }));
        this.monthList2 = [
            { name: 'Jul', flag: false, fullname: 'july' },
            { name: 'Aug', flag: false, fullname: 'august' },
            { name: 'Sep', flag: false, fullname: 'september' },
            { name: 'Oct', flag: false, fullname: 'october' },
            { name: 'Nov', flag: false, fullname: 'november' },
            { name: 'Dec', flag: false, fullname: 'december' },
        ];
        // generate id for monthlist 2
        this.monthList2.forEach((/**
         * @param {?} monthlist2element
         * @return {?}
         */
        (monthlist2element) => {
            monthlist2element['id'] = window.crypto.getRandomValues(new Uint32Array(1))[0] / 4294967295 + '_id';
        }));
        this.curYear = this.currrentDate.getFullYear();
        /** @type {?} */
        let i = 0;
        /** @type {?} */
        let j = 0;
        for (i = 4; i >= 0; i--) {
            this.yearList1[j].year = this.curYear - i;
            j++;
        }
        j = 0;
        for (i = 1; i <= 5; i++) {
            this.yearList2[j].year = this.curYear + i;
            j++;
        }
    }
    /**
     * @param {?} month
     * @return {?}
     */
    getDropdownMonth(month) {
        this.monthList1.forEach((/**
         * @param {?} element
         * @return {?}
         */
        (element) => {
            this.elementFlagMethod(element);
        }));
        this.monthList2.forEach((/**
         * @param {?} element
         * @return {?}
         */
        (element) => {
            this.elementFlagMethod(element);
        }));
        this.monthList1.forEach((/**
         * @param {?} element
         * @return {?}
         */
        (element) => {
            this.chkMonth(element, month);
        }));
        this.monthList2.forEach((/**
         * @param {?} element
         * @return {?}
         */
        (element) => {
            this.chkMonth(element, month);
        }));
        switch (month.name) {
            case 'Jan':
                this.monthNo = 0;
                break;
            case 'Feb':
                this.monthNo = 1;
                break;
            case 'Mar':
                this.monthNo = 2;
                break;
            case 'Apr':
                this.monthNo = 3;
                break;
            case 'May':
                this.monthNo = 4;
                break;
            case 'Jun':
                this.monthNo = 5;
                break;
            case 'Jul':
                this.monthNo = 6;
                break;
            case 'Aug':
                this.monthNo = 7;
                break;
            case 'Sep':
                this.monthNo = 8;
                break;
            case 'Oct':
                this.monthNo = 9;
                break;
            case 'Nov':
                this.monthNo = 10;
                break;
            case 'Dec':
                this.monthNo = 11;
                break;
            default:
                break;
        }
        this.focus({});
    }
    // Added method to avois recursive code
    /**
     * @param {?} element
     * @return {?}
     */
    elementFlagMethod(element) {
        if (element.flag) {
            element.flag = false;
        }
    }
    // this function broken from chk month getDropdownMonth()
    /**
     * @param {?} element
     * @param {?} month
     * @return {?}
     */
    chkMonth(element, month) {
        if (element.name === month.name) {
            element.flag = true;
        }
    }
    /**
     * @param {?} year
     * @return {?}
     */
    getDropdownYear(year) {
        this.yearList1.forEach((/**
         * @param {?} element
         * @return {?}
         */
        (element) => {
            // negate dropdown year flag
            this.yearFlagNegate(element);
        }));
        this.yearList2.forEach((/**
         * @param {?} element
         * @return {?}
         */
        (element) => {
            // negate dropdown year flag
            this.yearFlagNegate(element);
        }));
        this.yearList1.forEach((/**
         * @param {?} element
         * @return {?}
         */
        (element) => {
            this.yearFlag(element, year);
        }));
        this.yearList2.forEach((/**
         * @param {?} element
         * @return {?}
         */
        (element) => {
            this.yearFlag(element, year);
        }));
        this.yearNo = year.year;
        this.focus({});
    }
    // this function is broken from getDropdownYear
    /**
     * @private
     * @param {?} element
     * @return {?}
     */
    yearFlagNegate(element) {
        this.elementFlagMethod(element);
    }
    // this function is broken from getDropdownYear
    /**
     * @param {?} element
     * @param {?} year
     * @return {?}
     */
    yearFlag(element, year) {
        if (element.year === year.year) {
            element.flag = true;
        }
    }
    /**
     * @return {?}
     */
    getCryptoId() {
        return Math.floor(window.crypto.getRandomValues(new Uint32Array(1))[0]) + '_id';
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/
/** @type {?} */
const noop$9 = (/**
 * @return {?}
 */
() => {
});
class AmexioDateTimePickerComponent extends ListBaseDatepickerComponent {
    /**
     * @param {?} element
     * @param {?} cdf
     * @param {?} renderer
     */
    constructor(element, cdf, renderer) {
        super(renderer, element, cdf);
        this.element = element;
        this.cdf = cdf;
        /*
          Properties
          name : field-label
          datatype : string
          version : 5.5.5 onwards
          default :
          description :The label of this field
          */
        this.placeholder = '';
        /*
           Properties
           name : disabled
           datatype : boolean
           version : 4.1.5 onwards
           default : false
           description : Disable Date/Time Picker field
           */
        this.disabled = false;
        /*
           Properties
           name : diabled-date
           datatype :  any
           version : 4.2 onwards
           default : none
           description : sets disabled dates range
           */
        this.diabledDate = [];
        /*
           Properties
           name : inline-datepicker
           datatype :  boolean
           version : 4.2 onwards
           default : none
           description : sets inline calender
           */
        this.inlineDatepicker = false;
        /*
           Properties
           name : dropdown-datepicker
           datatype :  boolean
           version : 4.2 onwards
           default : none
           description : sets dropdown datepicker
           */
        this.dropdownDatepicker = false;
        /*
           Properties
           name : required
           datatype : boolean
           version : 4.0 onwards
           default : false
           description : Flag to allow blank field or not
           */
        this.required = false;
        /*
           Events
           name : blur
           description : On blur event
           */
        // @Output() blur: EventEmitter<any> = new EventEmitter<any>();
        /*
           Properties
           name : change
           description : On field value change event
           */
        this.change = new EventEmitter();
        /*
           Properties
           name : input
           description : On input event field.
           */
        this.input = new EventEmitter();
        /*
           Properties
           name : focus
           description : On field focus event
           */
        // @Output() focus: EventEmitter<any> = new EventEmitter<any>();
        this.inputtabindex = 0;
        this.daystabindex = -1;
        this.drop = false;
        this.tempFlag = true;
        this.hostFlag = false;
        this.isComponentValid = new EventEmitter();
        this.backArrowFlag = false;
        this.forwardArrowFlag = false;
        this.okispressed = false;
        this.cancelispressed = false;
        // The internal dataviews model
        this.innerValue = '';
        // Placeholders for the callbacks which are later provided
        // by the Control Value Accessor
        this.onTouchedCallback = noop$9;
        this.onChangeCallback = noop$9;
        this.viewmode = '1';
        this.minDate = '';
        this.maxDate = '';
        this.elementId = new Date().getTime() + '';
        this.selectedDate = new Date();
        this.commonDeclaration();
        this.daysTitle = [];
        this.daysArray = [];
        this.timepicker = false;
        this.hrs = this.currrentDate.getHours();
        this.min = this.currrentDate.getMinutes();
        this.initDaysTitle();
        this.createDaysForCurrentMonths(this.currrentDate);
        this.monthList1.forEach((/**
         * @param {?} tmpElement
         * @return {?}
         */
        (tmpElement) => {
        }));
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.inlineDatepicker) {
            this.showToolTip = true;
            this.dropdownstyle = { visibility: 'visible' };
        }
        this.isValid = !this.required;
        this.isComponentValid.emit(!this.required);
        if (this.dateformat != null) {
            this.dateformat = 'dd/MM/yyyy';
        }
        if (this.minDate.length > 0 || this.maxDate.length > 0) {
            this.minMaxDateFound();
        } // main if ends
        // logic for disabling yrs before min and after max
        if (this.minDate.length > 0 || this.maxDate.length > 0) {
            /** @type {?} */
            const min = new Date(this.minDate);
            /** @type {?} */
            const max = new Date(this.maxDate);
            this.yearList1.forEach((/**
             * @param {?} element
             * @return {?}
             */
            (element) => {
                this.disableMinMaxYear(element, min, max);
            }));
            this.yearList2.forEach((/**
             * @param {?} element
             * @return {?}
             */
            (element) => {
                this.disableMinMaxYear(element, min, max);
            }));
        }
    }
    /**
     * @private
     * @return {?}
     */
    initDaysTitle() {
        this.daysTitle.push({ text: 'Mo' });
        this.daysTitle.push({ text: 'Tu' });
        this.daysTitle.push({ text: 'We' });
        this.daysTitle.push({ text: 'Th' });
        this.daysTitle.push({ text: 'Fr' });
        this.daysTitle.push({ text: 'Sa' });
        this.daysTitle.push({ text: 'Su' });
    }
    /**
     * @private
     * @param {?} selectedPeriod
     * @return {?}
     */
    createDaysForCurrentMonths(selectedPeriod) {
        this.daysArray = [];
        /** @type {?} */
        const date = new Date(selectedPeriod.getFullYear(), selectedPeriod.getMonth(), 1, 0, 0, 0, 0);
        // Starting at the 1st of the month
        /** @type {?} */
        const extras = (date.getDay() + 6) % 7;
        date.setDate(date.getDate() - extras); // Skip back to the previous monday
        while (this.daysArray.length < 6) {
            /** @type {?} */
            const rowDays = [];
            for (let i = 0; i < 7; i++) {
                /** @type {?} */
                const day = {
                    date: null, selected: false, isCurrentMonth: null, isDisabled: false,
                };
                day.date = new Date(date.getTime());
                day.isCurrentMonth = (date.getMonth() === selectedPeriod.getMonth());
                day['id'] = this.getCryptoId();
                day['fulldate'] = (day.date).getDate() + ' ' +
                    this.getFullMonthName(day.date) + ' ' + (day.date).getFullYear() +
                    ' ' + this.getFullDayName(day.date);
                if (this.dateModel && (date.getMonth() === this.dateModel.getMonth()) &&
                    (date.getDate() === this.dateModel.getDate())) {
                    day.selected = true;
                }
                else if ((date.getMonth() === this.currrentDate.getMonth()) &&
                    (date.getDate() === this.currrentDate.getDate())) {
                    if (this.dateModel) {
                        day.selected = false;
                        day['tabindex'] = -1;
                    }
                    else {
                        day.selected = true;
                        day['tabindex'] = 1;
                    }
                }
                rowDays.push(day);
                date.setDate(date.getDate() + 1);
            }
            this.daysArray.push(rowDays);
        }
    }
    /**
     * @param {?} recevieddate
     * @return {?}
     */
    getFullMonthName(recevieddate) {
        /** @type {?} */
        const months = ['January', 'Febuary', 'March', 'April', 'May',
            'June', 'July', 'August', 'September', 'October', 'November', 'December'];
        /** @type {?} */
        const datemonth = recevieddate.getMonth();
        /** @type {?} */
        let monthString = '';
        months.forEach((/**
         * @param {?} element
         * @param {?} index
         * @return {?}
         */
        (element, index) => {
            if (datemonth === index) {
                monthString = element;
            }
        }));
        return monthString;
    }
    /**
     * @param {?} receiveddate
     * @return {?}
     */
    getFullDayName(receiveddate) {
        /** @type {?} */
        const weekdays = ['Sunday', 'Monday', 'Tuesday', 'Wednesday',
            'Thursday', 'Friday', 'Saturday'];
        /** @type {?} */
        const day = receiveddate.getDay();
        /** @type {?} */
        let dayname = '';
        weekdays.forEach((/**
         * @param {?} element
         * @param {?} index
         * @return {?}
         */
        (element, index) => {
            if (day === index) {
                dayname = element;
            }
        }));
        return dayname;
    }
    /**
     * @param {?} dateObj
     * @param {?} event
     * @return {?}
     */
    onDateClick(dateObj, event) {
        if (dateObj.isDisabled === false) {
            this.change.emit(dateObj.date);
            if (this.inlineDatepicker === false) {
                super.itemClicked();
            }
            this.hostFlag = true;
            this.selectedDate = dateObj.date;
            this.selectedDate.setHours(this.hrs);
            this.selectedDate.setMinutes(this.min);
            this.resetSelection(dateObj.date);
            this.dateModel = this.selectedDate;
            this.value = this.selectedDate;
            this.isValid = true;
            this.isComponentValid.emit(true);
            if (this.inlineDatepicker) {
                this.showToolTip = true;
            }
            else {
                this.showToolTip = !this.showToolTip;
            }
        }
        else {
            event.stopPropagation();
        }
    }
    /**
     * @param {?} dateObj
     * @return {?}
     */
    resetSelection(dateObj) {
        for (const i of this.daysArray) {
            for (const j of i) {
                /** @type {?} */
                const day = j;
                if (day.date.getTime() === dateObj.getTime()) {
                    day.selected = true;
                }
                else {
                    day.selected = false;
                }
            }
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onInput(event) {
        if (event.target.value != null && event.target.value !== '') {
            /** @type {?} */
            const timeValue = event.target.value.split(':');
            if (timeValue != null) {
                /** @type {?} */
                const hrs = parseInt(timeValue[0].trim(), 10);
                /** @type {?} */
                const mins = parseInt(timeValue[1].trim(), 10);
                this.selectedDate.setHours(hrs);
                this.selectedDate.setMinutes(mins);
                this.hrs = hrs;
                this.min = mins;
                this.value = this.selectedDate;
                event.stopPropagation();
            }
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    nextMonth(event) {
        this.setDateData('plus', 1, event);
        this.disableddays(this.diabledDate);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    prevMonth(event) {
        this.setDateData('minus', 1, event);
        this.disableddays(this.diabledDate);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    nextYear(event) {
        this.setDateData1('plus', 12, event);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    prevYear(event) {
        this.setDateData1('minus', 12, event);
    }
    // this function validates month
    /**
     * @param {?} state1
     * @param {?} mon
     * @param {?} event
     * @return {?}
     */
    setDateData(state1, mon, event) {
        /** @type {?} */
        const d = new Date(this.currrentDate.getFullYear(), this.currrentDate.getMonth(), this.currrentDate.getDate());
        /** @type {?} */
        const min = new Date(this.minDate);
        /** @type {?} */
        const max = new Date(this.maxDate);
        // checks if selected date is within maximum range of month
        if (state1 === 'plus') {
            this.setPlusData(d, max, mon);
        }
        else if (state1 === 'minus') {
            this.setMinusData(d, min, mon);
        }
        this.currrentDate = d;
        this.initDate();
        event.stopPropagation();
    }
    // Set Plus Data
    /**
     * @param {?} d
     * @param {?} max
     * @param {?} mon
     * @return {?}
     */
    setPlusData(d, max, mon) {
        if (this.maxDate.length > 0) {
            if (d.getFullYear() === max.getFullYear()) {
                this.setMaxFullYear(d, max, mon);
            }
            else {
                // logic to chk if year is valid
                if (d.getFullYear() <= max.getFullYear()) {
                    d.setMonth(d.getMonth() + mon);
                }
            }
        }
        else { // outer ends
            d.setMonth(d.getMonth() + mon);
        } // checks if selected date is within minimum range of month
    }
    // Set Max Full Year
    /**
     * @param {?} d
     * @param {?} max
     * @param {?} mon
     * @return {?}
     */
    setMaxFullYear(d, max, mon) {
        if ((d.getMonth() !== max.getMonth()) && d.getFullYear() <= max.getFullYear() && d.getMonth() <= max.getMonth()) {
            d.setMonth(d.getMonth() + mon);
        }
    }
    // Set Minus Data
    /**
     * @param {?} d
     * @param {?} min
     * @param {?} mon
     * @return {?}
     */
    setMinusData(d, min, mon) {
        if (this.minDate.length > 0) {
            if (d.getFullYear() === min.getFullYear()) {
                this.setMinFullYear(d, min, mon);
            }
            else {
                d.setMonth(d.getMonth() - mon);
            }
        }
        else {
            d.setMonth(d.getMonth() - mon);
        }
    }
    // Set Min Full year
    /**
     * @param {?} d
     * @param {?} min
     * @param {?} mon
     * @return {?}
     */
    setMinFullYear(d, min, mon) {
        if ((d.getMonth() !== min.getMonth()) && d.getFullYear() >= min.getFullYear() && d.getMonth() >= min.getMonth()) {
            // logic to chk if year is valid
            d.setMonth(d.getMonth() - mon);
        }
    }
    // this function validates year
    /**
     * @param {?} state1
     * @param {?} mon
     * @param {?} event
     * @return {?}
     */
    setDateData1(state1, mon, event) {
        /** @type {?} */
        const d = new Date(this.currrentDate.getFullYear(), this.currrentDate.getMonth(), this.currrentDate.getDate());
        /** @type {?} */
        const min = new Date(this.minDate);
        /** @type {?} */
        const max = new Date(this.maxDate);
        // checks if selected date is within maximum range of year
        if (state1 === 'plus') {
            if (this.maxDate.length > 0) {
                if (d.getFullYear() <= max.getFullYear() - 1) {
                    d.setMonth(d.getMonth() + mon);
                }
            }
            else {
                d.setMonth(d.getMonth() + mon);
            } // checks if selected date is within minimum range of year
        }
        else if (state1 === 'minus') {
            if (this.minDate.length > 0) {
                if (d.getFullYear() >= min.getFullYear() + 1) {
                    d.setMonth(d.getMonth() - mon);
                }
            }
            else {
                d.setMonth(d.getMonth() - mon);
            }
        }
        this.currrentDate = d;
        this.initDate();
        event.stopPropagation();
    }
    /**
     * @return {?}
     */
    setToday() {
        this.currrentDate = new Date();
        this.initDate();
        this.showToolTip = !this.showToolTip;
    }
    /**
     * @return {?}
     */
    initDate() {
        this.daysArray = [];
        this.createDaysForCurrentMonths(this.currrentDate);
        this.daysArray.forEach((/**
         * @param {?} dayrow
         * @param {?} outerindex
         * @return {?}
         */
        (dayrow, outerindex) => {
            dayrow.forEach((/**
             * @param {?} element
             * @param {?} innerindex
             * @return {?}
             */
            (element, innerindex) => {
                if (this.currrentDate === new Date(element.date)) {
                    /** @type {?} */
                    const itemid = this.daysArray[outerindex][innerindex];
                    document.getElementById(itemid['id']).focus();
                }
            }));
        }));
        this.selectedDate = this.currrentDate;
        this.dateModel = this.selectedDate;
        this.value = this.selectedDate;
        this.innerValue = '';
    }
    /**
     * @param {?} type
     * @param {?} event
     * @return {?}
     */
    plus(type, event) {
        if (type === 'min') {
            if (this.min === 59) {
                this.min = -1;
                this.hrs++;
            }
            this.min++;
        }
        if (type === 'hrs') {
            this.hrs++;
        }
        if (this.hrs === 24) {
            this.hrs = 0;
        }
        this.selectedDate.setHours(this.hrs);
        this.selectedDate.setMinutes(this.min);
        this.value = this.selectedDate;
        this.isValid = true;
        this.isComponentValid.emit(true);
        this.change.emit(this.value);
        event.stopPropagation();
    }
    /**
     * @param {?} type
     * @param {?} event
     * @return {?}
     */
    minus(type, event) {
        if (type === 'min') {
            if (this.min === 0) {
                this.min = 60;
                this.hrs--;
            }
            this.min--;
        }
        if (type === 'hrs') {
            this.hrs--;
        }
        if (this.hrs === 0) {
            this.hrs = 23;
        }
        this.selectedDate.setHours(this.hrs);
        this.selectedDate.setMinutes(this.min);
        this.value = this.selectedDate;
        this.isValid = true;
        this.isComponentValid.emit(true);
        this.change.emit(this.value);
        event.stopPropagation();
    }
    // get accessor
    /**
     * @return {?}
     */
    get value() {
        return this.innerValue;
    }
    // set accessor including call the onchange callback
    /**
     * @param {?} v
     * @return {?}
     */
    set value(v) {
        if (v !== this.innerValue) {
            this.innerValue = v;
            this.onChangeCallback(v);
        }
    }
    // Set touched on blur
    /**
     * @return {?}
     */
    onBlur() {
        this.onTouchedCallback();
    }
    // From ControlValueAccessor interface
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (value !== '') {
            if (value !== this.innerValue) {
                this.validateWriteValue(value);
            }
        }
        else {
            this.dateModel = '';
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    validateWriteValue(value) {
        this.innerValue = value;
        if (this.innerValue instanceof Date || ('number' === typeof this.innerValue)) {
            if (('number' === typeof this.innerValue)) {
                this.innerValue = new Date(this.innerValue);
            }
            this.dateModel = this.innerValue;
            this.currrentDate = this.dateModel;
            this.selectedDate = this.currrentDate;
            this.createDaysForCurrentMonths(this.dateModel);
            if (this.required) {
                this.isValid = true;
            }
        }
        else {
            this.negateisValid();
        }
    }
    /**
     * @return {?}
     */
    negateisValid() {
        this.isValid = false;
        this.hrs = 0;
        this.min = 0;
    }
    // From ControlValueAccessor interface
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChangeCallback = fn;
    }
    // From ControlValueAccessor interface
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouchedCallback = fn;
    }
    /**
     * @param {?} elem
     * @return {?}
     */
    onFocus(elem) {
    }
    /**
     * @param {?} value
     * @return {?}
     */
    onFocusOut(value) {
        if (isNaN(Date.parse(value.value))) {
            this.isValid = false;
            value.value = '';
        }
        else {
            this.value = Date.parse(value.value);
            this.isValid = true;
        }
    }
    /**
     * @param {?} elem
     * @return {?}
     */
    openPicker(elem) {
        this.inputtabindex = -1;
        this.daystabindex = 1;
        if (this.disabled === false) {
            super.focus(elem);
            this.hostFlag = false;
            this.pickerele = elem;
            if (this.inlineDatepicker) {
                this.showToolTip = this.inlineDatepicker;
                this.setFocus();
            }
            else {
                this.showToolTip = true;
            }
            this.posixUp = this.getListPosition(elem);
            /** @type {?} */
            const visibility = this.dropdownstyle.visibility;
            this.dropdownstyle = JSON.parse(JSON.stringify(this.positionClass));
            this.dropdownstyle.visibility = visibility;
            this.dropdownstyle.position = 'fixed';
            this.disableddays(this.diabledDate);
            this.setFocus();
        }
    }
    /**
     * @return {?}
     */
    setFocus() {
        setTimeout((/**
         * @return {?}
         */
        () => {
            // focus code starts
            this.daysArray.forEach((/**
             * @param {?} row
             * @param {?} index
             * @return {?}
             */
            (row, index) => {
                row.forEach((/**
                 * @param {?} day
                 * @param {?} innerindex
                 * @return {?}
                 */
                (day, innerindex) => {
                    if (day.selected) {
                        document.getElementById(day.id).focus();
                    }
                }));
            }));
        }), 0);
    }
    /**
     * @param {?} elementRef
     * @return {?}
     */
    getListPosition(elementRef) {
        /** @type {?} */
        const dropdownHeight = 350;
        if (window.innerHeight - (elementRef.getBoundingClientRect().bottom) < dropdownHeight) {
            this.positionClass = {
                top: ((elementRef.getBoundingClientRect().top - dropdownHeight) + elementRef.getBoundingClientRect().height) + 'px',
            };
            return true;
        }
        else {
            this.positionClass = {
                top: (elementRef.getBoundingClientRect().top + elementRef.getBoundingClientRect().height) + 'px',
            };
            return false;
        }
    }
    /**
     * @return {?}
     */
    onSelect() {
        this.showToolTip = false;
    }
    /**
     * @param {?} days
     * @return {?}
     */
    validateDays(days) {
        /** @type {?} */
        const max = new Date(this.maxDate);
        /** @type {?} */
        const min = new Date(this.minDate);
        // check1: if min max is null return false
        if (this.maxDate.length <= 0 && this.minDate.length <= 0) {
            return false;
        }
        if ((this.maxDate.length > 0 && this.minDate.length <= 0) ||
            (this.maxDate.length > 0 && this.minDate.length > 0)) {
            this.validateMaxDate(days, max);
        }
        if ((this.maxDate.length <= 0 && this.minDate.length > 0) || (this.maxDate.length > 0 && this.minDate.length > 0)) {
            // 3
            if ((days.getDate() < min.getDate() &&
                days.getMonth() === min.getMonth() && days.getFullYear() === min.getFullYear()) ||
                days.getMonth() < min.getMonth() && days.getFullYear() === min.getFullYear()) {
                return true;
                // 4
            }
        }
        this.disableddays(this.diabledDate);
    }
    /**
     * @private
     * @param {?} days
     * @param {?} max
     * @return {?}
     */
    validateMaxDate(days, max) {
        // check if days greater than max return
        // 1
        if ((days.getDate() > max.getDate() &&
            days.getMonth() >= max.getMonth() && days.getFullYear() >= max.getFullYear()) ||
            days.getMonth() > max.getMonth() && days.getFullYear() === max.getFullYear()) {
            return true;
            // 2
        }
    }
    /**
     * @private
     * @param {?} dates
     * @return {?}
     */
    disableddays(dates) {
        if (dates) {
            dates.forEach((/**
             * @param {?} element
             * @return {?}
             */
            (element) => {
                /** @type {?} */
                const From = new Date(element.from);
                /** @type {?} */
                const To = new Date(element.to);
                this.daysArray.forEach((/**
                 * @param {?} element2
                 * @return {?}
                 */
                (element2) => {
                    element2.forEach((/**
                     * @param {?} element1
                     * @return {?}
                     */
                    (element1) => {
                        if (element1.date.getFullYear() <= To.getFullYear() && element1.date.getMonth()
                            <= To.getMonth() && element1.date.getDate() <= To.getDate() && element1.date.getFullYear() >= From.getFullYear() &&
                            element1.date.getMonth() >= From.getMonth() &&
                            element1.date.getDate() >= From.getDate()) {
                            element1.isDisabled = true;
                        }
                    }));
                }));
            }));
        }
    }
    /**
     * @return {?}
     */
    dropdownDatePicker() {
        this.monthList1.forEach((/**
         * @param {?} element
         * @return {?}
         */
        (element) => {
            this.elementFlagMethod(element);
        }));
        this.monthList2.forEach((/**
         * @param {?} element
         * @return {?}
         */
        (element) => {
            this.elementFlagMethod(element);
        }));
        this.yearList1.forEach((/**
         * @param {?} element
         * @return {?}
         */
        (element) => {
            this.elementFlagMethod(element);
        }));
        this.yearList2.forEach((/**
         * @param {?} element
         * @return {?}
         */
        (element) => {
            this.elementFlagMethod(element);
        }));
        this.hostFlag = true;
        this.tempFlag = false;
        this.drop = true;
        super.focus({});
        this.okispressed = false;
        this.cancelispressed = false;
    }
    /**
     * @return {?}
     */
    negateDrop() {
        this.cancelispressed = true;
        this.hostFlag = true;
        this.drop = false;
        this.showToolTip = true;
        this.tempFlag = true;
    }
    /**
     * @return {?}
     */
    navigateDropdown() {
        this.okispressed = true;
        this.hostFlag = true;
        this.selectedDate = new Date();
        if (this.yearNo != null && this.monthNo != null) {
            this.selectedDate.setFullYear(this.yearNo);
            this.selectedDate.setMonth(this.monthNo);
        }
        else if (this.yearNo != null && this.monthNo === null) {
            this.selectedDate.setFullYear(this.yearNo);
        }
        else if (this.yearNo === null && this.monthNo != null) {
            this.selectedDate.setMonth(this.monthNo);
        }
        this.drop = false;
        this.daysArray = [];
        this.createDaysForCurrentMonths(this.selectedDate);
        this.disableddays(this.diabledDate);
        this.tempFlag = true;
        this.cdf.detectChanges();
        this.yearList1.forEach((/**
         * @param {?} element
         * @return {?}
         */
        (element) => {
            this.elementFlagMethod(element);
        }));
        this.yearList2.forEach((/**
         * @param {?} element
         * @return {?}
         */
        (element) => {
            this.elementFlagMethod(element);
        }));
        this.daysArray = [];
        this.createDaysForCurrentMonths(this.selectedDate);
        this.disableddays(this.diabledDate);
        super.focus({});
    }
    /**
     * @return {?}
     */
    cancelDropdown() {
        this.drop = false;
        this.showToolTip = true;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    arrowClickBack(event) {
        /** @type {?} */
        let i;
        // disable flag logic
        this.disableYearFlag();
        if (this.minDate.length > 0 || this.maxDate.length > 0) {
            // arrow click logic
            this.backArrow();
        }
        else {
            for (i = 0; i < 5; i++) {
                this.yearList1[i].year = this.yearList1[i].year - 10;
                this.yearList2[i].year = this.yearList2[i].year - 10;
            } // for ends
        } // main else ends
        // disable flag logic
        this.disableYearFlag();
        // rechking arrow flags after reinitialization of yrlist1 & 2
        this.rechkYearFlag();
        event.stopPropagation();
    }
    // this function is obtained by breaking arrowClickBack() for dropdown year back arrow logic for if
    /**
     * @private
     * @return {?}
     */
    backArrow() {
        /** @type {?} */
        const min = new Date(this.minDate);
        /** @type {?} */
        const max = new Date(this.maxDate);
        this.yearList1.forEach((/**
         * @param {?} element
         * @return {?}
         */
        (element) => {
            if (element.year === min.getFullYear() ||
                (element.year === min.getFullYear() && element.year === max.getFullYear())) {
                this.backArrowFlag = true;
            }
            if (element.year === max.getFullYear() && element.year !== min.getFullYear()) {
                this.forwardArrowFlag = true;
                this.backArrowFlag = false;
            }
            if (element.year !== min.getFullYear() && element.year !== max.getFullYear()) {
                this.forwardArrowFlag = false;
                this.backArrowFlag = false;
            }
        }));
        // resets Arrow Flag
        this.resetYearFlag();
    }
    // this function is broken from resetArrowFlag()
    /**
     * @param {?} element
     * @param {?} min
     * @return {?}
     */
    alterBackArrow(element, min) {
        if (element.year === min.getFullYear()) {
            this.backArrowFlag = true;
        }
    }
    // this function is broken from backArrow() resets Arrow Flag
    /**
     * @private
     * @return {?}
     */
    resetArrowFlag() {
        /** @type {?} */
        const min = new Date(this.minDate);
        /** @type {?} */
        const max = new Date(this.maxDate);
        this.yearList2.forEach((/**
         * @param {?} element
         * @return {?}
         */
        (element) => {
            this.alterBackArrow(element, min);
            if (element.year === max.getFullYear() ||
                (element.year === min.getFullYear() && element.year === max.getFullYear())) {
                this.forwardArrowFlag = true;
            }
        }));
    }
    // this fn is broken from  backArrow() and it resets Year Flag
    /**
     * @return {?}
     */
    resetYearFlag() {
        /** @type {?} */
        let i;
        if (!this.backArrowFlag) {
            for (i = 0; i < 5; i++) {
                this.yearList1[i].year = this.yearList1[i].year - 10;
                this.yearList2[i].year = this.yearList2[i].year - 10;
                this.yearList1[i].disabled = false;
                this.yearList2[i].disabled = false;
            }
        } /* if ends */
    }
    // this function is broken from forwardArrow()
    /**
     * @private
     * @param {?} element
     * @return {?}
     */
    alterBackForwardArrow(element) {
        /** @type {?} */
        const min = new Date(this.minDate);
        /** @type {?} */
        const max = new Date(this.maxDate);
        if (element.year === min.getFullYear()) {
            this.backArrowFlag = true;
        }
        if (element.year === max.getFullYear() ||
            (element.year === min.getFullYear() && element.year === max.getFullYear())) {
            this.forwardArrowFlag = true;
        }
    }
    // this function is obtained by breaking arrowClickForward() for dropdown year forward arrow logic for if
    /**
     * @private
     * @return {?}
     */
    forwardArrow() {
        /** @type {?} */
        let i;
        // chk yearlist1
        this.chkYearList1();
        this.yearList2.forEach((/**
         * @param {?} element
         * @return {?}
         */
        (element) => {
            this.alterBackForwardArrow(element);
        }));
        if (!this.forwardArrowFlag) {
            for (i = 0; i < 5; i++) {
                this.yearList1[i].year = this.yearList1[i].year + 10;
                this.yearList2[i].year = this.yearList2[i].year + 10;
                this.yearList1[i].disabled = false;
                this.yearList2[i].disabled = false;
            } // for ends
        } // if ends
    }
    // chk yearlist1 broken from forwardArrow()
    /**
     * @return {?}
     */
    chkYearList1() {
        /** @type {?} */
        const min = new Date(this.minDate);
        /** @type {?} */
        const max = new Date(this.maxDate);
        this.yearList1.forEach((/**
         * @param {?} element
         * @return {?}
         */
        (element) => {
            if (element.year === min.getFullYear() ||
                (element.year === min.getFullYear() && element.year === max.getFullYear())) {
                this.backArrowFlag = true;
            }
            if (element.year === min.getFullYear() && element.year !== max.getFullYear()) {
                this.forwardArrowFlag = false;
                this.backArrowFlag = true;
            }
            if (element.year !== min.getFullYear() && element.year !== max.getFullYear()) {
                this.forwardArrowFlag = false;
                this.backArrowFlag = false;
            }
            if (element.year === max.getFullYear()) {
                this.forwardArrowFlag = true;
            }
        }));
    }
    // this function is obtained by breaking arrowClickBack() and arrowClickForward()
    // for rechking arrow flags after reinitialization of yrlist1 & 2
    /**
     * @return {?}
     */
    rechkYearFlag() {
        this.yearList1.forEach((/**
         * @param {?} element
         * @return {?}
         */
        (element) => {
            /** @type {?} */
            const min = new Date(this.minDate);
            /** @type {?} */
            const max = new Date(this.maxDate);
            if (element.year === min.getFullYear() ||
                (element.year === min.getFullYear() && element.year === max.getFullYear())) {
                this.backArrowFlag = true;
            }
            if (element.year === max.getFullYear()) {
                this.forwardArrowFlag = true;
            }
            if (element.year !== min.getFullYear() && element.year !== max.getFullYear()) {
                this.forwardArrowFlag = false;
                this.backArrowFlag = false;
            }
        }));
        this.yearList2.forEach((/**
         * @param {?} element
         * @return {?}
         */
        (element) => {
            this.alterBackForwardArrow(element);
        }));
    }
    // this function is broken from disableYearFlag() , here year flag disable altered to true
    /**
     * @param {?} element
     * @return {?}
     */
    yearFlagDisable(element) {
        /** @type {?} */
        const min = new Date(this.minDate);
        /** @type {?} */
        const max = new Date(this.maxDate);
        if (element.year < min.getFullYear() || element.year > max.getFullYear()) {
            element.disabled = true;
        } // if ends
    }
    // this function is obtained by breaking arrowClickBack() and arrowClickForward()
    // for disabling year flag
    /**
     * @return {?}
     */
    disableYearFlag() {
        if (this.minDate.length > 0 || this.maxDate.length > 0) {
            this.yearList1.forEach((/**
             * @param {?} element
             * @return {?}
             */
            (element) => {
                this.yearFlagDisable(element);
            })); // for ends
            this.yearList2.forEach((/**
             * @param {?} element
             * @return {?}
             */
            (element) => {
                this.yearFlagDisable(element);
            })); // for ends
        } // outer if ends
    }
    /**
     * @param {?} event
     * @return {?}
     */
    arrowClickForward(event) {
        /** @type {?} */
        let i;
        // disable flag logic
        this.disableYearFlag();
        if (this.minDate.length > 0 || this.maxDate.length > 0) {
            this.forwardArrow();
        }
        else {
            for (i = 0; i < 5; i++) {
                this.yearList1[i].year = this.yearList1[i].year + 10;
                this.yearList2[i].year = this.yearList2[i].year + 10;
            }
        }
        // disable flag logic
        this.disableYearFlag();
        // rechking arrow flags after reinitialization of yrlist1 & 2
        this.rechkYearFlag();
        event.stopPropagation();
    }
    // onInit Method: If min max date is provided
    /**
     * @return {?}
     */
    minMaxDateFound() {
        /** @type {?} */
        const min = new Date(this.minDate);
        /** @type {?} */
        const max = new Date(this.maxDate);
        this.yearList1.forEach((/**
         * @param {?} element
         * @return {?}
         */
        (element) => {
            if (element.year === min.getFullYear() ||
                (element.year === min.getFullYear() && element.year === max.getFullYear())) {
                this.backArrowFlag = true;
            }
            if (element.year === max.getFullYear()) {
                this.forwardArrowFlag = true;
            }
        }));
        this.yearList2.forEach((/**
         * @param {?} element
         * @return {?}
         */
        (element) => {
            if (element.year === min.getFullYear()) {
                this.backArrowFlag = true;
            }
            if (element.year === max.getFullYear() ||
                (element.year === min.getFullYear() && element.year === max.getFullYear())) {
                this.forwardArrowFlag = true;
            }
        }));
    }
    // Method to disable when min max year provided
    /**
     * @param {?} element
     * @param {?} min
     * @param {?} max
     * @return {?}
     */
    disableMinMaxYear(element, min, max) {
        if (element.year < min.getFullYear() || element.year > max.getFullYear()) {
            element.disabled = true;
        }
    }
    // THIS MEHTOD CHECK INPUT IS VALID OR NOT
    /**
     * @return {?}
     */
    checkValidity() {
        return this.isValid;
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return (this.value || !this.required) ? null : {
            jsonParseError: {
                valid: true,
            },
        };
    }
    /**
     * @param {?} day
     * @param {?} month
     * @param {?} event
     * @return {?}
     */
    arrowright(day, month, event) {
        /** @type {?} */
        let currentindex;
        /** @type {?} */
        let ismonthchanged = false;
        /** @type {?} */
        let drindex;
        month.forEach((/**
         * @param {?} dayrow
         * @param {?} dayrowindex
         * @return {?}
         */
        (dayrow, dayrowindex) => {
            dayrow.forEach((/**
             * @param {?} element
             * @param {?} index
             * @return {?}
             */
            (element, index) => {
                if (day['id'] === element['id']) {
                    if (index < dayrow.length - 1) {
                        currentindex = index + 1;
                        drindex = dayrowindex;
                    }
                    else {
                        if ((dayrowindex === (month.length - 1)) && (index === (dayrow.length - 1))) {
                            this.nextMonth(event);
                            ismonthchanged = true;
                        }
                        else {
                            currentindex = 0;
                            drindex = dayrowindex + 1;
                        }
                    }
                }
            }));
        }));
        this.refactoredRightArrow(ismonthchanged, month, drindex, currentindex);
    }
    /**
     * @param {?} ismonthchanged
     * @param {?} month
     * @param {?} drindex
     * @param {?} currentindex
     * @return {?}
     */
    refactoredRightArrow(ismonthchanged, month, drindex, currentindex) {
        if (!ismonthchanged) {
            this.refactoredFocus(month, drindex, currentindex);
        }
        else {
            this.setFocus();
        }
    }
    /**
     * @param {?} month
     * @param {?} drindex
     * @param {?} currentindex
     * @return {?}
     */
    refactoredFocus(month, drindex, currentindex) {
        /** @type {?} */
        let itemid;
        itemid = month[drindex][currentindex];
        document.getElementById(itemid['id']).focus();
    }
    /**
     * @param {?} day
     * @param {?} month
     * @param {?} event
     * @return {?}
     */
    arrowleft(day, month, event) {
        /** @type {?} */
        let currentindex;
        /** @type {?} */
        let drindex;
        /** @type {?} */
        let ismonthchanged = false;
        month.forEach((/**
         * @param {?} dayrow
         * @param {?} dayrowindex
         * @return {?}
         */
        (dayrow, dayrowindex) => {
            dayrow.forEach((/**
             * @param {?} element
             * @param {?} index
             * @return {?}
             */
            (element, index) => {
                if (day['id'] === element['id']) {
                    if (index > 0) {
                        currentindex = index - 1;
                        drindex = dayrowindex;
                    }
                    else {
                        if (dayrowindex === 0 && index === 0) {
                            this.prevMonth(event);
                            ismonthchanged = true;
                        }
                        else {
                            drindex = dayrowindex - 1;
                            currentindex = 6;
                        }
                    }
                }
            }));
        }));
        this.refactoredarrow(ismonthchanged, month, drindex, currentindex);
    }
    /**
     * @param {?} ismonthchanged
     * @param {?} month
     * @param {?} drindex
     * @param {?} currentindex
     * @return {?}
     */
    refactoredarrow(ismonthchanged, month, drindex, currentindex) {
        /** @type {?} */
        let itemid;
        if (!ismonthchanged) {
            itemid = month[drindex][currentindex];
            document.getElementById(itemid['id']).focus();
        }
        else {
            this.setFocus();
        }
    }
    /**
     * @param {?} day
     * @param {?} month
     * @param {?} event
     * @return {?}
     */
    arrowup(day, month, event) {
        /** @type {?} */
        let isfirstrow = false;
        /** @type {?} */
        let drindex;
        /** @type {?} */
        let currentindex;
        month.forEach((/**
         * @param {?} dayrow
         * @param {?} dayrowindex
         * @return {?}
         */
        (dayrow, dayrowindex) => {
            dayrow.forEach((/**
             * @param {?} element
             * @param {?} index
             * @return {?}
             */
            (element, index) => {
                if (day.id === element.id) {
                    if (dayrowindex === 0) {
                        isfirstrow = true;
                        this.prevMonth(event);
                    }
                    else {
                        drindex = dayrowindex - 1;
                        currentindex = index;
                    }
                }
            }));
        }));
        if (!isfirstrow) {
            /** @type {?} */
            let itemid;
            itemid = this.daysArray[drindex][currentindex];
            document.getElementById(itemid['id']).focus();
        }
        else {
            this.setFocus();
        }
    }
    /**
     * @param {?} day
     * @param {?} month
     * @param {?} event
     * @return {?}
     */
    arrowdown(day, month, event) {
        /** @type {?} */
        let islastrow = false;
        /** @type {?} */
        let drindex;
        /** @type {?} */
        let currentindex;
        month.forEach((/**
         * @param {?} dayrow
         * @param {?} dayrowindex
         * @return {?}
         */
        (dayrow, dayrowindex) => {
            dayrow.forEach((/**
             * @param {?} element
             * @param {?} index
             * @return {?}
             */
            (element, index) => {
                if (day.id === element.id) {
                    if (dayrowindex === (month.length - 1)) {
                        islastrow = true;
                        this.nextMonth(event);
                    }
                    else {
                        drindex = dayrowindex + 1;
                        currentindex = index;
                    }
                }
            }));
        }));
        if (!islastrow) {
            /** @type {?} */
            let itemid;
            itemid = this.daysArray[drindex][currentindex];
            document.getElementById(itemid['id']).focus();
        }
        else {
            this.setFocus();
        }
    }
    /**
     * @param {?} currentmonth
     * @return {?}
     */
    dropdownListOneArrowDown(currentmonth) {
        /** @type {?} */
        let focusindex;
        /** @type {?} */
        let islast = false;
        this.monthList1.forEach((/**
         * @param {?} element
         * @param {?} index
         * @return {?}
         */
        (element, index) => {
            if (element.id === currentmonth.id) {
                if (index !== (this.monthList1.length - 1)) {
                    focusindex = index + 1;
                }
                else {
                    islast = true;
                }
            }
        }));
        /** @type {?} */
        let itemid;
        if (!islast) {
            itemid = this.monthList1[focusindex];
            document.getElementById(itemid['id']).focus();
        }
        else {
            itemid = this.monthList2[0];
            document.getElementById(itemid['id']).focus();
        }
    }
    /**
     * @param {?} currentmonth
     * @return {?}
     */
    dropdownListOneArrowUp(currentmonth) {
        /** @type {?} */
        let focusindex;
        /** @type {?} */
        let isfirst = false;
        this.monthList1.forEach((/**
         * @param {?} elementmonthList1
         * @param {?} index
         * @return {?}
         */
        (elementmonthList1, index) => {
            if (elementmonthList1.id === currentmonth.id) {
                if (index > 0) {
                    focusindex = index - 1;
                }
                else {
                    isfirst = true;
                }
            }
        }));
        /** @type {?} */
        let itemid;
        if (!isfirst) {
            itemid = this.monthList1[focusindex];
        }
        else {
            itemid = this.monthList2[this.monthList2.length - 1];
        }
        document.getElementById(itemid['id']).focus();
    }
    /**
     * @param {?} currentmonth
     * @return {?}
     */
    dropdownListTwoArrowDown(currentmonth) {
        /** @type {?} */
        let focusindex;
        /** @type {?} */
        let islast = false;
        this.monthList2.forEach((/**
         * @param {?} element
         * @param {?} index
         * @return {?}
         */
        (element, index) => {
            if (element.id === currentmonth.id) {
                if (index !== (this.monthList2.length - 1)) {
                    focusindex = index + 1;
                }
                else {
                    islast = true;
                }
            }
        }));
        /** @type {?} */
        let itemid;
        if (!islast) {
            itemid = this.monthList2[focusindex];
        }
        else {
            itemid = this.monthList1[0];
        }
        document.getElementById(itemid['id']).focus();
    }
    /**
     * @param {?} currentmonth
     * @return {?}
     */
    dropdownListTwoArrowUp(currentmonth) {
        /** @type {?} */
        let focusindex;
        /** @type {?} */
        let isfirst = false;
        this.monthList2.forEach((/**
         * @param {?} element
         * @param {?} index
         * @return {?}
         */
        (element, index) => {
            if (element.id === currentmonth.id) {
                if (index > 0) {
                    focusindex = index - 1;
                }
                else {
                    isfirst = true;
                }
            }
        }));
        /** @type {?} */
        let itemid;
        if (!isfirst) {
            itemid = this.monthList2[focusindex];
        }
        else {
            itemid = this.monthList1[this.monthList1.length - 1];
        }
        document.getElementById(itemid['id']).focus();
    }
    /**
     * @param {?} currentyear
     * @return {?}
     */
    yearList1ArrowDown(currentyear) {
        /** @type {?} */
        let focusindex;
        /** @type {?} */
        let islast = false;
        this.yearList1.forEach((/**
         * @param {?} element
         * @param {?} index
         * @return {?}
         */
        (element, index) => {
            if (element.id === currentyear.id) {
                if (index !== (this.yearList1.length - 1)) {
                    focusindex = index + 1;
                }
                else {
                    islast = true;
                }
            }
        }));
        /** @type {?} */
        let itemid;
        if (!islast) {
            itemid = this.yearList1[focusindex];
        }
        else {
            itemid = this.yearList2[0];
        }
        document.getElementById(itemid['id']).focus();
    }
    /**
     * @param {?} currentyear
     * @return {?}
     */
    yearList2ArrowDown(currentyear) {
        /** @type {?} */
        let focusindex;
        /** @type {?} */
        let islast = false;
        this.yearList2.forEach((/**
         * @param {?} element
         * @param {?} index
         * @return {?}
         */
        (element, index) => {
            if (element.id === currentyear.id) {
                if (index !== (this.yearList2.length - 1)) {
                    focusindex = index + 1;
                }
                else {
                    islast = true;
                }
            }
        }));
        /** @type {?} */
        let itemid;
        if (!islast) {
            itemid = this.yearList2[focusindex];
        }
        else {
            itemid = this.yearList1[0];
        }
        document.getElementById(itemid['id']).focus();
    }
    /**
     * @param {?} currentyear
     * @return {?}
     */
    yearList1ArrowUp(currentyear) {
        /** @type {?} */
        let focusindex;
        /** @type {?} */
        let isfirst = false;
        this.yearList1.forEach((/**
         * @param {?} elementyearList1
         * @param {?} index
         * @return {?}
         */
        (elementyearList1, index) => {
            if (elementyearList1.id === currentyear.id) {
                if (index !== 0) {
                    focusindex = index - 1;
                }
                else {
                    isfirst = true;
                }
            }
        }));
        /** @type {?} */
        let itemid;
        if (!isfirst) {
            itemid = this.yearList1[focusindex];
        }
        else {
            itemid = this.yearList2[this.yearList2.length - 1];
        }
        document.getElementById(itemid['id']).focus();
    }
    /**
     * @param {?} currentyear
     * @return {?}
     */
    yearList2ArrowUp(currentyear) {
        /** @type {?} */
        let focusindex;
        /** @type {?} */
        let isfirst = false;
        this.yearList2.forEach((/**
         * @param {?} element
         * @param {?} index
         * @return {?}
         */
        (element, index) => {
            if (element.id === currentyear.id) {
                if (index !== 0) {
                    focusindex = index - 1;
                }
                else {
                    isfirst = true;
                }
            }
        }));
        /** @type {?} */
        let itemid;
        if (!isfirst) {
            itemid = this.yearList2[focusindex];
        }
        else {
            itemid = this.yearList1[this.yearList1.length - 1];
        }
        document.getElementById(itemid['id']).focus();
    }
    /**
     * @param {?} type
     * @return {?}
     */
    setRoundEdge(type) {
        if (type === 'round-edge') {
            this.roundedgeclass = 'roundEdgeCommonCss';
        }
        else if (type === 'classic') {
            this.roundedgeclass = 'classicCommonCss';
        }
    }
}
AmexioDateTimePickerComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-date-time-picker',
                template: `
    <div id="maindiv" class="{{roundedgeclass}}">
        <div tabindex="{{inputtabindex}}" (keyup.enter)="openPicker(rootDiv)" aria-label="datetimepicker push button" class="inputgroup"
            *ngIf="!inlineDatepicker" #rootDiv>

            <label>
                {{fieldlabel}}
            </label>

            <ng-container *ngIf="datepicker && !timepicker">
                <input tabindex="-1" type="text" #pickerDt value="{{dateModel|date:dateformat}}" [attr.disabled]="disabled ? true: null"
                    [required]="required ? true: null" (blur)="onBlur()" (focus)="onFocus(rootDiv)" (focusout)="onFocusOut(pickerDt)"
                    class="input-control" [ngStyle]="{'cursor': readonly ? 'not-allowed':'pointer'}" [attr.placeholder]="placeholder"
                />
            </ng-container>

            <ng-container *ngIf="timepicker">
                <input type="text" [(ngModel)]="selectedDate" value="{{selectedDate|date:dateformat}} {{hrs + ' : ' + min}}" [attr.disabled]="disabled ? true: null"
                    [attr.required]="required ? true: null" (blur)="onBlur()" (focus)="onFocus(rootDiv)" (input)="onInput($event)"
                    (change)="change.emit()" class="input-control" [ngStyle]="{'cursor': readonly ? 'not-allowed':'pointer'}" [attr.placeholder]="placeholder"
                />
            </ng-container>

            <div class="drodown-caret-down" [ngStyle]="{'cursor':disabled ? 'not-allowed' : 'pointer'}" (click)="openPicker(rootDiv)">
                <ng-container *ngIf="timepicker">
                    <span tabindex="1" (keyup.enter)="openPicker(rootDiv)" aria-label="timepicker push button">
                        <amexio-c-icon key="datepicker-clock-icon"></amexio-c-icon>
                    </span>
                </ng-container>
                <ng-container *ngIf="!timepicker">
                    <span>
                        <amexio-c-icon key="datepicker_calendar"></amexio-c-icon>
                    </span>

                </ng-container>

            </div>


        </div>


        <div [@changeState]="dropdownstyle.visibility" [ngStyle]="dropdownstyle" [ngClass]="{'datetimepicker1':inlineDatepicker , 'datetimepicker':!inlineDatepicker}">
            <!-- datepicker starts -->
            <span aria-label="datepicker window opened " class={{roundedgeclass}}>
                <div aria-label="datetimepicker header" class="datetimepickertopbar" aria-label="datepicker header" [ngStyle]="{'display': datepicker ? 'block' : 'none'}">
                    <ul>
                        <li class="prev">
                            <span tabindex="1" aria-label="previous year push button" (keyup.enter)="prevYear($event)">
                                <amexio-c-icon key="datepicker_previous_fast" (onClick)="prevYear($event)"></amexio-c-icon>
                            </span>
                            <span tabindex="1" aria-label="previous month push button " (keyup.enter)="prevMonth($event)">
                                <amexio-c-icon key="datepicker_previous" (onClick)="prevMonth($event)"></amexio-c-icon>
                            </span>
                        </li>
                        <li class="next">
                            <span tabindex="1" aria-label="next month push button" (keyup.enter)="nextMonth($event)">
                                <amexio-c-icon key="datepicker_next" (onClick)="nextMonth($event)"></amexio-c-icon>
                            </span>
                            <span tabindex="1" aria-label="next year push button" (keyup.enter)="nextYear($event)">
                                <amexio-c-icon key="datepicker_next_fast" (onClick)="nextYear($event)"></amexio-c-icon>
                            </span>
                        </li>
                        <li>
                            <span *ngIf="dropdownDatepicker">
                                <span style="cursor:pointer" (click)="dropdownDatePicker()">
                                    {{selectedDate | date:'MMMM'}}
                                    <br>
                                    <span class="title">{{selectedDate | date:'y'}}</span>
                                </span>
                                <span tabindex="1" aria-label="dropdown datepicker push button" (keyup.enter)="dropdownDatePicker()" (onClick)=" dropdownDatePicker()"
                                    style="cursor:pointer">
                                    <amexio-c-icon key="dropdown_caret" (onClick)="dropdownDatePicker()"></amexio-c-icon>
                                </span>
                            </span>

                            <span *ngIf="!dropdownDatepicker">
                                {{selectedDate | date:'MMMM'}}
                                <br>
                                <span class="title" style="cursor:auto">{{selectedDate | date:'y'}}</span>
                            </span>

                        </li>
                    </ul>
                </div>
                <div *ngIf="!drop">
                    <ul class="weekdays" [ngStyle]="{'display': datepicker ? 'block' : 'none'}">
                        <li *ngFor="let dayTitle of daysTitle">{{dayTitle.text}}</li>
                    </ul>

                    <ul id="{{daystabindex}}" class="days" [ngStyle]="{'display': datepicker ? 'block' : 'none'}">

                        <ng-container *ngFor="let dayArray of daysArray">
                            <li [ngStyle]="{'cursor': disabled ? 'not-allowed' : 'pointer'}" *ngFor="let day of dayArray" (click)="onDateClick(day, $event)"
                                [ngClass]="{'notclickable':disabled}">
                                <span [attr.tabindex]="(day.selected ? 1: -1)" id="{{day.id}}" (keyup.arrowleft)="arrowleft(day,daysArray,$event)" (keyup.arrowright)="arrowright(day,daysArray,$event)"
                                    (keyup.arrowdown)="arrowdown(day,daysArray,$event)" (keyup.arrowup)="arrowup(day,daysArray,$event)"
                                    (keyup.enter)="onDateClick(day, $event)" attr.aria-label="{{day.fulldate}}" (click)="onDateClick(day, $event)"
                                    class="day" [ngClass]="{'active':day.selected, 'currentMonth':day.isCurrentMonth, 'notCurrentMonth':!day.isCurrentMonth,'invaliddays':validateDays(day.date), 'disabled':day.isDisabled}">
                                    {{ day.date | date:'d' }}
                                </span>
                            </li>
                        </ng-container>


                        <li (keyup.enter)="setToday()" class="date-today">
                            <amexio-button type="primary" label="TODAY" (onClick)="setToday()" size="small"></amexio-button>
                        </li>


                    </ul>
                </div>
            </span>
            <!--datepicker ends  -->
            <table  aria-describedby="table" role="none" aria-label="timepicker window opened" tabindex="1" class="table" [ngStyle]="{'display': timepicker ? 'block' : 'none'}"
                style="cursor : pointer;text-align: center;padding: 5px;">
                <!--if picker is true-->
                <tr style="padding: 10px;">
                    <td colspan="2"></td>
                    <td tabindex="1" aria-label="increment hour push button" (keyup.enter)="plus('hrs', $event)" (click)="plus('hrs', $event);">&#9650;</td>
                    <td></td>
                    <td tabindex="1" aria-label="increment minute push button" (keyup.enter)="plus('min', $event)" (click)="plus('min', $event);">&#9650;</td>
                    <td colspan="2"></td>
                </tr>
                <tr tabindex="1" attr.aria-label="{{hrs}} hours {{min}} minutes">
                    <td colspan="2"></td>
                    <td>{{hrs}}</td>
                    <td>:</td>
                    <td>{{min}}</td>
                    <td colspan="2">
                    </td>
                </tr>
                <tr>
                    <td colspan="2"></td>
                    <td tabindex="1" (keyup.enter)="minus('hrs', $event)" aria-label="decrement hour push button" (click)="minus('hrs', $event);">&#9660;</td>
                    <td></td>
                    <td tabindex="1" (keyup.enter)="minus('min', $event)" aria-label="decrement min push button" (click)="minus('min', $event);">&#9660;</td>
                    <td colspan="2">
                    </td>
                </tr>

            </table>

            <!--dropdown datepicker -->
            <div [ngStyle]="positionClass" class="datedropdown" *ngIf="drop && !timepicker">

                <div class="dropdiv1">
                    <span tabindex="1" aria-label="month list">

                        <span class="dropspan1">
                            <ul class="dropul1">
                                <li tabindex="1" id={{month.id}} class="li4" (click)="getDropdownMonth(month)" *ngFor="let month of monthList1" attr.aria-label="{{month.fullname}}"
                                    (keyup.arrowdown)="dropdownListOneArrowDown(month)" (keyup.arrowup)="dropdownListOneArrowUp(month)">
                                    <span [ngClass]="{'change4':month.flag}"> {{month.name}}</span>
                                </li>

                            </ul>
                        </span>

                        <span class="dropspan2">
                            <ul class="dropul2">
                                <li class="li4" tabindex="1" id={{month.id}} (click)="getDropdownMonth(month)" *ngFor="let month of monthList2" attr.aria-label="{{month.fullname}}"
                                    (keyup.arrowdown)="dropdownListTwoArrowDown(month)" (keyup.arrowup)="dropdownListTwoArrowUp(month)">
                                    <span [ngClass]="{'change4':month.flag}"> {{month.name}}</span>
                                </li>

                            </ul>
                        </span>

                    </span>

                    <span tabindex="1" aria-label="year list">

                        <span class="dropspan1">
                            <ul class="dropul1">
                                <li tabindex="1" (keyup.enter)="arrowClickBack($event)" id="prevyearbutton" aria-label="previous year list push button" [ngClass]="{ 'disablearrow':backArrowFlag}"
                                    class="dropiconpadding" (click)="arrowClickBack($event)">
                                    <amexio-c-icon key="paginator_first" (onClick)="arrowClickBack($event)"></amexio-c-icon>
                                </li>
                                <li tabindex="1" (keyup.arrowdown)="yearList1ArrowDown(year)" (keyup.arrowup)="yearList1ArrowUp(year)" id="{{year.id}}" [ngClass]="{ 'disablearrow':year.disabled}"
                                    class="li4" (click)="getDropdownYear(year)" *ngFor="let year of yearList1">
                                    <span [ngClass]="{'change4':year.flag && !year.disabled}">
                                        {{year.year}}
                                    </span>
                                </li>


                            </ul>
                        </span>

                        <span class="dropspan4">
                            <ul class="dropul2">

                                <li tabindex="1" (keyup.enter)="arrowClickForward($event)" id="nextyearbutton" aria-label="next year list push button" [ngClass]="{ 'disablearrow':forwardArrowFlag}"
                                    class="dropiconpadding" (click)="arrowClickForward($event)">
                                    <amexio-c-icon key="paginator_last" (onClick)="arrowClickForward($event)"></amexio-c-icon>
                                </li>
                                <li tabindex="1" (keyup.arrowdown)="yearList2ArrowDown(year)" (keyup.arrowup)="yearList2ArrowUp(year)" id="{{year.id}}" [ngClass]="{ 'disablearrow ':year.disabled}"
                                    class="li4" (click)="getDropdownYear(year)" *ngFor="let year of yearList2">
                                    <span [ngClass]="{'change4':year.flag && !year.disabled}">
                                        {{year.year}}
                                    </span>
                                </li>

                            </ul>
                        </span>

                    </span>
                </div>
                <div class="btndiv1">
                    <span class="dropbtnspan">
                        <button tabindex="1" role="button" [attr.aria-pressed]="okispressed" (click)="navigateDropdown()" class="datedropbtn">
                            ok
                        </button>
                        <button tabindex="1" role="button" [attr.aria-pressed]="cancelispressed" class="datedropbtn" (click)="negateDrop()">
                            cancel
                        </button>
                    </span>
                </div>
            </div>
        </div>
    </div>
  `,
                animations: [
                    trigger('changeState', [
                        state('visible', style({
                            transform: 'scale(1)',
                        })),
                        state('hidden', style({
                            transform: 'scale(0)',
                        })),
                        transition('*=>*', animate('200ms')),
                    ]),
                ],
                providers: [{
                        provide: NG_VALUE_ACCESSOR, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => AmexioDateTimePickerComponent)), multi: true,
                    }, {
                        provide: NG_VALIDATORS, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => AmexioDateTimePickerComponent)), multi: true,
                    }],
            },] },
];
/** @nocollapse */
AmexioDateTimePickerComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: Renderer2 }
];
AmexioDateTimePickerComponent.propDecorators = {
    dateformat: [{ type: Input, args: ['date-format',] }],
    datepicker: [{ type: Input, args: ['date-picker',] }],
    timepicker: [{ type: Input, args: ['time-picker',] }],
    fieldlabel: [{ type: Input, args: ['field-label',] }],
    placeholder: [{ type: Input, args: ['place-holder',] }],
    disabled: [{ type: Input, args: ['disabled',] }],
    readonly: [{ type: Input, args: ['read-only',] }],
    minDate: [{ type: Input, args: ['min-date',] }],
    maxDate: [{ type: Input, args: ['max-date',] }],
    diabledDate: [{ type: Input, args: ['disabled-date',] }],
    inlineDatepicker: [{ type: Input, args: ['inline-datepicker',] }],
    dropdownDatepicker: [{ type: Input, args: ['dropdown-datepicker',] }],
    required: [{ type: Input }],
    change: [{ type: Output }],
    input: [{ type: Output }],
    isComponentValid: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AmexioDialpadComponent {
    constructor() {
        this.btnArray1 = [0, 1, 2, 3, 4];
        this.btnArray2 = [5, 6, 7, 8, 9];
        this.type2Arr1 = [1, 2, 3];
        this.type2Arr2 = [4, 5, 6];
        this.type2Arr3 = [7, 8, 9];
        this.type3Arr1 = [7, 8, 9];
        this.type3Arr2 = [4, 5, 6];
        this.type3Arr3 = [1, 2, 3];
        this.textType = '';
        this.lastDigit = 0;
        this.value = '';
        this.label = '';
        this.type = '2-rows';
        this.btnType = '';
        this.showpassword = false;
        this.show = false;
        this.iconfeedback = false;
        this.valueChange = new EventEmitter();
        this.onClick = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        console.log('maxlen', this.maxlen, this.minlen);
        if (this.password || this.showpassword) {
            this.textType = 'password';
        }
        else {
            this.textType = 'text';
        }
        // set black cls
        this.cls = 'nonecls';
        if (this.minlen || this.maxlen) {
            this.iconfeedback = true;
        }
        this.randomArr = [];
        if (this.random && (this.type === '2-rows')) {
            this.generateRandomArray();
            if (this.randomArr.length >= 1) {
                this.btnArray1 = [];
                this.btnArray2 = [];
                this.generateTyp1Arr();
            }
        }
        if (this.random && (this.type === 'classic')) {
            // call random function
            this.generateType2Arr();
        }
    }
    /**
     * @return {?}
     */
    generateTyp1Arr() {
        this.randomArr.forEach((/**
         * @param {?} element
         * @param {?} index
         * @return {?}
         */
        (element, index) => {
            if ((index >= 0) && (index < 5)) {
                this.btnArray1.push(element);
            }
            if (index > 4) {
                this.btnArray2.push(element);
            }
        }));
    }
    /**
     * @return {?}
     */
    generateType2Arr() {
        this.generateRandomArray();
        if (this.randomArr.length >= 1) {
            this.type2Arr1 = [];
            this.type2Arr2 = [];
            this.type2Arr3 = [];
            this.generateTyp2Arry();
        }
    }
    /**
     * @return {?}
     */
    generateTyp2Arry() {
        this.randomArr.forEach((/**
         * @param {?} element
         * @param {?} index
         * @return {?}
         */
        (element, index) => {
            if ((index >= 0) && (index < 3)) {
                this.type2Arr1.push(element);
            }
            if ((index > 2) && (index < 6)) {
                this.type2Arr2.push(element);
            }
            if ((index > 5) && (index < 9)) {
                this.type2Arr3.push(element);
            }
        }));
        // initialize last digit
        this.lastDigit = this.randomArr[this.randomArr.length - 1];
    }
    /**
     * @return {?}
     */
    generateRandomArray() {
        /** @type {?} */
        let i = 0;
        /** @type {?} */
        let num;
        for (i = 0; i < 10; i++) {
            num = this.getRandomNumber();
            this.randomArr.push(num);
        }
    }
    /**
     * @return {?}
     */
    validateMinMax() {
        if (this.iconfeedback && this.value) {
            if (this.minlen && this.maxlen) {
                if (this.value.length >= this.minlen && this.value.length <= this.maxlen) {
                    this.isValid = true;
                }
                else {
                    this.isValid = false;
                }
            }
            this.validateMin();
            this.validateMax();
        }
    }
    /**
     * @return {?}
     */
    validateMin() {
        if (this.minlen && (this.maxlen === undefined)) {
            if (this.value.length >= this.minlen) {
                this.isValid = true;
            }
            else {
                this.isValid = false;
            }
        }
    }
    /**
     * @return {?}
     */
    validateMax() {
        if (this.maxlen && (this.minlen === undefined)) {
            if (this.value.length <= this.maxlen) {
                this.isValid = true;
            }
            else {
                this.isValid = false;
            }
        }
    }
    /**
     * @param {?} data
     * @return {?}
     */
    getBtnData(data) {
        this.value = this.value + data;
        this.emitBtnData(data);
        this.valueChange.emit(this.value);
        this.validateMinMax();
        // if isvalid thn set green
        // if isvalid thn set red
        if (this.isValid && this.iconfeedback) {
            this.cls = 'greencls';
        }
        else if (!this.isValid && this.iconfeedback) {
            this.cls = 'redcls';
        }
    }
    /**
     * @return {?}
     */
    eraseData() {
        /** @type {?} */
        let str;
        str = this.value.slice(0, -1);
        this.value = str;
        /** @type {?} */
        const object = { data: this.value };
        this.onClick.emit(object);
        this.valueChange.emit(this.value);
        this.validateMinMax();
        // if isvalid thn set green
        // if !isvalid thn set red
        if (this.isValid && this.iconfeedback) {
            this.cls = 'greencls';
        }
        else if (!this.isValid && this.iconfeedback) {
            this.cls = 'redcls';
        }
        if (this.value.length < 1 && this.iconfeedback) {
            this.isValid = null;
            this.cls = 'redcls';
        }
    }
    /**
     * @param {?} keycode
     * @return {?}
     */
    emitBtnData(keycode) {
        /** @type {?} */
        const obj = { key: keycode, data: this.value };
        this.onClick.emit(obj);
    }
    /**
     * @return {?}
     */
    clearData() {
        this.value = '';
        this.isValid = null;
        /** @type {?} */
        const object = { data: this.value };
        this.onClick.emit(object);
        this.valueChange.emit(this.value);
        // set black class
        if (this.minlen || this.maxlen) {
            this.isValid = null;
            this.cls = 'redcls';
        }
        else {
            this.cls = 'nonecls';
        }
    }
    /**
     * @return {?}
     */
    getRandomNumber() {
        /** @type {?} */
        const min = 0;
        /** @type {?} */
        const max = 10;
        /** @type {?} */
        const num = this.randomInt(min, max);
        /** @type {?} */
        let duplicate = false;
        if (this.randomArr.length > 0) {
            this.randomArr.forEach((/**
             * @param {?} element
             * @return {?}
             */
            (element) => {
                if (num === element) {
                    duplicate = true;
                }
            }));
            if (duplicate) {
                return this.getRandomNumber();
            }
            else {
                return num;
            }
        }
        else {
            return num;
        }
    }
    /**
     * @return {?}
     */
    randomFloat() {
        /** @type {?} */
        const int = window.crypto.getRandomValues(new Uint32Array(1))[0];
        return int / Math.pow(2, 32);
    }
    /**
     * @param {?} min
     * @param {?} max
     * @return {?}
     */
    randomInt(min, max) {
        /** @type {?} */
        const range = max - min;
        return Math.floor(this.randomFloat() * range + min);
    }
    /**
     * @return {?}
     */
    toggleShow() {
        this.show = !this.show;
        if (this.show) {
            this.textType = 'text';
        }
        else {
            this.textType = 'password';
        }
    }
}
AmexioDialpadComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-dial-pad',
                template: `
      <label class="labcolor"> {{label}}</label>
      <span style="display:flex">
        <input class="input-control" [ngClass]="cls" [(ngModel)]="value" style=" margin-bottom: 6px" type="{{textType}}" maxlength="maxlen"
          minlength="minlen" value="{{value}}" readonly>
        <ng-container *ngIf="showpassword">
          <span *ngIf="show" style=" cursor:pointer; border-bottom: 1px solid;margin-bottom: 6px; padding: .375rem 0" [ngClass]="cls"
            (click)="toggleShow()">
            <span>
              <em style="margin-top: 13px;
                    padding-right: 7px;" class="fa fa-eye"></em>
            </span>
          </span>
          <span *ngIf="!show" style="cursor:pointer; border-bottom: 1px solid;margin-bottom: 6px; padding: .375rem 0" [ngClass]="cls"
            (click)="toggleShow()">
            <span>
              <em style="margin-top: 13px;
                    padding-right: 7px;" class="fa fa-eye-slash"></em>
            </span>
          </span>
        </ng-container>
        <ng-container *ngIf="iconfeedback">
          <span style=" border-bottom: 1px solid;margin-bottom: 6px; padding: .375rem 0" [ngClass]="cls">
            <span *ngIf="!isValid && cls == 'redcls'">
              <em class="fa fa-times" style="margin-top: 13px"></em>
            </span>
            <span *ngIf="isValid && cls == 'greencls'">
              <em class="fa fa-check" style="margin-top: 13px"></em>
            </span>
          </span>
        </ng-container>
      </span>
      <ng-container *ngIf="type == '2-rows'">
        <span class="btnspan">
          <span *ngFor="let item of btnArray1" class="btn">
            <button type="button" tabindex="0" (keyup.enter)="getBtnData(item)" [ngClass]="{'rounded': (btnType == 'round')}" class="pointer btncolor"
              (click)="getBtnData(item)">{{item}}</button>
          </span>
          <span class="btn">
            <button type="button" tabindex="0" (keyup.enter)="eraseData()" [ngClass]="{'rounded': (btnType == 'round')}" aria-label="backspace"
              class="fa fa-arrow-left pointer btncolor" (click)="eraseData()">
            </button>
          </span>
        </span>

        <span class="btnspan">
          <span *ngFor="let item of btnArray2" class="btn ">
            <button style="margin-top:8px" tabindex="0" (keyup.enter)="getBtnData(item)" [ngClass]="{'rounded': btnType == 'round'}"
              type="button" class="pointer btncolor" (click)="getBtnData(item)">{{item}}</button>
          </span>
          <span class="btn">
            <button type="button" tabindex="0" (keyup.enter)="clearData()" aria-label="clear data" [ngClass]="{'rounded': (btnType == 'round')}"
              style="margin-top:8px" class="fa fa-eraser pointer btncolor" (click)="clearData()">

            </button>
          </span>
        </span>
      </ng-container>

      <ng-container *ngIf="type == 'classic'">
        <span class="btnspan">
          <span *ngFor="let item of type2Arr1" class="btn">
            <button type="button" tabindex="0" (keyup.enter)="getBtnData(item)" [ngClass]="{'rounded': (btnType == 'round')}" class="pointer btncolor"
              (click)="getBtnData(item)">{{item}}</button>
          </span>
        </span>

        <span class="btnspan">
          <span *ngFor="let item of type2Arr2" class="btn ">
            <button style="margin-top:8px" tabindex="0" (keyup.enter)="getBtnData(item)" [ngClass]="{'rounded': (btnType == 'round')}"
              type="button" class="pointer btncolor" (click)="getBtnData(item)">{{item}}</button>
          </span>
        </span>

        <span class="btnspan">
          <span *ngFor="let item of type2Arr3" class="btn ">
            <button style="margin-top:8px" tabindex="0" (keyup.enter)="getBtnData(item)" [ngClass]="{'rounded': (btnType == 'round')}"
              type="button" class="pointer btncolor" (click)="getBtnData(item)">{{item}}</button>
          </span>

        </span>

        <span class="btnspan">
          <span class="clear-btn">
            <button tabindex="0" (keyup.enter)="clearData()" aria-label="clear data" [ngClass]="{'rounded': (btnType == 'round')}" type="button"
              style="margin-top:10px; width: 42px; height: 35px; left:-1px;" class="fa fa-eraser pointer btncolor" (click)="clearData()">
            </button>
          </span>
          <span class="btn">
            <button style="margin-top:8px" tabindex="0" [ngClass]="{'rounded': (btnType == 'round')}" type="button" class="pointer btncolor"
              (click)="getBtnData(item)">{{lastDigit}}</button>
          </span>

          <span class="clear-btn">
            <button type="button" tabindex="0" (keyup.enter)="eraseData()" aria-label="backspace" [ngClass]="{'rounded': (btnType == 'round')}"
              style="margin-top:10px; width: 42px; height: 35px; left:3px;" class="fa fa-arrow-left pointer btncolor" (click)="eraseData()">
            </button>
          </span>
        </span>

      </ng-container>

      <ng-container *ngIf="type == 'calculator'">
        <span class="btnspan">
          <span *ngFor="let item of type3Arr1" class="btn">
            <button tabindex="0" (keyup.enter)="getBtnData(item)" type="button" [ngClass]="{'rounded': (btnType == 'round')}" class="pointer btncolor"
              (click)="getBtnData(item)">{{item}}</button>
          </span>
        </span>

        <span class="btnspan">
          <span *ngFor="let item of type3Arr2" class="btn ">
            <button tabindex="0" (keyup.enter)="getBtnData(item)" style="margin-top:8px" [ngClass]="{'rounded': (btnType == 'round')}"
              type="button" class="pointer btncolor" (click)="getBtnData(item)">{{item}}</button>
          </span>

        </span>

        <span class="btnspan">
          <span *ngFor="let item of type3Arr3" class="btn ">
            <button tabindex="0" (keyup.enter)="getBtnData(item)" style="margin-top:8px" [ngClass]="{'rounded': (btnType == 'round')}"
              type="button" class="pointer btncolor" (click)="getBtnData(item)">{{item}}</button>
          </span>
        </span>

        <span class="btnspan">

          <span class="clear-btn">
            <button tabindex="0" (keyup.enter)="clearData()" aria-label="clear data" [ngClass]="{'rounded': (btnType == 'round')}" type="button"
              style="margin-top:10px; width: 42px; height: 35px; left:-1px;" class="fa fa-eraser pointer btncolor" (click)="clearData()">
            </button>
          </span>
          <span class="btn">
            <button tabindex="0" (keyup.enter)="getBtnData(item)" style="margin-top:8px" [ngClass]="{'rounded': (btnType == 'round')}"
              type="button" class="pointer btncolor" (click)="getBtnData(item)">{{lastDigit}}</button>
          </span>

          <span class="clear-btn">
            <button tabindex="0" (keyup.enter)="eraseData()" aria-label="backspace" type="button" [ngClass]="{'rounded': (btnType == 'round')}"
              style="margin-top:10px; width: 42px; height: 35px;left: 3px; " class="fa fa-arrow-left pointer btncolor" (click)="eraseData()">
            </button>
          </span>
        </span>

      </ng-container>
    `,
            },] },
];
AmexioDialpadComponent.propDecorators = {
    value: [{ type: Input }],
    label: [{ type: Input, args: ['field-label',] }],
    type: [{ type: Input }],
    random: [{ type: Input }],
    password: [{ type: Input }],
    maxlen: [{ type: Input, args: ['max-length',] }],
    minlen: [{ type: Input, args: ['min-length',] }],
    btnType: [{ type: Input, args: ['button-type',] }],
    showpassword: [{ type: Input, args: ['show-password',] }],
    valueChange: [{ type: Output }],
    onClick: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 Component Name : Amexio  Dropdown Menu
 Component Selector : <amexio-drop-down-menu-items>
 Component Description : Amexio Dropdown component with various modes and configurations .
 */
class AmexioDropDownitemsComponent {
    constructor() {
        /*
           Properties
           name : add-seperator
           datatype :  boolean
           version : 4.2 onwards
           default : false
           description : add divider to the dropdown menu list
           */
        this.onClick = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.iconalign && this.labelalign
            && this.iconalign.toLowerCase() === this.labelalign.toLowerCase()) {
            this.iconalign = null;
            this.labelalign = null;
        }
        else if (this.iconalign && this.iconalign === 'left') {
            this.labelalign = 'right';
            this.iconalign = null;
        }
        else if (this.iconalign && this.iconalign === 'right') {
            this.labelalign = null;
        }
    }
    /**
     * @param {?} clickEvent
     * @return {?}
     */
    onItemClick(clickEvent) {
        this.toggle = false;
        /** @type {?} */
        const e = {
            event: clickEvent,
            this: this,
        };
        this.onClick.emit(e);
    }
}
AmexioDropDownitemsComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-drop-down-menu-item',
                template: `
    <div *ngIf="!(icon && label)"  class="dropdowndivider" style="padding-bottom: 5px;">
      <ng-content></ng-content>
    </div>
    <a  *ngIf=" (icon || label)"   (click)="onItemClick($event)" id={{index}}  [ngStyle]="{'background': selected ? '#ffcccc':''}"  [ngClass]="{'dropdowndivider':separator}">

      <ng-container *ngIf="icon">
        <em [style.float]="iconalign" [ngClass]="icon"></em>
      </ng-container>

      <ng-container *ngIf="label">
        <span [style.float]="labelalign" style="padding: 5px;">
          {{label}}
        </span>
      </ng-container>
    </a>
  `,
            },] },
];
AmexioDropDownitemsComponent.propDecorators = {
    label: [{ type: Input }],
    icon: [{ type: Input }],
    labelalign: [{ type: Input, args: ['label-align',] }],
    iconalign: [{ type: Input, args: ['icon-align',] }],
    separator: [{ type: Input, args: ['separator',] }],
    index: [{ type: Input, args: ['index',] }],
    selected: [{ type: Input, args: ['selected',] }],
    onClick: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AmexioDropDownMenuComponent extends LifeCycleBaseComponent {
    /**
     * @param {?} element
     * @param {?} matchMediaService
     */
    constructor(element, matchMediaService) {
        super();
        this.element = element;
        this.matchMediaService = matchMediaService;
        this.xposition = false;
        /*
           Properties
           name : menu icon
           datatype : string
           version : 4.2 onwards
           default :
           description : icon on menu
           */
        this.downArrowIcon = true;
        /*
           Properties
           name : transparent
           datatype : string
           version : 4.2 onwards
           default :
           description : transparent style for menu
           */
        this.transparent = false;
        this.dropdownmenuindex = -1;
        this.prevdropdownmenuindex = -1;
        this.onClick = new EventEmitter();
        this.optionsCollection = [];
        this.iconalign = 'left';
        this.padding = '5px 10px';
        this.componentId = 'dropdownmenu' + Math.floor(window.crypto.getRandomValues(new Uint32Array(1))[0]);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.data) {
            this.data.forEach((/**
             * @param {?} node
             * @return {?}
             */
            (node) => {
                if (!node.iconalign && this.iconalign) {
                    node.iconalign = this.iconalign;
                }
                if (!node.labelalign) {
                    node.labelalign = 'left';
                }
            }));
            this.generateIndex(this.data);
        }
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.optionsCollection = this.dropdowns.toArray();
        this.optionsCollection.forEach((/**
         * @param {?} node
         * @return {?}
         */
        (node) => node.onClick.subscribe((/**
         * @param {?} eventdata
         * @return {?}
         */
        (eventdata) => {
            this.toggle = false;
        }))));
    }
    /**
     * @param {?} targetElement
     * @return {?}
     */
    onElementOutClick(targetElement) {
        /** @type {?} */
        let parentFound = false;
        while (targetElement !== null && !parentFound) {
            if (targetElement === this.element.nativeElement) {
                parentFound = true;
            }
            targetElement = targetElement.parentElement;
        }
        if (!parentFound) {
            this.toggle = false;
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    showDropDownContent(event) {
        if (this.dropdownmenuindex > -1) {
            this.data[this.dropdownmenuindex]['selected'] = false;
        }
        this.toggle = !this.toggle;
        this.top = event.target.getBoundingClientRect().top + 25;
        if ((this.matchMediaService.browserWindow().innerWidth - event.clientX) < 200) {
            this.xposition = true;
        }
        else {
            this.xposition = false;
        }
        /** @type {?} */
        const inputid = document.getElementById(this.componentId);
        inputid.setAttribute('aria-activedescendant', 'dropdownitem');
        this.dropdownmenuindex = -1;
        this.prevdropdownmenuindex = -1;
    }
    /**
     * @param {?} childposition
     * @param {?} parentIconPosition
     * @return {?}
     */
    getIconPosition(childposition, parentIconPosition) {
        if (childposition.hasOwnProperty('iconalign') && childposition.iconalign !== '') {
            if (childposition.iconalign === 'right') {
                return true;
            }
            else {
                return false;
            }
        }
        else {
            if (parentIconPosition === 'right') {
                return true;
            }
            else {
                return false;
            }
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onDropDownMenuClick(event) {
        this.toggle = false;
        this.onClick.emit(event);
    }
    /**
     * @param {?} childPosition
     * @param {?} parentLabelPosition
     * @return {?}
     */
    getLabelPosition(childPosition, parentLabelPosition) {
        if (childPosition.hasOwnProperty('labelalign') && childPosition.labelalign !== '') {
            if (childPosition.labelalign === 'right') {
                return true;
            }
            else {
                return false;
            }
        }
        else {
            if (parentLabelPosition === 'right') {
                return true;
            }
            else {
                return false;
            }
        }
    }
    // Aria Logic Starts
    /**
     * @param {?} data
     * @return {?}
     */
    generateIndex(data) {
        data.forEach((/**
         * @param {?} element
         * @param {?} index
         * @return {?}
         */
        (element, index) => {
            element['index'] = this.componentId + 'dropdownmenuitem' + index;
            element['selected'] = false;
        }));
    }
    /**
     * @param {?} item
     * @return {?}
     */
    navigateOptions(item) {
        if (item.keyCode === 38) {
            this.upArrowKeyNavigation(item);
        }
        else if (item.keyCode === 40) {
            this.downArrowKeyNavigation(item);
        }
        else if (item.keyCode === 13 && this.dropdownmenuindex > -1) {
            /** @type {?} */
            const emitdata = this.createEmitObject(this.data[this.dropdownmenuindex]);
            /** @type {?} */
            const e = {
                event: item,
                this: emitdata,
            };
            this.onClick.emit(e);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    upArrowKeyNavigation(event) {
        if (this.prevdropdownmenuindex > -1) {
            this.data[this.prevdropdownmenuindex]['selected'] = false;
        }
        this.prevdropdownmenuindex--;
        if (this.prevdropdownmenuindex === -1) {
            this.prevdropdownmenuindex = this.data.length - 1;
            this.dropdownmenuindex = -1;
        }
        this.setAriaActiveDescendant(this.prevdropdownmenuindex);
        if (this.prevdropdownmenuindex === 0) {
            this.dropdownmenuindex = 0;
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    downArrowKeyNavigation(event) {
        if (this.prevdropdownmenuindex > -1) {
            this.data[this.prevdropdownmenuindex]['selected'] = false;
        }
        this.dropdownmenuindex++;
        this.prevdropdownmenuindex = this.dropdownmenuindex;
        if (this.dropdownmenuindex >= this.data.length) {
            this.dropdownmenuindex = 0;
            this.prevdropdownmenuindex = 0;
        }
        this.setAriaActiveDescendant(this.dropdownmenuindex);
    }
    /**
     * @param {?} object
     * @return {?}
     */
    createEmitObject(object) {
        /** @type {?} */
        const obj = {};
        if (object['icon']) {
            obj['icon'] = object['icon'];
        }
        if (object['label']) {
            obj['label'] = object['label'];
        }
        if (object['labelalign']) {
            obj['labelalign'] = object['labelalign'];
        }
        if (object['iconalign']) {
            obj['iconalign'] = object['iconalign'];
        }
        if (object['separator']) {
            obj['separator'] = object['separator'];
        }
        return obj;
    }
    /**
     * @param {?} rowindex
     * @return {?}
     */
    setAriaActiveDescendant(rowindex) {
        this.data[rowindex]['selected'] = true;
        /** @type {?} */
        const inputid = document.getElementById(this.componentId);
        inputid.setAttribute('aria-activedescendant', this.data[rowindex]['index']);
    }
}
AmexioDropDownMenuComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-drop-down-menu',
                template: `

    <div  tabindex="1" id="{{componentId}}" 
    [attr.aria-expanded]="toggle"
    [attr.aria-label]="title"
     role="menu"
    (keyup)="navigateOptions($event)"
    (keyup.enter) ="showDropDownContent($event)"
    (click)="showDropDownContent($event)" class="dropdown-menu {{roundedgeclass}}" 
    [style.padding]="padding"

    [ngStyle]="{'background-color':(transparent)?'white':'null','color':(transparent)?'black':'null' }"
    
    >
    <span *ngIf="title">
        <em *ngIf="icon" style="padding-right: 5px;" [ngClass]="icon">&nbsp;</em>{{title}}&nbsp;
    </span>
    <span *ngIf="!title">
        <em *ngIf="icon" style="padding-right: 5px;" [ngClass]="icon">&nbsp;</em>Title&nbsp;
    </span>


    <ng-container *ngIf="downArrowIcon">
    <em *ngIf="!toggle"  class="fa fa-angle-down "></em>
    <em *ngIf="toggle"  class="fa fa-angle-up "></em>
    </ng-container>

    </div>
    <div  *ngIf="toggle" class="dropdown-menu-content"
    [style.height]="height"   [ngClass]="{'menu-right':xposition}">

    <ng-content></ng-content>
    <div  >
    <span  role="option" tabindex="1"  *ngFor="let node of data"   id="{{node.index}}"  >
    <amexio-drop-down-menu-item   
                              (onClick)="onDropDownMenuClick($event)"  
                              [icon-align]="node.iconalign"
                              [label-align]="node.labelalign"
                              [label]="node.label"
                              [separator]="node.separator"
                              [icon]="node.icon"
                              [index]="node.index" 
                              [selected]="node.selected">
    </amexio-drop-down-menu-item>
    </span>
    </div>
    </div>
  `,
            },] },
];
/** @nocollapse */
AmexioDropDownMenuComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: DeviceQueryService }
];
AmexioDropDownMenuComponent.propDecorators = {
    dropDownMenuLocalData: [{ type: Input }],
    data: [{ type: Input }],
    title: [{ type: Input }],
    icon: [{ type: Input }],
    iconalign: [{ type: Input, args: ['icon-align',] }],
    padding: [{ type: Input }],
    downArrowIcon: [{ type: Input, args: ['down-arrow-icon',] }],
    transparent: [{ type: Input }],
    height: [{ type: Input }],
    onClick: [{ type: Output }],
    dropdowns: [{ type: ContentChildren, args: [AmexioDropDownitemsComponent,] }],
    onElementOutClick: [{ type: HostListener, args: ['document:click', ['$event.target'],] }, { type: HostListener, args: ['document: touchstart', ['$event.target'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/
class AmexioEmailInputComponent extends BaseInputEventComponent {
    constructor() {
        super();
        /*
           Properties
           name : has-label
           datatype : boolean
           version : 4.0 onwards
           default : false
           description : Flag to set label
           */
        this.hasLabel = true;
        this.showToolTip = false;
    }
    /**
     * @return {?}
     */
    get pattern() {
        return this._pattern;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set pattern(value) {
        if (value != null) {
            this._pattern = value;
            this.regEx = new RegExp(this._pattern);
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.name = this.generateName(this.name, this.fieldlabel, 'emailinput');
        this.componentId = this.createCompId('emailinput', this.name);
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return this.isEmailFieldValid() ? null : {
            jsonParseError: {
                valid: true,
            },
        };
    }
}
AmexioEmailInputComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-email-input',
                template: `

    <div class="inputgroup">

      <label *ngIf="hasLabel"  role="email" for="{{componentId}}" id="{{componentId}}" [style.font-style]="fontstyle" [style.font-family]="fontfamily" [style.font-size]="fontsize">
        {{fieldlabel}}
      </label> 

      <input type="email" 

            role="email" 
            tabindex="1"
            id="{{componentId}}" 
            name="emailText"
            attr.aria-labelledby="{{componentId}}"
            aria-describedby="emailDes"
            [attr.aria-disabled]="disabled ? true: null"
            [attr.aria-required]="!allowblank"
            [attr.aria-invalid]="!isValid "



        
             class="input-control"
             [ngClass]="model.touched ? allowblank ? '' : (isValid && model.touched) ? 'input-control-success' : 'input-control-error' :''"
             [(ngModel)]="value"
             (blur)="onBlurEvent()"
             (focus)="onFocusEvent($event)"
             (input)="onEmailInputEvent($event)"
             (change)="onChangeEvent($event)"
             [name]="name"
             [pattern]="regEx"
             [attr.placeholder]="placeholder"
             [attr.disabled] = "disabled ? true: null"
             [required]="!allowblank"/>

             <ng-container *ngIf="iconfeedback">
              <span class="input-control-feedback">
                  <span *ngIf="!isValid && model.touched"><em class="fa fa-times"></em></span>
                  <span *ngIf="isValid && model.touched"><em class="fa fa-check"></em></span>
              </span>
          </ng-container>
    
          <input-help *ngIf="showToolTip && enablepopover"
          id="emailDes" 
          role="tooltip"
          [error-msg]="errormsg">
          </input-help>
     
          <span class="inputfieldbar"></span>
        </div>
  `,
                providers: [{
                        provide: NG_VALUE_ACCESSOR, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => AmexioEmailInputComponent)), multi: true,
                    }, {
                        provide: NG_VALIDATORS, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => AmexioEmailInputComponent)), multi: true,
                    }],
            },] },
];
/** @nocollapse */
AmexioEmailInputComponent.ctorParameters = () => [];
AmexioEmailInputComponent.propDecorators = {
    fieldlabel: [{ type: Input, args: ['field-label',] }],
    hasLabel: [{ type: Input, args: ['has-label',] }],
    allowblank: [{ type: Input, args: ['allow-blank',] }],
    model: [{ type: ViewChild, args: [NgModel,] }],
    placeholder: [{ type: Input, args: ['place-holder',] }],
    disabled: [{ type: Input }],
    iconfeedback: [{ type: Input, args: ['icon-feedback',] }],
    fontstyle: [{ type: Input, args: ['font-style',] }],
    fontfamily: [{ type: Input, args: ['font-family',] }],
    fontsize: [{ type: Input, args: ['font-size',] }],
    errormsg: [{ type: Input, args: ['error-msg',] }],
    pattern: [{ type: Input, args: ['pattern',] }],
    enablepopover: [{ type: Input, args: ['enable-popover',] }],
    name: [{ type: Input, args: ['name',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/
class AmexioFileUploadComponent {
    /**
     * @param {?} dataService
     */
    constructor(dataService) {
        this.dataService = dataService;
        /*
           Events
           name : onRemove
           datatype : any
           version : none
           default :
           description : On remove click event
           */
        this.onRemove = new EventEmitter();
        this.onFileUpload = new EventEmitter();
        this.success = new EventEmitter();
        this.error = new EventEmitter();
        this.uploadedFiles = [];
    }
    /**
     * @return {?}
     */
    ngOnInit() { }
    /**
     * @return {?}
     */
    ngAfterViewInit() { }
    /**
     * @param {?} bytes
     * @param {?} decimals
     * @return {?}
     */
    formatBytes(bytes, decimals) {
        if (bytes === 0) {
            return '0 Bytes';
        }
        /** @type {?} */
        const k = 1024;
        /** @type {?} */
        const dm = decimals || 2;
        // tslint:disable-next-line:one-variable-per-declaration
        /** @type {?} */
        const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
        /** @type {?} */
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onFileDrop(event) {
        event.preventDefault();
        this.dropClass = '';
        /** @type {?} */
        const dt = event.dataTransfer;
        if (dt.items) {
            // Use DataTransferItemList interface to access the file(s)
            // tslint:disable-next-line:prefer-for-of
            for (let i = 0; i < dt.items.length; i++) {
                if (dt.items[i].kind === 'file') {
                    /** @type {?} */
                    const f = dt.items[i].getAsFile();
                    this.uploadFile(f, true);
                }
            }
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onDragOver(event) {
        event.preventDefault();
        this.dropClass = 'drop';
    }
    /**
     * @param {?} filedata
     * @param {?} index
     * @return {?}
     */
    closeFile(filedata, index) {
        this.onRemove.emit({ fileData: filedata });
        this.uploadedFiles.splice(index, 1);
    }
    //  For Uploading files
    /**
     * @param {?} event
     * @param {?} singleFile
     * @return {?}
     */
    uploadFile(event, singleFile) {
        if (singleFile) {
            /** @type {?} */
            const formData = new FormData();
            formData.append(this.paramname, event);
            if (this.httpmethod && this.httpurl) {
                this.dataService
                    .uploadFile(this.httpurl, this.httpmethod, formData)
                    .subscribe((/**
                 * @param {?} response
                 * @return {?}
                 */
                (response) => {
                    this.responseData = response;
                }), (/**
                 * @param {?} error
                 * @return {?}
                 */
                (error) => {
                    this.error.emit(error);
                }), (/**
                 * @return {?}
                 */
                () => {
                    this.success.emit(this.responseData);
                }));
            }
            this.uploadedFiles.push({
                name: event.name,
                size: this.formatBytes(event.size, 2),
            });
        }
        else {
            this.serviceCall(event);
        }
        this.onFileUpload.emit(this.uploadedFiles);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    serviceCall(event) {
        /** @type {?} */
        const fileList = event.target.files != null ? event.target.files : event;
        /** @type {?} */
        const formData = new FormData();
        if (fileList) {
            // tslint:disable-next-line:prefer-for-of
            for (let i = 0; i < fileList.length; i++) {
                if (!this.paramname) {
                    this.paramname = 'file';
                }
                formData.append(this.paramname, fileList[i]);
            }
            this.uploadService(formData);
            if (fileList.length === 1) {
                /** @type {?} */
                const fsize = this.formatBytes(fileList[0].size, 2);
                this.uploadedFiles.push({ name: fileList[0].name, size: fsize });
            }
            else if (fileList.length > 1) {
                // tslint:disable-next-line:prefer-for-of
                for (let i = 0; i < fileList.length; i++) {
                    /** @type {?} */
                    const fsize = this.formatBytes(fileList[i].size, 2);
                    this.uploadedFiles.push({ name: fileList[i].name, size: fsize });
                }
            }
        }
    }
    /**
     * @param {?} formData
     * @return {?}
     */
    uploadService(formData) {
        this.dataService.uploadFile(this.httpurl, this.httpmethod, formData)
            .subscribe((/**
         * @param {?} response
         * @return {?}
         */
        (response) => {
            this.responseData = response;
        }), (/**
         * @param {?} error
         * @return {?}
         */
        (error) => { }), (/**
         * @return {?}
         */
        () => {
        }));
    }
}
AmexioFileUploadComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-fileupload',
                template: `
    <div class='input-group' *ngIf='!droppable'>
        <ng-container *ngIf='fieldlabel'>
            <label for="fileName">{{fieldlabel}}</label>
        </ng-container>
        <ng-container *ngIf='!fieldlabel'>
            <label for="fileName">Choose File</label>
        </ng-container>
        <input type='file' aria-controls="fileUpload" id="fileName" class='input-control' [attr.accept]='filetype' (change)='uploadFile($event,false)' [attr.multiple]='multiplefile' #inp>
    </div>
    <ng-container *ngIf='droppable'>
        <ng-container *ngIf='fieldlabel'>
            <label for="dragFileName">{{fieldlabel}}</label>
        </ng-container>
        <ng-container *ngIf='!fieldlabel'>
            <label for="dragFileName">Drag and Drop Files below</label>
        </ng-container>
        <div class='upload-drop-zone {{dropClass}}' aria-controls="dragFileUpload" id="dragFileName" (drop)='onFileDrop($event)' (dragover)='onDragOver($event)' (dragleave)='dropClass = "";' #drpZone>
            Just drag and drop files here
        </div>
    </ng-container>

    <div class='file-upload-box' style='width: 100%'>
        <ul>
                <li *ngFor='let file of uploadedFiles ; let index = index' class='file-upload-info'>
                        <span class='uploaded-file-name'>({{file.name}} &nbsp; &nbsp; ({{file.size}}) )</span>
                        <amexio-c-icon key='tab_close' class='close-icon' (onClick)='closeFile(file,index)'>
                        </amexio-c-icon>
                    </li>
        </ul>
    </div>
  `,
            },] },
];
/** @nocollapse */
AmexioFileUploadComponent.ctorParameters = () => [
    { type: CommonDataService }
];
AmexioFileUploadComponent.propDecorators = {
    fieldlabel: [{ type: Input, args: ['field-label',] }],
    httpurl: [{ type: Input, args: ['http-url',] }],
    httpmethod: [{ type: Input, args: ['http-method',] }],
    filetype: [{ type: Input, args: ['file-type',] }],
    multiplefile: [{ type: Input, args: ['multiple-file',] }],
    paramname: [{ type: Input, args: ['param-name',] }],
    droppable: [{ type: Input }],
    onRemove: [{ type: Output }],
    onFileUpload: [{ type: Output }],
    success: [{ type: Output }],
    error: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by ketangote on 26/2/2018.
*/
class AmexioFloatingButtonComponent {
    constructor() {
        /*
          Properties
          name : block
          datatype : none
          version : 4.1 onwards
          default : none
          description : Display button as round or square
          */
        this.block = 'circle';
        /*
          Properties
          name : color
          datatype : string
          version : 5.5.4 onwards
          default : white color
          description : sets icon color.
          */
        this.iconcolor = 'white';
        /*
           Properties
           name : bg-color
           datatype : string
           version : 5.5.4 onwards
           default : none
           description : sets background color of floating button.
           */
        this.bgcolor = '';
        /*
          Properties
          name : relative
          datatype : boolean
          version : 4.1 onwards
          default : none
          description : Place floating button at relative position
          */
        this.relative = false;
        /*
          Events
          name : onClick
          datatype : any
          version : none
          default : none
          description : Event is fired when button is click
          */
        this.onClick = new EventEmitter();
        /*
           Properties
           name : absolute
           datatype : boolean
           version : 5.5.5 onwards
           default : none
           description : Place floating button at absolute position
           */
        this.absolute = false;
        this.absoluteposition = false;
        this.ispressed = false;
        this.bgcolorflag = false;
        this.floatingButtonCss = ' floatingbutton-';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.componentId = this.createCompId('floatingBtn');
        this.addCSSClasses();
    }
    // THIS METHOD IS USED FOR SETTING CSS CLASSSES
    /**
     * @return {?}
     */
    addCSSClasses() {
        if (this.top || this.bottom || this.right || this.left) {
            this.absoluteposition = true;
        }
        this.positionclass = '';
        if (this.relative && !this.absolute) {
            this.positionclass = ' floatingbutton-relative ';
            this.top = '';
            this.left = '';
            this.right = '';
            this.bottom = '';
        }
        else if (this.absolute) {
            this.positionclass = 'floatingbutton-absolute ';
        }
        else {
            this.positionclass = ' floatingbutton-fixed ';
        }
        if (!this.absoluteposition && !this.relative) {
            this.btnPositionCss();
        }
        if (this.block === 'circle') {
            this.setCricle();
        }
        else if (this.block === 'square') {
            this.positionclass = this.positionclass + ' floatingbutton-square';
        }
        if (this.bgcolor.length > 1) {
            this.bgcolorflag = true;
            this.type = 'default';
            this.getPositionClass();
        }
        else {
            this.getPositionClass();
        }
        return this.positionclass;
    }
    /**
     * @private
     * @return {?}
     */
    getPositionClass() {
        this.positionclass = this.disabled ? this.positionclass + this.floatingButtonCss + this.type + '-disabled' :
            this.positionclass + this.floatingButtonCss + this.type;
    }
    /**
     * @private
     * @return {?}
     */
    setCricle() {
        if (this.size && (this.size === 'large' || this.size === 'small')) {
            this.positionclass = this.positionclass + ' floatingbutton-circle-' + this.size;
        }
        else {
            this.positionclass = this.positionclass + ' floatingbutton-circle';
        }
        this.label = '';
    }
    // --------------------------------------------------------
    // Method to call css class on the basis of theme color
    // ---------------------------------------------------------------
    // Css on btn position
    /**
     * @return {?}
     */
    btnPositionCss() {
        if (this.verticalposition === null) {
            this.verticalposition = 'top';
        }
        else if (this.horizontalposition === null) {
            this.horizontalposition = 'right';
        }
        this.positionclass = this.positionclass + this.floatingButtonCss +
            this.verticalposition + this.floatingButtonCss + this.horizontalposition +
            ' floatingbutton-default';
    }
    // Method for button click
    /**
     * @param {?} clickEvent
     * @return {?}
     */
    buttonClick(clickEvent) {
        this.ispressed = !this.ispressed;
        if (!this.disabled) {
            this.onClick.emit({ thisObj: this, event: clickEvent });
        }
    }
    /**
     * @param {?} event1
     * @return {?}
     */
    togglebtn(event1) {
        this.ispressed = !this.ispressed;
        if (!this.disabled) {
            this.onClick.emit({ thisObj: this, event: event1 });
        }
    }
    /**
     * @param {?} inputType
     * @return {?}
     */
    createCompId(inputType) {
        return inputType + '_' + window.crypto.getRandomValues(new Uint32Array(1))[0];
    }
}
AmexioFloatingButtonComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-floating-button',
                template: `
    <div [ngClass]="{floatingbtntooltip: tooltip}">
        <div class="floatingbutton" title="" role="button" tabindex="1" [attr.aria-pressed]="ispressed" attr.aria-describedby="{{componentId}}" (keyup.enter)="togglebtn($event)" (keyup.space)="togglebtn($event)" [ngClass]="addCSSClasses()" [ngStyle]="{'top':top,'bottom':bottom,'left':left,'right':right, 'background-color': bgcolorflag ? bgcolor : ''}"
            (click)="buttonClick($event)">
             <amexio-c-icon *ngIf="icon" [customclass]="icon" [color]="iconcolor">
            </amexio-c-icon>
            {{label}}

        </div>
        <span id="{{componentId}}" role="tooltip" *ngIf="tooltip" class="floatingbtntooltiptext">{{tooltip}}</span>

    </div>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush,
            },] },
];
/** @nocollapse */
AmexioFloatingButtonComponent.ctorParameters = () => [];
AmexioFloatingButtonComponent.propDecorators = {
    verticalposition: [{ type: Input, args: ['vertical-position',] }],
    horizontalposition: [{ type: Input, args: ['horizontal-position',] }],
    top: [{ type: Input, args: ['position-top',] }],
    bottom: [{ type: Input, args: ['position-bottom',] }],
    left: [{ type: Input, args: ['position-left',] }],
    right: [{ type: Input, args: ['position-right',] }],
    label: [{ type: Input, args: ['label',] }],
    block: [{ type: Input, args: ['block',] }],
    icon: [{ type: Input, args: ['icon',] }],
    iconcolor: [{ type: Input, args: ['color',] }],
    bgcolor: [{ type: Input, args: ['bg-color',] }],
    type: [{ type: Input, args: ['type',] }],
    disabled: [{ type: Input, args: ['disabled',] }],
    relative: [{ type: Input, args: ['relative',] }],
    onClick: [{ type: Output }],
    size: [{ type: Input, args: ['size',] }],
    tooltip: [{ type: Input, args: ['tool-tip',] }],
    absolute: [{ type: Input, args: ['absolute',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by ketangote on 26/2/2018.
*/
class AmexioFloatingGroupButtonComponent extends ListBaseDatepickerComponent {
    /**
     * @param {?} elementref
     * @param {?} cdf
     * @param {?} renderer
     */
    constructor(elementref, cdf, renderer) {
        super(renderer, elementref, cdf);
        this.elementref = elementref;
        this.cdf = cdf;
        /*
          Properties
          name : relative
          datatype : boolean
          version : 4.1 onwards
          default : none
          description : Place floating buttong at relative position
          */
        this.relative = false;
        /*
          Events
          name : onClick
          datatype : any
          version : none
          default : none
          description : Event is fired when button is click
          */
        this.onClick = new EventEmitter();
        this.togglefloatinggroup = false;
        this.ispressed = false;
        this.color = 'red-color';
        this.datacount = 0;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.dropdownstyle = { visibility: 'hidden' };
        if (this.data && this.data.length > 0) {
            this.datacount = this.data.length;
            this.data.forEach((/**
             * @param {?} node
             * @param {?} index
             * @return {?}
             */
            (node, index) => {
                if (!node['type']) {
                    node['type'] = this.type;
                    node['index'] = index;
                    node['typeclass'] = 'floatingbutton-' + this.type;
                }
                else {
                    node['index'] = index;
                    node['typeclass'] = 'floatingbutton-' + node['type'];
                }
                this.addCssToBtnGroup();
            }));
        }
    }
    /**
     * @return {?}
     */
    addCssToBtnGroup() {
        if (this.data && this.data.length > 0) {
            this.data.forEach((/**
             * @param {?} node
             * @return {?}
             */
            (node) => {
                if (this.size && (this.size === 'large')) {
                    node['typeclass'] = node['typeclass'] + ' floatingbutton-circle-' + this.size;
                }
                if (this.size && (this.size === 'small')) {
                    node['typeclass'] = node['typeclass'] + ' floatingbutton-circle-' + this.size;
                }
                if ((this.size !== 'large') && (this.size !== 'small')) {
                    node['typeclass'] = node['typeclass'] + ' floatingbutton-circle';
                }
            }));
        }
    }
    /**
     * @param {?} clickEvent
     * @return {?}
     */
    buttonClick(clickEvent) {
        this.ispressed = !this.ispressed;
        /** @type {?} */
        const x = clickEvent.currentTarget.getBoundingClientRect().left;
        /** @type {?} */
        const y = clickEvent.currentTarget.getBoundingClientRect().top;
        if (!this.disabled) {
            if (this.size === 'small' && this.floatinggroupposition === 'bottom') {
                this.floatinggroupxposition = (x) + 'px';
                this.floatinggroupyposition = (y + 34) + 'px';
            }
            if (this.size === 'large' && this.floatinggroupposition === 'bottom') {
                this.floatinggroupxposition = (x) + 'px';
                this.floatinggroupyposition = (y + 108) + 'px';
            }
            if (((this.size !== 'large') && (this.size !== 'small')) && this.floatinggroupposition === 'bottom') {
                this.floatinggroupxposition = (x) + 'px';
                this.floatinggroupyposition = (y + 70) + 'px';
            }
            this.floatingBtnGroupTopPostion(event);
            this.toggleVisibility();
            this.togglefloatinggroup = !this.togglefloatinggroup;
            this.onClick.emit({ thisObj: this, event: clickEvent });
        }
    }
    /**
     * @param {?} clickEvent
     * @return {?}
     */
    floatingBtnGroupTopPostion(clickEvent) {
        /** @type {?} */
        const x = clickEvent.currentTarget.getBoundingClientRect().left;
        /** @type {?} */
        const y = clickEvent.currentTarget.getBoundingClientRect().top;
        if (this.size === 'small' && this.floatinggroupposition === 'top') {
            this.floatinggroupxposition = (x) + 'px';
            this.floatinggroupyposition = (y - (38 * this.datacount)) + 'px';
        }
        if (this.size === 'large' && this.floatinggroupposition === 'top') {
            this.floatinggroupxposition = (x) + 'px';
            this.floatinggroupyposition = (y - (108 * this.datacount)) + 'px';
        }
        if (((this.size !== 'large') && (this.size !== 'small')) && this.floatinggroupposition === 'top') {
            this.floatinggroupxposition = (x) + 'px';
            this.floatinggroupyposition = (y - (80 * this.datacount)) + 'px';
        }
    }
    /**
     * @return {?}
     */
    toggleVisibility() {
        if (this.dropdownstyle.visibility === 'visible') {
            super.itemClicked();
        }
        else {
            /** @type {?} */
            const event = '';
            super.focus(event);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onFloatingButtonClick(event) {
        this.buttonClick(event.event);
    }
    /**
     * @param {?} node
     * @param {?} clickEvent
     * @return {?}
     */
    onButtonClick(node, clickEvent) {
        this.toggleVisibility();
        this.togglefloatinggroup = !this.togglefloatinggroup;
        this.onClick.emit({ this: node, parent: this, event: clickEvent });
    }
    /**
     * @param {?} ref
     * @return {?}
     */
    arrowDown(ref) {
        /** @type {?} */
        let trefid;
        /** @type {?} */
        const refId = (parseInt(ref.id, 10));
        if (refId === (this.data.length - 1)) {
            trefid = 0;
        }
        else {
            trefid = refId + 1;
        }
        document.getElementById((trefid).toString()).focus();
    }
    /**
     * @param {?} ref
     * @return {?}
     */
    arrowUp(ref) {
        /** @type {?} */
        let trefid;
        /** @type {?} */
        const refId = (parseInt(ref.id, 10));
        if (refId === 0) {
            trefid = this.data.length - 1;
        }
        else {
            trefid = refId - 1;
        }
        document.getElementById((trefid).toString()).focus();
    }
}
AmexioFloatingGroupButtonComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-floating-group-button',
                template: `
 
 
 
 
     <div id="parentdiv" role="menu" [attr.aria-expanded]="togglefloatinggroup"
     tabindex="-1" [attr.aria-pressed]="ispressed">
       <amexio-floating-button 
           (onClick)="onFloatingButtonClick($event)"
           [vertical-position]="verticalposition" 
           [horizontal-position]="horizontalposition"
           [icon]="icon" 
           [type]="type" 
           [disabled]="disabled"
           [size]="size"
           [relative]="relative"
           [position-top]="top"
           [position-bottom]="bottom"
           [position-left]="left" 
           [position-right]="right">
       </amexio-floating-button>
    </div>


    <div 

       class="floatinggroup" 
       *ngIf="togglefloatinggroup"
       tabindex="-1"
       [ngStyle]="{'top':floatinggroupyposition, 'left':floatinggroupxposition}">

       <div #ref attr.id="{{node.index}}" role="button" attr.aria-label="{{node.label}}" role="options"
        class="floatinggroupitems" style= "text-align:center;"

           tabindex="1" *ngFor="let node of data" (keyup.enter)="onButtonClick(node,$event)" (keyup.arrowdown)="arrowDown(ref)"
           (keyup.arrowup)="arrowUp(ref)">
           <div *ngIf="node.icon" role="tooltip"  [ngClass]="node.typeclass" (click)="onButtonClick(node,$event)">
               <amexio-c-icon [customclass]="node.icon">
               </amexio-c-icon>
           </div>
       </div>
    </div> 
  `,
            },] },
];
/** @nocollapse */
AmexioFloatingGroupButtonComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: Renderer2 }
];
AmexioFloatingGroupButtonComponent.propDecorators = {
    verticalposition: [{ type: Input, args: ['vertical-position',] }],
    horizontalposition: [{ type: Input, args: ['horizontal-position',] }],
    top: [{ type: Input, args: ['position-top',] }],
    size: [{ type: Input, args: ['size',] }],
    bottom: [{ type: Input, args: ['position-bottom',] }],
    left: [{ type: Input, args: ['position-left',] }],
    right: [{ type: Input, args: ['position-right',] }],
    icon: [{ type: Input, args: ['icon',] }],
    type: [{ type: Input, args: ['type',] }],
    disabled: [{ type: Input, args: ['disabled',] }],
    relative: [{ type: Input, args: ['relative',] }],
    floatinggroupposition: [{ type: Input, args: ['floating-group-position',] }],
    data: [{ type: Input, args: ['data',] }],
    onClick: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class GeolocComponent {
    constructor() {
        this.getlocation = new EventEmitter();
        this.onfailure = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.getLocation();
    }
    /**
     * @return {?}
     */
    getLocation() {
        if (navigator.geolocation) {
            navigator.
                geolocation.getCurrentPosition((/**
             * @param {?} position
             * @return {?}
             */
            (position) => {
                if (position) {
                    this.getlocation.emit(position);
                }
            }), (/**
             * @param {?} error
             * @return {?}
             */
            (error) => console.log(error)));
        }
        else {
            this.onfailure.emit(-1);
        }
    }
}
GeolocComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-geolocation',
                template: `

    `,
            },] },
];
GeolocComponent.propDecorators = {
    getlocation: [{ type: Output, args: ['onSuccess',] }],
    onfailure: [{ type: Output, args: ['onFailure',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/
class AmexioMultipleDatePickerComponent extends ListBaseDatepickerComponent {
    /**
     * @param {?} element
     * @param {?} cdf
     * @param {?} renderer
     */
    constructor(element, cdf, renderer) {
        super(renderer, element, cdf);
        this.element = element;
        this.cdf = cdf;
        this.numberofmonths = 1;
        /*
         Properties
         name : inline-datepicker
         datatype :  boolean
         version : 4.2 onwards
         default : none
         description : sets inline calender
         */
        this.inlineDatepicker = false;
        /*
           Properties
           name : disabled
           datatype : boolean
           version : 4.1.5 onwards
           default : false
           description : Disable Date/Time Picker field
           */
        this.disabled = false;
        /*
           Properties
           name : min-date
           datatype : string
           version : 4.2 onwards
           default : none
           description : sets minimum date range
           */
        this.minDate = '';
        /*
           Properties
           name : max-date
           datatype : string
           version : 4.2 onwards
           default : none
           description : sets maximum date range
           */
        this.maxDate = '';
        /*
         Properties
         name : diabled-date
         datatype :  any
         version : 4.2 onwards
         default : none
         description : sets disabled dates range
         */
        this.diabledDate = [];
        this.rangePickerFromDate = new Date();
        this.rangePickerToDate = new Date();
        this.fromdate = new Date();
        this.todate = new Date();
        this.selectedDate = new Date();
        this.datepicker = false;
        this.daysTitle = [];
        this.alterfromdate = false;
        this.altertodate = false;
        this.backarrowflag = false;
        this.forwardarrowflag = false;
        this.fromcardselected = false;
        this.tocardselected = false;
        this.fromtab = false;
        this.totab = false;
        this.totalwidth = 0;
        this.drop = false;
        this.change = new EventEmitter();
        this.completeDaysArray = [];
        this.commonDeclaration();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.currrentDate = new Date();
        /** @type {?} */
        const d = new Date(this.currrentDate);
        /** @type {?} */
        let i;
        for (i = 0; i < this.numberofmonths; i++) {
            /** @type {?} */
            const obj = {};
            if (i === 0) {
                d.setMonth(d.getMonth());
                obj['prevarrow'] = true;
            }
            else {
                d.setMonth(d.getMonth() + 1);
                obj['prevarrow'] = false;
            }
            obj['date'] = new Date(d);
            this.createDaysForCurrentMonths(d);
            obj['montharray'] = this.daysArray;
            obj['month'] = this.getFullMonthName(d);
            obj['year'] = d.getFullYear();
            if (i === (this.numberofmonths - 1)) {
                obj['nextarrow'] = true;
            }
            else {
                obj['nextarrow'] = false;
            }
            this.completeDaysArray.push(obj);
        }
        this.initDaysTitle();
        this.todate.setDate(this.fromdate.getDate() + 7);
        // set from to on completedayarray
        // this.setfromtooncompletedayarray();
        this.calculateMonthBlocks();
        this.fromdate = null;
        this.todate = null;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        // get all values
        if (this.dateRangePickerFlag) {
            this.fromdate = this.rangePickerFromDate;
            this.todate = this.rangePickerToDate;
            this.rangepickerFlag = this.dateRangePickerFlag;
            this.dropdownstyle = { visibility: 'visible' };
            /** @type {?} */
            const elem = '';
            this.openPicker(elem);
            this.resetRange();
            this.setRange();
            this.calculateMonthBlocks();
            this.listen = false;
            this.fromcardselected = true;
            this.fromtab = true;
        }
    }
    /**
     * @return {?}
     */
    setfromtooncompletedayarray() {
        this.completeDaysArray.forEach((/**
         * @param {?} dayarr
         * @return {?}
         */
        (dayarr) => {
            dayarr.montharray.forEach((/**
             * @param {?} individualmonth
             * @return {?}
             */
            (individualmonth) => {
                individualmonth.forEach((/**
                 * @param {?} day
                 * @return {?}
                 */
                (day) => {
                    if ((day.date.getFullYear() === this.fromdate.getFullYear()) &&
                        (day.date.getMonth() === this.fromdate.getMonth()) &&
                        (day.date.getDate() === this.fromdate.getDate())) {
                        day.from = true;
                    }
                    if ((day.date.getFullYear() === this.todate.getFullYear()) &&
                        (day.date.getMonth() === this.todate.getMonth()) &&
                        (day.date.getDate() === this.todate.getDate())) {
                        day.to = true;
                    }
                }));
            }));
        }));
    }
    /**
     * @param {?} elem
     * @param {?} event
     * @return {?}
     */
    fromPicker(elem, event) {
        this.resetDisabledaysBeforeFrom();
        this.calculateMonthBlocks();
        this.fromtab = true;
        this.totab = false;
        this.fromcardselected = true;
        this.tocardselected = false;
        this.dropdownstyle = { visibility: 'visible' };
        this.openPicker(elem);
        this.resetRange();
        this.setRange();
        event.stopPropagation();
    }
    /**
     * @param {?} elem
     * @param {?} event
     * @return {?}
     */
    toPicker(elem, event) {
        this.setDisableDaysBeforeFrom();
        this.fromtab = false;
        this.totab = true;
        this.tocardselected = true;
        this.fromcardselected = false;
        this.dropdownstyle = { visibility: 'visible' };
        this.openPicker(elem);
        this.resetRange();
        this.setRange();
        event.stopPropagation();
    }
    /**
     * @param {?} elem
     * @return {?}
     */
    openPicker(elem) {
        if (this.disabled === false) {
            super.focus(elem);
            this.datepicker = true;
            this.validateMinMaxDate();
            this.disableddays();
            this.validateDaysForMinMax();
            this.clearClicks();
        }
    }
    /**
     * @return {?}
     */
    calculateMonthBlocks() {
        if (!this.rangepickerFlag) {
            /** @type {?} */
            const screenwidth = window.screen.width;
            /** @type {?} */
            const noofmonthblocks = parseInt(JSON.stringify(screenwidth / 290), 10);
            if (this.numberofmonths <= 4) {
                this.totalwidth = this.numberofmonths * 290;
            }
            else {
                this.totalwidth = noofmonthblocks * 290;
            }
        }
        else {
            this.totalwidth = 290;
        }
    }
    /**
     * @param {?} selectedPeriod
     * @return {?}
     */
    createDaysForCurrentMonths(selectedPeriod) {
        this.daysArray = [];
        /** @type {?} */
        const date = new Date(selectedPeriod.getFullYear(), selectedPeriod.getMonth(), 1, 0, 0, 0, 0);
        // Starting at the 1st of the month
        /** @type {?} */
        const extras = (date.getDay() + 6) % 7;
        date.setDate(date.getDate() - extras); // Skip back to the previous monday
        while (this.daysArray.length < 6) {
            /** @type {?} */
            const rowDays = [];
            for (let i = 0; i < 7; i++) {
                /** @type {?} */
                const day = {
                    date: null, selected: false, isCurrentMonth: null, isDisabled: false,
                    from: false, to: false, range: false,
                };
                day.date = new Date(date.getTime());
                day.isCurrentMonth = (date.getMonth() === selectedPeriod.getMonth());
                day['id'] = this.getCryptoId();
                day['fulldate'] = (day.date).getDate() + ' ' +
                    this.getFullMonthName(day.date) + ' ' + (day.date).getFullYear() +
                    ' ' + this.getFullDayName(day.date);
                if (this.dateModel && (date.getMonth() === this.dateModel.getMonth()) &&
                    (date.getDate() === this.dateModel.getDate())) {
                    day.selected = true;
                }
                else if ((date.getMonth() === this.currrentDate.getMonth()) &&
                    (date.getDate() === this.currrentDate.getDate())) {
                    if (this.dateModel) {
                        day.selected = false;
                        day['tabindex'] = -1;
                    }
                    else {
                        day.selected = true;
                        day['tabindex'] = 1;
                    }
                }
                rowDays.push(day);
                date.setDate(date.getDate() + 1);
            }
            this.daysArray.push(rowDays);
        }
    }
    // getFullMonthName
    /**
     * @param {?} recevieddate
     * @return {?}
     */
    getFullMonthName(recevieddate) {
        /** @type {?} */
        const months = ['January', 'Febuary', 'March', 'April', 'May',
            'June', 'July', 'August', 'September', 'October', 'November', 'December'];
        /** @type {?} */
        const datemonth = recevieddate.getMonth();
        /** @type {?} */
        let monthString = '';
        months.forEach((/**
         * @param {?} element
         * @param {?} index
         * @return {?}
         */
        (element, index) => {
            if (datemonth === index) {
                monthString = element;
            }
        }));
        return monthString;
    }
    // getFullDayName
    /**
     * @param {?} receiveddate
     * @return {?}
     */
    getFullDayName(receiveddate) {
        /** @type {?} */
        const weekdays = ['Sunday', 'Monday', 'Tuesday', 'Wednesday',
            'Thursday', 'Friday', 'Saturday'];
        /** @type {?} */
        const day = receiveddate.getDay();
        /** @type {?} */
        let dayname = '';
        weekdays.forEach((/**
         * @param {?} element
         * @param {?} index
         * @return {?}
         */
        (element, index) => {
            if (day === index) {
                dayname = element;
            }
        }));
        return dayname;
    }
    /**
     * @private
     * @return {?}
     */
    initDaysTitle() {
        this.daysTitle.push({ text: 'Mo' });
        this.daysTitle.push({ text: 'Tu' });
        this.daysTitle.push({ text: 'We' });
        this.daysTitle.push({ text: 'Th' });
        this.daysTitle.push({ text: 'Fr' });
        this.daysTitle.push({ text: 'Sa' });
        this.daysTitle.push({ text: 'Su' });
    }
    /**
     * @param {?} days
     * @return {?}
     */
    validateDays(days) {
        this.disableddays();
        this.validateDaysForMinMax();
    }
    /**
     * @return {?}
     */
    setDisableDaysBeforeFrom() {
        if (this.fromdate && !this.rangepickerFlag) {
            this.completeDaysArray.forEach((/**
             * @param {?} daysarray
             * @return {?}
             */
            (daysarray) => {
                daysarray.montharray.forEach((/**
                 * @param {?} dayobject
                 * @return {?}
                 */
                (dayobject) => {
                    dayobject.forEach((/**
                     * @param {?} singleday
                     * @return {?}
                     */
                    (singleday) => {
                        if (singleday.date < this.fromdate) {
                            singleday.isDisabled = true;
                        }
                    }));
                }));
            }));
        }
    }
    /**
     * @return {?}
     */
    resetDisabledaysBeforeFrom() {
        if (this.fromdate && !this.rangepickerFlag) {
            this.completeDaysArray.forEach((/**
             * @param {?} daysarray
             * @return {?}
             */
            (daysarray) => {
                daysarray.montharray.forEach((/**
                 * @param {?} dayobject
                 * @return {?}
                 */
                (dayobject) => {
                    dayobject.forEach((/**
                     * @param {?} singleday
                     * @return {?}
                     */
                    (singleday) => {
                        if (singleday.date < this.fromdate) {
                            singleday.isDisabled = false;
                        }
                    }));
                }));
            }));
        }
        this.disableddays();
    }
    /**
     * @param {?} dateObj
     * @param {?} event
     * @param {?} elem
     * @return {?}
     */
    onDateClick(dateObj, event, elem) {
        // refactored code
        this.setVisibility(dateObj);
        if (dateObj.isDisabled === false) {
            if (this.fromcardselected) {
                this.refactoredOnDateClick(dateObj, event, elem);
                this.onfromCardSelected(dateObj, event, elem);
            }
            if (this.tocardselected) {
                this.onToCardSelected(dateObj, event, elem);
            }
            this.change.emit(dateObj.date);
        }
        else {
            event.stopPropagation();
        }
        this.resetRange();
        this.setRange();
    }
    /**
     * @param {?} dateObj
     * @param {?} event
     * @param {?} elem
     * @return {?}
     */
    refactoredOnDateClick(dateObj, event, elem) {
        if ((this.fromdate == null) && (this.todate == null)) {
            this.clearFrom();
            this.assignFrom(dateObj);
            this.fromdate = dateObj.date;
            this.toPicker(elem, event);
            this.clearTo();
            this.todate = null;
            this.setDisableDaysBeforeFrom();
        }
        else if (this.fromdate && (this.todate == null)) {
            this.clearFrom();
            this.assignFrom(dateObj);
            this.fromdate = dateObj.date;
            this.toPicker(elem, event);
            this.setDisableDaysBeforeFrom();
        }
    }
    /**
     * @param {?} dateObj
     * @param {?} event
     * @param {?} elem
     * @return {?}
     */
    onfromCardSelected(dateObj, event, elem) {
        if (this.fromdate && this.todate) {
            this.clearFrom();
            this.assignFrom(dateObj);
            this.fromdate = dateObj.date;
            if (dateObj.date > this.todate) {
                this.clearTo();
                this.todate = null;
                this.toPicker(elem, event);
                this.setDisableDaysBeforeFrom();
            }
        }
    }
    /**
     * @param {?} dateObj
     * @param {?} event
     * @param {?} elem
     * @return {?}
     */
    onToCardSelected(dateObj, event, elem) {
        if (this.fromdate && (dateObj.date > this.fromdate)) {
            this.clearTo();
            this.assignTo(dateObj);
            this.todate = dateObj.date;
        }
    }
    /**
     * @param {?} dateObj
     * @return {?}
     */
    setVisibility(dateObj) {
        if (this.inlineDatepicker === false) {
            this.dropdownstyle = { visibility: 'visible' };
            event.stopPropagation();
        }
        if (dateObj.date.isDisabled) {
            this.dropdownstyle = { visibility: 'visible' };
            event.stopPropagation();
        }
    }
    /**
     * @param {?} dateObj
     * @return {?}
     */
    fromdateRefactored(dateObj) {
        this.clearFrom();
        this.clearTo();
        this.fromdate = dateObj.date;
        // call assign from flag true of matching dateObj.date
        this.assignFrom(dateObj);
        /** @type {?} */
        const newdate = new Date(this.fromdate);
        newdate.setDate(this.fromdate.getDate() + 1);
        this.todate = newdate;
        /** @type {?} */
        const daysobject = { date: this.todate };
        this.assignTo(daysobject);
    }
    /**
     * @param {?} dateObj
     * @return {?}
     */
    assignFrom(dateObj) {
        // assign from flags
        this.completeDaysArray.forEach((/**
         * @param {?} daysarray
         * @return {?}
         */
        (daysarray) => {
            daysarray.montharray.forEach((/**
             * @param {?} dayobject
             * @return {?}
             */
            (dayobject) => {
                dayobject.forEach((/**
                 * @param {?} singleday
                 * @return {?}
                 */
                (singleday) => {
                    if ((dateObj.date.getFullYear() === singleday.date.getFullYear()) &&
                        (dateObj.date.getMonth() === singleday.date.getMonth()) &&
                        (dateObj.date.getDate() === singleday.date.getDate())) {
                        singleday.from = true;
                    }
                }));
            }));
        }));
    }
    /**
     * @param {?} dateObj
     * @return {?}
     */
    assignTo(dateObj) {
        // assdign to
        this.completeDaysArray.forEach((/**
         * @param {?} daysarrays
         * @return {?}
         */
        (daysarrays) => {
            daysarrays.montharray.forEach((/**
             * @param {?} dayobj
             * @return {?}
             */
            (dayobj) => {
                dayobj.forEach((/**
                 * @param {?} day
                 * @return {?}
                 */
                (day) => {
                    if ((dateObj.date.getFullYear() === day.date.getFullYear()) &&
                        (dateObj.date.getMonth() === day.date.getMonth()) &&
                        (dateObj.date.getDate() === day.date.getDate())) {
                        day.to = true;
                    }
                }));
            }));
        }));
    }
    /**
     * @return {?}
     */
    resetRange() {
        this.completeDaysArray.forEach((/**
         * @param {?} arrays
         * @return {?}
         */
        (arrays) => {
            arrays.montharray.forEach((/**
             * @param {?} dayobj
             * @return {?}
             */
            (dayobj) => {
                dayobj.forEach((/**
                 * @param {?} day
                 * @return {?}
                 */
                (day) => {
                    day.range = false;
                }));
            }));
        }));
    }
    /**
     * @return {?}
     */
    setRange() {
        this.completeDaysArray.forEach((/**
         * @param {?} days
         * @return {?}
         */
        (days) => {
            days.montharray.forEach((/**
             * @param {?} dayobj
             * @return {?}
             */
            (dayobj) => {
                dayobj.forEach((/**
                 * @param {?} day
                 * @return {?}
                 */
                (day) => {
                    if ((day.date > this.fromdate) && (day.date < this.todate)) {
                        day.range = true;
                    }
                }));
            }));
        }));
    }
    /**
     * @return {?}
     */
    disableddays() {
        if (this.diabledDate) {
            this.diabledDate.forEach((/**
             * @param {?} element
             * @return {?}
             */
            (element) => {
                /** @type {?} */
                const From = new Date(element.from);
                /** @type {?} */
                const To = new Date(element.to);
                this.completeDaysArray.forEach((/**
                 * @param {?} dayarr
                 * @return {?}
                 */
                (dayarr) => {
                    dayarr.montharray.forEach((/**
                     * @param {?} weekarr
                     * @return {?}
                     */
                    (weekarr) => {
                        weekarr.forEach((/**
                         * @param {?} day
                         * @return {?}
                         */
                        (day) => {
                            if (day.date.getFullYear() <= To.getFullYear() &&
                                day.date.getMonth() <= To.getMonth() &&
                                day.date.getDate() <= To.getDate() &&
                                day.date.getFullYear() >= From.getFullYear() &&
                                day.date.getMonth() >= From.getMonth() &&
                                day.date.getDate() >= From.getDate()) {
                                day.isDisabled = true;
                            }
                        }));
                    }));
                }));
            }));
        }
    }
    /**
     * @return {?}
     */
    validateDaysForMinMax() {
        this.completeDaysArray.forEach((/**
         * @param {?} dayarr
         * @return {?}
         */
        (dayarr) => {
            dayarr.montharray.forEach((/**
             * @param {?} weekarr
             * @return {?}
             */
            (weekarr) => {
                weekarr.forEach((/**
                 * @param {?} day
                 * @return {?}
                 */
                (day) => {
                    this.refactoredvalidateDaysForMinMax(day);
                }));
            }));
        }));
    }
    /**
     * @param {?} day
     * @return {?}
     */
    refactoredvalidateDaysForMinMax(day) {
        if (this.minDate) {
            /** @type {?} */
            const min = new Date(this.minDate);
            if (day.date < min) {
                day.isDisabled = true;
            }
        }
        if (this.maxDate) {
            /** @type {?} */
            const max = new Date(this.maxDate);
            if (day.date > max) {
                day.isDisabled = true;
            }
        }
    }
    /**
     * @return {?}
     */
    clearFromTo() {
        if (this.alterfromdate) {
            // clear all from flags
            this.completeDaysArray.forEach((/**
             * @param {?} darray
             * @return {?}
             */
            (darray) => {
                darray.montharray.forEach((/**
                 * @param {?} dobject
                 * @return {?}
                 */
                (dobject) => {
                    dobject.forEach((/**
                     * @param {?} sday
                     * @return {?}
                     */
                    (sday) => {
                        sday.from = false;
                    }));
                }));
            }));
        }
        if (this.altertodate) {
            // clear to flag
            this.completeDaysArray.forEach((/**
             * @param {?} daysarray
             * @return {?}
             */
            (daysarray) => {
                daysarray.montharray.forEach((/**
                 * @param {?} dayobject
                 * @return {?}
                 */
                (dayobject) => {
                    dayobject.forEach((/**
                     * @param {?} singleday
                     * @return {?}
                     */
                    (singleday) => {
                        singleday.to = false;
                    }));
                }));
            }));
        }
    }
    /**
     * @return {?}
     */
    clearFrom() {
        // clear all from flags
        this.completeDaysArray.forEach((/**
         * @param {?} daysarray
         * @return {?}
         */
        (daysarray) => {
            daysarray.montharray.forEach((/**
             * @param {?} dayobject
             * @return {?}
             */
            (dayobject) => {
                dayobject.forEach((/**
                 * @param {?} singleday
                 * @return {?}
                 */
                (singleday) => {
                    singleday.from = false;
                }));
            }));
        }));
    }
    /**
     * @return {?}
     */
    clearTo() {
        // clear all to flags
        this.completeDaysArray.forEach((/**
         * @param {?} darr
         * @return {?}
         */
        (darr) => {
            darr.montharray.forEach((/**
             * @param {?} dayobj
             * @return {?}
             */
            (dayobj) => {
                dayobj.forEach((/**
                 * @param {?} singleday
                 * @return {?}
                 */
                (singleday) => {
                    singleday.to = false;
                }));
            }));
        }));
    }
    /**
     * @param {?} operation
     * @param {?} event
     * @return {?}
     */
    updateMonthList(operation, event) {
        event.stopPropagation();
        if ((operation === 'plus') && !this.forwardarrowflag) {
            // call plus function
            this.incrementMonthList(event);
        }
        if ((operation === 'minus') && !this.backarrowflag) {
            // call minus function
            this.decrementMonthList(event);
        }
        this.validateMinMaxDate();
        this.disableddays();
        this.validateDaysForMinMax();
        // call set range
        this.resetRange();
        this.setRange();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    incrementMonthList(event) {
        this.completeDaysArray.forEach((/**
         * @param {?} singleDayArray
         * @return {?}
         */
        (singleDayArray) => {
            /** @type {?} */
            const d = new Date(singleDayArray.date);
            d.setMonth(d.getMonth() + this.numberofmonths);
            this.createDaysForCurrentMonths(d);
            singleDayArray.date = d;
            singleDayArray.montharray = this.daysArray;
            singleDayArray.month = this.getFullMonthName(d);
            singleDayArray.year = d.getFullYear();
        }));
    }
    /**
     * @param {?} event
     * @return {?}
     */
    decrementMonthList(event) {
        this.completeDaysArray.forEach((/**
         * @param {?} singleDayArray
         * @return {?}
         */
        (singleDayArray) => {
            /** @type {?} */
            const d = new Date(singleDayArray.date);
            d.setMonth(d.getMonth() - this.numberofmonths);
            this.createDaysForCurrentMonths(d);
            singleDayArray.date = d;
            singleDayArray.montharray = this.daysArray;
            singleDayArray.month = this.getFullMonthName(d);
            singleDayArray.year = d.getFullYear();
        }));
    }
    /**
     * @return {?}
     */
    validateMinMaxDate() {
        this.backarrowflag = false;
        this.forwardarrowflag = false;
        if (this.minDate.length > 0) {
            this.validateMinDate();
        }
        if (this.maxDate.length > 0) {
            this.validateMaxDate();
        }
    }
    /**
     * @return {?}
     */
    validateMinDate() {
        this.completeDaysArray.forEach((/**
         * @param {?} dayarray
         * @return {?}
         */
        (dayarray) => {
            if ((dayarray.date.getMonth() === new Date(this.minDate).getMonth()) &&
                (dayarray.date.getFullYear() === new Date(this.minDate).getFullYear())) {
                this.backarrowflag = true;
            }
        }));
    }
    /**
     * @return {?}
     */
    validateMaxDate() {
        this.completeDaysArray.forEach((/**
         * @param {?} daysarray
         * @return {?}
         */
        (daysarray) => {
            if ((daysarray.date.getMonth() === new Date(this.maxDate).getMonth()) &&
                (daysarray.date.getFullYear() === new Date(this.maxDate).getFullYear())) {
                this.forwardarrowflag = true;
            }
        }));
    }
    /**
     * @return {?}
     */
    altercompleteDaysArray() {
        this.clearFrom();
        this.clearTo();
        /** @type {?} */
        const frmDateObj = { date: this.fromdate };
        this.assignFrom(frmDateObj);
        /** @type {?} */
        const toDateObj = { date: this.todate };
        this.assignTo(toDateObj);
        this.alterdatesrange();
    }
    /**
     * @return {?}
     */
    alterdatesrange() {
        // clear range flag
        this.resetRange();
        // set range flag
        this.setRange();
    }
    /**
     * @return {?}
     */
    dropdownDatePicker() {
        this.drop = !this.drop;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    arrowClickBack(event) {
        /** @type {?} */
        let i;
        // disable flag logic
        if (this.minDate.length > 0 || this.maxDate.length > 0) {
            // arrow click logic
        }
        else {
            for (i = 0; i < 5; i++) {
                this.yearList1[i].year = this.yearList1[i].year - 10;
                this.yearList2[i].year = this.yearList2[i].year - 10;
            } // for ends
        } // main else ends
        event.stopPropagation();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    arrowClickForward(event) {
        /** @type {?} */
        let i;
        for (i = 0; i < 5; i++) {
            this.yearList1[i].year = this.yearList1[i].year + 10;
            this.yearList2[i].year = this.yearList2[i].year + 10;
        }
        event.stopPropagation();
    }
    /**
     * @return {?}
     */
    navigateDropdown() {
        this.okispressed = true;
        this.selectedDate = new Date();
        if (this.yearNo != null && this.monthNo != null) {
            this.selectedDate.setFullYear(this.yearNo);
            this.selectedDate.setMonth(this.monthNo);
        }
        else if (this.yearNo != null && this.monthNo === null) {
            this.selectedDate.setFullYear(this.yearNo);
        }
        else if (this.yearNo === null && this.monthNo != null) {
            this.selectedDate.setMonth(this.monthNo);
        }
        // chk if yr exist
        this.completeDaysArray.forEach((/**
         * @param {?} element
         * @param {?} index
         * @return {?}
         */
        (element, index) => {
            /** @type {?} */
            const alterDate = new Date(this.selectedDate.getFullYear(), this.selectedDate.getMonth() + index, this.selectedDate.getDate());
            element.date = alterDate;
            this.createDaysForCurrentMonths(element.date);
            element.montharray = this.daysArray;
            element.month = this.getFullMonthName(element.date);
            element.year = element.date.getFullYear();
        }));
        this.drop = false;
        this.validateMinMaxDate();
        this.disableddays();
        this.validateDaysForMinMax();
        // call set range
        this.resetRange();
        this.setRange();
        // this.fromdate
    }
    /**
     * @return {?}
     */
    negateDrop() {
        this.drop = false;
    }
}
AmexioMultipleDatePickerComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-multiple-date-picker',
                template: `
    <div #rootDiv>


        <span *ngIf="!rangepickerFlag" class="mainspan">

            <div (click)="fromPicker(rootDiv, $event)" style=" border-right-style: outset;" class="fromdiv">
                <span class="lbl_text appendButton10 latoBold">
                    {{fromlabel}}
                </span>
                <em class="fa fa-angle-down dropicon"></em>
                <span id="parentdate" class="blackText font20">
                    <span class="font30 lactoBlack">
                        {{fromdate | date :'dd'}}
                    </span>
                    <span class="">
                        {{fromdate | date: 'MMM'}}
                        <ng-container *ngIf="fromdate !== null"> ' </ng-container>
                    </span>
                    <span class="">
                        {{fromdate | date: 'yy'}}
                    </span>
                    <span>
                        <h6 style="padding: 0%; margin:1%; opacity:0.5">
                            {{fromdate | date: 'EEEE'}}
                        </h6>
                    </span>
                </span>

            </div>

            <div [ngClass]="{'disabled':(todate == null)}" (click)="toPicker(rootDiv, $event)" class="fromdiv pointer">
                <span class="lbl_text appendButton10 latoBold">
                    {{tolabel}}
                </span>
                <em class="fa fa-angle-down dropicon"></em>
                <span id="parentdate" class="blackText font20">
                    <span class="font30 lactoBlack">
                        {{todate | date :'dd'}}
                    </span>
                    <span class="">
                        {{todate | date: 'MMM'}}
                        <ng-container *ngIf="todate !== null"> ' </ng-container>
                    </span>
                    <span class="">
                        {{todate | date: 'yy'}}
                    </span>
                    <span>

                        <h6 style="padding: 0%; margin:1%; opacity:0.5">
                            {{todate | date: 'EEEE'}}
                        </h6>
                    </span>
                </span>
            </div>

        </span>
        <div [ngStyle]="dropdownstyle" [style.width]="totalwidth+'px'" *ngIf="datepicker" class="datePickerContainer datetabs">


            <div class="flightCalOverlay">
                <div class="dayPickerFlightWrap">
                    <div class="RangeExample">
                        <div class="dayPickerHeader dayToFromCont blackText">
                            <div class="calHeading makeFlex">
                                <div class="dateFiled active" style="padding-left: 8px" [ngClass]="{'activecolordatetab':fromtab}" (click)="fromPicker(rootDiv, $event)">
                                    <p class="font16 blackText latoBold appendRight30">
                                        <span *ngIf="!rangepickerFlag" class="widgetSprite icCalendar appendRight10">
                                            <amexio-c-icon key="datepicker_calendar"></amexio-c-icon>
                                        </span>
                                        <span class="selectedDateField appendBottom8 pointer">
                                             {{fromdate | date: 'dd'}} {{fromdate | date: 'MMM'}} {{fromdate | date: 'yy'}}
                                        </span>
                                    </p>
                                </div>
                                <div class="font16 blackText lactoBlack dashed appendRight30"> - </div>
                                <div class="dateFiled active" [ngClass]="{'activecolordatetab':totab, 'disabled': (todate == null)}" (click)="toPicker(rootDiv, $event)">
                                    <p class="font16 blackText latoBold appendRight30">
                                        <span *ngIf="!rangepickerFlag" class="widgetSprite icCalendar appendRight10">
                                            <amexio-c-icon key="datepicker_calendar"></amexio-c-icon>
                                        </span>
                                        <span class="selectedDateField appendBottom8 pointer">
                                            {{todate | date: 'dd'}} {{todate | date: 'MMM'}} {{todate | date: 'yy'}}
                                        </span>
                                    </p>
                                </div>
                            </div>
                        </div>

                    </div>
                </div>
            </div>

            <!-- new div -->

            <ul *ngIf="rangepickerFlag" style="list-style-type: none; margin: 0; padding:4px; display: flex; justify-content: space-between">
                <li class="prev" style="cursor: pointer" (click)="updateMonthList('minus',$event)" (keyup.enter)="updateMonthList('minus',$event)"
                    [ngStyle]="{'cursor': backarrowflag ? 'not-allowed':'pointer'}">
                    <span aria-label="previous month push button " (keyup.enter)="updateMonthList('minus',$event)">
                        <amexio-c-icon class="arrowiconshadow" key="datepicker_previous" (onClick)="updateMonthList('minus',$event)"></amexio-c-icon>
                    </span>
                </li>

                <li style="cursor: pointer">
                    <span>
                        <span style="cursor:pointer" (click)="dropdownDatePicker()">
                            {{selectedDate | date:'MMM'}}
                            <!-- <br> -->
                            <span class="title"> {{selectedDate | date:'y'}}</span>
                        </span>
                        <span aria-label="dropdown datepicker push button" (keyup.enter)="dropdownDatePicker()" (onClick)=" dropdownDatePicker()"
                            style="cursor:pointer; padding-left: 5px;">
                            <amexio-c-icon key="dropdown_caret" (onClick)="dropdownDatePicker()"></amexio-c-icon>
                        </span>
                    </span>
                </li>
                <li class="next" style="cursor: pointer" (click)="updateMonthList('plus',$event)" (keyup.enter)="updateMonthList('plus',$event)"
                    [ngStyle]="{'cursor': forwardarrowflag ? 'not-allowed':'pointer'}">
                    <span aria-label="next month push button" (keyup.enter)="updateMonthList('plus',$event)">
                        <amexio-c-icon class="arrowiconshadow" key="datepicker_next" (onClick)="updateMonthList('plus',$event)"></amexio-c-icon>
                    </span>
                </li>
            </ul>

            <div style="position: absolute; width:100%; padding-right:5px;">
                <span [ngStyle]="{'display': rangepickerFlag ? '':'inline-flex' }" style="display: inline-flex; flex-flow: wrap;box-shadow: 0 2px 5px 0 rgba(0, 0, 0, 0.16), 0 2px 10px 0 rgba(0, 0, 0, 0.12);">

                    <ng-container *ngFor="let itemdaysArray of  completeDaysArray; index as i">


                        <span style="position: relative;" [ngClass]="{'datetimepicker':!inlineDatepicker}" [ngStyle]="{'box-shadow': rangepickerFlag ? '0 2px 5px 0 rgba(0,0,0,.16), 0 2px 10px 0 rgba(0,0,0,.12)':''}">
                            <!-- datepicker starts -->
                            <span aria-label="datepicker window opened ">
                                <!-- datepicker header starts and contains: 4 angles drop icon and title -->
                                <div aria-label="datetimepicker header" class="datetimepickertopbar" aria-label="datepicker header" [ngStyle]="{'display': datepicker ? 'block' : 'none'}">
                                    <ul>

                                        <li>
                                            <span (click)="updateMonthList('minus',$event)" (keyup.enter)="updateMonthList('minus',$event)" [ngStyle]="{'cursor': backarrowflag ? 'not-allowed':'pointer'}"
                                                *ngIf="itemdaysArray.prevarrow && !rangepickerFlag" tabindex="0" role="button" aria-label="Previous Month">
                                                <!-- left arrow icon -->
                                                <i class="fa fa-arrow-left arrowiconshadow" [ngStyle]="{'opacity': backarrowflag ? '0.2' : ''}" style="float:left" aria-hidden="true"></i>
                                            </span>

                                            <span (click)="updateMonthList('plus',$event)" (keyup.enter)="updateMonthList('plus',$event)" class="pointer" *ngIf="itemdaysArray.nextarrow && !rangepickerFlag"
                                                [ngStyle]="{'cursor': forwardarrowflag ? 'not-allowed':'pointer'}" tabindex="0" role="button"
                                                aria-label="Next Month">
                                                <!-- right arrow icon -->
                                                <i class="fa fa-arrow-right arrowiconshadow" [ngStyle]="{'opacity': forwardarrowflag ? '0.2' : ''}" style="float:right" aria-hidden="true"></i>
                                            </span>
                                            <span class="title" style="cursor:auto">
                                                {{itemdaysArray.date | date:'MMMM'}} {{itemdaysArray.date | date:'y'}}
                                            </span>

                                        </li>
                                    </ul>
                                </div>

                                <ul class="weekdays" [ngStyle]="{'display': datepicker ? 'block' : 'none'}">
                                    <li *ngFor="let dayTitle of daysTitle">{{dayTitle.text}}</li>
                                </ul>

                                <ul class="days" [ngStyle]="{'display': datepicker ? 'block' : 'none'}">

                                    <ng-container *ngFor="let dayArray of itemdaysArray.montharray">
                                        <li [ngStyle]="{'cursor': day.isDisabled ? 'not-allowed' : 'pointer'}" *ngFor="let day of dayArray" [ngClass]="{'notclickable':disabled}">
                                            <span [attr.tabindex]="(day.selected ? 1: -1)" id="{{day.id}}" (keyup.enter)="onDateClick(day, $event, rootDiv)" attr.aria-label="{{day.fulldate}}"
                                                (click)="onDateClick(day, $event, rootDiv)" class="day" [ngClass]="{'active': (day.from || day.to) , 'datesrange': day.range, 'currentMonth':day.isCurrentMonth, 'notCurrentMonth':!day.isCurrentMonth,'invaliddays':validateDays(day.date), 'disabled':day.isDisabled}">
                                                {{ day.date | date:'d' }}
                                            </span>
                                        </li>
                                    </ng-container>
                                </ul>
                            </span>
                            <!--datepicker ends  -->

                        </span>

                    </ng-container>
                </span>
            </div>
        </div>


    </div>
    <!-- 
    fromdate => {{fromdate}}
    <br> todate => {{todate}}
    <br> rangepickerFlag => {{rangepickerFlag}}
    <br> dropdownstyle = {{dropdownstyle | json}} -->


    <!--dropdown datepicker -->
    <div style="position: relative; z-index:1000" *ngIf="drop" class="datedropdown">
        <!-- hi -->
    <!-- New Refactor code -->
        <div class="dropdivMulti">
            <span tabindex="1" aria-label="month list">

                <span class="dropspanMulti">
                    <ul class="dropulMulti">
                        <li tabindex="1" id={{month.id}} class="li4" (click)="getDropdownMonth(month)" *ngFor="let month of monthList1" attr.aria-label="{{month.fullname}}"
                            (keyup.arrowdown)="dropdownListOneArrowDown(month)" (keyup.arrowup)="dropdownListOneArrowUp(month)">
                            <span [ngClass]="{'change4':month.flag}"> {{month.name}}</span>
                        </li>

                    </ul>
                </span>

                <span class="dropspanMulti2">
                    <ul class="dropulMulti2">
                        <li class="li4" tabindex="1" id={{month.id}} (click)="getDropdownMonth(month)" *ngFor="let month of monthList2" attr.aria-label="{{month.fullname}}"
                            (keyup.arrowdown)="dropdownListTwoArrowDown(month)" (keyup.arrowup)="dropdownListTwoArrowUp(month)">
                            <span [ngClass]="{'change4':month.flag}"> {{month.name}}</span>
                        </li>

                    </ul>
                </span>

            </span>

            <span tabindex="1" aria-label="year list">

                <span class="dropspanMulti">
                    <ul class="dropulMulti">
                        <li tabindex="1" (keyup.enter)="arrowClickBack($event)" id="prevyearbutton" aria-label="previous year list push button" [ngClass]="{ 'disablearrow':backArrowFlag}"
                            class="dropiconpaddingMulti" (click)="arrowClickBack($event)">
                            <amexio-c-icon key="paginator_first" (onClick)="arrowClickBack($event)"></amexio-c-icon>
                        </li>
                        <li tabindex="1" (keyup.arrowdown)="yearList1ArrowDown(year)" (keyup.arrowup)="yearList1ArrowUp(year)" id="{{year.id}}" [ngClass]="{ 'disablearrow':year.disabled}"
                            class="li4" (click)="getDropdownYear(year)" *ngFor="let year of yearList1">
                            <span [ngClass]="{'change4':year.flag && !year.disabled}">
                                {{year.year}}
                            </span>
                        </li>


                    </ul>
                </span>

                <span class="dropspanMulti4">
                    <ul class="dropulMulti2">

                        <li tabindex="1" (keyup.enter)="arrowClickForward($event)" id="nextyearbutton" aria-label="next year list push button" [ngClass]="{ 'disablearrow':forwardArrowFlag}"
                            class="dropiconpaddingMulti" (click)="arrowClickForward($event)">
                            <amexio-c-icon key="paginator_last" (onClick)="arrowClickForward($event)"></amexio-c-icon>
                        </li>
                        <li tabindex="1" (keyup.arrowdown)="yearList2ArrowDown(year)" (keyup.arrowup)="yearList2ArrowUp(year)" id="{{year.id}}" [ngClass]="{ 'disablearrow ':year.disabled}"
                            class="li4" (click)="getDropdownYear(year)" *ngFor="let year of yearList2">
                            <span [ngClass]="{'change4':year.flag && !year.disabled}">
                                {{year.year}}
                            </span>
                        </li>

                    </ul>
                </span>

            </span>
        </div>
        <div class="btndivMulti1">
            <span class="dropbtnspanMulti">
                <button tabindex="1" role="button" [attr.aria-pressed]="okispressed" (click)="navigateDropdown()" class="datedropbtn">
                    ok
                </button>
                <button tabindex="1" role="button" [attr.aria-pressed]="cancelispressed" class="datedropbtn" (click)="negateDrop()">
                    cancel
                </button>
            </span>
        </div>
    </div>
  `,
                animations: [
                    trigger('changeState', [
                        state('visible', style({
                            transform: 'scale(1)',
                        })),
                        state('hidden', style({
                            transform: 'scale(0)',
                        })),
                        transition('*=>*', animate('200ms')),
                    ]),
                ],
                providers: [{
                        provide: NG_VALUE_ACCESSOR, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => AmexioMultipleDatePickerComponent)), multi: true,
                    }, {
                        provide: NG_VALIDATORS, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => AmexioMultipleDatePickerComponent)), multi: true,
                    }],
            },] },
];
/** @nocollapse */
AmexioMultipleDatePickerComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef },
    { type: Renderer2 }
];
AmexioMultipleDatePickerComponent.propDecorators = {
    fromlabel: [{ type: Input }],
    tolabel: [{ type: Input }],
    numberofmonths: [{ type: Input, args: ['number-of-months',] }],
    inlineDatepicker: [{ type: Input, args: ['inline-datepicker',] }],
    disabled: [{ type: Input, args: ['disabled',] }],
    minDate: [{ type: Input, args: ['min-date',] }],
    maxDate: [{ type: Input, args: ['max-date',] }],
    diabledDate: [{ type: Input, args: ['disabled-date',] }],
    rangePickerFromDate: [{ type: Input, args: ['from-date',] }],
    rangePickerToDate: [{ type: Input, args: ['to-date',] }],
    dateRangePickerFlag: [{ type: Input, args: ['date-range-picker',] }],
    change: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/
class AmexioPasswordComponent extends BaseInputEventComponent {
    constructor() {
        super();
        this.isValid = false;
        /*
          Properties
          name : has-label
          datatype : boolean
          version : 4.0 onwards
          default : false
          description : flag to set label
          */
        this.haslabel = true;
        /*
         Properties
         name : show-password
         datatype : boolean
         version : 5.19 onwards
         default : false
         description : flag to set label
         */
        this.showpassword = false;
        this.show = false;
        this.type = 'password';
        this.showToolTip = false;
    }
    /**
     * @return {?}
     */
    get pattern() {
        return this._pattern;
    }
    /*
      Properties
      name : pattern
      datatype : string
      version : 4.0 onwards
      default :
      description : Apply Reg-ex to the field
      */
    /**
     * @param {?} value
     * @return {?}
     */
    set pattern(value) {
        if (value != null) {
            this.regEx = new RegExp(this.pattern);
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.isValid = this.isFieldValid();
        this.name = this.generateName(this.name, this.fieldlabel, 'passwordinput');
        this.componentId = this.createCompId('passwordinput', this.name);
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return this.isFieldValid() ? null : {
            jsonParseError: {
                valid: true,
            },
        };
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onInputPasswordEvent(event) {
        super.onInputEvent(event);
    }
    /**
     * @return {?}
     */
    toggleShow() {
        this.show = !this.show;
        if (this.show) {
            this.type = 'text';
        }
        else {
            this.type = 'password';
        }
    }
}
AmexioPasswordComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-password-input',
                template: `
    <div class="inputgroup">

        <label *ngIf="haslabel" role="password" id="{{componentId}}" for="{{componentId}}" [style.font-style]="fontstyle" [style.font-family]="fontfamily"
            [style.font-size]="fontsize">
            {{fieldlabel}}
        </label>

        <input type="{{type}}" role="password" tabindex="1" id="{{componentId}}" name="passwordText" attr.aria-labelledby="{{componentId}}"
            aria-describedby="passwordDec" [attr.aria-required]="!allowblank" [attr.aria-invalid]="!isValid " class="input-control"
            [ngClass]="model.touched ? allowblank ? '' : (isValid && model.touched) ? 'input-control-success' : 'input-control-error' :''"
            [(ngModel)]="value" (blur)="onBlurEvent()" (focus)="onFocusEvent($event)" (input)="onInputPasswordEvent($event)" (change)="onChangeEvent($event)"
            [name]="name" [pattern]="regEx" [attr.placeholder]="placeholder" [maxlength]="maxlength" [minlength]="minlength" [attr.disabled]="disabled ? true: null"
            [required]="!allowblank" />


  
        <ng-container *ngIf="showpassword">
            <span *ngIf="show" style="cursor:pointer" (click)="toggleShow()" class="input-control-eye">
                <span>
                    <em class="fa fa-eye"></em>
                </span>
            </span>
            <span *ngIf="!show" style="cursor:pointer" (click)="toggleShow()" class="input-control-eye">
                <span>
                    <em class="fa fa-eye-slash"></em>
                </span>
            </span>
        </ng-container>
        <ng-container *ngIf="iconfeedback">
            <span class="input-control-feedback">
                <span *ngIf="!isValid && model.touched">
                    <em class="fa fa-times"></em>
                </span>
                <span *ngIf="isValid && model.touched">
                    <em class="fa fa-check"></em>
                </span>
            </span>
        </ng-container>

        <input-help *ngIf="showToolTip && enablepopover" id="passwordDec" role="tooltip" [error-msg]="errormsg" [max-error-msg]="maxerrormsg"
            [min-error-msg]="minerrormsg" [min-length]="minlength" [max-length]="maxlength">
        </input-help>

        <span class="inputfieldbar"></span>
    </div>
  `,
                providers: [{
                        provide: NG_VALUE_ACCESSOR, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => AmexioPasswordComponent)), multi: true,
                    }, {
                        provide: NG_VALIDATORS, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => AmexioPasswordComponent)), multi: true,
                    }],
            },] },
];
/** @nocollapse */
AmexioPasswordComponent.ctorParameters = () => [];
AmexioPasswordComponent.propDecorators = {
    fieldlabel: [{ type: Input, args: ['field-label',] }],
    minlength: [{ type: Input, args: ['min-length',] }],
    maxlength: [{ type: Input, args: ['max-length',] }],
    allowblank: [{ type: Input, args: ['allow-blank',] }],
    minerrormsg: [{ type: Input, args: ['min-error-msg',] }],
    maxerrormsg: [{ type: Input, args: ['max-error-msg',] }],
    errormsg: [{ type: Input, args: ['error-msg',] }],
    placeholder: [{ type: Input, args: ['place-holder',] }],
    disabled: [{ type: Input }],
    iconfeedback: [{ type: Input, args: ['icon-feedback',] }],
    fontstyle: [{ type: Input, args: ['font-style',] }],
    fontfamily: [{ type: Input, args: ['font-family',] }],
    fontsize: [{ type: Input, args: ['font-size',] }],
    haslabel: [{ type: Input, args: ['has-label',] }],
    showpassword: [{ type: Input, args: ['show-password',] }],
    pattern: [{ type: Input, args: ['pattern',] }],
    enablepopover: [{ type: Input, args: ['enable-popover',] }],
    model: [{ type: ViewChild, args: [NgModel,] }],
    name: [{ type: Input, args: ['name',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AmexioRangeSliderComponent {
    /**
     * @param {?} el
     * @param {?} renderer
     * @param {?} ngZone
     * @param {?} cd
     */
    constructor(el, renderer, ngZone, cd) {
        this.el = el;
        this.renderer = renderer;
        this.ngZone = ngZone;
        this.cd = cd;
        this.handleValues = [];
        this.dragData = false;
        this.sliderHandleClick = false;
        this.handleIndex = 0;
        this.animate = false;
        this.disabled = false;
        this.min = 0;
        this.orientation = 'horizontal';
        this.range = false;
        this.fullRange = false;
        this.onChange = new EventEmitter();
        this.onSlideEnd = new EventEmitter();
        this.onModelChange = (/**
         * @return {?}
         */
        () => { });
        this.onModelTouched = (/**
         * @return {?}
         */
        () => { });
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.writeValue([0, this.maxRange]);
    }
    /**
     * @param {?} event
     * @param {?=} index
     * @return {?}
     */
    onMouseMove(event, index) {
        if (this.disabled) {
            return;
        }
        this.dragData = true;
        this.updateDomData();
        this.sliderHandleClick = true;
        this.handleIndex = index;
        this.bindDragListeners();
        event.preventDefault();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onSlideBarClick(event) {
        if (this.disabled) {
            return;
        }
        if (!this.sliderHandleClick) {
            this.updateDomData();
            this.handleChange(event);
        }
        this.sliderHandleClick = false;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    handleChange(event) {
        /** @type {?} */
        const handleValue = this.calculateHandleValue(event);
        this.setValueFromHandle(event, handleValue);
    }
    /**
     * @return {?}
     */
    bindDragListeners() {
        this.ngZone.runOutsideAngular((/**
         * @return {?}
         */
        () => {
            if (!this.dragListener) {
                this.dragListener = this.renderer.listen('document', 'mousemove', (/**
                 * @param {?} event
                 * @return {?}
                 */
                (event) => {
                    if (this.dragData) {
                        this.ngZone.run((/**
                         * @return {?}
                         */
                        () => {
                            this.handleChange(event);
                        }));
                    }
                }));
            }
            if (!this.mouseupListener) {
                this.checkMouseUpListener();
            }
        }));
    }
    /**
     * @return {?}
     */
    checkMouseUpListener() {
        this.mouseupListener = this.renderer.listen('document', 'mouseup', (/**
         * @param {?} event
         * @return {?}
         */
        (event) => {
            if (this.dragData) {
                this.dragData = false;
                this.ngZone.run((/**
                 * @return {?}
                 */
                () => {
                    if (this.range) {
                        this.onSlideEnd.emit({ originalEvent: event, values: this.values });
                    }
                    else {
                        this.onSlideEnd.emit({ originalEvent: event, value: this.value });
                    }
                }));
            }
        }));
    }
    /**
     * @return {?}
     */
    unbindDragListeners() {
        if (this.dragListener) {
            this.dragListener();
        }
        if (this.mouseupListener) {
            this.mouseupListener();
        }
    }
    /**
     * @param {?} event
     * @param {?} handleValue
     * @return {?}
     */
    setValueFromHandle(event, handleValue) {
        /** @type {?} */
        const newValue = this.getValueFromHandle(handleValue);
        if (this.range) {
            if (this.step) {
                this.handleStepChange(newValue, this.values[this.handleIndex]);
            }
            else {
                this.handleValues[this.handleIndex] = handleValue;
                this.updateValue(newValue, event);
            }
        }
        else {
            if (this.step) {
                this.handleStepChange(newValue, this.value);
            }
            else {
                this.handleValue = handleValue;
                this.updateValue(newValue, event);
            }
        }
    }
    /**
     * @param {?} newValue
     * @param {?} oldValue
     * @return {?}
     */
    handleStepChange(newValue, oldValue) {
        /** @type {?} */
        const diff = (newValue - oldValue);
        /** @type {?} */
        let val = oldValue;
        if (diff < 0) {
            val = oldValue + Math.ceil(newValue / this.step - oldValue / this.step) * this.step;
        }
        else if (diff > 0) {
            val = oldValue + Math.floor(newValue / this.step - oldValue / this.step) * this.step;
        }
        this.updateValue(val);
        this.updateHandleValue();
    }
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        this.handleValues = [0, this.maxRange];
        if (this.range) {
            this.values = value || [0, this.maxRange];
        }
        else {
            this.value = value || 0;
        }
        this.updateHandleValue();
        this.cd.markForCheck();
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onModelChange = fn;
    }
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onModelTouched = fn;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    setDisabledState(val) {
        this.disabled = val;
    }
    /**
     * @return {?}
     */
    get rangeStartLeft() {
        return (this.isVertical() ? 'auto' : this.handleValues[0] + '%');
    }
    /**
     * @return {?}
     */
    get rangeStartBottom() {
        return this.isVertical() ? this.handleValues[0] + '%' : 'auto';
    }
    /**
     * @return {?}
     */
    get rangeEndLeft() {
        return (this.isVertical() ? 'auto' : this.handleValues[1] + '%');
    }
    /**
     * @return {?}
     */
    get rangeEndBottom() {
        return this.isVertical() ? this.handleValues[1] + '%' : 'auto';
    }
    /**
     * @return {?}
     */
    isVertical() {
        return this.orientation === 'vertical';
    }
    /**
     * @return {?}
     */
    updateDomData() {
        /** @type {?} */
        const rect = this.el.nativeElement.children[0].getBoundingClientRect();
        this.initX = rect.left + this.getWindowScrollLeft();
        this.initY = rect.top + this.getWindowScrollTop();
        this.barWidth = this.el.nativeElement.children[0].offsetWidth;
        this.barHeight = this.el.nativeElement.children[0].offsetHeight;
    }
    /**
     * @return {?}
     */
    getWindowScrollTop() {
        /** @type {?} */
        const doc = document.documentElement;
        return (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0);
    }
    /**
     * @return {?}
     */
    getWindowScrollLeft() {
        /** @type {?} */
        const doc = document.documentElement;
        return (window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    calculateHandleValue(event) {
        if (this.orientation === 'horizontal') {
            return ((event.pageX - this.initX) * 100) / (this.barWidth);
        }
        else {
            return (((this.initY + this.barHeight) - event.pageY) * 100) / (this.barHeight);
        }
    }
    /**
     * @return {?}
     */
    updateHandleValue() {
        this.max = this.maxRange;
        if (this.range) {
            this.handleValues[0] = (this.values[0] < this.min ? 0 : this.values[0] - this.min) * 100 / (this.max - this.min);
            this.handleValues[1] = (this.values[1] > this.max ? this.maxRange : this.values[1] - this.min) * 100 / (this.max - this.min);
        }
        else {
            if (this.value < this.min) {
                this.handleValue = 0;
            }
            else if (this.value > this.max) {
                this.handleValue = this.maxRange;
            }
            else {
                this.handleValue = (this.value - this.min) * this.maxRange / (this.max - this.min);
            }
        }
    }
    /**
     * @param {?} val
     * @param {?=} event
     * @return {?}
     */
    updateValue(val, event) {
        if (this.range) {
            this.updateValueMethodDivided(val, event);
        }
        else {
            if (val < this.min) {
                val = this.min;
                this.handleValue = 0;
            }
            else if (val > this.max) {
                val = this.max;
                this.handleValue = 100;
            }
            this.value = this.getNormalizedValue(val);
            this.onChange.emit({ event1: event, value2: this.value });
        }
        this.onModelChange(this.values);
    }
    /**
     * @param {?} val
     * @param {?=} event
     * @return {?}
     */
    updateValueMethodDivided(val, event) {
        /** @type {?} */
        let value = val;
        if (this.handleIndex === 0) {
            if (value < this.min) {
                value = this.min;
                this.handleValues[0] = 0;
            }
            else if (value > this.values[1]) {
                value = this.values[1];
                this.handleValues[0] = this.handleValues[1];
            }
        }
        else {
            if (value > this.max) {
                value = this.max;
                this.handleValues[1] = 100;
            }
            else if (value < this.values[0]) {
                value = this.values[0];
                this.handleValues[1] = this.handleValues[0];
            }
        }
        this.values[this.handleIndex] = this.getNormalizedValue(value);
        this.onChange.emit({ event1: event, values2: this.values });
    }
    /**
     * @param {?} handleValue
     * @return {?}
     */
    getValueFromHandle(handleValue) {
        return (this.max - this.min) * (handleValue / 100) + this.min;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    getDecimalsCount(value) {
        if (value && Math.floor(value) !== value) {
            return value.toString().split('.')[1].length || 0;
        }
    }
    /**
     * @param {?} val
     * @return {?}
     */
    getNormalizedValue(val) {
        /** @type {?} */
        const decimalsCount = this.getDecimalsCount(this.step);
        if (decimalsCount > 0) {
            return +val.toFixed(decimalsCount);
        }
        else {
            return Math.floor(val);
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.unbindDragListeners();
    }
}
AmexioRangeSliderComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-value-range',
                template: `
    <div [ngStyle]="style" [class]="styleClass" [ngClass]="{'amexio-slider amexio-slider-widget amexio-slider-widget-content ui-corner-all':true,
    'ui-state-disabled':disabled,
    'amexio-slider-horizontal':orientation == 'horizontal',
    'amexio-slider-vertical':orientation == 'vertical',
    'amexio-slider-animate':animate}"
        (click)="onSlideBarClick($event)">

        <span *ngIf=" range && orientation == 'horizontal'" class="amexio-slider-range amexio-slider-widget-header ui-corner-all"
            [ngStyle]="{'left':handleValues[0] + '%',width: (handleValues[1] - handleValues[0] + '%')}">
        </span>

        <span *ngIf="range && orientation == 'vertical'" class="amexio-slider-range amexio-slider-widget-header ui-corner-all"
            [ngStyle]="{'bottom':handleValues[0] + '%',height: (handleValues[1] - handleValues[0] + '%')}">
        </span>




        <span *ngIf="range" (mousedown)="onMouseMove($event,0)" [style.transition]="dragData ? 'none': null" class="amexio-slider-handle ui-state-default ui-corner-all ui-clickable "
            [ngStyle]="{'left': rangeStartLeft, 'bottom': rangeStartBottom}" [ngClass]="{'amexio-slider-handle-active':handleIndex==0,
        'rectangle-css' :type == 'rectangle',
        'circle-css' :type == 'circle',
        'square-css' :type == 'square'}">
            {{values[0]}}
        </span>


        <span *ngIf="range" (mousedown)="onMouseMove($event,1)" [style.transition]="dragData ? 'none': null" class="amexio-slider-handle ui-state-default ui-corner-all ui-clickable"
            [ngStyle]="{'left': rangeEndLeft, 'bottom': rangeEndBottom}" [ngClass]="{'amexio-slider-handle-active':handleIndex==1, 
        'rectangle-css' :type == 'rectangle',
        'circle-css' :type == 'circle',
        'square-css' :type == 'square'}">


            <span style="margin-bottom: 30px;">
                {{values[1]}}
            </span>

        </span>
    </div>
  `,
                providers: [
                    { provide: NG_VALUE_ACCESSOR, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => AmexioRangeSliderComponent)), multi: true },
                ],
            },] },
];
/** @nocollapse */
AmexioRangeSliderComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: NgZone },
    { type: ChangeDetectorRef }
];
AmexioRangeSliderComponent.propDecorators = {
    animate: [{ type: Input }],
    disabled: [{ type: Input }],
    min: [{ type: Input, args: ['min',] }],
    max: [{ type: Input, args: ['max',] }],
    orientation: [{ type: Input, args: ['orientation',] }],
    step: [{ type: Input, args: ['step-value',] }],
    range: [{ type: Input }],
    maxRange: [{ type: Input, args: ['max-range',] }],
    style: [{ type: Input }],
    type: [{ type: Input, args: ['type',] }],
    styleClass: [{ type: Input }],
    onChange: [{ type: Output }],
    onSlideEnd: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class LoadRecaptchaService {
    constructor() {
    }
    /**
     * @return {?}
     */
    loadScript() {
        /** @type {?} */
        const script = document.createElement('script');
        script.innerHTML = '';
        script.src = 'https://www.google.com/recaptcha/api.js?render=explicit';
        script.async = true;
        script.defer = true;
        return script;
    }
}
LoadRecaptchaService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
LoadRecaptchaService.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by dattaram on 12/9/18.
*/
class RecaptchaComponent {
    /**
     * @param {?} _loadRecaptchaService
     */
    constructor(_loadRecaptchaService) {
        this._loadRecaptchaService = _loadRecaptchaService;
        this.onSuccess = new EventEmitter();
        this.onFailure = new EventEmitter();
        this.responseStructure = {};
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.componentId =
            +Math.floor(window.crypto.getRandomValues(new Uint32Array(1))[0]) + 'google';
        /** @type {?} */
        const script = this._loadRecaptchaService.loadScript();
        /** @type {?} */
        const body = (/** @type {?} */ (document.body));
        script.onload = (/**
         * @return {?}
         */
        () => {
            grecaptcha.ready((/**
             * @return {?}
             */
            () => {
                this.rendercaptcha();
            }));
        });
        body.appendChild(script);
    }
    /**
     * @return {?}
     */
    rendercaptcha() {
        grecaptcha.render(this.componentId, {
            sitekey: this.sitekey, callback: (/**
             * @param {?} response
             * @return {?}
             */
            (response) => {
                if (response && response.length > 0) {
                    this.responseStructure['success'] = true;
                    this.responseStructure['response'] = response;
                    this.onSuccess.emit(this.responseStructure);
                }
                else {
                    this.responseStructure['success'] = false;
                    this.responseStructure['response'] = '';
                    this.onFailure.emit(this.responseStructure);
                }
            }),
        });
    }
}
RecaptchaComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-google-recaptcha',
                template: `
    <div class="g-recaptcha" [attr.id]="componentId">
    </div>
  `,
            },] },
];
/** @nocollapse */
RecaptchaComponent.ctorParameters = () => [
    { type: LoadRecaptchaService }
];
RecaptchaComponent.propDecorators = {
    sitekey: [{ type: Input, args: ['site-key',] }],
    onSuccess: [{ type: Output }],
    onFailure: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by pratik on 29/1/18.
*/
class DomHandler {
    constructor() {
        this.calculatedScrollbarWidth = null;
    }
    /**
     * @param {?} element
     * @param {?} className
     * @return {?}
     */
    addClass(element, className) {
        if (element.classList) {
            element.classList.add(className);
        }
        else {
            element.className += ' ' + className;
        }
    }
    /**
     * @param {?} element
     * @param {?} className
     * @return {?}
     */
    addMultipleClasses(element, className) {
        if (element.classList) {
            /** @type {?} */
            const styles = className.split(' ');
            for (const i of styles) {
                element.classList.add([i]);
            }
        }
        else {
            /** @type {?} */
            const styles = className.split(' ');
            for (const i of styles) {
                element.className += ' ' + [i];
            }
        }
    }
    /**
     * @param {?} element
     * @param {?} className
     * @return {?}
     */
    removeClass(element, className) {
        if (element.classList) {
            element.classList.remove(className);
        }
        else {
            element.className = element.className.replace(new RegExp('(^|\\b)' + className.split(' ').join('|') + '(\\b|$)', 'gi'), ' ');
        }
    }
    /**
     * @param {?} element
     * @param {?} className
     * @return {?}
     */
    hasClass(element, className) {
        if (element.classList) {
            return element.classList.contains(className);
        }
        else {
            return new RegExp('(^| )' + className + '( |$)', 'gi').test(element.className);
        }
    }
    /**
     * @param {?} element
     * @return {?}
     */
    siblings(element) {
        return Array.prototype.filter.call(element.parentNode.children, (/**
         * @param {?} child
         * @return {?}
         */
        (child) => {
            return child !== element;
        }));
    }
    /**
     * @param {?} element
     * @param {?} selector
     * @return {?}
     */
    find(element, selector) {
        return element.querySelectorAll(selector);
    }
    /**
     * @param {?} element
     * @param {?} selector
     * @return {?}
     */
    findSingle(element, selector) {
        return element.querySelector(selector);
    }
    /**
     * @param {?} element
     * @return {?}
     */
    index(element) {
        /** @type {?} */
        const children = element.parentNode.childNodes;
        /** @type {?} */
        let num = 0;
        for (const i of children) {
            if (i === element) {
                return num;
            }
            if (i.nodeType === 1) {
                num++;
            }
        }
        return -1;
    }
    /**
     * @param {?} element
     * @param {?} target
     * @return {?}
     */
    relativePosition(element, target) {
        /** @type {?} */
        const elementDimensions = (element.offsetParent ? { width: element.offsetWidth, height: element.offsetHeight } :
            this.getHiddenElementDimensions(element));
        /** @type {?} */
        const targetHeight = target.offsetHeight;
        /** @type {?} */
        const targetWidth = target.offsetWidth;
        /** @type {?} */
        const targetOffset = target.getBoundingClientRect();
        /** @type {?} */
        const viewport = this.getViewport();
        /** @type {?} */
        let top;
        /** @type {?} */
        let left;
        if ((targetOffset.top + targetHeight + elementDimensions.height) > viewport.height) {
            top = -1 * (elementDimensions.height);
            if (targetOffset.top + top < 0) {
                top = 0;
            }
        }
        else {
            top = targetHeight;
        }
        if ((targetOffset.left + elementDimensions.width) > viewport.width) {
            left = targetWidth - elementDimensions.width;
        }
        else {
            left = 0;
        }
        element.style.top = top + 'px';
        element.style.left = left + 'px';
    }
    /**
     * @param {?} element
     * @param {?} target
     * @return {?}
     */
    absolutePosition(element, target) {
        /** @type {?} */
        const elementDimensions = (element.offsetParent ? { width: element.offsetWidth, height: element.offsetHeight }
            : this.getHiddenElementDimensions(element));
        /** @type {?} */
        const elementOuterHeight = elementDimensions.height;
        /** @type {?} */
        const elementOuterWidth = elementDimensions.width;
        /** @type {?} */
        const targetOuterHeight = target.offsetHeight;
        /** @type {?} */
        const targetOuterWidth = target.offsetWidth;
        /** @type {?} */
        const targetOffset = target.getBoundingClientRect();
        /** @type {?} */
        const windowScrollTop = this.getWindowScrollTop();
        /** @type {?} */
        const windowScrollLeft = this.getWindowScrollLeft();
        /** @type {?} */
        const viewport = this.getViewport();
        /** @type {?} */
        let top;
        /** @type {?} */
        let left;
        if (targetOffset.top + targetOuterHeight + elementOuterHeight > viewport.height) {
            top = targetOffset.top + windowScrollTop - elementOuterHeight;
            if (top < 0) {
                top = 0 + windowScrollTop;
            }
        }
        else {
            top = targetOuterHeight + targetOffset.top + windowScrollTop;
        }
        if (targetOffset.left + targetOuterWidth + elementOuterWidth > viewport.width) {
            left = targetOffset.left + windowScrollLeft + targetOuterWidth - elementOuterWidth;
        }
        else {
            left = targetOffset.left + windowScrollLeft;
        }
        element.style.top = top + 'px';
        element.style.left = left + 'px';
    }
    /**
     * @param {?} element
     * @return {?}
     */
    getHiddenElementOuterHeight(element) {
        element.style.visibility = 'hidden';
        element.style.display = 'block';
        /** @type {?} */
        const elementHeight = element.offsetHeight;
        element.style.display = 'none';
        element.style.visibility = 'visible';
        return elementHeight;
    }
    /**
     * @param {?} element
     * @return {?}
     */
    getHiddenElementOuterWidth(element) {
        element.style.visibility = 'hidden';
        element.style.display = 'block';
        /** @type {?} */
        const elementWidth = element.offsetWidth;
        element.style.display = 'none';
        element.style.visibility = 'visible';
        return elementWidth;
    }
    /**
     * @param {?} element
     * @return {?}
     */
    getHiddenElementDimensions(element) {
        /** @type {?} */
        const dimensions = {};
        element.style.visibility = 'hidden';
        element.style.display = 'block';
        dimensions.width = element.offsetWidth;
        dimensions.height = element.offsetHeight;
        element.style.display = 'none';
        element.style.visibility = 'visible';
        return dimensions;
    }
    /**
     * @param {?} container
     * @param {?} item
     * @return {?}
     */
    scrollInView(container, item) {
        /** @type {?} */
        const borderTopValue = getComputedStyle(container).getPropertyValue('borderTopWidth');
        /** @type {?} */
        const borderTop = borderTopValue ? parseFloat(borderTopValue) : 0;
        /** @type {?} */
        const paddingTopValue = getComputedStyle(container).getPropertyValue('paddingTop');
        /** @type {?} */
        const paddingTop = paddingTopValue ? parseFloat(paddingTopValue) : 0;
        /** @type {?} */
        const containerRect = container.getBoundingClientRect();
        /** @type {?} */
        const itemRect = item.getBoundingClientRect();
        /** @type {?} */
        const offset = (itemRect.top + document.body.scrollTop) - (containerRect.top + document.body.scrollTop) - borderTop - paddingTop;
        /** @type {?} */
        const scroll = container.scrollTop;
        /** @type {?} */
        const elementHeight = container.clientHeight;
        /** @type {?} */
        const itemHeight = this.getOuterHeight(item);
        if (offset < 0) {
            container.scrollTop = scroll + offset;
        }
        else if ((offset + itemHeight) > elementHeight) {
            container.scrollTop = scroll + offset - elementHeight + itemHeight;
        }
    }
    /**
     * @param {?} element
     * @param {?} duration
     * @return {?}
     */
    fadeIn(element, duration) {
        element.style.opacity = 0;
        /** @type {?} */
        let last = +new Date();
        /** @type {?} */
        let opacity = 0;
        /** @type {?} */
        const tick = (/**
         * @return {?}
         */
        () => {
            opacity = +element.style.opacity.replace(',', '.') + (new Date().getTime() - last) / duration;
            element.style.opacity = opacity;
            last = +new Date();
        });
        tick();
    }
    /**
     * @param {?} element
     * @param {?} ms
     * @return {?}
     */
    fadeOut(element, ms) {
        /** @type {?} */
        let opacity = 1;
        /** @type {?} */
        const interval = 50;
        /** @type {?} */
        const duration = ms;
        /** @type {?} */
        const gap = interval / duration;
        /** @type {?} */
        const fading = setInterval((/**
         * @return {?}
         */
        () => {
            opacity = opacity - gap;
            if (opacity <= 0) {
                opacity = 0;
                clearInterval(fading);
            }
            element.style.opacity = opacity;
        }), interval);
    }
    /**
     * @return {?}
     */
    getWindowScrollTop() {
        /** @type {?} */
        const doc = document.documentElement;
        return (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0);
    }
    /**
     * @return {?}
     */
    getWindowScrollLeft() {
        /** @type {?} */
        const doc = document.documentElement;
        return (window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0);
    }
    /**
     * @param {?} element
     * @param {?} selector
     * @return {?}
     */
    matches(element, selector) {
        /** @type {?} */
        const p = Element.prototype;
        /** @type {?} */
        const f = p['matches'] || p.webkitMatchesSelector || p['mozMatchesSelector'] || p['msMatchesSelector'] || (/**
         * @param {?} s
         * @return {?}
         */
        function (s) {
            return [].indexOf.call(document.querySelectorAll(s), this) !== -1;
        });
        return f.call(element, selector);
    }
    /**
     * @param {?} el
     * @param {?=} margin
     * @return {?}
     */
    getOuterWidth(el, margin) {
        /** @type {?} */
        let width = el.offsetWidth;
        if (margin) {
            /** @type {?} */
            const style = getComputedStyle(el);
            width += parseFloat(style.marginLeft) + parseFloat(style.marginRight);
        }
        return width;
    }
    /**
     * @param {?} el
     * @return {?}
     */
    getHorizontalPadding(el) {
        /** @type {?} */
        const style = getComputedStyle(el);
        return parseFloat(style.paddingLeft) + parseFloat(style.paddingRight);
    }
    /**
     * @param {?} el
     * @return {?}
     */
    getHorizontalMargin(el) {
        /** @type {?} */
        const style = getComputedStyle(el);
        return parseFloat(style.marginLeft) + parseFloat(style.marginRight);
    }
    /**
     * @param {?} el
     * @return {?}
     */
    innerWidth(el) {
        /** @type {?} */
        let width = el.offsetWidth;
        /** @type {?} */
        const style = getComputedStyle(el);
        width += parseFloat(style.paddingLeft) + parseFloat(style.paddingRight);
        return width;
    }
    /**
     * @param {?} el
     * @return {?}
     */
    width(el) {
        /** @type {?} */
        let width = el.offsetWidth;
        /** @type {?} */
        const style = getComputedStyle(el);
        width -= parseFloat(style.paddingLeft) + parseFloat(style.paddingRight);
        return width;
    }
    /**
     * @param {?} el
     * @return {?}
     */
    getInnerHeight(el) {
        /** @type {?} */
        let height = el.offsetHeight;
        /** @type {?} */
        const style = getComputedStyle(el);
        height += parseFloat(style.paddingTop) + parseFloat(style.paddingBottom);
        return height;
    }
    /**
     * @param {?} el
     * @param {?=} margin
     * @return {?}
     */
    getOuterHeight(el, margin) {
        /** @type {?} */
        let height = el.offsetHeight;
        if (margin) {
            /** @type {?} */
            const style = getComputedStyle(el);
            height += parseFloat(style.marginTop) + parseFloat(style.marginBottom);
        }
        return height;
    }
    /**
     * @param {?} el
     * @return {?}
     */
    getHeight(el) {
        /** @type {?} */
        let height = el.offsetHeight;
        /** @type {?} */
        const style = getComputedStyle(el);
        height -= (parseFloat(style.paddingTop) + parseFloat(style.paddingBottom)
            + parseFloat(style.borderTopWidth) + parseFloat(style.borderBottomWidth));
        return height;
    }
    /**
     * @param {?} el
     * @return {?}
     */
    getWidth(el) {
        /** @type {?} */
        let width = el.offsetWidth;
        /** @type {?} */
        const style = getComputedStyle(el);
        width -= (parseFloat(style.paddingLeft) + parseFloat(style.paddingRight) +
            parseFloat(style.borderLeftWidth) + parseFloat(style.borderRightWidth));
        return width;
    }
    /**
     * @return {?}
     */
    getViewport() {
        /** @type {?} */
        const win = window;
        /** @type {?} */
        const d = document;
        /** @type {?} */
        const e = d.documentElement;
        /** @type {?} */
        const g = d.getElementsByTagName('body')[0];
        /** @type {?} */
        const w = win.innerWidth || e.clientWidth || g.clientWidth;
        /** @type {?} */
        const h = win.innerHeight || e.clientHeight || g.clientHeight;
        return { width: w, height: h };
    }
    /**
     * @param {?} el
     * @return {?}
     */
    getOffset(el) {
        /** @type {?} */
        const rect = el.getBoundingClientRect();
        return {
            top: rect.top + document.body.scrollTop,
            left: rect.left + document.body.scrollLeft,
        };
    }
    /**
     * @return {?}
     */
    getUserAgent() {
        return navigator.userAgent;
    }
    /**
     * @return {?}
     */
    isIE() {
        /** @type {?} */
        const ua = window.navigator.userAgent;
        /** @type {?} */
        const msie = ua.indexOf('MSIE ');
        if (msie > 0) {
            // IE 10 or older => return version number
            return true;
        }
        /** @type {?} */
        const trident = ua.indexOf('Trident/');
        if (trident > 0) {
            // IE 11 => return version number
            return true;
        }
        /** @type {?} */
        const edge = ua.indexOf('Edge/');
        if (edge > 0) {
            // Edge (IE 12+) => return version number
            return true;
        }
        // other browser
        return false;
    }
    /**
     * @param {?} element
     * @param {?} target
     * @return {?}
     */
    appendChild(element, target) {
        if (this.isElement(target)) {
            target.appendChild(element);
        }
        else if (target.el && target.el.nativeElement) {
            target.el.nativeElement.appendChild(element);
        }
        else {
            throw new Error('Cannot append ' + target + ' to ' + element);
        }
    }
    /**
     * @param {?} element
     * @param {?} target
     * @return {?}
     */
    removeChild(element, target) {
        if (this.isElement(target)) {
            target.removeChild(element);
        }
        else if (target.el && target.el.nativeElement) {
            target.el.nativeElement.removeChild(element);
        }
        else {
            throw new Error('Cannot remove ' + element + ' from ' + target);
        }
    }
    /**
     * @param {?} obj
     * @return {?}
     */
    isElement(obj) {
        return (typeof HTMLElement === 'object' ? obj instanceof HTMLElement :
            obj && typeof obj === 'object' && obj !== null && obj.nodeType === 1 && typeof obj.nodeName === 'string');
    }
    /**
     * @return {?}
     */
    calculateScrollbarWidth() {
        if (this.calculatedScrollbarWidth !== null) {
            return this.calculatedScrollbarWidth;
        }
        /** @type {?} */
        const scrollDiv = document.createElement('div');
        scrollDiv.className = 'ui-scrollbar-measure';
        document.body.appendChild(scrollDiv);
        /** @type {?} */
        const scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
        document.body.removeChild(scrollDiv);
        this.calculatedScrollbarWidth = scrollbarWidth;
        return scrollbarWidth;
    }
    /**
     * @param {?} element
     * @param {?} methodName
     * @param {?=} args
     * @return {?}
     */
    invokeElementMethod(element, methodName, args) {
        (element)[methodName].apply(element, args);
    }
    /**
     * @return {?}
     */
    clearSelection() {
        if (window.getSelection) {
            if (window.getSelection().empty) {
                window.getSelection().empty();
            }
            else if (window.getSelection().removeAllRanges &&
                window.getSelection().rangeCount > 0 &&
                window.getSelection().getRangeAt(0).getClientRects().length > 0) {
                window.getSelection().removeAllRanges();
            }
        }
        else if (document['selection'] && document['selection'].empty) {
            try {
                document['selection'].empty();
            }
            catch (error) {
                // ignore IE bug
            }
        }
    }
    /**
     * @return {?}
     */
    getBrowser() {
        if (!this.browser) {
            /** @type {?} */
            const matched = this.resolveUserAgent();
            this.browser = {};
            if (matched.browser) {
                this.browser[matched.browser] = true;
                this.browser['version'] = matched.version;
            }
            if (this.browser['chrome']) {
                this.browser['webkit'] = true;
            }
            else if (this.browser['webkit']) {
                this.browser['safari'] = true;
            }
        }
        return this.browser;
    }
    /**
     * @return {?}
     */
    resolveUserAgent() {
        /** @type {?} */
        const ua = navigator.userAgent.toLowerCase();
        /** @type {?} */
        const match = /(chrome)[ \/]([\w.]+)/.exec(ua) ||
            /(webkit)[ \/]([\w.]+)/.exec(ua) ||
            /(opera)(?:.*version|)[ \/]([\w.]+)/.exec(ua) ||
            /(msie) ([\w.]+)/.exec(ua) ||
            ua.indexOf('compatible') < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(ua) ||
            [];
        return {
            browser: match[1] || '',
            version: match[2] || '0',
        };
    }
}
DomHandler.zindex = 1000;
DomHandler.decorators = [
    { type: Injectable },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by pratik on 29/1/18.
*/
class AmexioSliderComponent extends ValueAccessorBaseComponent {
    /**
     * @param {?} el
     * @param {?} domHandler
     * @param {?} renderer
     * @param {?} ngZone
     */
    constructor(el, domHandler, renderer, ngZone) {
        super();
        this.el = el;
        this.domHandler = domHandler;
        this.renderer = renderer;
        this.ngZone = ngZone;
        /*
        Properties
        name : min-value
        datatype : number
        version : 4.0 onwards
        default :
        description : Min slider value
        */
        this.min = 0;
        /*
        Properties
        name : max-value
        datatype : number
        version : 4.0 onwards
        default :
        description : Max slider value
        */
        this.max = 100;
        /*
        Properties
        name : orientation
        datatype : string
        version : 4.0 onwards
        default : horizontal
        description : Vertical or Horizontal Orientation of slider
        */
        this.orientation = 'horizontal';
        /*
        Properties
        name : input
        datatype : number
        version : 5.11.2 onwards
        default :
        description : Type applied to slider
        */
        this.type = 1;
        /*
            /*
          Events
          name : onChange
          datatype : any
          version : 4.0 onwards
          default :
          description : Triggers when slider is moved
          */
        this.onChange = new EventEmitter();
        /*
        Events
        name : onSlideEnd
        datatype : any
        version : 4.0 onwards
        default :
        description : Triggers when slider reaches the end
        */
        this.onSlideEnd = new EventEmitter();
        // For input use only
        this.darkmodeSlider = false;
        this.handleIndex = 0;
        this.handleValues = [];
        this.sliderFocus = false;
        this.onModelChange = (/**
         * @return {?}
         */
        () => { });
        this.onModelTouched = (/**
         * @return {?}
         */
        () => { });
        this.componentId = 'slider' + '_' + Math.floor(window.crypto.getRandomValues(new Uint32Array(1))[0]);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.shape === '' || this.shape == null) {
            this.shape = 'round';
        }
    }
    /**
     * @param {?} event
     * @param {?=} index
     * @return {?}
     */
    onMouseDown(event, index) {
        if (this.disabled) {
            return;
        }
        this.dragging = true;
        this.updateDomData();
        this.sliderHandleClick = true;
        this.handleIndex = index;
        this.bindDragListeners();
        event.preventDefault();
    }
    /**
     * @param {?} event
     * @param {?=} index
     * @return {?}
     */
    onTouchStart(event, index) {
        /** @type {?} */
        const touchobj = event.changedTouches[0];
        this.startHandleValue = (this.range) ? this.handleValues[index] : this.handleValue;
        this.dragging = true;
        this.handleIndex = index;
        if (this.orientation === 'horizontal') {
            this.startx = parseInt(touchobj.clientX, 10);
            this.barWidth = this.el.nativeElement.children[0].offsetWidth;
        }
        else {
            this.starty = parseInt(touchobj.clientY, 10);
            this.barHeight = this.el.nativeElement.children[0].offsetHeight;
        }
        event.preventDefault();
    }
    /**
     * @param {?} event
     * @param {?=} index
     * @return {?}
     */
    onTouchMove(event, index) {
        /** @type {?} */
        const touchobj = event.changedTouches[0];
        /** @type {?} */
        let handleValue = 0;
        if (this.orientation === 'horizontal') {
            handleValue = Math.floor(((parseInt(touchobj.clientX, 10) - this.startx) * 100) / (this.barWidth)) + this.startHandleValue;
        }
        else {
            handleValue = Math.floor(((this.starty - parseInt(touchobj.clientY, 10)) * 100) / (this.barHeight)) + this.startHandleValue;
        }
        this.setValueFromHandle(event, handleValue);
        event.preventDefault();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onBarClick(event) {
        if (this.disabled) {
            return;
        }
        if (!this.sliderHandleClick) {
            this.updateDomData();
            this.handleChange(event);
        }
        this.sliderHandleClick = false;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    handleChange(event) {
        /** @type {?} */
        let handleValue = this.calculateHandleValue(event);
        /** @type {?} */
        const stepvalue = parseInt(this.step + '', 10);
        if ((handleValue + stepvalue) > 99) {
            handleValue = 100;
        }
        else if ((handleValue - stepvalue) < 1) {
            handleValue = 0;
        }
        this.setValueFromHandle(event, handleValue);
    }
    /**
     * @return {?}
     */
    bindDragListeners() {
        this.ngZone.runOutsideAngular((/**
         * @return {?}
         */
        () => {
            if (!this.dragListener) {
                this.dragListener = this.renderer.listen('document', 'mousemove', (/**
                 * @param {?} event
                 * @return {?}
                 */
                (event) => {
                    if (this.dragging) {
                        this.ngZone.run((/**
                         * @return {?}
                         */
                        () => {
                            this.handleChange(event);
                        }));
                    }
                }));
            }
            if (!this.mouseupListener) {
                this.mouseupListener = this.renderer.listen('document', 'mouseup', (/**
                 * @param {?} event
                 * @return {?}
                 */
                (event) => {
                    this.mouseUpListMethod();
                }));
            }
        }));
    }
    /**
     * @return {?}
     */
    mouseUpListMethod() {
        if (this.dragging) {
            this.dragging = false;
            this.ngZone.run((/**
             * @return {?}
             */
            () => {
                if (this.range) {
                    this.onSlideEnd.emit({ originalEvent: event, values: this.values });
                }
                else {
                    this.onSlideEnd.emit({ originalEvent: event, value: this.value });
                }
            }));
        }
    }
    /**
     * @return {?}
     */
    unbindDragListeners() {
        if (this.dragListener) {
            this.dragListener();
        }
        if (this.mouseupListener) {
            this.mouseupListener();
        }
    }
    /**
     * @param {?} event
     * @param {?} handleValue
     * @return {?}
     */
    setValueFromHandle(event, handleValue) {
        /** @type {?} */
        const newValue = this.getValueFromHandle(handleValue);
        if (this.range) {
            if (this.step) {
                this.handleStepChange(newValue, this.values[this.handleIndex]);
            }
            else {
                this.handleValues[this.handleIndex] = handleValue;
                this.updateValue(newValue, event);
            }
        }
        else {
            if (this.step) {
                this.handleStepChange(newValue, this.value);
            }
            else {
                this.handleValue = handleValue;
                this.updateValue(newValue, event);
            }
        }
    }
    /**
     * @param {?} newValue
     * @param {?} oldValue
     * @return {?}
     */
    handleStepChange(newValue, oldValue) {
        /** @type {?} */
        const diff = (newValue - oldValue);
        /** @type {?} */
        let val = oldValue;
        if (diff < 0) {
            val = oldValue + Math.ceil((newValue - oldValue) / this.step) * this.step;
        }
        else if (diff > 0) {
            val = oldValue + Math.floor((newValue - oldValue) / this.step) * this.step;
        }
        this.updateValue(val);
        this.updateHandleValue();
    }
    /**
     * @param {?} val
     * @return {?}
     */
    setDisabledState(val) {
        this.disabled = val;
    }
    /**
     * @return {?}
     */
    get rangeStartLeft() {
        return this.isVertical() ? 'auto' : this.handleValues[0] + '%';
    }
    /**
     * @return {?}
     */
    get rangeStartBottom() {
        return this.isVertical() ? this.handleValues[0] + '%' : 'auto';
    }
    /**
     * @return {?}
     */
    get rangeEndLeft() {
        return this.isVertical() ? 'auto' : this.handleValues[1] + '%';
    }
    /**
     * @return {?}
     */
    get rangeEndBottom() {
        return this.isVertical() ? this.handleValues[1] + '%' : 'auto';
    }
    /**
     * @return {?}
     */
    isVertical() {
        return this.orientation === 'vertical';
    }
    /**
     * @return {?}
     */
    updateDomData() {
        /** @type {?} */
        const rect = this.el.nativeElement.children[0].getBoundingClientRect();
        this.initX = rect.left + this.domHandler.getWindowScrollLeft();
        this.initY = rect.top + this.domHandler.getWindowScrollTop();
        this.barWidth = this.el.nativeElement.children[0].offsetWidth;
        this.barHeight = this.el.nativeElement.children[0].offsetHeight;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    calculateHandleValue(event) {
        if (this.orientation === 'horizontal') {
            return ((event.pageX - this.initX) * 100) / (this.barWidth);
        }
        else {
            return (((this.initY + this.barHeight) - event.pageY) * 100) / (this.barHeight);
        }
    }
    /**
     * @return {?}
     */
    updateHandleValue() {
        if (this.range) {
            this.handleValues[0] = (this.values[0] < this.min ? 0 : this.values[0] - this.min) * 100 / (this.max - this.min);
            this.handleValues[1] = (this.values[1] > this.max ? 100 : this.values[1] - this.min) * 100 / (this.max - this.min);
        }
        else {
            if (this.value < this.min) {
                this.handleValue = 0;
            }
            else if (this.value > this.max) {
                this.handleValue = 100;
            }
            else {
                this.handleValue = (this.value - this.min) * 100 / (this.max - this.min);
            }
        }
    }
    /**
     * @param {?} val
     * @param {?=} valueEvent
     * @return {?}
     */
    updateValue(val, valueEvent) {
        if (this.range) {
            /** @type {?} */
            let value = val;
            if (this.handleIndex === 0) {
                if (value < this.min) {
                    value = this.min;
                    this.handleValues[0] = 0;
                }
                else if (value > this.values[1]) {
                    value = this.values[1];
                    this.handleValues[0] = this.handleValues[1];
                }
            }
            else {
                if (value > this.max) {
                    value = this.max;
                    this.handleValues[1] = 100;
                }
                else if (value < this.values[0]) {
                    value = this.values[0];
                    this.handleValues[1] = this.handleValues[0];
                }
            }
            this.values[this.handleIndex] = Math.floor(value);
            this.onModelChange(this.values);
            this.onChange.emit({ event: valueEvent, values: this.values });
        }
        else {
            this.updateValueNoRange(val, valueEvent);
        }
    }
    /**
     * @param {?} val
     * @param {?=} valueEvent
     * @return {?}
     */
    updateValueNoRange(val, valueEvent) {
        if (val < this.min) {
            val = this.min;
            this.handleValue = 0;
        }
        else if (val > this.max) {
            val = this.max;
            this.handleValue = 100;
        }
        this.value = Math.floor(val);
        this.onModelChange(this.value);
        this.onChange.emit({ event: valueEvent, value: this.value });
    }
    /**
     * @param {?} handleValue
     * @return {?}
     */
    getValueFromHandle(handleValue) {
        return (this.max - this.min) * (handleValue / 100) + this.min;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.unbindDragListeners();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onKeyLeftDown(event) {
        if (!this.step) {
            this.step = 10;
            this.step = this.max / this.step;
        }
        else if (!this.max && !this.step && !this.min) {
            this.step = this.max / this.step;
        }
        this.handleValue = this.handleValue - this.step;
        this.setValueFromHandle(event, this.handleValue);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onKeyRightUp(event) {
        if (!this.step) {
            this.step = 10;
            this.step = this.max / this.step;
        }
        else if (!this.max && !this.step && !this.min) {
            this.step = this.max / this.step;
        }
        this.handleValue = this.handleValue + this.step;
        this.setValueFromHandle(event, this.handleValue);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onKeyHome(event) {
        if (!this.step) {
            this.step = 10;
            this.step = this.max / this.step;
        }
        else if (!this.max && !this.step && !this.min) {
            this.step = this.max / this.step;
        }
        this.handleValue = this.min;
        this.setValueFromHandle(event, this.handleValue);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onKeyEnd(event) {
        if (!this.step) {
            this.step = 10;
            this.step = this.max / this.step;
        }
        else if (!this.max && !this.step && !this.min) {
            this.step = this.max / this.step;
        }
        this.handleValue = this.max;
        this.setValueFromHandle(event, this.handleValue);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onKeyPageUp(event) {
        this.handleValue = this.handleValue + 10;
        this.setValueFromHandle(event, this.handleValue);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onKeyPageDown(event) {
        this.handleValue = this.handleValue - 10;
        this.setValueFromHandle(event, this.handleValue);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onFocus(event) {
        this.sliderFocus = true;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onBlur(event) {
        this.sliderFocus = false;
    }
}
AmexioSliderComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-slider',
                template: `
    <ng-container *ngIf="!darkmodeSlider">
        <div id="value" role="slider" [ngStyle]="style" [class]="styleClass" [ngClass]="{'ui-slider ui-widget ui-widget-content ui-corner-all':true,'disable-component':disabled,
                'ui-slider-horizontal':(orientation == 'horizontal' && type != 2),
                'ui-slider-horizontal2':(orientation == 'horizontal' && type == 2),
                'ui-slider-vertical':(orientation == 'vertical' && type != 2),
                'ui-slider-vertical2':(orientation =='vertical' && type == 2),
                'ui-slider-animate':animate}" (click)="onBarClick($event);">
            <div attr.aria-labelled={{value}} role="slider" [tabindex]="disabled ? -1 : 0" [attr.aria-orientation]="orientation" [attr.aria-valuenow]="value"
                aria-valuemin="1" aria-valuemax="10" [attr.aria-valuetext]="value" (keydown.arrowdown)="onKeyLeftDown($event)" (keydown.arrowup)="onKeyRightUp($event)"
                (keydown.arrowright)="onKeyRightUp($event)" (keydown.arrowleft)="onKeyLeftDown($event)" (keydown.home)="onKeyHome($event)"
                (keydown.end)="onKeyEnd($event)" (focus)="onFocus($event)" (blur)="onBlur($event)" [ngClass]="{'focusOnSlider':sliderFocus}"
                (keydown.pageup)="onKeyPageUp($event)" (keydown.pagedown)="onKeyPageDown($event)"></div>


            <span *ngIf="range && orientation == 'horizontal'" class=" ui-slider-range ui-widget-header ui-corner-all" [ngStyle]="{'left':handleValues[0] + '%',width: (handleValues[1] - handleValues[0] + '%')}">
            </span>
            <span *ngIf="range && orientation == 'vertical'" class="ui-slider-range ui-widget-header ui-corner-all" [ngStyle]="{'bottom':handleValues[0] + '%',height: (handleValues[1] - handleValues[0] + '%')}"></span>

            <span *ngIf="!range && orientation=='vertical'" class="ui-slider-range-min ui-widget-header ui-corner-all" [ngClass]="{'ui-slider-range':type != 2,'ui-slider-range2':type == 2}"
                [ngStyle]="{'height': handleValue + '%'}"></span>

            <span *ngIf="!range && orientation=='horizontal'" class="ui-slider-range ui-slider-range-min ui-widget-header ui-corner-all"
                [ngStyle]="{'width': handleValue + '%'}"></span>

            <span *ngIf="!range" class="ui-state-default ui-corner-all ui-clickable" [ngClass]="{'ui-slider-handle': (orientation == 'horizontal' && type !=2),
                    'ui-slider-handle2': (orientation == 'horizontal' && type == 2),
                'ui-slider-handle1':(orientation =='vertical' && type!=2),
                'ui-slider-handle3':(orientation =='vertical' && type ==2)}" (mousedown)="onMouseDown($event)" (touchstart)="onTouchStart($event)"
                (touchmove)="onTouchMove($event)" (touchend)="dragging=false" [style.transition]="dragging ? 'none': null" [ngStyle]="{'left': orientation == 'horizontal' ? handleValue + '%' : null,
                'bottom': orientation == 'vertical' ? handleValue + '%' : null}"></span>

            <span *ngIf="range" (mousedown)="onMouseDown($event,0)" aria-labelledby="id" (touchstart)="onTouchStart($event,0)" (touchmove)="onTouchMove($event,0)"
                (touchend)="dragging=false" setValueFromHandle(event,this.slidevar); [style.transition]="dragging ? 'none': null"
                class="ui-slider-handle ui-state-default ui-corner-all ui-clickable" [ngStyle]="{'left': rangeStartLeft, 'bottom': rangeStartBottom}"
                [ngClass]="{'ui-slider-handle-active':handleIndex==0}
            "></span>

            <span *ngIf="range" (mousedown)="onMouseDown($event,1)" (touchstart)="onTouchStart($event,1)" (touchmove)="onTouchMove($event,1)"
                (touchend)="dragging=false" [style.transition]="dragging ? 'none': null" [ngStyle]="{'left': rangeEndLeft, 'bottom': rangeEndBottom}"
                [ngClass]="{'ui-slider-handle-active':handleIndex==1 ,'ui-slider-range3': type == 2
      
        }"></span>
        </div>
    </ng-container>

    <ng-container *ngIf="darkmodeSlider">
        <div class="slidecontainer">
            <input class="slider-{{shape}}" name="value" type="range" min="{{min}}" max="{{max}}" step={{step}} value="1"
                [(ngModel)]="value">
        </div>
    </ng-container>
  `,
                providers: [{
                        provide: NG_VALUE_ACCESSOR, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => AmexioSliderComponent)), multi: true,
                    }],
            },] },
];
/** @nocollapse */
AmexioSliderComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: DomHandler },
    { type: Renderer2 },
    { type: NgZone }
];
AmexioSliderComponent.propDecorators = {
    animate: [{ type: Input }],
    disabled: [{ type: Input }],
    min: [{ type: Input, args: ['min-value',] }],
    max: [{ type: Input, args: ['max-value',] }],
    orientation: [{ type: Input }],
    step: [{ type: Input, args: ['step-value',] }],
    range: [{ type: Input }],
    style: [{ type: Input }],
    styleClass: [{ type: Input, args: ['style-class',] }],
    type: [{ type: Input, args: ['type',] }],
    shape: [{ type: Input }],
    onChange: [{ type: Output }],
    onSlideEnd: [{ type: Output }],
    darkmodeSlider: [{ type: Input, args: ['darkmode-slider',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Created by kedar on 17/09/18.
 */
/*
Component Name : Amexio Spinner
Component Selector :  <amexio-spinner>
Component Description :
*/
class AmexioSpinnerComponent {
    /**
     * @param {?} renderer
     */
    constructor(renderer) {
        this.renderer = renderer;
        /*
          Events
          name : show
          datatype : boolean
          version : none
          default : true
          description : if show  is true than and only than the spinner is enable, if false then it is disable.
          */
        this.show = true;
        this.relative = false;
        this.spinnerVertialCss = 'spinner-vertical-';
        this.spinnerHorizontalCss = ' spinner-horizontal-';
        this.spinnerRelativeCss = 'spinnerCss-relative';
        this.alpha = '0.2';
    }
    /*
       Events
       name : color
       datatype : string
       version : none
       default : none
       description : spinner want color
       */
    /**
     * @param {?} v
     * @return {?}
     */
    set color(v) {
        /** @type {?} */
        const ischanges = (this._color !== v);
        this._color = v;
        if (ischanges) {
            this.assignColor();
        }
    }
    /**
     * @return {?}
     */
    get color() {
        return this._color;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.assignColor();
        this.positionChangeClass();
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
        this.positionChangeClass();
    }
    /**
     * @return {?}
     */
    positionChangeClass() {
        if (this.relative) {
            this.positionSpinnerClass = this.spinnerRelativeCss;
        }
        else {
            if (this.verticalposition === null) {
                this.verticalposition = 'top';
            }
            else if (this.horizontalposition === null) {
                this.horizontalposition = 'right';
            }
            this.positionSpinnerClass = this.spinnerVertialCss + this.verticalposition + this.spinnerHorizontalCss + this.horizontalposition;
        }
    }
    /**
     * @private
     * @return {?}
     */
    assignColor() {
        if (this.type === 'spinnerround' && this.color) {
            /** @type {?} */
            let newColor;
            /** @type {?} */
            const r = parseInt(this.color.slice(1, 3), 16);
            /** @type {?} */
            const g = parseInt(this.color.slice(3, 5), 16);
            /** @type {?} */
            const b = parseInt(this.color.slice(5, 7), 16);
            if (this.alpha) {
                newColor = `rgba(${r}, ${g}, ${b}, ${this.alpha})`;
            }
            else {
                newColor = `rgba(${r}, ${g}, ${b})`;
            }
            /** @type {?} */
            const inlinecss = 'margin: 60px auto;font-size: 10px;position: relative;text-indent: -9999em;border-top: 1.1em solid ' + newColor +
                '; border-right: 1.1em solid ' + newColor +
                ';border-left: 1.1em solid ;-webkit-transform: translateZ(0);-ms-transform: translateZ(0);border-bottom: 1.1em solid ' + newColor +
                ';transform: translateZ(0);  -webkit-animation: load8 1.1s infinite linear;animation: load8 1.1s infinite linear;';
            /** @type {?} */
            const inlinecssafter = ' border-radius: 50%; width: 10em; height: 10em;';
            this.insertStyleSheetRule('.dynamicclass { ' + inlinecss + inlinecssafter + '}');
            this.insertStyleSheetRule('@-webkit-keyframes load8 { 0% {  -webkit-transform: rotate(0deg);  transform: rotate(0deg);} ' +
                '100%{-webkit-transform: rotate(360deg); transform: rotate(360deg);} }');
            this.renderer.addClass(this.element.nativeElement, 'dynamicclass');
        }
    }
    /**
     * @param {?} ruleText
     * @return {?}
     */
    insertStyleSheetRule(ruleText) {
        /** @type {?} */
        const sheets = document.styleSheets;
        if (sheets.length === 0) {
            /** @type {?} */
            const style = document.createElement('style');
            style.appendChild(document.createTextNode(''));
            document.head.appendChild(style);
        }
        /** @type {?} */
        const sheet = sheets[sheets.length - 1];
        sheet.insertRule(ruleText, sheet.rules ? sheet.rules.length : sheet.cssRules.length);
    }
}
AmexioSpinnerComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-spinner',
                template: `
    <div class="spinner-sm" [ngClass]="positionSpinnerClass">

            <div #loadindicator [ngStyle]="{'display': show ? 'block': 'none'}"
             [style.color]='color' [style.font-size]='size'
                    [ngClass]="{
            'rectangle-bounces' :type == 'rectanglebounce',
            'rings' :type == 'ring',
            'half-circles' :type == 'halfcircle',
            'fading-circles' :type == 'fadingcircle',
            'ball-spins' :type == 'ballspin',
            'fire-spins' :type == 'firespin',
            'three-bounces' :type == 'threebounce',
            'spinner-rounds' :type == 'spinnerround'}
            ">
            </div>
    </div>
  `,
            },] },
];
/** @nocollapse */
AmexioSpinnerComponent.ctorParameters = () => [
    { type: Renderer2 }
];
AmexioSpinnerComponent.propDecorators = {
    type: [{ type: Input, args: ['type',] }],
    color: [{ type: Input, args: ['color',] }],
    show: [{ type: Input }],
    verticalposition: [{ type: Input, args: ['vertical-position',] }],
    horizontalposition: [{ type: Input, args: ['horizontal-position',] }],
    size: [{ type: Input, args: ['size',] }],
    relative: [{ type: Input, args: ['relative',] }],
    element: [{ type: ViewChild, args: ['loadindicator',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by pratik on 20/12/17.
*/
class AmexioTagsInputComponent extends EventBaseComponent {
    /**
     * @param {?} displayFieldService
     * @param {?} dataService
     * @param {?} element
     * @param {?} renderer
     * @param {?} _cd
     */
    constructor(displayFieldService, dataService, element, renderer, _cd) {
        super(renderer, element, _cd);
        this.displayFieldService = displayFieldService;
        this.dataService = dataService;
        this.element = element;
        this.renderer = renderer;
        /*
         Properties
         name : has-label
         datatype : boolean
         version : 4.0 onwards
         default : false
         description : flag to set label
         */
        this.haslabel = true;
        /*
         Events
         name : input
         datatype : any
         version : none
         default :
         description :	On input event field.
         */
        this.input = new EventEmitter();
        /*
        Events
        name : onChange
        datatype : any
        version : none
        default :
        description : on change event
        */
        this.onChange = new EventEmitter();
        /*
        Events
        name : focus
        datatype : any
        version : none
        default :
        description : On field focus event
        */
        this.focus = new EventEmitter();
        this.onSelections = [];
        this.activeindex = 0;
        this.selectedindex = -1;
        this.scrollposition = 30;
        this.maskloader = true;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set data(value) {
        this._data = value;
        if (this.componentLoaded) {
            this.setData(this._data);
        }
    }
    /**
     * @return {?}
     */
    get data() {
        return this._data;
    } /*
   Properties
   name : data-reader
   datatype : string
   version : 4.0 onwards
   default :
   description : Key in JSON datasource for records
   */
    /**
     * @return {?}
     */
    ngOnInit() {
        this.componentId = this.createCompId('taginput', this.displayfield);
        if (this.placeholder === '' || this.placeholder === null) {
            this.placeholder = 'Choose Option';
        }
        if (!this.triggerchar) {
            this.triggerchar = 1;
        }
        if (this.httpmethod && this.httpurl) {
            this.dataService.fetchData(this.httpurl, this.httpmethod).subscribe((/**
             * @param {?} response
             * @return {?}
             */
            (response) => {
                this.responseData = response;
            }), (/**
             * @param {?} error
             * @return {?}
             */
            (error) => {
            }), (/**
             * @return {?}
             */
            () => {
                this.setData(this.responseData);
            }));
        }
        else if (this.data) {
            this.previousData = JSON.parse(JSON.stringify(this.data));
            this.setData(this.data);
        }
        this.componentLoaded = true;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    navigateKey(event) {
    }
    /**
     * @param {?} event
     * @return {?}
     */
    focusToLastElement(event) {
        this.filteredResult[this.selectedindex].selected = false;
        this.selectedindex = this.filteredResult.length - 1;
        this.filteredResult[this.filteredResult.length - 1].selected = true;
        this.setAriaActiveDescendant(this.selectedindex);
        this.setScrollToList(this.selectedindex);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    focusToFirstElement(event) {
        this.filteredResult[this.selectedindex].selected = false;
        this.selectedindex = 0;
        this.filteredResult[0].selected = true;
        this.setAriaActiveDescendant(this.selectedindex);
        this.setScrollToList(this.selectedindex);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    closeOnEScapeList(event) {
        this.showToolTip = false;
        this.hide();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onKeyUp(event) {
        this.filteredResult = [];
        this.showToolTip = false;
        /** @type {?} */
        const keyword = event.target.value;
        if (keyword !== null && keyword !== ' ' && keyword.length >= this.triggerchar) {
            /** @type {?} */
            const search_term = keyword.toLowerCase();
            this.viewData.forEach((/**
             * @param {?} item
             * @return {?}
             */
            (item) => {
                if (item != null && this.displayFieldService.findValue(this.key, item).toLowerCase().startsWith(search_term)) {
                    this.filteredResult.push(item);
                }
            }));
            if (this.filteredResult.length > 0) {
                this.showToolTip = true;
                this.onBaseFocusEvent({});
            }
            else {
                this.showToolTip = this.onBaseBlurEvent({});
            }
        }
        if (event.keyCode === 40 || event.keyCode === 38 || event.keyCode === 13) {
            this.navigateUsingKey(event);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    navigateUsingKey(event) {
        if (this.selectedindex > this.filteredResult.length) {
            this.selectedindex = 0;
        }
        if (event.keyCode === 40 || event.keyCode === 38 && this.selectedindex < this.filteredResult.length) {
            this.keyUpDownMethod(event);
        }
        if (event.keyCode === 13 && this.filteredResult[this.selectedindex]) {
            this.onItemSelect(this.filteredResult[this.selectedindex], this.selectedindex);
        }
        this.setScrollToList(this.selectedindex);
    }
    // Method when up arrow or down arrow is pressed
    /**
     * @param {?} event
     * @return {?}
     */
    keyUpDownMethod(event) {
        if (!this.showToolTip) {
            this.showToolTip = true;
        }
        /** @type {?} */
        let prevselectedindex = -1;
        prevselectedindex = this.selectedindex;
        if (event.keyCode === 40) {
            this.selectedindex++;
        }
        else if (event.keyCode === 38) {
            this.selectedindex--;
        }
        if (this.filteredResult[this.selectedindex]) {
            this.filteredResult[this.selectedindex].selected = true;
            this.setAriaActiveDescendant(this.selectedindex);
        }
        if (this.filteredResult[prevselectedindex]) {
            this.filteredResult[prevselectedindex].selected = false;
            this.toNavigateFirstAndLastOption();
        }
    }
    /**
     * @return {?}
     */
    toNavigateFirstAndLastOption() {
        if (this.selectedindex === -1) {
            this.selectedindex = this.filteredResult.length - 1;
            this.filteredResult[this.filteredResult.length - 1].selected = true;
        }
        else if (this.selectedindex === this.filteredResult.length) {
            this.selectedindex = 0;
            this.filteredResult[this.selectedindex].selected = true;
        }
        this.setAriaActiveDescendant(this.selectedindex);
    }
    /**
     * @param {?} rowindex
     * @return {?}
     */
    setAriaActiveDescendant(rowindex) {
        if (this.filteredResult.length > 0) {
            /** @type {?} */
            const inputid = document.getElementById(this.componentId);
            inputid.setAttribute('aria-activedescendant', this.filteredResult[rowindex].index);
        }
        else if (this.displayValue.length < 1) {
            /** @type {?} */
            const inputid = document.getElementById(this.componentId);
            inputid.setAttribute('aria-activedescendant', 'listitem');
        }
    }
    /**
     * @param {?} rowindex
     * @return {?}
     */
    setScrollToList(rowindex) {
        /** @type {?} */
        const listitems = this.element.nativeElement.getElementsByClassName('list-items')[rowindex];
        if (listitems) {
            listitems.scrollIntoView({ behavior: 'smooth' });
        }
    }
    /**
     * @param {?} activerow
     * @return {?}
     */
    showAllData(activerow) {
        /** @type {?} */
        let i = 0;
        this.viewData.forEach((/**
         * @param {?} item
         * @return {?}
         */
        (item) => {
            if (item != null) {
                if (i === activerow) {
                    item.active = true;
                    this.currentActive = item;
                }
                else {
                    item.active = false;
                }
                item.activerow = activerow;
                this.filteredResult.push(item);
            }
            i++;
        }));
        if (this.filteredResult.length > 0) {
            this.showToolTip = true;
        }
    }
    /**
     * @param {?} row
     * @param {?} index
     * @return {?}
     */
    onItemSelect(row, index) {
        this.value = row[this.valuefield];
        this.displayFieldService.findValue(this.displayfield, row);
        this.setValue(row, index);
        this.showToolTip = false;
    }
    /**
     * @param {?} input
     * @return {?}
     */
    onInput(input) {
        if (this.selectedindex > -1) {
            this.filteredResult[this.selectedindex].selected = false;
        }
        this.selectedindex = -1;
        this.input.emit();
    }
    /**
     * @param {?} elem
     * @return {?}
     */
    onFocus(elem) {
        this.inpHandle.nativeElement.placeholder = '';
        this.onBaseFocusEvent({});
        this.posixUp = this.getListPosition(elem);
        this.focus.emit(this.value);
    }
    /**
     * @param {?} elementRef
     * @return {?}
     */
    getListPosition(elementRef) {
        /** @type {?} */
        const dropdownHeight = 325;
        // must be same in dropdown.scss
        if (elementRef) {
            if (window.screen.height - (elementRef.getBoundingClientRect().bottom) < dropdownHeight) {
                return true;
            }
            else {
                return false;
            }
        }
    }
    /**
     * @param {?} httpResponse
     * @return {?}
     */
    setData(httpResponse) {
        /** @type {?} */
        let responsedata = httpResponse;
        if (this.datareader != null) {
            /** @type {?} */
            const dr = this.datareader.split('.');
            for (const ir of dr) {
                responsedata = responsedata[ir];
            }
        }
        else {
            responsedata = httpResponse;
        }
        this.viewData = responsedata;
        this.generateIndex(this.viewData);
        this.maskloader = false;
    }
    /**
     * @param {?} data
     * @return {?}
     */
    generateIndex(data) {
        data.forEach((/**
         * @param {?} element
         * @param {?} index
         * @return {?}
         */
        (element, index) => {
            element['index'] = this.componentId + 'listitem' + index;
        }));
    }
    /**
     * @param {?} value
     * @param {?} index
     * @return {?}
     */
    setValue(value, index) {
        this.inpHandle.nativeElement.value = '';
        this.onSelections.push(value);
        this.onChange.emit(this.onSelections);
        if (this.onSelections.length > 0) {
            this.isValid = true;
        }
        this.hide();
        if (index) {
            this.filteredResult[index].selected = false;
        }
        this.selectedindex = -1;
        this.showToolTip = false;
    }
    /**
     * @param {?} item
     * @return {?}
     */
    removePill(item) {
        /** @type {?} */
        let indexToRemove = null;
        this.onSelections.forEach((/**
         * @param {?} selectedVal
         * @param {?} index
         * @return {?}
         */
        (selectedVal, index) => {
            if (selectedVal === item) {
                indexToRemove = index;
            }
        }));
        this.onSelections.splice(indexToRemove, 1);
        if (this.onSelections.length === 0) {
            this.isValid = false;
        }
        this.onChange.emit(this.onSelections);
    }
    // THIS MEHTOD CHECK INPUT IS VALID OR NOT
    /**
     * @return {?}
     */
    checkValidity() {
        return this.isValid;
    }
}
AmexioTagsInputComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-tag-input',
                template: `
    <div class="inputgroup" #rootDiv (keyup.esc)="closeOnEScapeList($event)">

      <label *ngIf="haslabel" for="{{componentId}}" [style.font-style]="fontstyle" [style.font-family]="fontfamily" [style.font-size]="fontsize">
        {{fieldlabel}}
      </label>

      <div class="tag-input" [ngClass]="{'loading-mask' : maskloader}">
        <div class="tag" *ngFor="let item of onSelections">
          <amexio-display-field [data]="item" [data-index]="key"></amexio-display-field>
          <span class="closebtn" (click)="removePill(item)">&times;</span>
        </div>
        <input id="{{componentId}}" aria-autocomplete="list" role="combobox" [attr.aria-expanded]="showToolTip" type="text" class="input-control"
          [ngClass]="{'input-control-error' : inp.invalid && (inp.dirty || inp.touched),'input-control-success' : inp.valid && (inp.dirty || inp.touched)}"
          (focus)="onFocus(rootDiv)" (input)="onInput(inp)" (keyup)="onKeyUp($event)" (keyup.end)="focusToLastElement($event)"
          (keyup.home)="focusToFirstElement($event)" [attr.placeholder]="placeholder" [attr.disabled]="disabled ? true: null" [required]="allowblank ? true: null"
          #inp />
      </div>


      <span #dropdownitems class="dropdown" [@changeState]="dropdownstyle.visibility" [ngClass]="{'dropdown-up' : posixUp}" [ngStyle]="dropdownstyle"
        #tagDropRef>
        <ul role="list" class="dropdown-list">
          <li tabindex="1" role="listitem" class="list-items" [ngClass]="{'list-items-selected':item.selected}" *ngFor="let item of filteredResult"
            id="{{item.index}}" (click)="setValue(item,inp)">
            <div>
              <amexio-display-field [data]="item" [data-index]="displayfield"></amexio-display-field>
            </div>
          </li>
        </ul>
      </span>
    </div>


    <span *ngIf="iconfeedback && (inp.invalid && (inp.dirty || inp.touched) || inp.valid)" class="input-control-feedback">
      <span *ngIf="inp.invalid && (inp.dirty || inp.touched)">&#9888;</span>
      <span *ngIf="inp.valid && (inp.dirty || inp.touched)"> &#10004;</span>
    </span>
  `,
                animations: [
                    trigger('changeState', [
                        state('visible', style({
                            'max-height': '200px',
                        })),
                        state('hidden', style({
                            'max-height': '0px',
                        })),
                        transition('*=>*', animate('200ms')),
                    ]),
                ],
            },] },
];
/** @nocollapse */
AmexioTagsInputComponent.ctorParameters = () => [
    { type: DisplayFieldService },
    { type: CommonDataService },
    { type: ElementRef },
    { type: Renderer2 },
    { type: ChangeDetectorRef }
];
AmexioTagsInputComponent.propDecorators = {
    fieldlabel: [{ type: Input, args: ['field-label',] }],
    allowblank: [{ type: Input, args: ['allow-blank',] }],
    data: [{ type: Input, args: ['data',] }],
    datareader: [{ type: Input, args: ['data-reader',] }],
    httpmethod: [{ type: Input, args: ['http-method',] }],
    httpurl: [{ type: Input, args: ['http-url',] }],
    displayfield: [{ type: Input, args: ['display-field',] }],
    valuefield: [{ type: Input, args: ['value-field',] }],
    placeholder: [{ type: Input, args: ['place-holder',] }],
    disabled: [{ type: Input }],
    iconfeedback: [{ type: Input, args: ['icon-feedback',] }],
    fontstyle: [{ type: Input, args: ['font-style',] }],
    fontfamily: [{ type: Input, args: ['font-family',] }],
    fontsize: [{ type: Input, args: ['font-size',] }],
    enablepopover: [{ type: Input, args: ['enable-popover',] }],
    key: [{ type: Input }],
    triggerchar: [{ type: Input, args: ['trigger-char',] }],
    haslabel: [{ type: Input, args: ['has-label',] }],
    input: [{ type: Output }],
    onChange: [{ type: Output }],
    focus: [{ type: Output }],
    inpHandle: [{ type: ViewChild, args: ['inp',] }],
    tagDropRef: [{ type: ViewChild, args: ['tagDropRef',] }],
    dropdownitems: [{ type: ViewChild, args: ['dropdownitems', { read: ElementRef },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/
class AmexioTextAreaComponent extends ValueAccessorBaseComponent {
    constructor() {
        super();
        /*
        Events
        name : onBlur
        datatype : any
        version : 4.0 onwards
        default :
        description : On blur event
        */
        this.onBlur = new EventEmitter();
        /*
         Events
         name : input
         datatype : any
         version : none
         default :
         description : 	On input event field.
         */
        this.input = new EventEmitter();
        /*
         Events
         name : focus
         datatype : any
         version : none
         default :
         description : On focus event field.
         */
        this.focus = new EventEmitter();
        /*
         Events
         name : change
         datatype : any
         version : none
         default :
         description : On field value change event
         */
        this.change = new EventEmitter();
        /*
        Properties
        name : has-label
        datatype : boolean
        version : 4.0 onwards
        default : none
        description : flag to set label
        */
        this.haslabel = true;
        this.isValid = false;
        this.showToolTip = false;
    }
    /**
     * @return {?}
     */
    get pattern() {
        return this._pattern;
    }
    /*
    Properties
    name : pattern
    datatype : string
    version : 4.0 onwards
    default : none
    description : Apply Reg-ex to the field
    */
    /**
     * @param {?} value
     * @return {?}
     */
    set pattern(value) {
        if (value != null) {
            this._pattern = value;
            this.regEx = new RegExp(this._pattern);
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.name = this.generateName(this.name, this.fieldlabel, 'textareainput');
        this.componentId = this.createCompId('textareainput', this.name);
    }
    // Set touched on blur
    /**
     * @return {?}
     */
    onBlurEvent() {
        this.showToolTip = false;
        this.onBlur.emit(this.value);
    }
    /**
     * @param {?} inputEvent
     * @return {?}
     */
    onFocusEvent(inputEvent) {
        this.eventPropagation(event);
        this.showToolTip = true;
        this.focus.emit({ value: this.value, event: inputEvent });
    }
    /**
     * @param {?} inputEvent
     * @return {?}
     */
    onInputEvent(inputEvent) {
        this.eventPropagation(event);
        this.isValid = this.isFieldValid();
        this.input.emit({ value: this.value, event: inputEvent });
    }
    /**
     * @param {?} inputEvent
     * @return {?}
     */
    onChangeEv(inputEvent) {
        this.eventPropagation(event);
        this.change.emit({ value: this.value, event: inputEvent });
    }
    /**
     * @param {?} event
     * @return {?}
     */
    eventPropagation(event) {
        event.stopPropagation();
    }
    // THIS METHOD IS USED FOR VALIDATION
    /**
     * @return {?}
     */
    isFieldValid() {
        return (!this.allowblank && (this.value && (this.value.length > 0)) ||
            (this.value && this.value.length > 0)) || this.allowblank;
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return this.isFieldValid() ? null : {
            jsonParseError: {
                valid: true,
            },
        };
    }
}
AmexioTextAreaComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-textarea-input',
                template: `

    <div class="inputgroup">

      <label *ngIf="haslabel" role="textarea" for="{{componentId}}" id="{{componentId}}"  [style.font-style]="fontstyle" [style.font-family]="fontfamily" [style.font-size]="fontsize">
        {{fieldlabel}}
      </label>
 
      <textarea type="text"

            role="text" 
            tabindex="1"
            id="{{componentId}}" 
            name="areaText"
            attr.aria-labelledby="{{componentId}}"
            aria-describedby="textAreaDes"
            aria-multiline="true"
            [attr.aria-required]="!allowblank"
            [attr.aria-invalid]="!isValid "

         

             class="input-control"
             [(ngModel)]="value"
             [ngClass]="model.touched ? allowblank ? '' : (isValid && model.touched) ? 'input-control-success' : 'input-control-error' :''" 
             (blur)="onBlurEvent()"
             (focus)="onFocusEvent($event)"
             (input)="onInputEvent($event)"
             (change)="onChangeEv($event)"
             [name]="name"
             [pattern]="regEx"
             [attr.placeholder]="placeholder"
             [attr.rows]="rows"
             [attr.cols]="columns"
             [attr.disabled] = "disabled ? true: null"
             [required]="!allowblank">
      </textarea>

      <ng-container *ngIf="iconfeedback">
          <span class="input-control-feedback">
            <span *ngIf="!isValid && model.touched"><em class="fa fa-times"></em></span>
          <span *ngIf="isValid && model.touched"><em class="fa fa-check"></em></span>
          </span>
      </ng-container>

      <input-help *ngIf="showToolTip && enablepopover" 
            id="textAreaDes"
            role="tooltip"
            [error-msg]="errormsg"
            [max-error-msg]="maxerrormsg"
            [min-error-msg]="minerrormsg" >
      </input-help>

      <span class="inputfieldbar"></span>
    </div>
  `,
                providers: [{
                        provide: NG_VALUE_ACCESSOR, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => AmexioTextAreaComponent)), multi: true,
                    }, {
                        provide: NG_VALIDATORS, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => AmexioTextAreaComponent)), multi: true,
                    }],
            },] },
];
/** @nocollapse */
AmexioTextAreaComponent.ctorParameters = () => [];
AmexioTextAreaComponent.propDecorators = {
    fieldlabel: [{ type: Input, args: ['field-label',] }],
    rows: [{ type: Input }],
    columns: [{ type: Input }],
    allowblank: [{ type: Input, args: ['allow-blank',] }],
    onBlur: [{ type: Output }],
    input: [{ type: Output }],
    focus: [{ type: Output }],
    change: [{ type: Output }],
    minerrormsg: [{ type: Input, args: ['min-error-msg',] }],
    maxerrormsg: [{ type: Input, args: ['max-error-msg',] }],
    errormsg: [{ type: Input, args: ['error-msg',] }],
    placeholder: [{ type: Input, args: ['place-holder',] }],
    disabled: [{ type: Input }],
    iconfeedback: [{ type: Input, args: ['icon-feedback',] }],
    fontstyle: [{ type: Input, args: ['font-style',] }],
    fontfamily: [{ type: Input, args: ['font-family',] }],
    fontsize: [{ type: Input, args: ['font-size',] }],
    haslabel: [{ type: Input, args: ['has-label',] }],
    pattern: [{ type: Input, args: ['pattern',] }],
    enablepopover: [{ type: Input, args: ['enable-popover',] }],
    name: [{ type: Input, args: ['name',] }],
    model: [{ type: ViewChild, args: [NgModel,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/
class ToolbaroneComponent {
    constructor() {
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
}
ToolbaroneComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-toolbar-item',
                template: `
  <div tabindex="1" [ngClass]="{'toolbaritemseperatorright':(seperatorposition === 'right'),
  'toolbaritemseperatorleft':(seperatorposition === 'left')}">
  <ng-content></ng-content>
  </div>
   `,
            },] },
];
/** @nocollapse */
ToolbaroneComponent.ctorParameters = () => [];
ToolbaroneComponent.propDecorators = {
    seperatorposition: [{ type: Input, args: ['seperator-position',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/
class ToolbarComponent {
    constructor() {
        this.className = 'toolbar-header';
        /*
          Events
          name : onClick
          datatype : none
          version : none
          default : none
          description : Callback to invoke on activated tab event.
          */
        this.onClick = new EventEmitter();
        this.toolbarposition = 'top';
        this.seperator = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.toolCollection = this.queryTool.toArray();
        for (const i of this.toolCollection) {
            [i]['position'] = this.getToolbaritemposition([i]['position']);
        }
    }
    /**
     * @param {?} position
     * @return {?}
     */
    getToolbaritemposition(position) {
        if (position === 'right') {
            return 'main-right';
        }
        if (position === 'left') {
            return 'main-left';
        }
        if (position === 'center') {
            return 'main-center';
        }
        if (position === '') {
            return 'main-center';
        }
    }
    /**
     * @param {?} tool
     * @return {?}
     */
    onToolClick(tool) {
        if (!tool.disabled) {
            for (const i of this.toolCollection) {
                if ([i] === tool) {
                    [i]['active'] = true;
                    this.onClick.emit(tool);
                }
                else {
                    [i]['active'] = false;
                }
            }
        }
    }
    // THIS METHOD IS  FOR APPLIED SPERATOR CLASS
    /**
     * @param {?} toolnode
     * @return {?}
     */
    getSeperatotClass(toolnode) {
        /** @type {?} */
        let cssName = '';
        if (this.seperator) {
            cssName = 'seperator-line';
        }
        cssName = cssName + toolnode.position;
        return cssName;
    }
    /**
     * @return {?}
     */
    getToolbarPosition() {
        if (this.toolbarposition === 'top') {
            return '';
        }
        if (this.toolbarposition === 'right') {
            return '';
        }
        if (this.toolbarposition === 'bottom') {
            return '';
        }
    }
}
ToolbarComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-toolbar',
                template: `


    <div tabindex="1" class="toolbar">
        <div class="topnavmainbar">
            <div class="toolbar-item">
                <ng-content select="[position-left]"></ng-content>
                <ng-content select="amexio-panel-header"></ng-content>
                <ng-content select="amexio-form-header"></ng-content>
                <ng-content select="amexio-window-header"></ng-content>
            </div>
            <div class="toolbar-item">
                <ng-content select="[position-center]"></ng-content>
            </div>
            <div class="toolbar-item">
                <ng-content select="[position-right]"></ng-content>
            </div>
        </div>
    </div>
  `,
            },] },
];
/** @nocollapse */
ToolbarComponent.ctorParameters = () => [];
ToolbarComponent.propDecorators = {
    className: [{ type: HostBinding, args: ['attr.class',] }],
    seperator: [{ type: Input, args: ['seperator',] }],
    toolbarposition: [{ type: Input, args: ['toolbar-position',] }],
    onClick: [{ type: Output }],
    tabLocalData: [{ type: Input }],
    queryTool: [{ type: ContentChildren, args: [ToolbaroneComponent,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/
class ToolBarActionComponent {
    constructor() {
        /*
          Events
          name : navLinkClick
          datatype : any
          version : none
          default : none
          description : Fire when nav item is clicked,
          This event is fired when nav item type is defined as 'link/button/menu'
        
          */
        this.navLinkClick = new EventEmitter();
        this.actionComponent = '';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @param {?} clickEvent
     * @return {?}
     */
    onClick(clickEvent) {
        /** @type {?} */
        const node = {
            title: this.title,
            type: this.type,
        };
        this.navLinkClick.emit({ data: node, event: clickEvent });
    }
    /**
     * @return {?}
     */
    checkActionComponent() {
        this.dropdown = this.queryDropDown.toArray();
        if (this.dropdown.length > 0) {
            this.actionComponent = 'dropdown';
            this.dropdown[0].fieldlabel = '';
        }
        this.button = this.queryButton.toArray();
        if (this.button.length > 0) {
            this.actionComponent = 'button';
        }
    }
}
ToolBarActionComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-toolbar-action',
                template: `
   <ng-content></ng-content>
  `,
            },] },
];
/** @nocollapse */
ToolBarActionComponent.ctorParameters = () => [];
ToolBarActionComponent.propDecorators = {
    queryDropDown: [{ type: ContentChildren, args: [AmexioDropDownComponent, { descendants: true },] }],
    queryButton: [{ type: ContentChildren, args: [AmexioButtonComponent, { descendants: true },] }],
    queryLabel: [{ type: ContentChildren, args: [AmexioLabelComponent, { descendants: true },] }],
    type: [{ type: Input }],
    title: [{ type: Input }],
    navLinkClick: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
/**
 * @template T
 */
class BaseInput extends ValueAccessorBaseComponent {
    /**
     * @param {?} event
     * @return {?}
     */
    onBaseInputFocus(event) {
        this.checkValidity();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onBaseInput(event) {
        this.checkValidity();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onBlur2(event) {
        this.checkValidity();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onBaseInputChange(event) {
        this.checkValidity();
    }
    /**
     * @return {?}
     */
    checkValidity() {
    }
    /**
     * @return {?}
     */
    validateOnInit() {
        return true;
    }
    /**
     * @return {?}
     */
    isVali1d() {
        return true;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
/**
 * @template T
 */
class ListBaseComponent extends BaseInput {
    /**
     * @param {?} renderer
     * @param {?} element
     * @param {?} cd
     */
    constructor(renderer, element, cd) {
        super();
        this.renderer = renderer;
        this.element = element;
        this.cd = cd;
        this.self = false;
        this.itemClick = false;
        this.hide();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onFocusEvent(event) {
        this.self = true;
        this.dropdownstyle = { visibility: 'visible' };
        this.bindDocumentClickListener();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    blur(event) {
        this.itemClicked();
    }
    /**
     * @return {?}
     */
    itemClicked() {
        this.itemClick = true;
        this.hide();
        this.unbindDocumentClickListener();
        this.clearClicks();
    }
    /**
     * @return {?}
     */
    bindDocumentClickListener() {
        if (!this.documentClickListener) {
            this.documentClickListener = this.renderer
                .listen('document', 'click', (/**
             * @param {?} event
             * @return {?}
             */
            (event) => this.handleDocumentListener(event)));
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    handleDocumentListener(event) {
        if (!this.self && !this.itemClick) {
            this.hide();
            this.unbindDocumentClickListener();
        }
        this.clearClicks();
        this.cd.markForCheck();
    }
    /**
     * @return {?}
     */
    clearClicks() {
        this.self = false;
        this.itemClick = false;
    }
    /**
     * @return {?}
     */
    unbindDocumentClickListener() {
        if (this.documentClickListener) {
            this.documentClickListener();
            this.documentClickListener = null;
        }
    }
    /**
     * @return {?}
     */
    hide() {
        this.dropdownstyle = { visibility: 'hidden' };
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by ketangote on 11/21/17
*/
class AmexioTypeAheadComponent extends ListBaseComponent {
    /**
     * @param {?} displayFieldService
     * @param {?} dataService
     * @param {?} element
     * @param {?} renderer
     * @param {?} cd
     */
    constructor(displayFieldService, dataService, element, renderer, cd) {
        super(renderer, element, cd);
        this.displayFieldService = displayFieldService;
        this.dataService = dataService;
        this.element = element;
        this.displayValue = '';
        this.onBlur = new EventEmitter();
        this.onInputOutput = new EventEmitter();
        this.onFocusOutput = new EventEmitter();
        this.change = new EventEmitter();
        this.onClick = new EventEmitter();
        this.isComponentValid = new EventEmitter();
        this.rowindex = 0;
        this.maskloader = true;
        this.ariaListExpand = false;
        this.filterarray = [];
    }
    /*
       Properties
       name : field-label
       datatype : string
       version : 4.0 onwards
       default :
       description : The label of this field
       */
    /**
     * @param {?} v
     * @return {?}
     */
    set fieldlabel(v) {
        if (v != null && v.length > 0) {
            this._fieldlabel = v;
            this.initComponent();
        }
    }
    /**
     * @return {?}
     */
    get fieldlabel() {
        return this._fieldlabel;
    }
    /*
       Properties
       name : has-label
       datatype : boolean
       version : 4.0 onwards
       default : false
       description : Flag to set label
       */
    /**
     * @param {?} v
     * @return {?}
     */
    set haslabel(v) {
        this._haslabel = v;
    }
    /**
     * @return {?}
     */
    get haslabel() {
        return this._haslabel;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set data(value) {
        this._data = value;
        if (this.componentLoaded) {
            this.setData(this._data);
        }
    }
    /**
     * @return {?}
     */
    get data() {
        return this._data;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set key(v) {
        this._key = v;
        this.displayfield = this._key;
    }
    /**
     * @return {?}
     */
    get key() {
        return this._key;
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.dropdown = this.dropdownlist.toArray();
        setTimeout((/**
         * @return {?}
         */
        () => {
            this.dropdown.forEach((/**
             * @param {?} dropdown
             * @return {?}
             */
            (dropdown) => {
                dropdown.template = this.bodyTemplate;
            }));
        }), 200);
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.placeholder && !changes.placeholder.isFirstChange()) {
            this.placeholder = changes.placeholder.currentValue;
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.name = this.generateName(this.name, this.fieldlabel, 'typeaheadinput');
        this.componentId = this.createCompId('typeahead', this.displayfield);
        if (!this.valuefield) {
            this.valuefield = this.displayfield;
        }
        this.isValid = this.allowblank;
        this.isComponentValid.emit(this.allowblank);
        if (this.placeholder === '' || this.placeholder == null) {
            this.placeholder = 'Choose Option';
        }
        if (!this.triggerchar) {
            this.triggerchar = 1;
        }
        if (this.httpmethod && this.httpurl) {
            this.dataService.fetchData(this.httpurl, this.httpmethod).subscribe((/**
             * @param {?} response
             * @return {?}
             */
            (response) => {
                this.responseData = response;
            }), (/**
             * @param {?} error
             * @return {?}
             */
            (error) => {
            }), (/**
             * @return {?}
             */
            () => {
                this.setData(this.responseData);
            }));
        }
        else if (this.data) {
            this.previousData = JSON.parse(JSON.stringify(this.data));
            this.setData(this.data);
        }
        this.componentLoaded = true;
    }
    /**
     * @return {?}
     */
    generateIndex() {
        this.viewdata.value.forEach((/**
         * @param {?} element
         * @param {?} index
         * @return {?}
         */
        (element, index) => {
            element['index'] = this.componentId + 'listitem' + index;
        }));
    }
    /**
     * @param {?} event
     * @return {?}
     */
    closeOnEScapeKey(event) {
        this.ariaListExpand = false;
        this.hide();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    input(event) {
        this.filterarray = [];
        /** @type {?} */
        let value;
        this.displayValue = event.target.value;
        this.rowindex = 0;
        if (this.displayValue.length >= 0 && !this.self && this.displayValue.length >= this.triggerchar) {
            this.dropdownstyle = { visibility: 'visible' };
            this.ariaListExpand = true;
            this.bindDocumentClickListener();
        }
        else {
            this.dropdownstyle = { visibility: 'hidden' };
            this.ariaListExpand = false;
        }
        this.onInputOutput.emit(event);
        if (this.displayValue.length > 0) {
            if (this.displayValue === this.displayValue.toUpperCase()) {
                value = this.displayValue.toLowerCase();
            }
            else {
                value = this.displayValue;
            }
            this.viewdata.value.forEach((/**
             * @param {?} element
             * @return {?}
             */
            (element) => {
                if ((this.displayFieldService.findValue(this.displayfield, element).toLowerCase()).startsWith(value)) {
                    this.filterarray.push(element);
                }
            }));
        }
    }
    /**
     * @return {?}
     */
    focustoLast() {
        this.rowindex = this.filterarray.length - 1;
        this.setScrollToList(this.rowindex);
        this.setAriaActiveDescendant(this.rowindex);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    focus(event) {
        this.self = true;
        this.dropdownstyle = { visibility: 'hidden' };
        this.bindDocumentClickListener();
        this.onFocusOutput.emit(event);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    keyup(event) {
        /** @type {?} */
        const keycode = event.keyCode;
        if (keycode === 40) {
            this.rowindex++;
        }
        else if (keycode === 38) {
            this.rowindex--;
        }
        else if (keycode === 40 || keycode === 38) {
            this.rowindex = 0;
        }
        if (this.rowindex < 0) {
            this.rowindex = this.filterarray.length - 1;
        }
        else if (this.rowindex >= this.filterarray.length) {
            this.rowindex = 0;
        }
        this.setAriaActiveDescendant(this.rowindex);
        if (keycode === 13) {
            /** @type {?} */
            const data = this.dropdown[0].selectedItem();
            this.value = data[0].attributes['valuefield'].value;
            this.displayValue = data[0].attributes['displayfield'].value;
            this.itemClicked();
            this.isComponentValid.emit(true);
        }
        else if (keycode === 40 || keycode === 38) {
            this.dropdown[0].scroll(this.rowindex);
        }
    }
    // METHOS FOR BLUR EVENT
    /**
     * @param {?} event
     * @return {?}
     */
    blur(event) {
        super.blur(event);
        /** @type {?} */
        const userinput = event.target.value;
        /** @type {?} */
        const listitems = this.viewdata.value;
        listitems.forEach((/**
         * @param {?} item
         * @return {?}
         */
        (item) => {
            if ((this.displayFieldService.findValue(this.displayfield, item) + '').toLowerCase() === userinput.toLowerCase()) {
                this.displayValue = this.displayFieldService.findValue(this.displayfield, item);
                this.value = item[this.valuefield];
                this.isComponentValid.emit(true);
            }
        }));
        this.onBlur.emit(event);
    }
    // METHOD TO DISPLAY ITEM WHEN SELECTED
    /**
     * @param {?} data
     * @return {?}
     */
    onDropDownListItemClick(data) {
        if (this.valuefield) {
            this.value = data[this.valuefield];
        }
        else {
            this.value = this.displayFieldService.findValue(this.displayfield, data);
        }
        this.displayValue = this.displayFieldService.findValue(this.displayfield, data);
        this.onClick.emit(data);
        this.ariaListExpand = false;
    }
    // METHOD TO READ CURRENT ELEMENT FOCUSED
    /**
     * @param {?} rowindex
     * @return {?}
     */
    setAriaActiveDescendant(rowindex) {
        if (this.filterarray.length > 0) {
            /** @type {?} */
            const inputid = document.getElementById(this.componentId);
            inputid.setAttribute('aria-activedescendant', this.filterarray[rowindex].index);
        }
        else if (this.displayValue.length < 1) {
            /** @type {?} */
            const inputid = document.getElementById(this.componentId);
            inputid.setAttribute('aria-activedescendant', 'listitem');
        }
    }
    // METHOD TO SET SCROLL BASED ON ROWINDEX
    /**
     * @param {?} rowindex
     * @return {?}
     */
    setScrollToList(rowindex) {
        /** @type {?} */
        const listitems = this.element.nativeElement.getElementsByClassName('list-items')[rowindex];
        if (listitems) {
            listitems.scrollIntoView({ behavior: 'smooth' });
        }
    }
    /**
     * @param {?} v
     * @return {?}
     */
    writeValue(v) {
        super.writeValue(v);
        if (v && this.viewdata) {
            this.showValue();
        }
    }
    /**
     * @private
     * @return {?}
     */
    showValue() {
        /** @type {?} */
        const listitems = this.viewdata.value;
        listitems.forEach((/**
         * @param {?} item
         * @return {?}
         */
        (item) => {
            if (item[this.valuefield] === this.value) {
                this.displayValue = this.displayFieldService.findValue(this.displayfield, item);
                this.isComponentValid.emit(true);
            }
        }));
    }
    // METHOD TO INITIALIZE COMPONENT
    /**
     * @return {?}
     */
    initComponent() {
        if (this.fieldlabel != null && this.fieldlabel.length > 0) {
            this.haslabel = true;
        }
    }
    // METHOD TO EMIT CHANGE EVENT
    /**
     * @param {?} event
     * @return {?}
     */
    onChange(event) {
        if (event != null) {
            this.change.emit(event);
        }
    }
    // METHOD TO SET DATA IN DROPDOWN
    /**
     * @param {?} httpResponse
     * @return {?}
     */
    setData(httpResponse) {
        /** @type {?} */
        let responsedata = httpResponse;
        if (this.datareader != null) {
            /** @type {?} */
            const dr = this.datareader.split('.');
            for (const ir of dr) {
                responsedata = responsedata[ir];
            }
        }
        else {
            responsedata = httpResponse;
        }
        this.viewdata = of(responsedata);
        this.generateIndex();
        // SET USER SELECTION
        if (this.value != null) {
            /** @type {?} */
            const valueKey = this.valuefield;
            /** @type {?} */
            const displayKey = this.displayfield;
            /** @type {?} */
            const val = this.value;
            this.viewdata.forEach((/**
             * @param {?} item
             * @return {?}
             */
            (item) => {
                if (item[valueKey] === val) {
                    this.isValid = true;
                    this.displayValue = item[displayKey];
                }
            }));
        }
        this.maskloader = false;
    }
    /**
     * @param {?} c
     * @return {?}
     */
    validate(c) {
        return ((!this.allowblank && this.value) || this.allowblank) ? null : {
            jsonParseError: {
                valid: true,
            },
        };
    }
}
AmexioTypeAheadComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-typeahead',
                template: `


    <div class="inputgroup form-group" (keyup.esc) ="closeOnEScapeKey($event)">

      <label  id="fieldlabel" for="{{componentId}}"  *ngIf="haslabel" [style.font-style]="fontstyle" [style.font-family]="fontfamily" [style.font-size]="fontsize">
        {{fieldlabel}}
      </label>

      <input type="hidden"  [(ngModel)]="value" [name]="name" #model="ngModel" required (ngModelChange)="onChange($event)">
  
      <div class="input-container" >
              <input 
                      id="{{componentId}}"
                      aria-autocomplete="list"	
                      role="combobox"
                      [(ngModel)]="value"
                      [attr.aria-expanded]="ariaListExpand"
                      type="text" class="input-control"
                      [ngClass]="{'input-control-error': ((model.dirty || model.touched || (value && value.length>0)) && !model.valid),
                      'input-disabled' : disabled}"
                      [required]="!allowblank" 
                      [value]="displayValue"
                      [attr.placeholder]="placeholder"
                      [attr.disabled] = "disabled ? true: null"
                      (focus)="focus($event)"
                      (input)="input($event)"
                      (keyup)="keyup($event)"
                      (blur)="blur($event)"
                      (keyup.end)="focustoLast()"
                      />
              <em *ngIf="(iconfeedback && (model.dirty || model.touched) && model.valid)" class="fa fa-check"></em>
              <em *ngIf="(iconfeedback && (model.dirty || model.touched) && !model.valid)" class="fa fa-times icon-error"></em>
      </div>
  
      <dropdown-list-item [@changeState]="dropdownstyle.visibility" class="dropdown" [ngStyle]="dropdownstyle"  
                          [data]="viewdata" [display-field]="displayfield" [value-field]="valuefield" 
                          [highlight-row]="rowindex" [display-value]="displayValue" 
                          (itemclick)="onDropDownListItemClick($event)">
      </dropdown-list-item>
    </div>
  `,
                animations: [
                    trigger('changeState', [
                        state('visible', style({
                            'max-height': '200px',
                        })),
                        state('hidden', style({
                            'max-height': '0px',
                        })),
                        transition('*=>*', animate('200ms')),
                    ]),
                ],
                providers: [{
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: AmexioTypeAheadComponent,
                        multi: true,
                    }, {
                        provide: NG_VALIDATORS, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => AmexioTypeAheadComponent)), multi: true,
                    }],
            },] },
];
/** @nocollapse */
AmexioTypeAheadComponent.ctorParameters = () => [
    { type: DisplayFieldService },
    { type: CommonDataService },
    { type: ElementRef },
    { type: Renderer2 },
    { type: ChangeDetectorRef }
];
AmexioTypeAheadComponent.propDecorators = {
    fieldlabel: [{ type: Input, args: ['field-label',] }],
    haslabel: [{ type: Input, args: ['has-label',] }],
    data: [{ type: Input, args: ['data',] }],
    key: [{ type: Input, args: ['key',] }],
    allowblank: [{ type: Input, args: ['allow-blank',] }],
    datareader: [{ type: Input, args: ['data-reader',] }],
    httpmethod: [{ type: Input, args: ['http-method',] }],
    httpurl: [{ type: Input, args: ['http-url',] }],
    displayfield: [{ type: Input, args: ['display-field',] }],
    valuefield: [{ type: Input, args: ['value-field',] }],
    placeholder: [{ type: Input, args: ['place-holder',] }],
    iconfeedback: [{ type: Input, args: ['icon-feedback',] }],
    fontstyle: [{ type: Input, args: ['font-style',] }],
    fontfamily: [{ type: Input, args: ['font-family',] }],
    fontsize: [{ type: Input, args: ['font-size',] }],
    enablepopover: [{ type: Input, args: ['enable-popover',] }],
    triggerchar: [{ type: Input, args: ['trigger-char',] }],
    name: [{ type: Input }],
    disabled: [{ type: Input }],
    onBlur: [{ type: Output }],
    onInputOutput: [{ type: Output, args: ['input',] }],
    onFocusOutput: [{ type: Output, args: ['focus',] }],
    change: [{ type: Output }],
    onClick: [{ type: Output }],
    isComponentValid: [{ type: Output }],
    model: [{ type: ViewChild, args: [NgModel,] }],
    dropdownlist: [{ type: ViewChildren, args: [DropDownListComponent,] }],
    bodyTemplate: [{ type: ContentChild, args: ['amexioBodyTmpl',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
class AmexioInputHelperComponent {
    constructor() {
        this.isNumberComponent = false;
        this.help = [];
    }
    // error Msg
    /**
     * @param {?} v
     * @return {?}
     */
    set errormsg(v) {
        this._errormsg = v;
    }
    /**
     * @return {?}
     */
    get errormsg() {
        return this._errormsg;
    }
    // Min Msg
    /**
     * @param {?} v
     * @return {?}
     */
    set minmsg(v) {
        this._minmsg = v;
    }
    /**
     * @return {?}
     */
    get minmsg() {
        return this._minmsg;
    }
    // Max Msg
    /**
     * @param {?} v
     * @return {?}
     */
    set maxmsg(v) {
        this._maxmsg = v;
    }
    /**
     * @return {?}
     */
    get maxmsg() {
        return this._maxmsg;
    }
    // mini error msg
    /**
     * @param {?} v
     * @return {?}
     */
    set minerrormsg(v) {
        this._minerrormsg = v;
    }
    /**
     * @return {?}
     */
    get minerrormsg() {
        return this._minerrormsg;
    }
    // max error msg
    /**
     * @param {?} v
     * @return {?}
     */
    set maxerrormsg(v) {
        this._maxerrormsg = v;
    }
    /**
     * @return {?}
     */
    get maxerrormsg() {
        return this._maxerrormsg;
    }
    /**
     * @private
     * @return {?}
     */
    createHelpMsg() {
        if (this.errormsg && this.errormsg.length > 0) {
            this.help.push(this.errormsg);
        }
        if (this.errormsg && this.errormsg.length > 0) {
            this.help.push(this.errormsg);
        }
        if (this.errormsg && this.errormsg.length > 0) {
            this.help.push(this.errormsg);
        }
    }
}
AmexioInputHelperComponent.decorators = [
    { type: Component, args: [{
                selector: 'input-help',
                template: `
      <div  class="input-helper dropdown tooltiptext">
          <div *ngIf="minmsg">
              {{minmsg}}
          </div>
          <div *ngIf="maxmsg">
              {{maxmsg}}
          </div>
          <div *ngIf="errormsg">
              {{errormsg}}
          </div>
          <div *ngIf="!isNumberComponent && minerrormsg">
              <strong>Min Length:</strong> {{minerrormsg}} 
          </div>
          <div *ngIf="!isNumberComponent && maxerrormsg">
              <strong>Max Length: </strong> {{maxerrormsg}} 
          </div> 
          <div *ngIf="isNumberComponent && minvalue && minvalue >0 && minerrormsg">
              <strong>Min Value:</strong> {{minerrormsg}} 
          </div>
          <div *ngIf="isNumberComponent && maxvalue && maxvalue >0 && maxerrormsg">
              <strong>Max Value:</strong> {{maxerrormsg}} 
          </div>
  
      </div>
    `,
                styles: [`
      .input-helper{overflow:auto;position:absolute;width:100%;max-height:200px;-webkit-box-shadow:0 1px 3px 0 #ced4da;box-shadow:0 1px 3px 0 #ced4da}
    `],
            },] },
];
/** @nocollapse */
AmexioInputHelperComponent.ctorParameters = () => [];
AmexioInputHelperComponent.propDecorators = {
    minlength: [{ type: Input, args: ['min-length',] }],
    maxlength: [{ type: Input, args: ['max-length',] }],
    minvalue: [{ type: Input, args: ['min-value',] }],
    maxvalue: [{ type: Input, args: ['max-value',] }],
    isNumberComponent: [{ type: Input, args: ['is-number',] }],
    errormsg: [{ type: Input, args: ['error-msg',] }],
    minmsg: [{ type: Input, args: ['min-msg',] }],
    maxmsg: [{ type: Input, args: ['max-msg',] }],
    minerrormsg: [{ type: Input, args: ['min-error-msg',] }],
    maxerrormsg: [{ type: Input, args: ['max-error-msg',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/
class AmexioAccordionHeaderComponent {
    constructor() {
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
}
AmexioAccordionHeaderComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-accordion-header', template: `
    <ng-content></ng-content>
  `,
            },] },
];
/** @nocollapse */
AmexioAccordionHeaderComponent.ctorParameters = () => [];
AmexioAccordionHeaderComponent.propDecorators = {
    padding: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/
class AmexioAccordionTabComponent {
    constructor() {
        /*
          Events
          name : emittedEvent
          datatype :none
          version : none
          default : none
          description : Fires the on accordion pane click event.
          */
        this.emittedEvent = new EventEmitter();
        this.expanded = false;
        this.isSelected = false;
        this.amexioComponentId = 'amexio-accordion';
        this.currentstate = 'hidden';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.componentId = '' + Math.floor(window.crypto.getRandomValues(new Uint32Array(1))[0]);
        this.emittedEvent.emit({ keydown: true, current: this });
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        setTimeout((/**
         * @return {?}
         */
        () => {
            this.accordionHeaderData = this.amexioAccHeader.toArray();
            if (this.accordionHeaderData && this.accordionHeaderData.length > 0) {
                this.headerPresent = true;
            }
        }), 500);
    }
    /**
     * @return {?}
     */
    emitEvent() {
        if (!this.disabled) {
            this.active = !this.active;
            this.emittedEvent.emit({ keydown: false, current: this });
        }
        if (this.active) {
            this.currentstate = 'visible';
        }
        else {
            this.currentstate = 'hidden';
        }
    }
    /**
     * @return {?}
     */
    onEnterClick() {
        this.expanded = !this.expanded;
    }
    /**
     * @return {?}
     */
    onArrowDown() {
        this.emittedEvent.emit({ keydown: true, current: this });
    }
    /**
     * @return {?}
     */
    onArrowUp() {
        this.emittedEvent.emit({ keyup: true, current: this });
    }
    // Theme Apply
    /**
     * @param {?} themeClass
     * @return {?}
     */
    setColorPalette(themeClass) {
        this.themeCss = themeClass;
    }
    /**
     * @return {?}
     */
    changeHeaderColor() {
        this.gradientFlag = true;
    }
}
AmexioAccordionTabComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-accordion-tab',
                template: `
    <button #btn [ngClass]="themeCss" role="button" id="{{componentId}}" tabindex="0" (click)="emitEvent()" [attr.aria-expanded]="active"
      (keyup.enter)="onEnterClick()" (keyup.arrowdown)="onArrowDown()" (keyup.arrowup)="onArrowUp()" class="{{isTransparent ? 'accordion-transparent' : 'accordion'}} {{active ? 'active-accordion' : ''}} {{disabled ? 'accordion-disable' : ''}}"
      (mouseover)="hover=true" (mouseleave)="hover=false" [ngStyle]="{color: hover==true ? bgColor : color, backgroundColor: hover==true  ? color : bgColor}">
      <div style="float: left; padding-right:5px;" *ngIf="leftIcon">
        <em class="fa {{leftIcon}}"></em>
      </div>
      <ng-container>
       <span [ngStyle]="{'color': gradientFlag ? 'white':''}">{{header}}</span> 
        <div [ngStyle]="{'color': gradientFlag ? 'black':''}" style="float: right" role="img" aria-label="close push button" tabindex="0">
          <ng-content select="amexio-accordion-header">&nbsp;</ng-content> &nbsp;
          <em *ngIf="!angleIcon" class="fa" [ngClass]="{'fa-plus' : !active,'fa-minus' : active}" aria-hidden="true"></em>
          <em *ngIf="angleIcon" class="fa" [ngClass]="{'fa-angle-down' : !active,'fa-angle-up' : active}" aria-hidden="true"></em>
        </div>
      </ng-container>
    </button>
    <div role="region" attr.aria-labelledby="{{componentId}}" tabindex="0" [@accordionState]="active ? 'visible':'hidden'"
      class="panel">
      <ng-content></ng-content>
    </div>
  `,
                animations: [
                    trigger('accordionState', [
                        state('hidden', style({
                            display: 'none',
                            height: '0px',
                        })),
                        state('visible', style({
                            display: 'block',
                            height: '*',
                        })),
                        transition('*=>hidden', animate('0ms')),
                        transition('*=>visible', animate('200ms')),
                    ]),
                ],
            },] },
];
/** @nocollapse */
AmexioAccordionTabComponent.ctorParameters = () => [];
AmexioAccordionTabComponent.propDecorators = {
    header: [{ type: Input }],
    active: [{ type: Input }],
    emittedEvent: [{ type: Output }],
    leftIcon: [{ type: Input, args: ['left-icon',] }],
    angleIcon: [{ type: Input, args: ['angle-icon',] }],
    disabled: [{ type: Input, args: ['disabled',] }],
    data: [{ type: Input, args: ['data',] }],
    btn: [{ type: ViewChild, args: ['btn',] }],
    amexioAccHeader: [{ type: ContentChildren, args: [AmexioAccordionHeaderComponent,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/
class AmexioAccordionComponent extends LifeCycleBaseComponent {
    constructor() {
        super();
        this.flag = false;
        this.prevaccindex = -1;
        this.accindex = -1;
        this.flag = true;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        super.ngAfterViewInit();
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.accordionCollections = this.queryTabs.toArray();
        this.accordionCollections.forEach((/**
         * @param {?} node
         * @return {?}
         */
        (node) => node.emittedEvent.subscribe((/**
         * @param {?} eventdata
         * @return {?}
         */
        (eventdata) => this.activateAccordionPane(eventdata)))));
        this.accordionCollections.forEach((/**
         * @param {?} node
         * @param {?} index
         * @return {?}
         */
        (node, index) => {
            if (this.expandAll) {
                node.active = true;
            }
            else if (node.active) {
                node.active = true;
            }
            else {
                node.active = false;
            }
            if (this.isTransparent) {
                node.isTransparent = true;
            }
            if (this.angleIcon) {
                node.angleIcon = true;
            }
            if (this.color) {
                node.color = this.color;
            }
            if (this.bgColor) {
                node.bgColor = this.bgColor;
            }
            node['index'] = node.componentId;
        }));
    }
    /**
     * @param {?} nodeEvent
     * @return {?}
     */
    activateAccordionPane(nodeEvent) {
        /** @type {?} */
        const node = nodeEvent.current;
        if (nodeEvent.keydown) {
            this.onkeyDown();
        }
        else if (nodeEvent.keyup) {
            this.onkeyUp();
        }
        else {
            this.accordionCollections.forEach((/**
             * @param {?} tab
             * @return {?}
             */
            (tab) => {
                if (tab === node) {
                    tab.active = node.active;
                }
                else if (this.multiopen && tab.active) {
                    tab.active = true;
                }
                else {
                    tab.active = false;
                }
            }));
        }
    }
    /**
     * @return {?}
     */
    onkeyDown() {
        this.onPreAccIndex();
        this.accindex++;
        this.prevaccindex = this.accindex;
        if (this.accindex >= this.accordionCollections.length) {
            this.accindex = 0;
            this.prevaccindex = 0;
        }
        this.setAccoordionActive(this.accindex);
    }
    /**
     * @return {?}
     */
    onkeyUp() {
        this.onPreAccIndex();
        this.prevaccindex--;
        if (this.prevaccindex === -1) {
            this.prevaccindex = this.accordionCollections.length - 1;
            this.accindex = -1;
        }
        this.setAccoordionActive(this.prevaccindex);
        if (this.prevaccindex === 0) {
            this.accindex = 0;
        }
    }
    /**
     * @private
     * @return {?}
     */
    onPreAccIndex() {
        if (this.prevaccindex > -1) {
            this.accordionCollections[this.prevaccindex]['isSelected'] = false;
        }
    }
    /**
     * @private
     * @param {?} index
     * @return {?}
     */
    setAccoordionActive(index) {
        this.accordionCollections[index]['isSelected'] = true;
        if (this.accordionCollections[index]['isSelected']) {
            this.accordionCollections[index].btn.nativeElement.focus();
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        super.ngOnDestroy();
    }
}
AmexioAccordionComponent.decorators = [
    { type: Component, args: [{ selector: 'amexio-accordion', template: `

  <div class="{{roundedgeclass}}">
      <ng-content  select="amexio-accordion-tab"></ng-content>
  </div>
` },] },
];
/** @nocollapse */
AmexioAccordionComponent.ctorParameters = () => [];
AmexioAccordionComponent.propDecorators = {
    expandAll: [{ type: Input, args: ['expand-all',] }],
    isTransparent: [{ type: Input, args: ['transparent',] }],
    angleIcon: [{ type: Input, args: ['angle-icon',] }],
    bgColor: [{ type: Input, args: ['background',] }],
    color: [{ type: Input, args: ['color',] }],
    multiopen: [{ type: Input, args: ['multi-open',] }],
    queryTabs: [{ type: ContentChildren, args: [AmexioAccordionTabComponent,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const LayoutConstant = {
    'start': 'flex-start',
    'end': 'flex-end',
    'center': 'center',
    'space-between': 'space-between',
    'space-around': 'space-around',
    'space-evenly': 'space-evenly',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/
class AmexioLayoutComponent {
    /**
     * @param {?} matchMediaService
     */
    constructor(matchMediaService) {
        this.matchMediaService = matchMediaService;
        this.orientation = 'horizontal';
        this.responsiveMode = false;
        this.border = true;
        this.fit = true;
        /** @type {?} */
        const that = this;
        this.matchMediaService.OnDesktop((/**
         * @param {?} mediaQueryList
         * @return {?}
         */
        (mediaQueryList) => {
            that.handleDeviceSettings();
        }));
        this.matchMediaService.OnTablet((/**
         * @param {?} mediaQueryList
         * @return {?}
         */
        (mediaQueryList) => {
            that.handleDeviceSettings();
        }));
        this.matchMediaService.OnPhone((/**
         * @param {?} mediaQueryList
         * @return {?}
         */
        (mediaQueryList) => {
            that.handleDeviceSettings();
        }));
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.setLayoutDefination();
        this.handleDeviceSettings();
    }
    /**
     * @return {?}
     */
    setLayoutDefination() {
        this.setorientation();
        this.setAlignment();
        this.setBorder();
        this.setFit();
    }
    /**
     * @private
     * @return {?}
     */
    setorientation() {
        this.updateOrientation(this.orientation);
    }
    // THIS FUNCTION IS USED FOR UPDATING ORIENTATION
    /**
     * @private
     * @param {?} orientationName
     * @return {?}
     */
    updateOrientation(orientationName) {
        if (orientationName && orientationName.toLowerCase() === 'vertical') {
            this.orientationDirection = 'column';
        }
        else {
            this.orientationDirection = 'row';
        }
    }
    /**
     * @private
     * @return {?}
     */
    setAlignment() {
        if (this.alignment && LayoutConstant[this.alignment.toLowerCase()]) {
            this.justifyContent = LayoutConstant[this.alignment.toLowerCase()];
        }
        else {
            this.justifyContent = 'start';
        }
    }
    /**
     * @private
     * @return {?}
     */
    setBorder() {
        if (this.border) {
            this.borderstyle = '1px solid #ced4da';
            this.borderboxstyle = '0 2px 2px 0 rgba(0,0,0,.14)';
        }
    }
    /**
     * @private
     * @return {?}
     */
    setFit() {
        if (this.fit) {
            this.height = '100%';
        }
    }
    // THIS FUNCTION HANDLE THE ORITENATION AS PER DEVICE
    /**
     * @private
     * @return {?}
     */
    handleDeviceSettings() {
        if (!this.responsiveMode) {
            if (this.matchMediaService.IsPhone()) {
                this.updateOrientation('vertical');
            }
            else {
                this.updateOrientation(this.orientation);
            }
        }
    }
}
AmexioLayoutComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-layout-columns',
                template: `
      <ng-content></ng-content>
    `,
                styles: [`
    :host {
        display: flex;
    }
  `],
            },] },
];
/** @nocollapse */
AmexioLayoutComponent.ctorParameters = () => [
    { type: DeviceQueryService }
];
AmexioLayoutComponent.propDecorators = {
    orientation: [{ type: Input, args: ['orientation',] }],
    responsiveMode: [{ type: Input, args: ['responsive-mode',] }],
    alignment: [{ type: Input, args: ['alignment',] }],
    border: [{ type: Input, args: ['border',] }],
    fit: [{ type: Input, args: ['fit',] }],
    orientationDirection: [{ type: HostBinding, args: ['style.flex-direction',] }],
    justifyContent: [{ type: HostBinding, args: ['style.justify-content',] }],
    borderstyle: [{ type: HostBinding, args: ['style.border',] }],
    borderboxstyle: [{ type: HostBinding, args: ['style.box-shadow',] }],
    height: [{ type: HostBinding, args: ['style.height',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/
class AmexioLayoutItemComponent {
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.fit) {
            this.flexgrow = 1;
        }
        if (this.padding) {
            this.lipadding = this.padding;
        }
    }
}
AmexioLayoutItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-layout-item',
                template: `
        <ng-content></ng-content>
    `,
            },] },
];
AmexioLayoutItemComponent.propDecorators = {
    fit: [{ type: Input, args: ['fit',] }],
    padding: [{ type: Input, args: ['padding',] }],
    flexgrow: [{ type: HostBinding, args: ['style.flex-grow',] }],
    lipadding: [{ type: HostBinding, args: ['style.padding',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by ketangote on 1/4/18.
*/
class AmexioBorderLayoutItemComponent {
    constructor() {
        this.positionClass = 'borderlayout-';
        this.role = this.positionClass;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @return {?}
     */
    getClassType() {
        /** @type {?} */
        let pos = '';
        if (this.position.toLowerCase() === 'north') {
            pos = 'N';
        }
        else if (this.position.toLowerCase() === 'east') {
            pos = 'E';
        }
        else if (this.position.toLowerCase() === 'center') {
            pos = 'C';
        }
        else if (this.position.toLowerCase() === 'west') {
            pos = 'W';
        }
        else if (this.position.toLowerCase() === 'south') {
            pos = 'S';
        }
        this.positionClass = this.positionClass + pos;
        this.role = this.positionClass;
        return pos;
    }
}
AmexioBorderLayoutItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-borderlayout-item',
                template: `
    <div tabindex="0" attr.aria-label="borderlayoutitem{{position}}">
        <aside style="height:100%;">
            <ng-content></ng-content>
        </aside>
    </div>
  `,
            },] },
];
/** @nocollapse */
AmexioBorderLayoutItemComponent.ctorParameters = () => [];
AmexioBorderLayoutItemComponent.propDecorators = {
    position: [{ type: Input }],
    role: [{ type: HostBinding, args: ['attr.class',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by ketangote on 1/4/18.
*/
class AmexioBorderLayoutComponent {
    constructor() {
        this.borderclass = 'borderlayout-container';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.layoutitems = this.layout.toArray();
        this.layoutitems.forEach((/**
         * @param {?} item
         * @return {?}
         */
        (item) => {
            this.borderclass = this.borderclass + '-' + item.getClassType();
        }));
    }
}
AmexioBorderLayoutComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-borderlayout',
                template: `
    <span tabindex="0" aria-label="borderlayout">
      <section [ngClass]="borderclass">
        <ng-content></ng-content>
      </section>
    </span>
  `,
            },] },
];
/** @nocollapse */
AmexioBorderLayoutComponent.ctorParameters = () => [];
AmexioBorderLayoutComponent.propDecorators = {
    layout: [{ type: ContentChildren, args: [AmexioBorderLayoutItemComponent,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by anaghak07 on 6/3/18.
*/
class AmexioBoxComponent {
    constructor() {
        /*
          Properties
          name : padding
          datatype : boolean
          version : 4.1 onwards
          default : false
          description : Padding to all sides
          */
        this.padding = false;
        /*
         Properties
         name : border-dotted
         datatype : boolean
         version : 4.1.8 onwards
         default : false
         description : Dotted border
         */
        this.borderDotted = false;
        /*
          Properties
          name : closable
          datatype : boolean
          version : 4.1.8 onwards
          default : false
          description : closable box
          */
        this.closable = false;
        this.amexioComponentId = 'amexio-box';
        this.close = true;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.componentId = +Math.floor(window.crypto.getRandomValues(new Uint32Array(1))[0]) + 'box';
        if (this.borderColor == null) {
            this.borderColor = 'box-default';
        }
        if (this.borderColor != null && this.bgColor == null) {
            this.bgColor = this.borderColor;
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    closeBox(event) {
        this.close = false;
        this.closable = false;
    }
    // Theme Apply
    /**
     * @param {?} themeClass
     * @return {?}
     */
    setColorPalette(themeClass) {
        if (themeClass) {
            this.themeCss = themeClass;
        }
    }
    /**
     * @param {?} type
     * @return {?}
     */
    setRoundEdge(type) {
        if (type === 'round-edge') {
            this.roundedgeclass = 'roundEdgeCommonCss';
        }
        else if (type === 'classic') {
            this.roundedgeclass = 'classicCommonCss';
        }
    }
}
AmexioBoxComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-box',
                template: `
    <div class="{{roundedgeclass}}">
    <div for="boxText" id="{{componentId}}" class="box-content {{themeCss}}"  *ngIf="close" [style.height]="height ? height:'none'" [style.width]="width ? width:'none'" [style.align]="align ? align:'none'" [ngClass]="{
    'box-default': borderColor=='default' || borderColor ==null,
    'border-topbar': border=='top',
    'border-bottombar': border =='bottom',
    'border-rightbar': border =='right',
    'border-leftbar': border =='left',
    'border-all' : border =='all',
    'border-top-bottom' : border =='top-bottom' || border =='bottom-top',
    'border-right-left' : border =='right-left' || border =='left-right',

    'bg-brown': bgColor=='brown', 
    'bg-red': bgColor=='red',
    'bg-green': bgColor=='green',
    'bg-yellow': bgColor=='yellow',
    'bg-blue': bgColor=='blue',
    'bg-purple': bgColor=='purple',
    'bg-theme-color' : bgColor =='theme-color',
    'box-transparent' : bgColor =='transparent',

    'border-theme-color' : borderColor =='theme-color',
    'border-red' : borderColor =='red',
    'border-yellow' : borderColor =='yellow',
    'border-green' : borderColor =='green',
    'border-blue' : borderColor =='blue',
    'border-brown' : borderColor =='brown',
    'border-purple' : borderColor =='purple',
    'border-transparent' : borderColor =='transparent',
    'padding' : padding,
    'border-dotted' : borderDotted
     }">
        <span *ngIf="closable" class="box-close">
     <amexio-c-icon key="tab_close" (onClick)="closeBox($event)"></amexio-c-icon>
     </span>
        <span role="tooltip" tabindex="0" id="boxText" name="boxText" attr.aria-labelledby="{{componentId}}">
      <ng-content ></ng-content>
    </span>
    </div>
    </div>
  `,
            },] },
];
/** @nocollapse */
AmexioBoxComponent.ctorParameters = () => [];
AmexioBoxComponent.propDecorators = {
    border: [{ type: Input, args: ['border',] }],
    borderColor: [{ type: Input, args: ['border-color',] }],
    bgColor: [{ type: Input, args: ['background-color',] }],
    padding: [{ type: Input, args: ['padding',] }],
    height: [{ type: Input, args: ['box-height',] }],
    width: [{ type: Input, args: ['box-width',] }],
    borderDotted: [{ type: Input, args: ['border-dotted',] }],
    align: [{ type: Input, args: ['align',] }],
    closable: [{ type: Input, args: ['closable',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by ketangote on 12/18/17.
*/
class AmexioCardComponent extends LifeCycleBaseComponent {
    /**
     * @param {?} renderer
     * @param {?} document
     */
    constructor(renderer, document) {
        super(document);
        this.renderer = renderer;
        this.document = document;
        /*
        Properties
        name : show
        datatype :  boolean
        version : 4.0 onwards
        default : true
        description : User can bind variable to this and hide/unhide card based on requirement..
        */
        this.show = true;
        this.nodeRightClick = new EventEmitter();
        this.rightClick = new EventEmitter();
        this.mouseLocation = { left: 0, top: 0 };
        this.amexioComponentId = 'amexio-card';
        this.maximizeflagchanged = false;
        this.headeralign = 'left';
        this.footeralign = 'right';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
        this.instance = this;
        this.polarideStyleMap = new Map();
        this.polarideStyleMap.set('tilted-minus-2-degree', 'card-container-pol-styl');
        this.polarideStyleMap.set('tilted-2-degree', 'card-container-pol-styl2');
        this.polarideStyleMap.set('tilted-4-degree', 'card-container-pol-styl3');
        this.polarideStyleMap.set('tilted-minus-4-degree', 'card-container-pol-styl4');
        this.polarideStyleMap.forEach((/**
         * @param {?} ele
         * @param {?} key
         * @return {?}
         */
        (ele, key) => {
            if (key === this.styletype) {
                this.tempPolaride = ele;
            }
        }));
        return 'this.tempPolaide';
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        super.ngAfterViewInit();
    }
    /**
     * @return {?}
     */
    ngAfterContentChecked() {
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        // FOR HEADER PADING
        this.headerComponentList = this.amexioHeader.toArray();
        this.headerComponentList.forEach((/**
         * @param {?} item
         * @param {?} currentIndex
         * @return {?}
         */
        (item, currentIndex) => {
            item.fullScreenFlag = this.yesFullScreen;
            item.fullscreenMaxCard = true;
            item.aComponent = 'card';
            if (item.padding) {
                this.headerPadding = item.padding;
            }
        }));
        // FOR BODY PADDING
        this.bodyComponentList = this.amexioBody.toArray();
        this.bodyComponentList.forEach((/**
         * @param {?} item
         * @param {?} currentIndex
         * @return {?}
         */
        (item, currentIndex) => {
            if (item.padding) {
                this.bodyPadding = item.padding;
            }
        }));
        // FOR FOOTER PADDING
        this.footerComponentList = this.amexioFooter.toArray();
        this.footerComponentList.forEach((/**
         * @param {?} item
         * @param {?} currentIndex
         * @return {?}
         */
        (item, currentIndex) => {
            if (item.padding) {
                this.footerPadding = item.padding;
            }
            item.footer = this.footer;
            item.setFooterAlignment(this.footeralign);
        }));
        this.onResize();
        if (this.yesFullScreen) {
            this.amexioHeader.toArray()[0].maximizeWindow1.subscribe((/**
             * @param {?} obj
             * @return {?}
             */
            (obj) => {
                this.headerinst = obj.tempThis;
                this.maximizeflagchanged = this.maxScreenChange(obj.tempEvent);
                obj.tempThis.fullscreenMaxCard = !this.maximizeflagchanged;
            }));
            this.amexioHeader.toArray()[0].minimizeWindow1.subscribe((/**
             * @param {?} obj
             * @return {?}
             */
            (obj) => {
                this.headerinst = obj.tempThis;
                this.maximizeflagchanged = this.minScreenChange(obj.tempEvent);
                obj.tempThis.fullscreenMaxCard = !this.maximizeflagchanged;
            }));
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    adjustHeight(event) {
        this.onResize();
    }
    // Calculate body size based on browser height
    /**
     * @return {?}
     */
    onResize() {
        if (this.bodyheight) {
            /** @type {?} */
            let h = (window.innerHeight / 100) * this.bodyheight;
            if (this.cardHeader && this.cardHeader.nativeElement && this.cardHeader.nativeElement.offsetHeight) {
                h = h - this.cardHeader.nativeElement.offsetHeight;
            }
            if (this.cardFooter && this.cardFooter.nativeElement && this.cardFooter.nativeElement.offsetHeight) {
                h = h - this.cardFooter.nativeElement.offsetHeight;
            }
            if (this.bodyheight === 100) {
                h = h - 40;
            }
            this.minHeight = h;
            this.height = h;
        }
    }
    /**
     * @return {?}
     */
    getContextMenu() {
        if (this.contextmenu && this.contextmenu.length > 0) {
            this.flag = true;
            this.addListner();
        }
    }
    /**
     * @param {?} elementRef
     * @return {?}
     */
    getListPosition(elementRef) {
        /** @type {?} */
        const height = 240;
        if ((window.screen.height - elementRef.getBoundingClientRect().bottom) < height) {
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * @param {?} rightClickData
     * @return {?}
     */
    loadContextMenu(rightClickData) {
        if (this.contextmenu && this.contextmenu.length > 0) {
            this.mouseLocation.left = rightClickData.event.clientX;
            this.mouseLocation.top = rightClickData.event.clientY;
            this.getContextMenu();
            this.posixUp = this.getListPosition(rightClickData.ref);
            rightClickData.event.preventDefault();
            rightClickData.event.stopPropagation();
            this.rightClickNodeData = rightClickData.data;
            this.nodeRightClick.emit(rightClickData);
        }
    }
    /**
     * @param {?} Data
     * @return {?}
     */
    rightClickDataEmit(Data) {
        this.rightClick.emit(Data);
    }
    /**
     * @return {?}
     */
    addListner() {
        this.globalClickListenFunc = this.renderer.listen('document', 'click', (/**
         * @param {?} e
         * @return {?}
         */
        (e) => {
            this.flag = false;
            if (!this.flag) {
                this.removeListner();
            }
        }));
    }
    /**
     * @return {?}
     */
    removeListner() {
        if (this.globalClickListenFunc) {
            this.globalClickListenFunc();
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        super.ngOnDestroy();
        this.removeListner();
    }
    // Theme Apply
    /**
     * @param {?} themeClass
     * @return {?}
     */
    setColorPalette(themeClass) {
        this.themeCss = themeClass;
    }
}
AmexioCardComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-card',
                template: `
    <div #id class="card-container {{roundedgeclass}} {{tempPolaride}}" *ngIf="show" (window:resize)="onResize()" 
    (contextmenu)="loadContextMenu({event:$event,ref:id})" [ngClass]="{'full-screen-card': maximizeflagchanged}">
        <header #cardHeader [ngClass]="themeCss" [style.padding]="headerPadding" class="card-header" *ngIf="header"
         [ngClass]="{'flex-start':(headeralign=='left'),'flex-end':(headeralign=='right'),'flex-center':(headeralign=='center')}">
            <ng-content select="amexio-header"></ng-content>
        </header>
        <div class="card-body cardbody" [style.padding]="bodyPadding"
         [ngStyle]="{'height.px' : height,'overflow-y' : height!= null ? 'auto' : '','min-height.px' : minHeight}">
            <ng-content select="amexio-body"></ng-content>
        </div>
        <footer #cardFooter [style.padding]="footerPadding" class="card-footer {{roundedgeclass}}" *ngIf="footer"
         [ngClass]="{'flex-start':(footeralign=='left'),'flex-end':(footeralign=='right'),'flex-center':(footeralign=='center')}">
            <ng-content select="amexio-action"></ng-content>
        </footer>
    </div>

    <ng-container *ngIf="flag">
        <base-contextmenu 
        [base-context-menu]="contextmenu" 
        [mouse-location-top]="mouseLocation.top"
        [mouse-location-left]="mouseLocation.left" 
        [is-FlagShow]="flag" 
        [right-click-data]="nodeRightClick"
        (onRightClick) ="rightClickDataEmit($event)"
        [position-up]="posixUp">
        </base-contextmenu>
    </ng-container>
  `,
            },] },
];
/** @nocollapse */
AmexioCardComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
];
AmexioCardComponent.propDecorators = {
    headeralign: [{ type: Input, args: ['header-align',] }],
    header: [{ type: Input }],
    footer: [{ type: Input }],
    footeralign: [{ type: Input, args: ['footer-align',] }],
    show: [{ type: Input }],
    height: [{ type: Input }],
    minHeight: [{ type: Input, args: ['min-height',] }],
    bodyheight: [{ type: Input, args: ['body-height',] }],
    contextmenu: [{ type: Input, args: ['context-menu',] }],
    styletype: [{ type: Input, args: ['polaroid-type',] }],
    parentRef: [{ type: Input }],
    nodeRightClick: [{ type: Output }],
    rightClick: [{ type: Output }],
    cardHeader: [{ type: ViewChild, args: ['cardHeader', { read: ElementRef },] }],
    cardFooter: [{ type: ViewChild, args: ['cardFooter', { read: ElementRef },] }],
    amexioHeader: [{ type: ContentChildren, args: [AmexioHeaderComponent,] }],
    amexioBody: [{ type: ContentChildren, args: [AmexioBodyComponent,] }],
    amexioFooter: [{ type: ContentChildren, args: [AmexioFooterComponent,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by pratik on 8/1/18.
*/
class AmexioColumnComponent {
    constructor() {
        this.role = this.colclass;
    }
    /*
    Properties
    name : size
    datatype : any
    version : 4.0 onwards
    default :
    description : Column size*/
    /**
     * @param {?} value
     * @return {?}
     */
    set size(value) {
        this.size_ = value;
        this.colclass = 'flex-col flex-col-' + value;
        this.role = this.colclass;
    }
    /**
     * @return {?}
     */
    get size() {
        return this.size_;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
}
AmexioColumnComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-column', template: `

    <div [ngStyle]="{'height':fit ? '100%':''}">
        <ng-content></ng-content>
    </div>
  `,
            },] },
];
/** @nocollapse */
AmexioColumnComponent.ctorParameters = () => [];
AmexioColumnComponent.propDecorators = {
    role: [{ type: HostBinding, args: ['attr.class',] }],
    fit: [{ type: Input, args: ['fit',] }],
    size: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const GridConstants = {
    Tablet: 'tab',
    Desktop: 'desktop',
    Mobile: 'mobile',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/
class AmexioGridLayoutService {
    constructor() {
        this.layoutData = [];
    }
    /**
     * @param {?} dataLayout
     * @return {?}
     */
    createLayout(dataLayout) {
        /** @type {?} */
        let findStatus = false;
        this.count = dataLayout.count;
        /** @type {?} */
        const data = dataLayout.getLayout();
        data.count = this.count;
        if (this.layoutData.length <= 0) {
            this.layoutData.push(data);
        }
        else {
            this.layoutData.forEach((/**
             * @param {?} obj
             * @return {?}
             */
            (obj) => {
                if (obj.name === data.name) {
                    obj[data.layoutType] = data[data.layoutType];
                    findStatus = true;
                }
            }));
            if (!findStatus) {
                this.layoutData.push(data);
            }
        }
    }
    /**
     * @param {?} layoutName
     * @return {?}
     */
    getLayoutData(layoutName) {
        return this.layoutData.find((/**
         * @param {?} obj
         * @return {?}
         */
        (obj) => obj.name === layoutName));
    }
}
AmexioGridLayoutService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
AmexioGridLayoutService.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/
class AmexioGridItemComponent {
    constructor() {
        this.hcDirection = 'right';
        this.vcDirection = 'top';
        this.onToggle = new EventEmitter();
        this.showContent = true;
        this.containerDirection = 'column';
        this.iconDegreeData = [];
        this.iconDegreeData['vc-towards-top-true'] = 'rotate(270deg)';
        this.iconDegreeData['vc-towards-bottom-true'] = 'rotate(90deg)';
        this.iconDegreeData['hc-towards-left-true'] = 'rotate(180deg)';
        this.iconDegreeData['hc-towards-right-true'] = 'rotate(0deg)';
        this.iconDegreeData['vc-towards-top-false'] = 'rotate(90deg)';
        this.iconDegreeData['vc-towards-bottom-false'] = 'rotate(270deg)';
        this.iconDegreeData['hc-towards-left-false'] = 'rotate(0deg)';
        this.iconDegreeData['hc-towards-right-false'] = 'rotate(180deg)';
    }
    /**
     * @return {?}
     */
    get name() {
        return this._name;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set name(value) {
        this._name = value;
        this.hostname = this._name;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.hcEnabled || this.vcEnabled) {
            this.insertStyleSheetRule('.' + this.name + '{ grid-area: ' + this.name + ' ; padding: 0px } ');
        }
        else {
            this.insertStyleSheetRule('.' + this.name + '{ grid-area: ' + this.name + ' ; padding: 5px } ');
        }
    }
    /**
     * @param {?} ruleText
     * @return {?}
     */
    insertStyleSheetRule(ruleText) {
        /** @type {?} */
        const sheets = document.styleSheets;
        if (sheets.length === 0) {
            /** @type {?} */
            const style = document.createElement('style');
            style.appendChild(document.createTextNode(''));
            document.head.appendChild(style);
        }
        /** @type {?} */
        let isCssAdded = false;
        if (navigator.userAgent.search('Firefox') === -1) {
            for (const sh of sheets) {
                /** @type {?} */
                const sheet = sh;
                if (!isCssAdded && (sheet && sheet.href === null && sheet.rules)) {
                    try {
                        sheet.insertRule(ruleText, 0);
                        isCssAdded = true;
                    }
                    catch (e) {
                    }
                }
            }
        }
        else {
            /** @type {?} */
            const sheet = sheets[sheets.length - 1];
            isCssAdded = false;
            sheet.insertRule(ruleText, sheet.rules ? sheet.rules.length : sheet.cssRules.length);
        }
        this.setClassDefinition();
    }
    /**
     * @return {?}
     */
    setClassDefinition() {
        if (this.hcEnabled) {
            this.hcPosition = 'hc-towards-' + this.hcDirection;
            this.cPosition = 'grid-' + this.hcPosition;
            this.iconDegree = this.iconDegreeData[this.hcPosition + '-' + this.showContent];
            this.containerDirection = (this.showContent) ? 'column' : 'row';
        }
        else if (this.vcEnabled) {
            this.vcPosition = 'vc-towards-' + this.vcDirection;
            this.cPosition = 'grid-' + this.vcPosition;
            this.iconDegree = this.iconDegreeData[this.vcPosition + '-' + this.showContent];
            this.containerDirection = 'column';
        }
    }
    /**
     * @return {?}
     */
    toggle() {
        this.showContent = !this.showContent;
        this.setClassDefinition();
        this.onToggle.emit(this);
    }
}
AmexioGridItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-grid-item',
                template: `
    <div style="height: 100%; width: 100%; position: relative;" [class]="cPosition">

        <div *ngIf="(hcEnabled)" [class]="hcPosition" [ngStyle]="{transform: iconDegree}" (click)="toggle()">
            <i class="fa fa-caret-right" aria-hidden="true"></i>
        </div>
        <div *ngIf="(vcEnabled)" [class]="vcPosition" (click)="toggle()">
            <i class="fa fa-caret-right" aria-hidden="true" [ngStyle]="{transform: iconDegree}"></i>
        </div>

        <div class="griditemcontainer" [ngStyle]="{'flex-direction': containerDirection}">
            <div *ngIf="title" class="griditemcontainer-header"
                [ngClass]="{'griditemcontainer-header-collapsed': (!showContent && hcEnabled)}">
                <label>{{title}}</label>
            </div>
            <div class="griditemcontainer-body" [ngStyle]="{display: showContent ? 'block':'none'}">
                <ng-content></ng-content>
            </div>
        </div>

    </div>
  `,
            },] },
];
/** @nocollapse */
AmexioGridItemComponent.ctorParameters = () => [];
AmexioGridItemComponent.propDecorators = {
    hostname: [{ type: HostBinding, args: ['class',] }],
    name: [{ type: Input, args: ['name',] }],
    title: [{ type: Input, args: ['title',] }],
    hcEnabled: [{ type: Input, args: ['hc-enabled',] }],
    hcDirection: [{ type: Input, args: ['hc-direction',] }],
    vcEnabled: [{ type: Input, args: ['vc-enabled',] }],
    vcDirection: [{ type: Input, args: ['vc-direction',] }],
    onToggle: [{ type: Output, args: ['onToggle',] }],
    mincontent: [{ type: Input, args: ['min-content',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/
class AmexioGridComponent {
    /**
     * @param {?} _gridlayoutService
     */
    constructor(_gridlayoutService) {
        this._gridlayoutService = _gridlayoutService;
        this.gridtemplatecolumnconfig = '';
        this.gridItemCollapsible = false;
        this.prevConfigData = [];
        this.isInit = false;
        this.desktopWidth = '(min-width: 1025px)';
        this.mobileWidth = '(max-width: 767px)';
        this.tabletWidth = '(min-width: 768px) and (max-width: 1024px)';
    }
    /**
     * @return {?}
     */
    get layout() {
        return this._layout;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set layout(value) {
        if (value != null) {
            this._layout = value;
            if (this.isInit) {
                this.gridInit();
            }
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @return {?}
     */
    gridInit() {
        this.containerClass = '';
        this.className = '';
        this.cssGenreration(this._gridlayoutService.getLayoutData(this.layout));
    }
    /**
     * @return {?}
     */
    getCssAttribute() {
        if (this.gridItemCollapsible) {
            return 'display: grid; border:1px solid lightgray;' + ' grid-gap: 0px;'
                + 'grid-template-columns: repeat(' + this.colCount + ', 1fr);';
        }
        else {
            return 'display: grid;' + ' grid-gap: 5px;'
                + 'grid-template-columns: repeat(' + this.colCount + ', 1fr);';
        }
    }
    /**
     * @param {?} ruleText
     * @return {?}
     */
    insertStyleSheetRuleParent(ruleText) {
        /** @type {?} */
        const sheets = document.styleSheets;
        if (sheets.length === 0) {
            /** @type {?} */
            const style = document.createElement('style');
            style.appendChild(document.createTextNode(''));
            document.head.appendChild(style);
        }
        /** @type {?} */
        let isCssAdded = false;
        if (navigator.userAgent.search('Firefox') === -1) {
            for (const sh of sheets) {
                /** @type {?} */
                const sheet = sh;
                if (!isCssAdded && (sheet && sheet.href === null && sheet.rules)) {
                    try {
                        sheet.insertRule(ruleText, 0);
                        isCssAdded = true;
                    }
                    catch (e) {
                    }
                }
            }
        }
        else {
            /** @type {?} */
            const sheet = sheets[sheets.length - 1];
            isCssAdded = false;
            sheet.insertRule(ruleText, sheet.rules ? sheet.rules.length : sheet.cssRules.length);
        }
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.itemCollection = this.queryItem.toArray();
        this.itemCollectionMap = [];
        this.itemCollection.forEach((/**
         * @param {?} cmp
         * @return {?}
         */
        (cmp) => {
            this.itemCollectionMap[cmp.name] = cmp;
            if (!this.gridItemCollapsible) {
                this.gridItemCollapsible = (cmp.hcEnabled || cmp.vcEnabled);
            }
            return cmp.onToggle.subscribe((/**
             * @param {?} cmpObject
             * @return {?}
             */
            (cmpObject) => this.subscribeToGridItemEvents(cmpObject)));
        }));
        this.gridInit();
        this.isInit = true;
    }
    /**
     * @param {?} cmp
     * @return {?}
     */
    subscribeToGridItemEvents(cmp) {
        this.gridtemplatecolumnconfig = '';
        /** @type {?} */
        let rowConfig = [];
        /** @type {?} */
        rowConfig = this.layoutMethod(cmp);
        /** @type {?} */
        let colConfig = [];
        /** @type {?} */
        let prevConfig = '';
        rowConfig.forEach((/**
         * @param {?} name
         * @return {?}
         */
        (name) => {
            /** @type {?} */
            const griditemcmp = this.itemCollectionMap[name];
            if (this.prevConfigData.length === 0) {
                if (griditemcmp.showContent) {
                    colConfig.push((griditemcmp.mincontent ? ' min-content ' : ' 1fr '));
                }
                else if (griditemcmp.name === prevConfig) {
                    colConfig[colConfig.length - 1] = ' 1fr ';
                    colConfig.push((griditemcmp.mincontent ? ' min-content ' : ' 1fr '));
                }
                else {
                    colConfig.push(' auto ');
                }
                prevConfig = griditemcmp.name;
            }
        }));
        colConfig = this.preConfigDataMethod(cmp, colConfig);
        this.prevConfigData = colConfig;
        colConfig.forEach((/**
         * @param {?} name
         * @return {?}
         */
        (name) => {
            this.gridtemplatecolumnconfig = this.gridtemplatecolumnconfig + name;
        }));
    }
    /**
     * @param {?} cmp
     * @return {?}
     */
    layoutMethod(cmp) {
        /** @type {?} */
        let rowConfig = [];
        /** @type {?} */
        const layouts = this._gridlayoutService.getLayoutData(this.layout).desktop;
        layouts.forEach((/**
         * @param {?} rows
         * @return {?}
         */
        (rows) => {
            rows.forEach((/**
             * @param {?} name
             * @return {?}
             */
            (name) => {
                if (name === cmp.name && rowConfig.length === 0) {
                    rowConfig = rows;
                }
            }));
        }));
        return rowConfig;
    }
    /**
     * @param {?} cmp
     * @param {?} colConfig
     * @return {?}
     */
    preConfigDataMethod(cmp, colConfig) {
        this.prevConfigData.forEach((/**
         * @param {?} data
         * @param {?} index
         * @return {?}
         */
        (data, index) => {
            if (data === ' auto ') {
                if (this.itemCollectionMap[cmp.name].showContent) {
                    colConfig = this.prevConfigData;
                    if (cmp.name === 'west' && index === 0) {
                        colConfig[index] = ' 1fr ';
                    }
                    else if (cmp.name === 'east' && index === 5) {
                        colConfig[index] = ' 1fr  ';
                    }
                }
                else {
                    colConfig[index] = data;
                }
            }
            else {
                colConfig[index] = ' 1fr ';
            }
            colConfig = this.subItemCollectionMap(cmp, index, colConfig);
        }));
        return colConfig;
    }
    /**
     * @param {?} cmp
     * @param {?} index
     * @param {?} colConfig
     * @return {?}
     */
    subItemCollectionMap(cmp, index, colConfig) {
        if (this.itemCollectionMap[cmp.name].showContent === false) {
            if (cmp.name === 'west' && index === 0) {
                colConfig[0] = ' auto ';
            }
            else if (cmp.name === 'east' && index === 5) {
                colConfig[colConfig.length - 1] = ' auto ';
            }
        }
        return colConfig;
    }
    /**
     * @param {?} deviceName
     * @return {?}
     */
    dataCreation(deviceName) {
        this.containerClass = '';
        deviceName.forEach((/**
         * @param {?} ele
         * @return {?}
         */
        (ele) => {
            this.containerClass = this.containerClass + '"' + ele.join(' ') + '"';
        }));
        return this.containerClass;
    }
    /**
     * @param {?} layoutData
     * @return {?}
     */
    cssGenreration(layoutData) {
        this.colCount = layoutData.count;
        this.className = this.className + '' + layoutData.name;
        if (layoutData.desktop.length > 0) {
            this.cssGenerationCommonMethod(layoutData, this.desktopWidth, GridConstants.Desktop);
            if (layoutData.tab.length === 0) {
                this.cssGenerationCommonMethod(layoutData, this.tabletWidth, GridConstants.Desktop);
            }
            else {
                this.cssGenerationCommonMethod(layoutData, this.tabletWidth, GridConstants.Tablet);
            }
            if (layoutData.mobile.length === 0 && layoutData.tab.length === 0) {
                this.cssGenerationCommonMethod(layoutData, this.mobileWidth, GridConstants.Desktop);
            }
            else if (layoutData.mobile.length === 0 && layoutData.tab.length > 0) {
                this.cssGenerationCommonMethod(layoutData, this.mobileWidth, GridConstants.Tablet);
            }
            else {
                this.cssGenerationCommonMethod(layoutData, this.mobileWidth, GridConstants.Mobile);
            }
        }
        else {
            this.cssGenerationNoDesktop(layoutData);
        }
    }
    // Refactored above method
    /**
     * @param {?} layoutData
     * @return {?}
     */
    cssGenerationNoDesktop(layoutData) {
        if (layoutData.tab.length > 0 && layoutData.mobile.length === 0) {
            this.cssGenerationCommonMethod(layoutData, this.desktopWidth, GridConstants.Tablet);
            this.cssGenerationCommonMethod(layoutData, this.tabletWidth, GridConstants.Tablet);
            this.cssGenerationCommonMethod(layoutData, this.mobileWidth, GridConstants.Tablet);
        }
        else if (layoutData.tab.length === 0 && layoutData.mobile.length > 0) {
            this.cssGenerationCommonMethod(layoutData, this.mobileWidth, GridConstants.Mobile);
            this.cssGenerationCommonMethod(layoutData, this.tabletWidth, GridConstants.Mobile);
            this.cssGenerationCommonMethod(layoutData, this.desktopWidth, GridConstants.Mobile);
        }
    }
    /**
     * @param {?} layoutData
     * @param {?} screenWidth
     * @param {?} deviceType
     * @return {?}
     */
    cssGenerationCommonMethod(layoutData, screenWidth, deviceType) {
        this.insertStyleSheetRuleParent('@' + 'media' + screenWidth + '{' + '.' + layoutData.name +
            '{' + this.getCssAttribute() + ' grid-template-areas: ' +
            this.dataCreation(layoutData[deviceType]) + '}' + '}');
    }
}
AmexioGridComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-layout-grid',
                template: `
    <div [ngClass]="className" [ngStyle]="{'grid-template-columns': gridtemplatecolumnconfig}">
          <ng-content select="amexio-grid-item"></ng-content>
    </div>
  `,
            },] },
];
/** @nocollapse */
AmexioGridComponent.ctorParameters = () => [
    { type: AmexioGridLayoutService }
];
AmexioGridComponent.propDecorators = {
    queryItem: [{ type: ContentChildren, args: [AmexioGridItemComponent,] }],
    layout: [{ type: Input, args: ['layout',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*  Created by pratik on 8/1/18.
*/
class AmexioRowComponent {
    constructor() {
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
    }
}
AmexioRowComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-row', template: `
    <div class="flex-row">
      <ng-content></ng-content>
    </div>
  `,
            },] },
];
/** @nocollapse */
AmexioRowComponent.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by pratik on 24/1/18.
*/
class AccordionService {
    constructor() {
        this.subject = new rxjs_5();
    }
    /**
     * @param {?} data
     * @param {?} parent
     * @return {?}
     */
    onClickEvent(data, parent) {
        this.subject.next({ data, parent });
    }
    /**
     * @return {?}
     */
    clearEvents() {
        this.subject.next();
    }
    /**
     * @return {?}
     */
    getEvents() {
        return this.subject.asObservable();
    }
}
AccordionService.decorators = [
    { type: Injectable },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*  Created by pratik on 27/11/17.
*/
/** @type {?} */
const LAYOUT_COMPONENTS = [
    AmexioRowComponent,
    AmexioColumnComponent,
    AmexioGridComponent,
    AmexioGridItemComponent,
    AmexioBorderLayoutItemComponent,
    AmexioBorderLayoutComponent,
    AmexioCardComponent,
    AmexioBoxComponent,
    AmexioAccordionTabComponent,
    AmexioAccordionComponent,
    AmexioAccordionHeaderComponent,
    AmexioLayoutComponent,
    AmexioLayoutItemComponent,
];
class AmexioLayoutModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: AmexioLayoutModule,
            providers: [CommonDataService, DeviceQueryService, IconLoaderService, AmexioGridLayoutService],
        };
    }
}
AmexioLayoutModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    FormsModule,
                    HttpClientModule,
                    AmexioBaseContextMenuModule,
                    AmexioCommonModule,
                ],
                exports: LAYOUT_COMPONENTS,
                declarations: LAYOUT_COMPONENTS,
                providers: [CommonDataService, DeviceQueryService, IconLoaderService, AmexioGridLayoutService],
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 * Copyright [2019] [Metamagic]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Created by sagar on 23/1/19.
 * INFO: THIS SERVICE USED FOR SCRIPT LOADING
 */
class ScriptLoadService {
    constructor() { }
    // THIS FUNCTION IS CREATING SCRIPT TAG AND DYNAMIC LOAD SCRIPT INFO HEAD
    /**
     * @param {?} loginProviderObj
     * @param {?=} onload
     * @return {?}
     */
    loadScript(loginProviderObj, onload) {
        /** @type {?} */
        const signInJS = document.createElement('script');
        signInJS.async = true;
        signInJS.onload = onload;
        signInJS.src = loginProviderObj.url;
        if (loginProviderObj.name === 'linkedin') {
            signInJS.async = false;
            signInJS.text = ('api_key: ' + loginProviderObj.id).replace('\'', '');
        }
        if (!this.isScriptAlreadyPresent(signInJS.src)) {
            document.head.appendChild(signInJS);
        }
    }
    // THIS METHOD IS USED FOR CHEKING SCIRPT IS PRESENT IN BODY OT NOT
    /**
     * @param {?} script
     * @return {?}
     */
    isScriptAlreadyPresent(script) {
        /** @type {?} */
        const scripts = document.getElementsByTagName('script');
        /** @type {?} */
        let isScriptLoaded;
        // tslint:disable-next-line:prefer-for-of
        for (let i = 0; i < scripts.length; i++) {
            /** @type {?} */
            const scriptData = scripts[i];
            if (scriptData.src === script) {
                isScriptLoaded = true;
                return isScriptLoaded;
            }
        }
        return isScriptLoaded;
    }
}
ScriptLoadService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
ScriptLoadService.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AmexioBadgeComponent {
    constructor() {
        this.orientation = 'vertical';
        this.cClass = '';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (!this.color && !this.background) {
            this.cClass = 'amexio-badge-color';
        }
    }
    /**
     * @param {?} type
     * @return {?}
     */
    setRoundEdge(type) {
        if (type === 'round-edge') {
            this.roundedgeclass = 'roundEdgeCommonCss';
        }
        else if (type === 'classic') {
            this.roundedgeclass = 'classicCommonCss';
        }
    }
}
AmexioBadgeComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-badge',
                template: `
    <div class="amexio-badge {{roundedgeclass}}" [ngClass]="cClass" [style.background]="background" [style.color]="color" [style.top]="top" [style.left]="left" [style.right]="right" [style.bottom]="bottom" [style.height]="height" [style.width]="width" [ngStyle]="{'position': absolute ? 'absolute' : 'relative',
                    'flex-direction': (orientation === 'horizontal') ? 'row' : 'column'
                    }">
        <ng-content></ng-content>
    </div>
  `,
            },] },
];
/** @nocollapse */
AmexioBadgeComponent.ctorParameters = () => [];
AmexioBadgeComponent.propDecorators = {
    absolute: [{ type: Input, args: ['absolute',] }],
    background: [{ type: Input, args: ['background',] }],
    color: [{ type: Input, args: ['color',] }],
    top: [{ type: Input, args: ['top',] }],
    left: [{ type: Input, args: ['left',] }],
    right: [{ type: Input, args: ['right',] }],
    bottom: [{ type: Input, args: ['bottom',] }],
    orientation: [{ type: Input, args: ['orientation',] }],
    height: [{ type: Input, args: ['height',] }],
    width: [{ type: Input, args: ['width',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 * Copyright [2019] [Metamagic]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Created by sagar on 29/1/19.
 * INFO: BASE COMPONENT
 */
class SocialBaseComponent {
    constructor() {
        /*
            Properties
            name : style-type
            datatype : string
            version : 5.5.3 onwards
            default : null
            description : style of component
           */
        this.styleType = 'square';
    }
}
SocialBaseComponent.propDecorators = {
    clientId: [{ type: Input, args: ['client-id',] }],
    label: [{ type: Input, args: ['label',] }],
    styleType: [{ type: Input, args: ['style-type',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 * Copyright [2019] [Metamagic]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Created by sagar on 23/1/19.
 * INFO: THIS CLASS HOLD LOGININ INFO
 */
class LoginProvider {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by sagar on 23/1/19.
  INFO: THIS CONSTANT USE FOR SOCIAL COMPONENT
*/
/** @type {?} */
const SOCIAL_CONSTANT = {
    GOOGLE: 'google',
    FACEBOOK: 'facebook',
    LINKEDIN: 'linkedin',
    FACEBOOK_API_URL: 'https://connect.facebook.net/en_US/sdk.js',
    GOOGLE_GMAIL_API_URL: 'https://apis.google.com/js/platform.js',
    LINKEDIN_API_URL: 'https://platform.linkedin.com/in.js',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 * Copyright [2019] [Metamagic]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Created by sagar on 23/1/19.
 * INFO:THIS MODEL CLASS HAVE INFO OF USER
 */
class SocialUserInfo {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 * Copyright [2019] [Metamagic]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Created by sagar on 23/1/19.
 * INFO: FACEBOOK AUTH COMPONENT IS USED FOR THIRD PARTY LOGIN USING FACEBOOK OAUTH API
 */
class FacebookAuthComponent extends SocialBaseComponent {
    /**
     * @param {?} scriptLoadService
     */
    constructor(scriptLoadService) {
        super();
        this.scriptLoadService = scriptLoadService;
        this.loginProviderObj = new LoginProvider();
        this.onLogin = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.styleType && this.styleType.toLowerCase() === 'circle') {
            this.isCircle = true;
        }
        if (this.styleType && this.styleType.toLowerCase() === 'square') {
            this.isCircle = false;
        }
        this.loginProviderObj.id = this.clientId;
        this.loginProviderObj.name = SOCIAL_CONSTANT.FACEBOOK;
        this.loginProviderObj.url = SOCIAL_CONSTANT.FACEBOOK_API_URL;
        this.initialize();
    }
    // ON CLICK EVENT CALL SIGNIN FUNCTION
    /**
     * @return {?}
     */
    onButtonClick() {
        this.signIn();
    }
    // THIS FUNCTION IS USED FOR INITALIZE THE AUTH2 OBJECT AND RETURN USER INFO
    /**
     * @return {?}
     */
    initialize() {
        return new Promise((/**
         * @param {?} resolve
         * @param {?} reject
         * @return {?}
         */
        (resolve, reject) => {
            this.scriptLoadService.loadScript(this.loginProviderObj, (/**
             * @return {?}
             */
            () => {
                FB.init({
                    appId: this.clientId,
                    autoLogAppEvents: true,
                    cookie: true,
                    xfbml: true,
                    version: 'v2.10',
                });
                FB.AppEvents.logPageView();
                FB.getLoginStatus((/**
                 * @param {?} response
                 * @return {?}
                 */
                function (response) {
                    if (response.status === 'connected') {
                        /** @type {?} */
                        const accessToken = FB.getAuthResponse()['accessToken'];
                        FB.api('/me?fields=name,email,picture', (/**
                         * @param {?} res
                         * @return {?}
                         */
                        (res) => {
                            resolve(this.getUserinfo(Object.assign({}, { token: accessToken }, res)));
                        }));
                    }
                }));
            }));
        }));
    }
    /**
     * @param {?} response
     * @return {?}
     */
    getUserinfo(response) {
        /** @type {?} */
        const user = new SocialUserInfo();
        user.id = response.id;
        user.name = response.name;
        user.email = response.email;
        user.token = response.token;
        user.image = 'https://graph.facebook.com/' + response.id + '/picture?type=normal';
        if (user && user.name) {
            this.onLogin.emit(user);
        }
        return user;
    }
    /**
     * @return {?}
     */
    signIn() {
        return new Promise((/**
         * @param {?} resolve
         * @param {?} reject
         * @return {?}
         */
        (resolve, reject) => {
            FB.login((/**
             * @param {?} response
             * @return {?}
             */
            (response) => {
                if (response.authResponse) {
                    /** @type {?} */
                    const accessToken = FB.getAuthResponse()['accessToken'];
                    FB.api('/me?fields=name,email,picture', (/**
                     * @param {?} res
                     * @return {?}
                     */
                    (res) => {
                        resolve(this.getUserinfo(Object.assign({}, { token: accessToken }, res)));
                    }));
                }
            }), { scope: 'email,public_profile' });
        }));
    }
}
FacebookAuthComponent.decorators = [
    { type: Component, args: [{
                // tslint:disable-next-line:component-selector
                selector: 'amexio-facebook-auth-provider',
                template: `
    <div class="social-button">
            <ng-container *ngIf="!isCircle && styleType != 'square'" >
                    <amexio-button [bg-color]="'#3b5998'" [color]="'#fff'" [label]="label" [tooltip]="'Facebook'" [icon]="'fa fa-facebook'" (onClick)="onButtonClick()"></amexio-button>
            </ng-container>
    
            <ng-container *ngIf="styleType == 'square'">
                    <amexio-floating-button  [block]="'square'" [bg-color]="'#3b5998'" [color]="'#fff'" [relative]="true" [type]="'default'" [icon]="'fa fa-facebook'" (onClick)="onButtonClick()"></amexio-floating-button>
            </ng-container>
    
            <ng-container *ngIf="styleType == 'circle'">
                    <amexio-floating-button [bg-color]="'#3b5998'" [color]="'#fff'" [relative]="true" [icon]="'fa fa-facebook'" [type]="'default'" (onClick)="onButtonClick()"></amexio-floating-button>
            </ng-container>
        </div>
  `,
            },] },
];
/** @nocollapse */
FacebookAuthComponent.ctorParameters = () => [
    { type: ScriptLoadService }
];
FacebookAuthComponent.propDecorators = {
    onLogin: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 * Copyright [2019] [Metamagic]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Created by medha on 23/1/19.
 * INFO: FACEBOOK AUTH COMPONENT IS USED FOR THIRD PARTY LOGIN USING FACEBOOK OAUTH API
 */
/**
 * @return {?}
 */
function _window() {
    // return the global native browser window object
    return window;
}
class GithubAuthComponent extends SocialBaseComponent {
    constructor() {
        super();
        this.onLogin = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.styleType && this.styleType.toLowerCase() === 'circle') {
            this.isCircle = true;
        }
        if (this.styleType && this.styleType.toLowerCase() === 'square') {
            this.isCircle = false;
        }
        /** @type {?} */
        const oauthScript = document.createElement('script');
        oauthScript.src = 'https://cdn.rawgit.com/oauth-io/oauth-js/c5af4519/dist/oauth.js';
        document.body.appendChild(oauthScript);
    }
    // navigate to github login api
    /**
     * @param {?} e
     * @return {?}
     */
    loginToGithub(e) {
        /** @type {?} */
        const user = new SocialUserInfo();
        _window().OAuth.initialize(this.clientId);
        _window().OAuth.popup('github').then((/**
         * @param {?} provider
         * @return {?}
         */
        (provider) => {
            user.token = provider.access_token;
            provider.me().then((/**
             * @param {?} response
             * @return {?}
             */
            (response) => {
                user.id = response.id;
                user.name = response.name ? response.name : null;
                user.email = response.email ? response.email : null;
                user.image = response.avatar_url ? response.avatar_url : null;
                if (user && user.name) {
                    this.onLogin.emit(user);
                }
            }));
        }));
    }
}
GithubAuthComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-github-auth-provider',
                template: `

    <div class="social-button">
    	<ng-container *ngIf="!isCircle && styleType != 'square'"  >
    			<amexio-button *ngIf="label" [bg-color]="'#424949'" [color]="'#fff'" [label]="label" [tooltip]="'Github'" [icon]="'fa fa-github'" (onClick)="loginToGithub($event)"></amexio-button>
    	</ng-container>

    	<ng-container *ngIf="styleType == 'square' && !label">
    			<amexio-floating-button  [block]="'square'" [bg-color]="'#424949'" [color]="'#fff'" [relative]="true" [type]="'default'" [icon]="'fa fa-github'" (onClick)="loginToGithub($event)"></amexio-floating-button>
    	</ng-container>

    	<ng-container *ngIf="styleType == 'circle'">
    			<amexio-floating-button [bg-color]="'#424949'" [color]="'#fff'" [relative]="true" [icon]="'fa fa-github'" [type]="'default'" (onClick)="loginToGithub($event)"></amexio-floating-button>
    	</ng-container>
    </div>
  `,
            },] },
];
/** @nocollapse */
GithubAuthComponent.ctorParameters = () => [];
GithubAuthComponent.propDecorators = {
    onLogin: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 * Copyright [2019] [Metamagic]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Created by sagar on 23/1/19.
 * INFO: GOOGLE AUTH COMPONENT IS USED FOR THIRD PARTY LOGIN USING GOOGLE OAUTH API
 */
class GoogleAuthComponent extends SocialBaseComponent {
    /**
     * @param {?} meta
     * @param {?} scriptLoadService
     */
    constructor(meta, scriptLoadService) {
        super();
        this.meta = meta;
        this.scriptLoadService = scriptLoadService;
        this.loginProviderObj = new LoginProvider();
        this.onLogin = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.loginProviderObj.id = this.clientId;
        this.loginProviderObj.name = SOCIAL_CONSTANT.GOOGLE;
        this.loginProviderObj.url = SOCIAL_CONSTANT.GOOGLE_GMAIL_API_URL;
        this.meta.addTag({
            name: 'google-signin-client_id',
            content: this.clientId,
        });
        if (this.styleType && this.styleType.toLowerCase() === 'circle') {
            this.isCircle = true;
        }
        if (!this.label && this.styleType && this.styleType.toLowerCase() !== 'circle') {
            this.label = 'GOOGLE';
        }
        this.initialize();
    }
    // ON CLICK EVENT CALL SIGNIN FUNCTION
    /**
     * @return {?}
     */
    onButtonClick() {
        this.signIn();
    }
    // THIS FUNCTION IS USED FOR INITALIZE THE AUTH2 OBJECT AND RETURN USER INFO
    /**
     * @return {?}
     */
    initialize() {
        return new Promise((/**
         * @param {?} resolve
         * @param {?} reject
         * @return {?}
         */
        (resolve, reject) => {
            this.scriptLoadService.loadScript(this.loginProviderObj, (/**
             * @return {?}
             */
            () => {
                gapi.load('auth2', (/**
                 * @return {?}
                 */
                () => {
                    this.auth2 = gapi.auth2.init({
                        client_id: this.clientId,
                        scope: 'email',
                    });
                    this.auth2.then((/**
                     * @return {?}
                     */
                    () => {
                        if (this.auth2.isSignedIn.get()) {
                            resolve(this.getLoginInUserInfo());
                        }
                    }));
                }));
            }));
        }));
    }
    // THIS FUNCTION IS USED FOR GETTING USER INFO
    /**
     * @return {?}
     */
    getLoginInUserInfo() {
        /** @type {?} */
        const user = new SocialUserInfo();
        /** @type {?} */
        const profile = this.auth2.currentUser.get().getBasicProfile();
        /** @type {?} */
        const authResponseObj = this.auth2.currentUser.get().getAuthResponse(true);
        if (profile && authResponseObj) {
            user.id = profile.getId();
            user.name = profile.getName();
            user.email = profile.getEmail();
            user.image = profile.getImageUrl();
            user.token = authResponseObj.access_token;
            user.idToken = authResponseObj.id_token;
            this.onLogin.emit(user);
        }
        return user;
    }
    // THIS FUNCTION IS USED FOR SIGN IN AND GET USER INFO
    /**
     * @return {?}
     */
    signIn() {
        return new Promise((/**
         * @param {?} resolve
         * @param {?} reject
         * @return {?}
         */
        (resolve, reject) => {
            /** @type {?} */
            const promise = this.auth2.signIn();
            promise.then((/**
             * @return {?}
             */
            () => {
                resolve(this.getLoginInUserInfo());
            }));
        }));
    }
}
GoogleAuthComponent.decorators = [
    { type: Component, args: [{
                // tslint:disable-next-line:component-selector
                selector: 'amexio-google-auth-provider',
                template: `
    <div class="social-button">

        <ng-container *ngIf="!isCircle && styleType != 'square'" >
                <amexio-button [bg-color]="'#dd4b39'" [color]="'#fff'" [label]="label" [tooltip]="'Google'" [icon]="'fa fa-google'" (onClick)="onButtonClick()"></amexio-button>
        </ng-container>

        <ng-container *ngIf="styleType == 'square'">
                <amexio-floating-button  [block]="'square'" [bg-color]="'#dd4b39'" [color]="'#fff'" [relative]="true" [type]="'default'" [icon]="'fa fa-google'" (onClick)="onButtonClick()"></amexio-floating-button>
        </ng-container>

        <ng-container *ngIf="styleType == 'circle'">
                <amexio-floating-button [bg-color]="'#dd4b39'" [color]="'#fff'" [relative]="true" [icon]="'fa fa-google'" [type]="'default'" (onClick)="onButtonClick()"></amexio-floating-button>
        </ng-container>
    </div>
  `,
            },] },
];
/** @nocollapse */
GoogleAuthComponent.ctorParameters = () => [
    { type: Meta },
    { type: ScriptLoadService }
];
GoogleAuthComponent.propDecorators = {
    onLogin: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 * Copyright [2019] [Metamagic]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Created by sagar on 23/1/19.
 * INFO: LINKEDIN AUTH COMPONENT IS USED FOR THIRD PARTY LOGIN USING LINKEDIN OAUTH API
 */
class LinkedInAuthComponent extends SocialBaseComponent {
    /**
     * @param {?} scriptLoadService
     */
    constructor(scriptLoadService) {
        super();
        this.scriptLoadService = scriptLoadService;
        this.loginProviderObj = new LoginProvider();
        this.onLogin = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.styleType && this.styleType.toLowerCase() === 'circle') {
            this.isCircle = true;
        }
        if (!this.label && this.styleType && this.styleType.toLowerCase() !== 'circle') {
            this.label = 'Linkedin';
        }
        this.loginProviderObj.id = this.clientId;
        this.loginProviderObj.name = SOCIAL_CONSTANT.LINKEDIN;
        this.loginProviderObj.url = SOCIAL_CONSTANT.LINKEDIN_API_URL;
        this.initialize();
    }
    // ON CLICK EVENT CALL SIGNIN FUNCTION
    /**
     * @return {?}
     */
    onButtonClick() {
        if (IN && IN.User.authorize()) {
            console.log('User already loggedin...');
            return;
        }
        else {
            this.signIn();
        }
    }
    // THIS FUNCTION IS USED FOR INITALIZE THE AUTH2 OBJECT AND RETURN USER INFO
    /**
     * @return {?}
     */
    initialize() {
        return new Promise((/**
         * @param {?} resolve
         * @param {?} reject
         * @return {?}
         */
        (resolve, reject) => {
            this.scriptLoadService.loadScript(this.loginProviderObj, (/**
             * @return {?}
             */
            () => {
                IN.init({
                    api_key: this.clientId,
                    authorize: true,
                });
                IN.Event.on(IN, 'auth', (/**
                 * @return {?}
                 */
                () => {
                    if (IN.User.isAuthorized()) {
                        IN.API.Raw('/people/~:(id,first-name,last-name,email-address,picture-url)').result((/**
                         * @param {?} res
                         * @return {?}
                         */
                        (res) => {
                            resolve(this.getLoginInUserInfo(res));
                        }));
                    }
                }));
            }));
        }));
    }
    // THIS FUNCTION IS USED FOR LINKEDIN
    /**
     * @return {?}
     */
    onLinkedInLoad() {
        IN.Event.on(IN, 'systemReady', (/**
         * @return {?}
         */
        () => {
            IN.User.refresh();
        }));
    }
    // THIS FUNCTION IS GET INFO OF LOGIINED USER
    /**
     * @private
     * @param {?} response
     * @return {?}
     */
    getLoginInUserInfo(response) {
        /** @type {?} */
        const user = new SocialUserInfo();
        user.id = response.emailAddress;
        user.name = response.firstName + ' ' + response.lastName;
        user.email = response.emailAddress;
        user.image = response.pictureUrl;
        user.token = IN.ENV.auth.oauth_token;
        this.onLogin.emit(user);
        return user;
    }
    /**
     * @private
     * @return {?}
     */
    signIn() {
        return new Promise((/**
         * @param {?} resolve
         * @param {?} reject
         * @return {?}
         */
        (resolve, reject) => {
            // tslint:disable-next-line:no-identical-functions
            IN.Event.on(IN, 'auth', (/**
             * @return {?}
             */
            () => {
                if (IN.User.isAuthorized()) {
                    IN.API.Raw('/people/~:(id,first-name,last-name,email-address,picture-url)').result((/**
                     * @param {?} res1
                     * @return {?}
                     */
                    (res1) => {
                        resolve(this.getLoginInUserInfo(res1));
                    }));
                }
            }));
        }));
    }
}
LinkedInAuthComponent.decorators = [
    { type: Component, args: [{
                // tslint:disable-next-line:component-selector
                selector: 'amexio-linkedin-auth-provider',
                template: `
    <div class="social-button">

        <ng-container *ngIf="!isCircle && styleType != 'square'" >
                <amexio-button [bg-color]="'#0082ca'" [color]="'#fff'" [label]="label" [tooltip]="'Linkedin'" [icon]="'fa fa-linkedin'" (onClick)="onButtonClick()"></amexio-button>
        </ng-container>

        <ng-container *ngIf="styleType == 'square'">
                <amexio-floating-button  [block]="'square'" [bg-color]="'#0082ca'" [color]="'#fff'" [relative]="true" [type]="'default'" [icon]="'fa fa-linkedin'" (onClick)="onButtonClick()"></amexio-floating-button>
        </ng-container>

        <ng-container *ngIf="styleType == 'circle'">
                <amexio-floating-button [bg-color]="'#0082ca'" [color]="'#fff'" [relative]="true" [icon]="'fa fa-linkedin'" [type]="'default'" (onClick)="onButtonClick()"></amexio-floating-button>
        </ng-container>
    </div>
  `,
            },] },
];
/** @nocollapse */
LinkedInAuthComponent.ctorParameters = () => [
    { type: ScriptLoadService }
];
LinkedInAuthComponent.propDecorators = {
    onLogin: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by sagar on 23/1/19.
  INFO: THIS COMPONENT USE FOR THIRD PARTY AUTH
*/
class AmexioSocialComponent {
    constructor() {
        this.onLogin = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.type) {
            this.type = this.type.toLocaleLowerCase();
        }
    }
    /**
     * @param {?} socialUserInfo
     * @return {?}
     */
    onLoginClick(socialUserInfo) {
        this.onLogin.emit(socialUserInfo);
    }
}
AmexioSocialComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-login-social',
                template: `
    <ng-container *ngIf="type ==='google'">
        <amexio-google-auth-provider [client-id]="key" [label]="label" [style-type]="styleType" (onLogin)="onLoginClick($event)"></amexio-google-auth-provider>
    </ng-container>
    <ng-container *ngIf="type === 'linkedin'">
        <amexio-linkedin-auth-provider [client-id]="key" [label]="label" [style-type]="styleType" (onLogin)="onLoginClick($event)"></amexio-linkedin-auth-provider>
    </ng-container>

    <ng-container *ngIf="type === 'facebook'">
        <amexio-facebook-auth-provider [client-id]="key" [label]="label" [style-type]="styleType" (onLogin)="onLoginClick($event)"></amexio-facebook-auth-provider>
    </ng-container>

    <ng-container *ngIf="type === 'github'">
        <amexio-github-auth-provider (onLogin)="onLoginClick($event)" [client-id]="key" [style-type]="styleType" [label]="label"></amexio-github-auth-provider>
    </ng-container>
  `,
                styles: [`
  .social-button .button-default:hover {
      box-shadow: 0 2px 5px 0 rgba(0, 0, 0, .16), 0 2px 10px 0 rgba(0, 0, 0, .12)!important;
  }`],
            },] },
];
/** @nocollapse */
AmexioSocialComponent.ctorParameters = () => [];
AmexioSocialComponent.propDecorators = {
    type: [{ type: Input, args: ['type',] }],
    key: [{ type: Input, args: ['api-key',] }],
    label: [{ type: Input, args: ['label',] }],
    styleType: [{ type: Input, args: ['style-type',] }],
    onLogin: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MultiDateRangePicker {
    constructor() {
        this.daysOptionToday = null;
        this.daysOptionYesterday = null;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/
class AmexioMultiRangePickerComponent {
    constructor() {
        this.dateRangePickerFlag = true;
        this.newFromDate = new Date();
        this.newToDate = new Date();
        this.fromCardSelected = false;
        this.toCardSelected = false;
        this.todayIconFlag = false;
        this.yesterdayIconFlag = false;
        this.disabledChkedIndex = 0;
        this.disabledDates = [];
        this.multiDateRangePickerModel = new MultiDateRangePicker();
        this.customRange = ['Today', 'Yesterday', 'This week (sun - sat)', 'Last 14 days',
            'This month', 'Last 30 days', 'Last month', 'All time',
        ];
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.fromCardSelected = this.child.fromcardselected;
        this.toCardSelected = this.child.tocardselected;
        this.child.altercompleteDaysArray();
        if (this.disabledDates) {
            // chk if today or yesterday are in list of disabled dates
            this.disabledDates.forEach((/**
             * @param {?} element
             * @return {?}
             */
            (element) => {
                /** @type {?} */
                const dfrom = new Date(element.from);
                /** @type {?} */
                const dto = new Date(element.to);
                /** @type {?} */
                const currentd = new Date();
                /** @type {?} */
                const yesterdayd = new Date(currentd.getFullYear(), currentd.getMonth(), currentd.getDate() - 1);
                if ((currentd <= dto) && (currentd >= dfrom)) {
                    this.todayIconFlag = true;
                }
                if ((yesterdayd <= dto) && (yesterdayd >= dfrom)) {
                    this.yesterdayIconFlag = true;
                }
            }));
            if (this.todayIconFlag) {
                //  update default frmdate and todate
                this.updateFromTodate();
            }
        }
    }
    /**
     * @return {?}
     */
    updateFromTodate() {
        // increment and send date as argument to fun
        /** @type {?} */
        let flag = false;
        //  store returned value =  call function()
        //  if returned value is false call fun agn
        /** @type {?} */
        let incdate = new Date();
        do {
            incdate = new Date(incdate.getFullYear(), incdate.getMonth(), incdate.getDate() + 1);
            flag = this.chkDisableddate(incdate);
        } while (!flag);
        if (flag) {
            //  update from to date
            this.child.fromdate = incdate;
            this.child.todate = incdate;
            // update selected date in completeDaysArray
            this.alterCompleteDaysArray(incdate);
        }
    }
    /**
     * @param {?} incrementedDate
     * @return {?}
     */
    chkDisableddate(incrementedDate) {
        // loop disabled days and if match found return true
        /** @type {?} */
        let retflag = false;
        this.disabledDates.forEach((/**
         * @param {?} element
         * @param {?} index
         * @return {?}
         */
        (element, index) => {
            /** @type {?} */
            const dfrom = new Date(element.from);
            /** @type {?} */
            const dto = new Date(element.to);
            // chk for match
            if (!(incrementedDate >= dfrom && incrementedDate <= dto)) {
                retflag = true;
            }
        }));
        return retflag;
    }
    /**
     * @return {?}
     */
    clearSelectedFlag() {
        this.child.completeDaysArray.forEach((/**
         * @param {?} month
         * @return {?}
         */
        (month) => {
            month.montharray.forEach((/**
             * @param {?} monthrowarray
             * @return {?}
             */
            (monthrowarray) => {
                monthrowarray.forEach((/**
                 * @param {?} individualday
                 * @return {?}
                 */
                (individualday) => {
                    if (individualday.selected || individualday.from || individualday.to) {
                        individualday.selected = false;
                        individualday.from = false;
                        individualday.to = false;
                    }
                }));
            }));
        }));
    }
    /**
     * @param {?} incdate
     * @return {?}
     */
    alterCompleteDaysArray(incdate) {
        this.clearSelectedFlag();
        this.child.completeDaysArray.forEach((/**
         * @param {?} month
         * @return {?}
         */
        (month) => {
            month.montharray.forEach((/**
             * @param {?} monthrowarray
             * @return {?}
             */
            (monthrowarray) => {
                // monthrow.mon
                // monthrowarray.forEach(monthrow => {
                monthrowarray.forEach((/**
                 * @param {?} individualday
                 * @return {?}
                 */
                (individualday) => {
                    if ((individualday.date.getFullYear() === incdate.getFullYear()) &&
                        (individualday.date.getMonth() === incdate.getMonth()) &&
                        (individualday.date.getDate() === incdate.getDate())) {
                        individualday.selected = true;
                        individualday.from = true;
                        individualday.to = true;
                    }
                }));
                // });
            }));
        }));
    }
    /**
     * @param {?} option
     * @return {?}
     */
    selectRangeOption(option) {
        switch (option) {
            case 'Today':
                /** @type {?} */
                const currentdate = new Date();
                if (this.child.fromcardselected) {
                    // set fromdate to currentdate
                    this.child.fromdate = currentdate;
                }
                if (this.child.tocardselected) {
                    //  set todate to currentdate
                    this.child.todate = currentdate;
                }
                break;
            case 'Yesterday':
                /** @type {?} */
                const yesterdaydate = new Date();
                yesterdaydate.setDate(yesterdaydate.getDate() - 1);
                if (this.child.fromcardselected) {
                    // reinitialize fromdate to yesterday date
                    this.child.fromdate = yesterdaydate;
                }
                if (this.child.tocardselected) {
                    // reinitialize todate to yesterday date
                    this.child.todate = yesterdaydate;
                }
                break;
            case 'This week (sun - sat)':
                // find index of day of currentdate
                // and substract tht index frm current day
                /** @type {?} */
                const startdate = new Date();
                /** @type {?} */
                const dayindex = startdate.getDay();
                /** @type {?} */
                const enddate = new Date();
                startdate.setDate(startdate.getDate() - dayindex);
                //  set frmdate
                this.child.fromdate = startdate;
                // set todate
                enddate.setDate(enddate.getDate() - dayindex + 6);
                this.child.todate = enddate;
                break;
            case 'Last 14 days':
                /** @type {?} */
                const lastday = new Date();
                this.child.todate = lastday;
                /** @type {?} */
                const firstday = new Date();
                firstday.setDate(firstday.getDate() - 14);
                this.child.fromdate = firstday;
                break;
            case 'This month':
                /** @type {?} */
                const d1 = new Date();
                /** @type {?} */
                const firstmonthday = new Date(d1.getFullYear(), d1.getMonth(), 1);
                this.child.fromdate = firstmonthday;
                /** @type {?} */
                const lastmonthday = new Date(d1.getFullYear(), d1.getMonth() + 1, 0);
                this.child.todate = lastmonthday;
                break;
            case 'Last 30 days':
                /** @type {?} */
                const d2 = new Date();
                /** @type {?} */
                const first30thdate = new Date();
                /** @type {?} */
                const last30thdate = new Date();
                this.child.todate = last30thdate;
                first30thdate.setDate(d2.getDate() - 29);
                this.child.fromdate = first30thdate;
                break;
            case 'Last month':
                /** @type {?} */
                const d3 = new Date();
                /** @type {?} */
                const fday = new Date(d3.getFullYear(), d3.getMonth() - 1, 1);
                /** @type {?} */
                const lday = new Date(d3.getFullYear(), d3.getMonth(), 0);
                this.child.fromdate = fday;
                this.child.todate = lday;
                break;
            case 'All time':
                /** @type {?} */
                const d4 = new Date();
                d4.setFullYear(1970);
                d4.setMonth(0);
                d4.setDate(1);
                this.child.fromdate = d4;
                this.child.todate = new Date();
                break;
            case '30 Days upto today':
                break;
            case '30 Days upto yesterday':
                break;
        }
        this.child.altercompleteDaysArray();
    }
    /**
     * @return {?}
     */
    ResetDaysTillToday() {
        // change fromdate
        /** @type {?} */
        const d = new Date();
        /** @type {?} */
        const newfrm = new Date(d.getFullYear(), d.getMonth(), (d.getDate() - this.multiDateRangePickerModel.daysOptionToday + 1));
        this.child.fromdate = newfrm;
        // change todate
        /** @type {?} */
        const newto = new Date();
        this.child.todate = newto;
        this.child.altercompleteDaysArray();
    }
    /**
     * @return {?}
     */
    ResetDaysTillYesterday() {
        // change fromdate
        /** @type {?} */
        const d = new Date();
        /** @type {?} */
        const newfrm = new Date(d.getFullYear(), d.getMonth(), d.getDate() - this.multiDateRangePickerModel.daysOptionYesterday);
        this.child.fromdate = newfrm;
        // change todate
        /** @type {?} */
        const newto = new Date(d.getFullYear(), d.getMonth(), d.getDate() - 1);
        this.child.todate = newto;
        this.child.altercompleteDaysArray();
    }
}
AmexioMultiRangePickerComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-date-range-picker',
                template: `
      <span style="display:inline-flex">
        <span style="display:inline-grid;     box-shadow: rgba(0, 0, 0, 0.16) 0px 2px 5px 0px, rgba(0, 0, 0, 0.12) 0px 2px 10px 0px;  ">
          <span class="customRangePanel customRange">
            Custom
          </span>
          <span *ngFor="let item of customRange ; let i = index" class="customRangePanel" (click)="selectRangeOption(item)">
            {{item}}
            <!-- today tooltip span -->
            <span *ngIf=" (i == 0) && todayIconFlag" class="tooltipRange"> <i class="fa fa-info-circle "
                style="color: red; font-weight: bold" aria-hidden="true"></i>
              <span class="tooltiptextRange">
                today is disabled date
              </span>
            </span>
            <!-- yesterday tooltip span -->
            <span *ngIf=" (i == 1) && yesterdayIconFlag" class="tooltipRange"> <i class="fa fa-info-circle "
                style="color: red; font-weight: bold" aria-hidden="true"></i>
              <span class="tooltiptextRange">
                yesterday is disabled date
              </span>
            </span>
          </span>
          <span style="display:inline-grid;   box-shadow: 0 2px 5px 0 rgba(0,0,0,.16), 0 2px 10px 0 rgba(0,0,0,.12);">
            <!-- blank days upto today -->
            <span class="customRangePanel">
              <input  [(ngModel)] = "multiDateRangePickerModel.daysOptionToday" (keyup.enter)="ResetDaysTillToday()" type="text" size="3"> Days upto today
            </span>
            <!-- blank days upto Yesterday -->
            <span class="customRangePanel">
              <input [(ngModel)] = "multiDateRangePickerModel.daysOptionYesterday"  (keyup.enter)="ResetDaysTillYesterday()" type="text" size="3"> Days upto Yesterday
            </span>
          </span>

        </span>
        <span style="display: inline-block; margin-left: 2px;">
          <amexio-multiple-date-picker [fromlabel]="'Departure'" [tolabel]="'Return'" [number-of-months]="2"
            [from-date]="newFromDate" [to-date]="newToDate" [date-range-picker]="true">
          </amexio-multiple-date-picker>
        </span>
      </span>
    `,
            },] },
];
/** @nocollapse */
AmexioMultiRangePickerComponent.ctorParameters = () => [];
AmexioMultiRangePickerComponent.propDecorators = {
    disabledDates: [{ type: Input, args: ['disabled-date',] }],
    child: [{ type: ViewChild, args: [AmexioMultipleDatePickerComponent,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the 'License');
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an 'AS IS' BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by Ketan Gote on 05 June, 2019.
* Reference to : https://codepen.io/estelle/pen/LVQLRq?editors=1111
*
*/
class AmexioInputPatternDirective {
    /**
     * @param {?} model
     * @param {?} ngControl
     */
    constructor(model, ngControl) {
        this.model = model;
        this.ngControl = ngControl;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onModelChange(event) {
        /** @type {?} */
        const isCharsetPresent = this.ngControl.valueAccessor['data-charset'];
        /** @type {?} */
        const placeholder = isCharsetPresent || this.inputPattern;
        /** @type {?} */
        const e = event.target.value;
        /** @type {?} */
        const strippedValue = isCharsetPresent ? e.replace(/\W/g, '') : e.replace(/\D/g, '');
        /** @type {?} */
        const newVal = this.handleCurrentValue(strippedValue, placeholder, isCharsetPresent, e);
        if (this.model != null) {
            this.model.update.emit(newVal);
        }
        else {
            this.ngControl.control.setValue(newVal);
        }
    }
    /**
     * @param {?} strippedValue
     * @param {?} placeholder
     * @param {?} isCharsetPresent
     * @param {?} e
     * @return {?}
     */
    handleCurrentValue(strippedValue, placeholder, isCharsetPresent, e) {
        this.getOperatingValues(isCharsetPresent, strippedValue, placeholder);
        if (this.ngControl.valueAccessor['data-valid-example']) {
            return this.validateProgress(e, this.newValue1);
        }
        return this.newValue1;
    }
    /**
     * @param {?} isCharsetPresent
     * @param {?} strippedValue
     * @param {?} placeholder
     * @return {?}
     */
    getOperatingValues(isCharsetPresent, strippedValue, placeholder) {
        /** @type {?} */
        let newValue = '';
        this.newValue1 = '';
        for (let i = 0, j = 0; i < placeholder.length; i++) {
            this.valueInitialize(strippedValue[j], placeholder[i]);
            if ((this.matchesNumber && this.isInt) || (isCharsetPresent && this.matchesLetter && this.isLetter)) {
                newValue += strippedValue[j++];
            }
            else if ((!isCharsetPresent && !this.isInt && this.matchesNumber) ||
                (isCharsetPresent && ((this.matchesLetter && !this.isLetter) || (this.matchesNumber && !this.isInt)))) {
                return newValue;
            }
            else {
                newValue += placeholder[i];
            }
            if (strippedValue[j] === undefined) {
                break;
            }
        }
        this.newValue1 = newValue;
    }
    /**
     * @param {?} strippedValue
     * @param {?} placeholder
     * @return {?}
     */
    valueInitialize(strippedValue, placeholder) {
        this.isInt = !isNaN(parseInt(strippedValue, 10));
        this.isLetter = strippedValue ? strippedValue.match(/[A-Z]/i) : false;
        this.matchesNumber = 'XdDmMyY9'.indexOf(placeholder) >= 0;
        this.matchesLetter = '_'.indexOf(placeholder) >= 0;
    }
    /**
     * @param {?} e
     * @param {?} value
     * @return {?}
     */
    validateProgress(e, value) {
        /** @type {?} */
        const validExample = this.ngControl.valueAccessor['data-valid-example'];
        /** @type {?} */
        const pattern = new RegExp(this.ngControl.valueAccessor['data-pattern']);
        /** @type {?} */
        const placeholder = this.inputPattern;
        /** @type {?} */
        const l = value.length;
        /** @type {?} */
        if (l === 1 && placeholder.toUpperCase().substr(0, 2) === 'MM') {
            if (value > 1 && value < 10) {
                value = '0' + value;
            }
            return value;
        }
        // test the value, removing the last character, until what you have is a submatch
        for (let i = l; i >= 0; i--) {
            /** @type {?} */
            const testValue1 = value + validExample.substr(value.length);
            if (pattern.test(testValue1)) {
                return value;
            }
            else {
                value = value.substr(0, value.length - 1);
            }
        }
        return value;
    }
}
AmexioInputPatternDirective.decorators = [
    { type: Directive, args: [{
                selector: '[amexio-mask-pattern]',
            },] },
];
/** @nocollapse */
AmexioInputPatternDirective.ctorParameters = () => [
    { type: NgModel, decorators: [{ type: Optional }] },
    { type: NgControl }
];
AmexioInputPatternDirective.propDecorators = {
    inputPattern: [{ type: Input, args: ['amexio-mask-pattern',] }],
    onModelChange: [{ type: HostListener, args: ['keyup', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Created by pratik on 27/11/17.
 */
/** @type {?} */
const FORM_COMPONENTS$1 = [
    AmexioTextInputComponent,
    AmexioCheckBoxComponent,
    AmexioDropDownComponent,
    AmexioTypeAheadComponent,
    AmexioInputHelperComponent,
    AmexioEmailInputComponent,
    AmexioNumberInputComponent,
    AmexioPasswordComponent,
    AmexioTextAreaComponent,
    AmexioToggleComponent,
    AmexioRatingComponent,
    AmexioButtonComponent,
    AmexioButtonGroupComponent,
    AmexioButtonDropdownComponent,
    AmexioSpiltButtonDropdownComponent,
    AmexioButtonDropDownItemComponent,
    AmexioCheckBoxGroupComponent,
    CheckboxComponent,
    AmexioSliderComponent,
    AmexioTagsInputComponent,
    AmexioDateTimePickerComponent,
    AmexioButtonDropDownItemComponent,
    AmexioButtonDropdownComponent,
    AmexioSpiltButtonDropdownComponent,
    AmexioFileUploadComponent,
    AmexioLabelComponent,
    AmexioFloatingButtonComponent,
    AmexioFloatingGroupButtonComponent,
    AmexioDropDownitemsComponent,
    AmexioDropDownMenuComponent,
    ToolbarComponent,
    ToolbaroneComponent,
    ToolBarActionComponent,
    SearchboxtoolComponent,
    AmexioSearchAdvanceComponent,
    RecaptchaComponent,
    AmexioSpinnerComponent,
    AmexioCreditcardComponent,
    AmexioChipComponent,
    AmexioChipsComponent,
    GithubAuthComponent,
    GoogleAuthComponent,
    LinkedInAuthComponent,
    FacebookAuthComponent,
    AmexioSocialComponent,
    AmexioBadgeComponent,
    DarkmodeComponent,
    AmexioRangeSliderComponent,
    AmexioMultipleDatePickerComponent,
    GeolocComponent,
    AmexioInputPatternDirective,
    AmexioDialpadComponent,
    AmexioMultiRangePickerComponent,
];
class AmexioFormsModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: AmexioFormsModule,
            providers: [CommonDataService, LoadRecaptchaService, ScriptLoadService],
        };
    }
}
AmexioFormsModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    FormsModule,
                    AmexioLayoutModule,
                    HttpClientModule,
                    AmexioCommonModule.forRoot(),
                ],
                exports: FORM_COMPONENTS$1,
                declarations: FORM_COMPONENTS$1,
                providers: [CommonDataService, DomHandler, ScriptLoadService,
                ],
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Created by dattaram on 4/3/19.
 */
class OverlayContainerComponent {
    /**
     * @param {?} _renderer
     */
    constructor(_renderer) {
        this._renderer = _renderer;
        this.show = false;
        this.right = null;
        this.left = null;
        this.top = null;
        this.bottom = null;
        this.marginLeft = null;
        this.height = '100%';
        this.arrowClass = 'leftTopArrow';
        this.width = 'auto';
        this.bodyHeight = null;
        this.closeonescape = true;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @return {?}
     */
    onClose() {
        this.resetData();
    }
    /**
     * @return {?}
     */
    resetData() {
        this.left = null;
        this.top = null;
        this.right = null;
        this.bottom = null;
        this.marginLeft = null;
        this.show = false;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    toggle(event) {
        this.resetData();
        this.show = !this.show;
        this.eventRef = event;
        if (this.show && this.closeonescape) {
            this.globalListenFunc = this._renderer.listen('document', 'keyup.esc', (/**
             * @param {?} e
             * @return {?}
             */
            (e) => {
                this.show = false;
                if (this.globalListenFunc) {
                    this.globalListenFunc();
                }
            }));
        }
    }
    /**
     * @return {?}
     */
    setRenderPositionClass() {
        if (this.position === 'relative') {
            this.left = null;
            this.marginLeft = null;
        }
        return {
            'bottom': this.bottom + 'px', 'margin-left': this.marginLeft + 'px',
            'right': this.right + 'px', 'margin-top': this.top + 'px',
            'left': this.left + 'px', 'width': this.width,
        };
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onAnimationStart(event) {
        if (this.show) {
            /** @type {?} */
            const positions = this.findOverlayPosition(event.element, this.eventRef.target || this.eventRef.currentTarget);
            this.top = this.eventRef.target.offsetHeight + 20;
            this.left = this.eventRef.pageX - this.eventRef.target.offsetWidth;
            this.marginLeft = this.eventRef.target.offsetWidth - this.left;
            if (positions.right) {
                this.iconPosition = {
                    left: '-8px',
                    right: '',
                };
                this.arrowClass = 'rightTopArrow';
                this.left = null;
                this.right = document.body.clientWidth - this.eventRef.pageX;
                if (positions.bottom) {
                    this.arrowClass = 'rightBottomArrow';
                    this.top = null;
                    this.bottom = Math.abs(document.body.offsetHeight - this.eventRef.pageY);
                }
            }
            else {
                this.iconPosition = {
                    right: '-8px', left: '',
                };
                this.arrowClass = 'leftTopArrow';
            }
            if (!positions.right && positions.bottom) {
                this.arrowClass = 'leftBottomArrow';
                this.top = null;
                this.bottom = Math.abs(document.body.offsetHeight - this.eventRef.pageY);
            }
            this.renderPositionClass = this.setRenderPositionClass();
            if (this.bodyHeight) {
                this.height = (window.outerHeight / 100) * this.bodyHeight + 'px';
            }
        }
    }
    /**
     * @param {?} element
     * @param {?} target
     * @return {?}
     */
    findOverlayPosition(element, target) {
        /** @type {?} */
        let rightAlign = false;
        /** @type {?} */
        let bottomAlign = false;
        /** @type {?} */
        const elementOuterHeight = element.offsetParent ? element.offsetHeight : '';
        /** @type {?} */
        const targetOuterHeight = target.offsetHeight;
        /** @type {?} */
        const targetOuterWidth = target.offsetWidth;
        /** @type {?} */
        const targetOffset = target.getBoundingClientRect();
        /** @type {?} */
        const windowScrollTop = this.getWindowScrollTop();
        /** @type {?} */
        const windowScrollLeft = this.getWindowScrollLeft();
        /** @type {?} */
        const viewport = this.getViewportDetails();
        /** @type {?} */
        let top;
        /** @type {?} */
        let left;
        if (targetOffset.top + targetOuterHeight + elementOuterHeight > viewport.height) {
            top = targetOffset.top + windowScrollTop - elementOuterHeight;
            if (top < 0) {
                top = 0 + windowScrollTop;
            }
            bottomAlign = true;
        }
        else {
            top = targetOuterHeight + targetOffset.top + windowScrollTop;
        }
        if (targetOffset.left + targetOuterWidth + 150 > viewport.width) {
            rightAlign = true;
        }
        else {
            left = targetOffset.left + windowScrollLeft;
        }
        return { topPosi: top, leftPosi: left, right: rightAlign, bottom: bottomAlign };
    }
    /**
     * @return {?}
     */
    getWindowScrollTop() {
        /** @type {?} */
        const doc = document.documentElement;
        return (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0);
    }
    /**
     * @return {?}
     */
    getWindowScrollLeft() {
        /** @type {?} */
        const doc = document.documentElement;
        return (window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0);
    }
    /**
     * @return {?}
     */
    getViewportDetails() {
        /** @type {?} */
        const win = window;
        /** @type {?} */
        const doc = document;
        /** @type {?} */
        const ele = doc.documentElement;
        /** @type {?} */
        const body = doc.getElementsByTagName('body')[0];
        /** @type {?} */
        const widthW = win.innerWidth || ele.clientWidth || body.clientWidth;
        /** @type {?} */
        const heightW = win.innerHeight || ele.clientHeight || body.clientHeight;
        return { width: widthW, height: heightW };
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.globalListenFunc) {
            this.globalListenFunc();
        }
    }
}
OverlayContainerComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-overlay-container',
                template: `

    <ng-container *ngIf="show">
      <div #overlay class="overlayContainer {{arrowClass}}"
           [ngStyle]="renderPositionClass"
           [@animation]="{value: 'show'}"
           (@animation.start)="onAnimationStart($event)">
        <i *ngIf="closable"
           class="fa fa-times-circle-o iconClass " [ngStyle]="iconPosition"
           aria-hidden="true" (click)="onClose()"></i>
        <div class="containerClass" [style.height]="height">
          <ng-content></ng-content>
        </div>
      </div>
    </ng-container>





  
  `,
                animations: [
                    trigger('animation', [
                        state('void', style({
                            transform: 'translateY(5%)',
                            opacity: 0,
                        })),
                        state('show', style({
                            transform: 'translateY(0)',
                            opacity: 1,
                        })),
                        transition('void => show', animate('200ms')),
                        transition('show => void', animate('200ms')),
                    ]),
                ],
            },] },
];
/** @nocollapse */
OverlayContainerComponent.ctorParameters = () => [
    { type: Renderer2 }
];
OverlayContainerComponent.propDecorators = {
    closable: [{ type: Input, args: ['closable',] }],
    position: [{ type: Input, args: ['position',] }],
    width: [{ type: Input, args: ['width',] }],
    bodyHeight: [{ type: Input, args: ['body-height',] }],
    closeonescape: [{ type: Input, args: ['close-on-escape',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PanelItemComponent {
    constructor() {
        this.activePane = 'left';
        this.childPanelClicked = new EventEmitter();
        this.isSwipeTriggered = false;
        this.hasContent = false;
        this.showrow = true;
        this.showngcontent = false;
        this.clicked = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.hasContent = this.tref.nativeElement.childNodes.length > 0;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onPanelClick(event) {
        if (this.hasContent) {
            this.isSwipeTriggered = true;
            this.clicked = true;
            this.childPanelClicked.emit(this.title);
        }
    }
}
PanelItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-panel-item',
                template: `
      <div [@slide]="!showrow ? 'right' : ''">

          <ng-container *ngIf="showrow">
            <div style="cursor: pointer" (click)=" onPanelClick($event)">
              <div class="panelitemrow" >
                <span style="padding-right: 5px;" *ngIf="icon">
                  <amexio-c-icon [customclass]="icon" [label]="title">
                  </amexio-c-icon>
                </span>
                <span *ngIf="!icon">
                  {{title}}
                </span>
                <span *ngIf="hasContent" style="float:right;padding-right:2%">
                  <amexio-c-icon [customclass]="'fa fa-arrow-right'">
                  </amexio-c-icon>
                </span>
              </div>
  
            </div>
          </ng-container>
  
        </div>
           <div  [@slide]="!showngcontent ? 'left' : ''" #tref style="width: 100%;
           padding: 1%;" class="panelborder"
           [ngStyle]="{'display':showngcontent ? 'block': 'none'}">
  
            <ng-content>
  
            </ng-content>
          </div>
  
   
    `,
                animations: [
                    trigger('slide', [
                        state('left', style({ transform: 'translateX(100%)' })),
                        state('right', style({ transform: 'translateX(-100%)' })),
                        transition('* => *', animate(500)),
                    ]),
                ],
            },] },
];
/** @nocollapse */
PanelItemComponent.ctorParameters = () => [];
PanelItemComponent.propDecorators = {
    activePane: [{ type: Input }],
    icon: [{ type: Input }],
    title: [{ type: Input }],
    tref: [{ type: ViewChild, args: ['tref', { read: ElementRef },] }],
    childPanelClicked: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SlidingPanelComponent {
    constructor() {
        this.onPanelItemClick = new EventEmitter();
        this.showbackarrow = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.ChildPanelSlidersCollection = this.queryTabs.toArray();
        this.ChildPanelSlidersCollection.forEach((/**
         * @param {?} node
         * @return {?}
         */
        (node) => node.childPanelClicked.subscribe((/**
         * @param {?} title
         * @return {?}
         */
        (title) => this.onPaneClick(title)))));
    }
    /**
     * @return {?}
     */
    restorePanelState() {
        this.ChildPanelSlidersCollection.forEach((/**
         * @param {?} node
         * @return {?}
         */
        (node) => {
            node.showrow = true;
            node.showngcontent = false;
        }));
        this.showbackarrow = false;
    }
    /**
     * @param {?} title
     * @return {?}
     */
    onPaneClick(title) {
        this.panelItemName = title;
        this.onPanelItemClick.emit(title);
        this.showbackarrow = true;
        this.ChildPanelSlidersCollection.forEach((/**
         * @param {?} node
         * @return {?}
         */
        (node) => {
            if (node.title === title) {
                node.showrow = false;
                node.showngcontent = true;
            }
            else {
                node.showrow = false;
                node.showngcontent = false;
            }
        }));
    }
}
SlidingPanelComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-sliding-panel',
                template: `
      <div>
          <div *ngIf="header && !showbackarrow" class="panelheader" style="font-weight: bold">
              {{header}}
          </div>
          <div *ngIf="showbackarrow" class="panelitemrow">
              <span style="cursor:pointer" (click)="restorePanelState()">
                  <amexio-c-icon [customclass]="'fa fa-arrow-left'">
                  </amexio-c-icon>
              </span>
              <span style="font-weight: bold;" >
                  {{panelItemName}}
              </span>
          </div>
          <ng-content select="amexio-panel-item ">

          </ng-content>
      </div>
    `,
            },] },
];
SlidingPanelComponent.propDecorators = {
    header: [{ type: Input }],
    queryTabs: [{ type: ContentChildren, args: [PanelItemComponent,] }],
    onPanelItemClick: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class StackableItemComponent {
    constructor() {
        this.open = false;
        this.toggle = new EventEmitter();
    }
}
StackableItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-stackablepanel-item',
                template: `
    <div class="stackablepanel">
      <div class="title" (click)="toggle.emit()">
      </div>
      <div style="text-align: center; font-size: 12px;cursor: pointer " (click)="toggle.emit()">{{title}} </div>
      <div class="body" [ngStyle]="{'display': open ? '': 'none'}">
        <ng-content></ng-content>
      </div>
      <div>
  `,
            },] },
];
/** @nocollapse */
StackableItemComponent.ctorParameters = () => [];
StackableItemComponent.propDecorators = {
    open: [{ type: Input }],
    title: [{ type: Input }],
    toggle: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class StackablePanelComponent {
    constructor() {
        this.totalCount = 0;
        this.text = 'Show All';
        this.expand = true;
        this.anyExpand = false;
        this.panelName = 'Comments';
        this.show = false;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.totalCount = this.groups.length;
        this.groups.toArray().forEach((/**
         * @param {?} items
         * @return {?}
         */
        (items) => {
            if (items) {
                items.toggle.subscribe((/**
                 * @return {?}
                 */
                () => {
                    this.openGroup(items);
                }));
            }
        }));
    }
    /**
     * @param {?} group
     * @return {?}
     */
    openGroup(group) {
        this.groups.toArray().forEach((/**
         * @param {?} data
         * @return {?}
         */
        (data) => {
            if (data) {
                group.open = !group.open;
            }
        }));
    }
    /**
     * @return {?}
     */
    showAll() {
        this.groups.toArray().forEach((/**
         * @param {?} data
         * @return {?}
         */
        (data) => {
            if (this.text === 'Show All') {
                data.open = true;
            }
            else {
                data.open = false;
            }
        }));
        if (this.text === 'Show All') {
            this.text = 'Hide All';
        }
        else {
            this.text = 'Show All';
        }
    }
}
StackablePanelComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-stackable-panel',
                template: `
    <div style="padding-bottom: 5px" >
      <amexio-button style="float: right;"
            [label]="text"
            [type]="'theme-color'"
            (onClick)="showAll()">
      </amexio-button>
      <h2> {{panelName}} ({{totalCount}})</h2>
    <ng-content></ng-content>
    </div>
  `,
            },] },
];
StackablePanelComponent.propDecorators = {
    panelName: [{ type: Input, args: ['panel-name',] }],
    groups: [{ type: ContentChildren, args: [StackableItemComponent,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Created by pratik on 16/1/18.
 */
/** @type {?} */
const PANE_COMPONENTS = [
    AmexioHeaderComponent,
    AmexioFooterComponent,
    AmexioBodyComponent,
    AmexioFieldSetComponent,
    AmexioFloatingPanelComponent,
    AmexioWindowPaneComponent,
    AmexioWindowHeaderComponent,
    AmexioStepsComponent,
    AmexioTabPillComponent,
    AmexioTabComponent,
    AmexioVerticalTabComponent,
    AmexioRightVerticalTabComponent,
    AmexioCarouselComponent,
    AmexioTemplateDirective,
    AmexioTemplateWrapperDirective,
    StepBlockComponent,
    AmexioPanelComponent,
    AmexioPanelHeaderComponent,
    AmexiodialoguePaneComponent,
    AmexioFormComponent,
    AmexioFormActionComponent,
    AmexioFormHeaderComponent,
    AmexioFormBodyComponent,
    AmexioFormGroupDirective,
    AmexioTabActionComponent,
    AmexiotimelineComponent,
    AmexiotimelineeventComponent,
    OverlayContainerComponent,
    PanelItemComponent,
    SlidingPanelComponent,
    MinimizeWindowComponent,
    StackablePanelComponent,
    StackableItemComponent,
];
class AmexioPaneModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: AmexioPaneModule,
            providers: [CommonDataService, DeviceQueryService, IconLoaderService],
        };
    }
}
AmexioPaneModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    FormsModule,
                    ReactiveFormsModule,
                    AmexioFormsModule,
                    HttpClientModule,
                    AmexioBaseContextMenuModule,
                    AmexioCommonModule,
                ],
                entryComponents: [AmexioTabPillComponent, MinimizeWindowComponent],
                exports: PANE_COMPONENTS,
                declarations: PANE_COMPONENTS,
                providers: [CommonDataService, DeviceQueryService, IconLoaderService],
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TitleModel {
    constructor() {
        this.centerTitle = '';
        this.previousTitle = '';
        this.nextTitle = '';
    }
    /**
     * @param {?} prev
     * @param {?} center
     * @param {?} next
     * @return {?}
     */
    setTitle(prev, center, next) {
        this.previousTitle = prev;
        this.centerTitle = center;
        this.nextTitle = next;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*  Created by kedar on 18/4/2019.
*/
class AmexioCarouselCEComponent {
    /**
     * @param {?} http
     * @param {?} dataService
     */
    constructor(http, dataService) {
        this.http = http;
        this.dataService = dataService;
        this.type = 1;
        this.translucent = false;
        this.currentImageIndex = 0;
        this.navigationType = 2;
        this.titleModel = new TitleModel();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.httpmethod && this.httpurl) {
            this.dataService.fetchData(this.httpurl, this.httpmethod).subscribe((/**
             * @param {?} response
             * @return {?}
             */
            (response) => {
                this.responseData = response;
            }), (/**
             * @param {?} error
             * @return {?}
             */
            (error) => {
            }), (/**
             * @return {?}
             */
            () => {
                this.setData(this.responseData);
            }));
        }
        else if (this.data) {
            this.setData(this.data);
        }
        this.positionCalculation();
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.templates.forEach((/**
         * @param {?} item
         * @return {?}
         */
        (item) => {
            this.itemTemplate = item.template;
        }));
    }
    /**
     * @return {?}
     */
    positionCalculation() {
        if (this.templateWidth) {
            if (this.position === 'left') {
                this.positionRight = (100 - this.templateWidth);
                this.positionLeft = 0;
            }
            else if (this.position === 'right') {
                this.positionRight = 0;
                this.positionLeft = (100 - this.templateWidth);
            }
            else if (this.position === 'center') {
                this.positionLeft = ((100 - this.templateWidth) / 2);
                this.positionRight = this.positionLeft;
            }
        }
        else {
            if (this.position === 'left') {
                this.positionRight = 60;
                this.positionLeft = 0;
            }
            else if (this.position === 'right') {
                this.positionRight = 0;
                this.positionLeft = 60;
            }
            else if (this.position === 'center') {
                this.positionLeft = 30;
                this.positionRight = 30;
            }
        }
    }
    /**
     * @param {?} httpResponse
     * @return {?}
     */
    setData(httpResponse) {
        /** @type {?} */
        let responsedata = httpResponse;
        // Check if key is added?
        if (this.datareader != null) {
            /** @type {?} */
            const dr = this.datareader.split('.');
            for (const ir of dr) {
                responsedata = responsedata[ir];
            }
        }
        else {
            responsedata = httpResponse;
        }
        this.imageData = responsedata;
        this.titleModel.previousTitle = this.imageData[this.imageData.length - 1].title ? this.imageData[this.imageData.length - 1].title : '';
        this.titleModel.centerTitle = this.imageData[0].title ? this.imageData[0].title : '';
        this.titleModel.nextTitle = this.imageData[1].title ? this.imageData[1].title : '';
    }
    /**
     * @return {?}
     */
    dividedPreviousMethod() {
        this.imageData.forEach((/**
         * @param {?} element
         * @param {?} index
         * @return {?}
         */
        (element, index) => {
            if (element && element.active) {
                this.currentImageIndex = index;
            }
        }));
    }
    /**
     * @return {?}
     */
    previousClick() {
        this.navigationType = 1;
        setTimeout((/**
         * @return {?}
         */
        () => {
            this.dividedPreviousMethod();
            if (this.currentImageIndex === 0) {
                this.previousClickMethod();
            }
            else {
                this.imageData.forEach((/**
                 * @param {?} element
                 * @param {?} index
                 * @return {?}
                 */
                (element, index) => {
                    if (index === this.currentImageIndex - 1) {
                        /** @type {?} */
                        const duplicateIndex = this.currentImageIndex - 1;
                        this.imageData[duplicateIndex].active = true;
                        if (this.imageData[duplicateIndex] && this.imageData[duplicateIndex - 1] &&
                            this.imageData[duplicateIndex].title && this.imageData[duplicateIndex + 1].title) {
                            this.titleModel.setTitle(this.imageData[duplicateIndex - 1].title, this.imageData[duplicateIndex].title, this.imageData[duplicateIndex + 1].title);
                        }
                        else {
                            this.titleModel.setTitle(this.imageData[this.imageData.length - 1].title, this.imageData[0].title, this.imageData[this.currentImageIndex].title);
                        }
                    }
                    else {
                        this.imageData[index].active = false;
                    }
                }));
            }
        }), 500);
    }
    /**
     * @return {?}
     */
    nextClickCurrentIndexLogic() {
        /** @type {?} */
        const nextIndex = this.currentImageIndex;
        if (this.imageData[nextIndex] && this.imageData[nextIndex].title) {
            this.titleModel.setTitle(this.imageData[nextIndex - 1].title, this.imageData[nextIndex].title, this.imageData[nextIndex + 1].title);
        }
    }
    /**
     * @return {?}
     */
    nextClick() {
        this.navigationType = 2;
        setTimeout((/**
         * @return {?}
         */
        () => {
            this.dividedPreviousMethod();
            if (this.currentImageIndex === 0) {
                this.currentImageIndex = 1;
                this.imageData[this.currentImageIndex].active = true;
                this.nextClickCurrentIndexLogic();
                this.setFlag();
            }
            else {
                if (this.currentImageIndex === this.imageData.length - 1) {
                    this.currentImageIndex = 0;
                    this.titleModel.setTitle(this.imageData[this.imageData.length - 1].title, this.imageData[this.currentImageIndex].title, this.imageData[this.currentImageIndex + 1].title);
                }
                else {
                    this.currentImageIndex++;
                    /** @type {?} */
                    const nextIndex = this.currentImageIndex;
                    if (this.currentImageIndex < this.imageData.length - 1) {
                        this.titleModel.setTitle(this.imageData[nextIndex - 1].title, this.imageData[nextIndex].title, this.imageData[nextIndex + 1].title);
                    }
                    else {
                        this.titleModel.setTitle(this.imageData[nextIndex - 1].title, this.imageData[nextIndex].title, this.imageData[0].title);
                    }
                }
                this.setFlag();
            }
        }), 500);
    }
    /**
     * @return {?}
     */
    previousClickMethod() {
        this.imageData[this.currentImageIndex].active = true;
        /** @type {?} */
        const lastIndex = this.imageData.length - 1;
        this.currentImageIndex = this.imageData.length - 1;
        this.imageData.forEach((/**
         * @param {?} element
         * @param {?} index
         * @return {?}
         */
        (element, index) => {
            if (index === this.currentImageIndex) {
                this.imageData[index].active = true;
                if (this.imageData[lastIndex] && this.imageData[lastIndex].title) {
                    this.titleModel.setTitle(this.imageData[lastIndex - 1].title, this.imageData[lastIndex].title, this.imageData[0].title);
                }
            }
            else {
                this.imageData[index]['active'] = false;
            }
        }));
    }
    /**
     * @param {?} i
     * @return {?}
     */
    onPreBtnHover(i) {
        if (i === 0) {
            this.preImagePath = this.imageData[this.imageData.length - 1].imagepath;
        }
        else {
            /** @type {?} */
            const ind = i - 1;
            this.preImagePath = this.imageData[ind].imagepath;
        }
    }
    /**
     * @param {?} i
     * @return {?}
     */
    onNextBtnHover(i) {
        if (i === 0) {
            /** @type {?} */
            const ind = i + 1;
            this.nextImagePath = this.imageData[ind].imagepath;
        }
        else {
            /** @type {?} */
            const ind = i + 1;
            if (ind === this.imageData.length) {
                this.nextImagePath = this.imageData[0].imagepath;
            }
            else {
                this.nextImagePath = this.imageData[ind].imagepath;
            }
        }
    }
    /**
     * @return {?}
     */
    setFlag() {
        this.imageData.forEach((/**
         * @param {?} element
         * @param {?} index
         * @return {?}
         */
        (element, index) => {
            if (index === this.currentImageIndex) {
                this.imageData[index].active = true;
            }
            else {
                this.imageData[index]['active'] = false;
            }
        }));
    }
}
AmexioCarouselCEComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-carousel-ce',
                template: `
    <br />
    <div class="wrapper" #tab>
        <div *ngFor="let item of imageData ;let i=index" style="width: 100%; height: 100%;  position: relative;  display: flex; overflow: hidden;">
            <ng-container>
                <div [@changeState]="(item.active) ? 'block'+type+'-'+navigationType:'none'+type+'-'+navigationType" [ngStyle]="{display: (item.active) ? 'block':'none'}"
                    class="ce-caroueslimages">
                    <img src="{{item.imagepath}}" alt="" style='height: 100%; width: 100%; object-fit: cover' />
                </div>

                <ng-container *ngIf="itemTemplate">
                    <div style=" position: absolute;" [style.left]="positionLeft+'%'" [style.right]="positionRight+'%'">
                        <ng-template tabindex="1" [amexioTemplateWrapper]="itemTemplate" [item]="item"></ng-template>
                    </div>
                </ng-container>

            </ng-container>

            <div class="ce-caroueslbar" [ngStyle]="{'opacity': translucent ? '0.7' : 'inherit'}" [style.background]="barBGColor">
                <div class="ce-caroueslnav">
                    <a class="ce-caroueslnav-prev">
                        <span>Previous</span>
                        <div (click)="previousClick()" (mouseenter)="onPreBtnHover(i)">
                            <img src="{{preImagePath}}" alt="" style='height: 100%; width: 100%; object-fit: cover; cursor:pointer' />

                        </div>
                    </a>
                    <a class="ce-caroueslnav-next">
                        <span>Next</span>
                        <div (click)="nextClick()" (mouseenter)="onNextBtnHover(i)">

                            <img src="{{nextImagePath}}" alt="" style='height: 100%; width: 100%; object-fit: cover; cursor:pointer' />

                        </div>
                    </a>
                </div>

                <div class="ce-caroueslnav-content">
                    <div class="ce-caroueslnav-content-prev">
                        <span [style.color]="barFontColor"> {{titleModel.previousTitle}}</span>
                    </div>
                    <div class="ce-caroueslnav-content-current">
                        <span [style.color]="barFontColor">
                            {{titleModel.centerTitle}}
                        </span>
                    </div>
                    <div class="ce-caroueslnav-content-next">
                        <span [style.color]="barFontColor"> {{titleModel.nextTitle}}</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
  `,
                animations: [trigger('changeState', [
                        state('block1-1', style({
                            opacity: 1,
                        })),
                        state('none1-1', style({
                            opacity: 0,
                        })),
                        state('block1-2', style({
                            opacity: 1,
                        })),
                        state('none1-2', style({
                            opacity: 0,
                        })),
                        state('block2-1', style({
                            transform: 'translateX(0%)',
                        })),
                        state('none2-1', style({
                            transform: 'translateX(-100%)',
                        })),
                        state('block2-2', style({
                            transform: 'translateX(0%)',
                        })),
                        state('none2-2', style({
                            transform: 'translateX(100%)',
                        })),
                        transition('*=>*', animate('200ms')),
                    ]),
                ],
            },] },
];
/** @nocollapse */
AmexioCarouselCEComponent.ctorParameters = () => [
    { type: HttpClient },
    { type: CommonDataService }
];
AmexioCarouselCEComponent.propDecorators = {
    data: [{ type: Input }],
    httpurl: [{ type: Input, args: ['http-url',] }],
    datareader: [{ type: Input, args: ['data-reader',] }],
    httpmethod: [{ type: Input, args: ['http-method',] }],
    type: [{ type: Input, args: ['type',] }],
    translucent: [{ type: Input, args: ['translucent',] }],
    translucentValue: [{ type: Input, args: ['translucent-value',] }],
    barBGColor: [{ type: Input, args: ['bar-bg-color',] }],
    barFontColor: [{ type: Input, args: ['bar-font-color',] }],
    templateWidth: [{ type: Input, args: ['template-width',] }],
    position: [{ type: Input, args: ['position',] }],
    templates: [{ type: ContentChildren, args: [AmexioTemplateDirective,] }],
    tabs: [{ type: ViewChild, args: ['tab', { read: ElementRef },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ColorPaletteComponent {
    constructor() {
        this.color = new EventEmitter(true);
        this.mousedown = false;
        this.emitData = { color: '', position: { x: '', y: '' } };
        this.selectedPosition = { x: 121, y: 53 };
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.draw();
    }
    /**
     * @return {?}
     */
    draw() {
        if (!this.ctx) {
            this.ctx = this.canvas.nativeElement.getContext('2d');
        }
        /** @type {?} */
        const width = this.canvas.nativeElement.width;
        /** @type {?} */
        const height = this.canvas.nativeElement.height;
        this.ctx.fillStyle = this.hue || 'rgba(255,255,255,1)';
        this.ctx.fillRect(0, 0, width, height);
        /** @type {?} */
        const whiteGrad = this.ctx.createLinearGradient(0, 0, width, 0);
        whiteGrad.addColorStop(0, 'rgba(255,255,255,1)');
        whiteGrad.addColorStop(1, 'rgba(255,255,255,0)');
        this.ctx.fillStyle = whiteGrad;
        this.ctx.fillRect(0, 0, width, height);
        /** @type {?} */
        const blackGrad = this.ctx.createLinearGradient(0, 0, 0, height);
        blackGrad.addColorStop(0, 'rgba(0,0,0,0)');
        blackGrad.addColorStop(1, 'rgba(0,0,0,1)');
        this.ctx.fillStyle = blackGrad;
        this.ctx.fillRect(0, 0, width, height);
        this.ctx.strokeStyle = 'white';
        this.ctx.fillStyle = 'white';
        this.ctx.beginPath();
        if (this.position != null) {
            this.ctx.arc(this.position.x, this.position.y, 6, 0, 2 * Math.PI);
        }
        else {
            this.ctx.arc(this.selectedPosition.x, this.selectedPosition.y, 6, 0, 2 * Math.PI);
        }
        this.ctx.lineWidth = 2;
        this.ctx.stroke();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes['hue'] && changes.hue.currentValue) {
            this.hue = changes.hue.currentValue;
        }
        if (changes.position && changes.position.currentValue) {
            this.position = changes.position.currentValue;
            this.draw();
            this.emitColor(this.position.x, this.position.y);
        }
        else {
            /** @type {?} */
            const pos = this.selectedPosition;
            this.draw();
            if (pos) {
                this.emitColor(pos.x, pos.y);
            }
        }
    }
    /**
     * @param {?} evt
     * @return {?}
     */
    onMouseUp(evt) {
        this.mousedown = false;
    }
    /**
     * @param {?} evt
     * @return {?}
     */
    onMouseDown(evt) {
        if (this.position) {
            this.position = null;
        }
        this.mousedown = true;
        this.selectedPosition = { x: evt.offsetX, y: evt.offsetY };
        this.draw();
        this.emitColor(evt.offsetX, evt.offsetY);
    }
    /**
     * @param {?} evt
     * @return {?}
     */
    onMouseMove(evt) {
        if (this.mousedown) {
            if (this.position) {
                this.position = null;
            }
            this.selectedPosition = { x: evt.offsetX, y: evt.offsetY };
            this.draw();
            this.emitColor(evt.offsetX, evt.offsetY);
        }
    }
    /**
     * @param {?} x
     * @param {?} y
     * @return {?}
     */
    emitColor(x, y) {
        /** @type {?} */
        const rgbaColor = this.getColorAtPosition(x, y);
        this.emitData.color = rgbaColor;
        this.emitData.position.x = x;
        this.emitData.position.y = y;
        this.color.emit(this.emitData);
    }
    /**
     * @param {?} x
     * @param {?} y
     * @return {?}
     */
    getColorAtPosition(x, y) {
        /** @type {?} */
        const imageData = this.ctx.getImageData(x, y, 1, 1).data;
        return 'rgba(' + imageData[0] + ',' + imageData[1] + ',' + imageData[2] + ',1)';
    }
}
ColorPaletteComponent.decorators = [
    { type: Component, args: [{
                selector: 'color-palette',
                template: `
    <canvas
      #canvas
      class="color-palette"
      width="160%"
      height="200px"
      (mousedown)="onMouseDown($event)"
      (mousemove)="onMouseMove($event)"
    >
    </canvas>
  `,
            },] },
];
/** @nocollapse */
ColorPaletteComponent.ctorParameters = () => [];
ColorPaletteComponent.propDecorators = {
    hue: [{ type: Input }],
    position: [{ type: Input, args: ['position',] }],
    color: [{ type: Output }],
    canvas: [{ type: ViewChild, args: ['canvas',] }],
    onMouseUp: [{ type: HostListener, args: ['window:mouseup', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ColorPickerComponent extends ValueAccessorBaseComponent {
    constructor() {
        super();
        this.selectedColor = new EventEmitter();
        this.inlineColorPicker = false;
        this.hue = 'rgba(255,3,0,1)';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @param {?} data
     * @return {?}
     */
    selectedPaletteColor(data) {
        this.position = data.position;
        this.color = data.color;
        this.value = '';
        this.value = this.rgbToHexConvert(data.color);
        this.selectedColor.emit(this.value);
    }
    /**
     * @param {?} rgbColor
     * @return {?}
     */
    rgbToHexConvert(rgbColor) {
        rgbColor = rgbColor.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i);
        return (rgbColor && rgbColor.length === 4) ? '#' +
            ('0' + parseInt(rgbColor[1], 10).toString(16)).slice(-2) +
            ('0' + parseInt(rgbColor[2], 10).toString(16)).slice(-2) +
            ('0' + parseInt(rgbColor[3], 10).toString(16)).slice(-2) : '';
    }
    /**
     * @param {?} data
     * @return {?}
     */
    selectedHue(data) {
        if (data) {
            this.offsetY = data.offsetY;
            this.hue = data.color;
        }
    }
    /**
     * @return {?}
     */
    openColorPicker() {
        this.showColorPicker = !this.showColorPicker;
    }
    /**
     * @return {?}
     */
    closeColorPicker() {
        this.showColorPicker = false;
    }
    /**
     * @param {?} type
     * @return {?}
     */
    setRoundEdge(type) {
        if (type === 'round-edge') {
            this.roundedgeclass = 'roundEdgeCommonCss';
        }
        else if (type === 'classic') {
            this.roundedgeclass = 'classicCommonCss';
        }
    }
}
ColorPickerComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-color-picker',
                template: `
    <div class="inputgroup form-group">

      <label>
        {{fieldlabel}}
      </label>

      <br/>

      <div *ngIf="!inlineColorPicker" class="input-container" style="display: inline-flex;
        align-items: center;" (click)="openColorPicker()">
        <input type="text" class="input-control" name="value" [(ngModel)]="value" />
        <span *ngIf="value" style="display: inline-block; width:32px; height:32px;" [style.background]="value"></span>
        &nbsp;
        <em class="fa fa-paint-brush" style="cursor: pointer;"></em>
      </div>

      <div  *ngIf="showColorPicker || inlineColorPicker " [@changeState]="showColorPicker "
           [ngClass]="{'card-container': (!inlineColorPicker)}" 
           [ngStyle]="{'position': (inlineColorPicker) ? 'relative':'absolute',
                         'height': (showColorPicker) ? '270px': 'auto','margin-top': (showColorPicker) ? '15px': '0px' }"
           style="align-items: center;z-index:70">
        <div class="color-wrapper {{roundedgeclass}}"  style="justify-content: center;">
          <color-palette [hue]="hue" [position]="position" (color)="selectedPaletteColor($event)"></color-palette>
          <color-slider [offsetY]="offsetY" [selected-hue]="hue" (color)="selectedHue($event)" style="margin-left:0px">
          </color-slider>
        </div>
        <span>
        <amexio-button *ngIf="!inlineColorPicker" [size]="'small'" (onClick)="closeColorPicker()" [label]="'Close'" [type]="'theme-color'" [tooltip]="'Close'">
        </amexio-button>
      </span>
      </div>
    </div>
  `,
                animations: [
                    trigger('changeState', [
                        state('true', style({
                            transform: 'scale(1.1)',
                        })),
                        state('false', style({
                            transform: 'scale(0)',
                        })),
                        transition('*=>*', animate('200ms')),
                    ]),
                ],
                providers: [{
                        provide: NG_VALUE_ACCESSOR, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => ColorPickerComponent)), multi: true,
                    }],
            },] },
];
/** @nocollapse */
ColorPickerComponent.ctorParameters = () => [];
ColorPickerComponent.propDecorators = {
    selectedColor: [{ type: Output }],
    inlineColorPicker: [{ type: Input, args: ['inline-color-picker',] }],
    fieldlabel: [{ type: Input, args: ['field-label',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ColorsliderComponent {
    /**
     * @param {?} element
     */
    constructor(element) {
        this.element = element;
        this.color = new EventEmitter();
        this.mousedown = false;
        this.selectedHeight = 0;
        this.emitData = { color: '', offsetY: '', visiblity: '' };
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.draw();
    }
    /**
     * @return {?}
     */
    draw() {
        if (!this.ctx) {
            this.ctx = this.canvas.nativeElement.getContext('2d');
        }
        /** @type {?} */
        const width = this.canvas.nativeElement.width;
        /** @type {?} */
        const height = this.canvas.nativeElement.height;
        this.ctx.clearRect(0, 0, width, height);
        /** @type {?} */
        const gradient = this.ctx.createLinearGradient(0, 0, 0, height);
        gradient.addColorStop(0, 'rgba(255, 0, 0, 1)');
        gradient.addColorStop(0.17, 'rgba(255, 255, 0, 1)');
        gradient.addColorStop(0.34, 'rgba(0, 255, 0, 1)');
        gradient.addColorStop(0.51, 'rgba(0, 255, 255, 1)');
        gradient.addColorStop(0.68, 'rgba(0, 0, 255, 1)');
        gradient.addColorStop(0.85, 'rgba(255, 0, 255, 1)');
        gradient.addColorStop(1, 'rgba(255, 0, 0, 1)');
        this.ctx.beginPath();
        this.ctx.rect(0, 0, width, height);
        this.ctx.fillStyle = gradient;
        this.ctx.fill();
        this.ctx.closePath();
        this.ctx.beginPath();
        this.ctx.strokeStyle = 'white';
        this.ctx.lineWidth = 2;
        if (this.offsetY) {
            this.ctx.rect(0, this.offsetY - 5, width, 10);
        }
        else {
            this.ctx.rect(0, this.selectedHeight - 5, width, 10);
        }
        this.ctx.stroke();
        this.ctx.closePath();
        if (this.selctedHue) {
            this.emitData.color = this.selctedHue;
            this.emitData.offsetY = this.offsetY;
            this.color.emit(this.emitData);
        }
        else {
            this.emitData.color = 'rgba(255,3,0,1)';
            this.color.emit(this.emitData);
        }
    }
    /**
     * @param {?} evt
     * @return {?}
     */
    onMouseDown(evt) {
        if (this.offsetY) {
            this.offsetY = '';
        }
        this.mousedown = true;
        this.selectedHeight = evt.offsetY;
        this.draw();
        this.emitColor(evt.offsetX, evt.offsetY);
    }
    /**
     * @param {?} evt
     * @return {?}
     */
    onMouseMove(evt) {
        if (this.mousedown) {
            if (this.offsetY) {
                this.offsetY = '';
            }
            this.selectedHeight = evt.offsetY;
            this.draw();
            this.emitColor(evt.offsetX, evt.offsetY);
        }
    }
    /**
     * @param {?} evt
     * @return {?}
     */
    onMouseUp(evt) {
        this.mousedown = false;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.hue && changes.hue.currentValue) {
            this.selctedHue = changes.hue.currentValue;
        }
        if (changes.offsetY && changes.offsetY.currentValue) {
            this.offsetY = changes.offsetY.currentValue;
        }
        this.draw();
    }
    /**
     * @param {?} x
     * @param {?} y
     * @return {?}
     */
    emitColor(x, y) {
        /** @type {?} */
        const rgbaColor = this.getColorAtPosition(x, y);
        this.selectedcolor = rgbaColor;
        this.emitData.color = rgbaColor;
        this.emitData.offsetY = y;
        this.color.emit(this.emitData);
    }
    /**
     * @param {?} x
     * @param {?} y
     * @return {?}
     */
    getColorAtPosition(x, y) {
        /** @type {?} */
        const imageData = this.ctx.getImageData(x, y, 1, 1).data;
        return 'rgba(' + imageData[0] + ',' + imageData[1] + ',' + imageData[2] + ',1)';
    }
}
ColorsliderComponent.decorators = [
    { type: Component, args: [{
                selector: 'color-slider',
                template: `

        <canvas #canvas class="color-slider" (mousedown)="onMouseDown($event)"
        (mousemove)="onMouseMove($event)" width="20%" height="200px"> </canvas>

   
  `,
            },] },
];
/** @nocollapse */
ColorsliderComponent.ctorParameters = () => [
    { type: ElementRef }
];
ColorsliderComponent.propDecorators = {
    canvas: [{ type: ViewChild, args: ['canvas',] }],
    color: [{ type: Output }],
    selctedHue: [{ type: Input, args: ['selected-hue',] }],
    offsetY: [{ type: Input, args: ['offsetY',] }],
    onMouseUp: [{ type: HostListener, args: ['window:mouseup', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 * Copyright [2019] [Metamagic]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Created by Kedar Kokil on 10/05/19.
 */
class AmexioMenuCEComponent {
    constructor() {
        this.font = 'Titillium Web';
        this.onClick = new EventEmitter();
        this.position = 'left';
        this.menuAlignment = 'left';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.data.forEach((/**
         * @param {?} element
         * @return {?}
         */
        (element) => {
            element['hover'] = false;
        }));
        if (this.type) {
            this.animatedClass = 'bmenu' + this.type;
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onMenuClick(event) {
        this.onClick.emit(event);
    }
}
AmexioMenuCEComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-menu-ce',
                template: `
    <div 
    [ngClass]="{textLeftPosition: (position == 'left'),
     textRightPosition: (position == 'right'), 
     textCenterPosition: (position == 'center')}">
        <div *ngFor="let node of data" 
        [ngClass]='animatedClass'
       >
        <a style="text-decoration: none;" href="#"
        (mouseover)="node.hover=true" 
        (mouseleave)="node.hover=false"
        (click)="onMenuClick(node)"
        [ngStyle]="{'font-family':font, 'font-size': size+'px', 'color': fontColor}"
        >{{node.label}}</a>
      </div>
    </div>
  `,
            },] },
];
/** @nocollapse */
AmexioMenuCEComponent.ctorParameters = () => [];
AmexioMenuCEComponent.propDecorators = {
    data: [{ type: Input }],
    font: [{ type: Input, args: ['font',] }],
    size: [{ type: Input }],
    fontColor: [{ type: Input, args: ['font-color',] }],
    onClick: [{ type: Output }],
    type: [{ type: Input, args: ['animation-type',] }],
    position: [{ type: Input, args: ['menu-positioning',] }],
    menuAlignment: [{ type: Input, args: ['menu-alignment',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ProgressModel {
    /**
     * @param {?} firstDegree
     * @param {?} secondDegree
     * @param {?} progresscolor
     * @param {?} inactiveprogresscolor
     */
    constructor(firstDegree, secondDegree, progresscolor, inactiveprogresscolor) {
        this.firstDegree = firstDegree;
        this.secondDegree = secondDegree;
        this.progresscolor = progresscolor;
        this.inactiveprogresscolor = inactiveprogresscolor;
    }
    /**
     * @return {?}
     */
    getStyle() {
        if (parseFloat(this.firstDegree) > -90 && parseFloat(this.firstDegree) < 90) {
            return {
                'background-image': 'linear-gradient( ' + this.firstDegree + ', ' + this.progresscolor +
                    ' 50%, transparent 50%, transparent), linear-gradient(' + this.secondDegree + ', ' + this.progresscolor +
                    ' 50%,' + this.inactiveprogresscolor + ' 50%, ' + this.inactiveprogresscolor + ')',
            };
        }
        else {
            return {
                'background-image': 'linear-gradient( ' + this.firstDegree + ', ' + this.inactiveprogresscolor +
                    ' 50%, transparent 50%, transparent), linear-gradient(' + this.secondDegree + ', ' + this.progresscolor +
                    ' 50%,' + this.inactiveprogresscolor + ' 50%, ' + this.inactiveprogresscolor + ')',
            };
        }
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AmexioProgressCEComponent {
    constructor() {
        /*
             Properties
             name : font-size
             datatype : string
             version : 5.6.0 onwards
             default :
             description : Set size to label of progress bar.
             */
        this.size = '30px';
        /*
             Properties
             name : background-color
             datatype : string
             version : 5.6.0 onwards
             default :
             description : Set background color to the circular creative progress bar.
             */
        this.background = 'rgb(242,244,245)';
        /*
             Properties
             name : background-color
             datatype : string
             version : 5.6.0 onwards
             default :
             description : Set label color to the circular creative progress bar.
             */
        this.labelcolor = 'black';
        /*
             Properties
             name : progress-color
             datatype : string
             version : 5.6.0 onwards
             default : '#2ecc71'
             description : Set progress color to the border of creative progress bar.
             */
        this.progresscolor = '#1565c0';
        /*
             Properties
             name : inactive-progress-color
             datatype : string
             version : 5.6.0 onwards
             default : '#d0d0d0'
             description : Set inactive color to the remaining border of creative progress bar.
             */
        this.inactiveprogresscolor = '#cce2f5';
        /*
          Properties
          name : unit
          datatype : string
          version : 5.6.0 onwards
          default : '%'
          description : Set unit to the label of progress bar.
          */
        this.unit = '%';
        this.showlabel = false;
        this.showunit = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.dyanmicHeightCreation();
        this.progressBarDegreeMap = new Map();
        this.progressBarDegreeMap.set('0', new ProgressModel('90deg', '90deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('1', new ProgressModel('90deg', '93.6deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('2', new ProgressModel('90deg', '97.2deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('3', new ProgressModel('90deg', '100.8deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('4', new ProgressModel('90deg', '104.4deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('5', new ProgressModel('90deg', '108deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('6', new ProgressModel('90deg', '111.6deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('7', new ProgressModel('90deg', '115.2deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('8', new ProgressModel('90deg', '118.8deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('9', new ProgressModel('90deg', '122.4deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('10', new ProgressModel('90deg', '126deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('11', new ProgressModel('90deg', '129.6deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('12', new ProgressModel('90deg', '133.2deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('13', new ProgressModel('90deg', '136.8deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('14', new ProgressModel('90deg', '140.4deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('15', new ProgressModel('90deg', '144deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('16', new ProgressModel('90deg', '147.6deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('17', new ProgressModel('90deg', '151.2deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('18', new ProgressModel('90deg', '154.8deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('19', new ProgressModel('90deg', '158.4deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('20', new ProgressModel('90deg', '162deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('21', new ProgressModel('90deg', '165.6deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('22', new ProgressModel('90deg', '169.2deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('23', new ProgressModel('90deg', '172.8deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('24', new ProgressModel('90deg', '176.4deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('25', new ProgressModel('90deg', '180deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('26', new ProgressModel('90deg', '183.6deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('27', new ProgressModel('90deg', '187.2deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('28', new ProgressModel('90deg', '190.8deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('29', new ProgressModel('90deg', '194.4deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('30', new ProgressModel('90deg', '198deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('31', new ProgressModel('90deg', '201.6deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('32', new ProgressModel('90deg', '205.2deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('33', new ProgressModel('90deg', '208.8deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('34', new ProgressModel('90deg', '212.4deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('35', new ProgressModel('90deg', '216deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('36', new ProgressModel('90deg', '219.6deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('37', new ProgressModel('90deg', '223.2deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('38', new ProgressModel('90deg', '226.8deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('39', new ProgressModel('90deg', '230.4deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('40', new ProgressModel('90deg', '234deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('41', new ProgressModel('90deg', '237.6deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('42', new ProgressModel('90deg', '241.2deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('43', new ProgressModel('90deg', '244.8deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('44', new ProgressModel('90deg', '248.4deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('45', new ProgressModel('90deg', '252deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('46', new ProgressModel('90deg', '255.6deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('47', new ProgressModel('90deg', '259.2deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('48', new ProgressModel('90deg', '262.8deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('49', new ProgressModel('90deg', '266.4deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('50', new ProgressModel('-90deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('51', new ProgressModel('-86.4deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('52', new ProgressModel('-82.8deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('53', new ProgressModel('-79.2deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('54', new ProgressModel('-75.6deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('55', new ProgressModel('-72deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('56', new ProgressModel('-68.4deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('57', new ProgressModel('-64.8deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('58', new ProgressModel('-61.2deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('59', new ProgressModel('-57.6deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('60', new ProgressModel('-54deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('61', new ProgressModel('-50.4deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('62', new ProgressModel('-46.8deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('63', new ProgressModel('-43.2deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('64', new ProgressModel('-39.6deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('65', new ProgressModel('-36deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('66', new ProgressModel('-32.4deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('67', new ProgressModel('-28.8deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('68', new ProgressModel('-25.2deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('69', new ProgressModel('-21.6deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('70', new ProgressModel('-18deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('71', new ProgressModel('-14.4deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('72', new ProgressModel('-10.8deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('73', new ProgressModel('-7.2deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('74', new ProgressModel('-3.6deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('75', new ProgressModel('0deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('76', new ProgressModel('3.6deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('77', new ProgressModel('7.2deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('78', new ProgressModel('10.8deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('79', new ProgressModel('14.4deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('80', new ProgressModel('18deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('81', new ProgressModel('21.6deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('82', new ProgressModel('25.2deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('83', new ProgressModel('28.8deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('84', new ProgressModel('32.4deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('85', new ProgressModel('36deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('86', new ProgressModel('39.6deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('87', new ProgressModel('43.2deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('88', new ProgressModel('46.8deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('89', new ProgressModel('50.4deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('90', new ProgressModel('54deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('91', new ProgressModel('57.6deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('92', new ProgressModel('61.2deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('93', new ProgressModel('64.8deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('94', new ProgressModel('68.4deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('95', new ProgressModel('72deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('96', new ProgressModel('76.6deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('97', new ProgressModel('79.2deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('98', new ProgressModel('82.8deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('99', new ProgressModel('86.4deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('100', new ProgressModel('90deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.forEach((/**
         * @param {?} element
         * @param {?} key
         * @return {?}
         */
        (element, key) => {
            if (this.progressvalue === parseInt(key, 10)) {
                this.pStyle = element.getStyle();
            }
        }));
    }
    /**
     * @return {?}
     */
    dyanmicHeightCreation() {
        if (this.width && this.width.length > 0 && this.height && this.height.length > 0) {
            this.outerWidth = this.getCal(this.width);
            this.outerHeight = this.getCal(this.height);
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    getCal(value) {
        return (parseInt(value, 10) + 32).toString() + 'px';
    }
}
AmexioProgressCEComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-progress-ce',
                template: `
    <!-- Radial -->
    <ng-container *ngIf="type =='radial'">
        <div class="circularProgress" [style.width]="outerWidth" [style.height]="outerHeight" [ngStyle]="pStyle">
            <div [style.background-color]="background" [style.width]="width+'px'" [style.height]="height+'px'" class="innerCircle"
                [ngClass]="type">
                <label tabindex="0" attr.aria-label="{{progressvalue}} {{unit}} {{tooltip}}" [style.font-size]="size"
                    [style.color]="labelcolor">
                    <ng-container *ngIf="showlabel">{{progressvalue }}</ng-container>
                    <ng-container *ngIf="showunit"> {{unit}}</ng-container>
                </label>
            </div>
        </div>
    </ng-container>
    <!-- Ring -->
    <ng-container *ngIf="type =='ring'">
        <div class="circularProgress" [style.width]="outerWidth" [style.height]="outerHeight" [ngStyle]="pStyle">
            <div [style.width]="width+'px'" [style.height]="height+'px'" class="innerCircle" [ngClass]="type">
                <label tabindex="0" attr.aria-label="{{progressvalue}} {{unit}} {{tooltip}}" [style.color]="labelcolor"
                    [style.font-size]="size">
                    <ng-container *ngIf="showlabel">{{progressvalue }}</ng-container>
                    <ng-container *ngIf="showunit"> {{unit}}</ng-container>
                </label>
            </div>
        </div>
    </ng-container>

    <!-- Pie -->
    <ng-container *ngIf="type =='pie'">
        <div class="circularProgress" [style.width]="outerWidth" [style.height]="outerHeight" [ngStyle]="pStyle">
            <div [style.width]="width+'px'" [style.height]="height+'px'" [ngClass]="type" class="innerCircle">
                <label tabindex="0" attr.aria-label="{{progressvalue}} {{unit}} {{tooltip}}" [style.color]="labelcolor"
                    [style.font-size]="size">
                    <ng-container *ngIf="showlabel">{{progressvalue }}</ng-container>
                    <ng-container *ngIf="showunit"> {{unit}}</ng-container>

                </label>
            </div>
        </div>
    </ng-container>
  `,
            },] },
];
/** @nocollapse */
AmexioProgressCEComponent.ctorParameters = () => [];
AmexioProgressCEComponent.propDecorators = {
    type: [{ type: Input, args: ['type',] }],
    size: [{ type: Input, args: ['font-size',] }],
    background: [{ type: Input, args: ['background-color',] }],
    labelcolor: [{ type: Input, args: ['label-color',] }],
    progresscolor: [{ type: Input, args: ['progress-color',] }],
    inactiveprogresscolor: [{ type: Input, args: ['inactive-progress-color',] }],
    unit: [{ type: Input, args: ['unit',] }],
    label: [{ type: Input, args: ['label',] }],
    height: [{ type: Input, args: ['height',] }],
    width: [{ type: Input, args: ['width',] }],
    progressvalue: [{ type: Input, args: ['progress-value',] }],
    tooltip: [{ type: Input, args: ['tooltip',] }],
    showlabel: [{ type: Input, args: ['show-label',] }],
    showunit: [{ type: Input, args: ['show-unit',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CeMinimizeWindowComponent {
    /**
     * @param {?} _ceService1
     */
    constructor(_ceService1) {
        this._ceService1 = _ceService1;
        this.arrayData = [];
        this.ceMiniButton = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this._ceService1.currentMessage.subscribe((/**
         * @param {?} shareData
         * @return {?}
         */
        (shareData) => {
            if (shareData && shareData.length > 0) {
                this.arrayData = shareData;
                this.ceMiniButton = true;
            }
            else {
                this.ceMiniButton = false;
            }
        }));
    }
    /**
     * @param {?} data
     * @return {?}
     */
    ceMiniBtnClick(data) {
        data.show = true;
        this.ceMiniButton = true;
    }
}
CeMinimizeWindowComponent.decorators = [
    { type: Component, args: [{
                selector: 'ce-minimize-window',
                template: `
      <div class="minimize-btn-css" [class.minimize-window-bg]="ceMiniButton"
          [ngStyle]="{'padding': ceMiniButton ? '10px  0px 10px 0px': '0px'}">

          <ng-container *ngIf="ceMiniButton">
              <span *ngFor="let data of arrayData">
                  <amexio-button [icon]=data.amexioHeader.first.minimizeIcon [label]="data.textName" [type]="'theme-color'"
                      [tooltip]="data.textName" (onClick)="ceMiniBtnClick(data)">
                  </amexio-button>
              </span>
          </ng-container>
      </div>
    `,
            },] },
];
/** @nocollapse */
CeMinimizeWindowComponent.ctorParameters = () => [
    { type: MinimizeService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/
class AmexioVideoPlayerComponent {
    constructor() {
        // Internal Use Only
        this.rederVideo = true;
        this.currentVolume = 1;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onVolumeChange(event) {
        this.videoPlayer.nativeElement.volume = this.currentVolume = event.target.value;
    }
    /**
     * @return {?}
     */
    updateMuteUI() {
        if (this.videoPlayer.nativeElement.muted) {
            this.isMuted = true;
        }
        else {
            this.isMuted = false;
        }
    }
    /**
     * @return {?}
     */
    onPlay() {
        if (!this.isPlaying) {
            this.videoPlayer.nativeElement.play();
            this.isPlaying = true;
        }
        else {
            this.videoPlayer.nativeElement.pause();
            this.isPlaying = false;
        }
    }
    /**
     * @return {?}
     */
    onTimeUpdate() {
        /** @type {?} */
        const percentage = Math.floor((100 / this.videoPlayer.nativeElement.duration) * this.videoPlayer.nativeElement.currentTime);
        this.progressBar.nativeElement.value = percentage;
        // Update the progress bar's text (for browsers that don't support the progress element)
        this.progressBar.nativeElement.innerHTML = percentage + '% played';
        if (percentage === 100) {
            this.isPlaying = false;
        }
    }
    /**
     * @return {?}
     */
    replayVideo() {
        this.resetPlayer();
        this.onPlay();
    }
    /**
     * @return {?}
     */
    resetPlayer() {
        this.videoPlayer.nativeElement.pause();
        this.progressBar.nativeElement.value = 0;
        this.videoPlayer.nativeElement.currentTime = 0;
        this.isPlaying = false;
    }
    /**
     * @return {?}
     */
    onFullScreen() {
        /** @type {?} */
        const elem = this.videoPlayer.nativeElement;
        if (elem.requestFullscreen) {
            elem.requestFullscreen();
        }
        else if (elem.mozRequestFullScreen) {
            elem.mozRequestFullScreen();
        }
        else if (elem.webkitRequestFullscreen) {
            elem.webkitRequestFullscreen();
        }
    }
    /**
     * @return {?}
     */
    onMute() {
        if (!this.isMuted) {
            this.videoPlayer.nativeElement.muted = true;
            this.isMuted = true;
            this.volumebar.nativeElement.value = 0;
        }
        else {
            this.videoPlayer.nativeElement.muted = false;
            this.isMuted = false;
            this.volumebar.nativeElement.value = this.currentVolume;
        }
    }
}
AmexioVideoPlayerComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-video-player',
                template: `

      <ng-container *ngIf="rederVideo">
      <video [style.width.px]="width" controls>
          <source [attr.src]="path">
          Your browser does not support HTML5 video.
          <track label="English" kind="captions" srclang="en" src="" default>
      </video>
    </ng-container>
  `,
                styles: [`
    video{width:100%;height:100%;background:#000}progress{color:#4682b4;font-size:12px;width:220px;height:16px;border:none;margin-right:10px;background:#434343;border-radius:9px;vertical-align:middle}progress::-moz-progress-bar{color:#4682b4;background:#434343}progress[value]::-webkit-progress-bar{background-color:#434343;border-radius:2px;-webkit-box-shadow:0 2px 5px rgba(0,0,0,.25) inset;box-shadow:inset 0 2px 5px rgba(0,0,0,.25)}progress[value]::-webkit-progress-value{background-color:#4682b4}@media screen and (max-width:600px){video{border:1px solid #4682b4;width:98%;height:231px;background:#000}}
  `],
            },] },
];
/** @nocollapse */
AmexioVideoPlayerComponent.ctorParameters = () => [];
AmexioVideoPlayerComponent.propDecorators = {
    path: [{ type: Input }],
    extension: [{ type: Input }],
    width: [{ type: Input }],
    rederVideo: [{ type: Input }],
    videoPlayer: [{ type: ViewChild, args: ['videoRef',] }],
    progressBar: [{ type: ViewChild, args: ['progressbar',] }],
    volumebar: [{ type: ViewChild, args: ['volumebar',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Created by pratik on 27/11/17.
 */
/** @type {?} */
const MEDIA_COMPONENTS = [
    AmexioVideoPlayerComponent,
    AmexioImageComponent,
];
class AmexioMediaModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: AmexioMediaModule,
            providers: [CommonDataService, DeviceQueryService],
        };
    }
}
AmexioMediaModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    FormsModule,
                    HttpClientModule,
                    AmexioCommonModule,
                ],
                exports: MEDIA_COMPONENTS,
                declarations: MEDIA_COMPONENTS,
                providers: [CommonDataService, DeviceQueryService, IconLoaderService],
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AmexioFormActionCEComponent {
    /**
     * @param {?} formBuilder
     */
    constructor(formBuilder) {
        this.formBuilder = formBuilder;
        this.enableaction = false;
        this.isFormValid = false;
        this.showDialogue = false;
        this.errorMsgArray = [];
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
    }
    /**
     * @param {?} event
     * @return {?}
     */
    showErrors(event) {
        this.errorMsgArray = [];
        this.addErrorMsg();
        this.showDialogue = !this.isFormValid;
        if (!this.isFormValid) {
            this.showDialogue = true;
        }
        else {
            this.showDialogue = false;
        }
    }
    /**
     * @return {?}
     */
    closeDialogue() {
        this.showDialogue = !this.showDialogue;
    }
    // THIS METHOD IS USED FOR ADDING MSG
    /**
     * @return {?}
     */
    addErrorMsg() {
        if (this.form && this.form.status === 'INVALID') {
            for (const [key, value] of Object.entries(this.form.controls)) {
                if (value && value.status === 'INVALID') {
                    /** @type {?} */
                    const errorObject = {};
                    errorObject['label'] = key;
                    this.errorMsgArray.push(errorObject);
                }
            }
        }
    }
    /**
     * @param {?} form
     * @param {?} formFlag
     * @return {?}
     */
    getValidationForm(form, formFlag) {
        this.enableaction = true;
        this.formFlag = formFlag;
        this.form = form;
    }
}
AmexioFormActionCEComponent.decorators = [
    { type: Component, args: [{
                selector: 'form-action-ce',
                template: `
        <ng-container *ngIf="enableaction">  
          <span  *ngIf="!form.valid" style="padding-bottom:10px;position:relative">
                  <button class="button" [attr.title]="'click'" (click)="showErrors($event)" [ngClass]="'button-warning button-small button-round'">
                              <span class="button-text">
                                <span style="padding-right: 5px;" *ngIf="icon">
                                  <amexio-c-icon [customclass]="icon" >
                                  </amexio-c-icon>
                                </span>
          <span style="padding-right: 5px;">
                                  <amexio-c-icon key="button-loading-icon"></amexio-c-icon>
                                </span> ?
          </span>
          </button>
          <amexio-dialogue class="dailogue-header-ce" [(show)]="showDialogue" [custom]="true" [content-align]="'left'" [closable]="false"
              [title]="'Invalid Fields'" [type]="'confirm'">

              <amexio-body *ngFor="let msg of errorMsgArray let index=index">
                  <amexio-label>{{index+1}}) {{msg.label}}</amexio-label><br>
              </amexio-body>

              <amexio-action>
                  <amexio-button type="primary" (onClick)="closeDialogue()" [label]="'OK'">
                  </amexio-button>
              </amexio-action>
          </amexio-dialogue>
          </span>
        </ng-container>  
    `,
            },] },
];
/** @nocollapse */
AmexioFormActionCEComponent.ctorParameters = () => [
    { type: FormBuilder }
];
AmexioFormActionCEComponent.propDecorators = {
    icon: [{ type: Input, args: ['icon',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*  Created by sagar on 4/02/2019.
*/
class AmexioCardCEActionComponent {
    /**
     * @param {?} formBuilder
     */
    constructor(formBuilder) {
        this.formBuilder = formBuilder;
        this.align = '';
        this.direction = 'row';
        this.cclass = '';
        this.formFlag = false;
        this.showError = false;
        this.buttons = [];
        this.isFormValid = false;
        this.showDialogue = false;
        this.errorMsgArray = [];
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.bordertop) {
            this.cclass = 'card-action-border';
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (this.btns.length > 0) {
            this.buttons = this.btns.toArray();
        }
        else if (this.btngrp.length > 0) {
            this.buttons = this.btngrp.toArray()[0].buttons;
        }
    }
    /**
     * @param {?} data
     * @return {?}
     */
    checkFormValidation(data) {
        if (this.formAction && data && this.formFlag) {
            this.form = data;
            this.formAction.getValidationForm(this.form, this.formFlag);
        }
    }
}
AmexioCardCEActionComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-action-ce',
                template: `

    <div   [ngStyle]="{'background': ' url(' + bgimage + ') center/cover no-repeat','height': height }" [ngClass]="cclass">
        <div class="creative-footer" [style.flex-direction]="direction" [ngStyle]="{'color': color, 'background':background, 'justify-content': (align === 'start' || align === 'end') ? 'flex-'+align:align}">
            <ng-content></ng-content>
            <form-action-ce *ngIf="(formFlag && showError)" [icon]="icon"></form-action-ce>
        </div>
    </div>
  `,
            },] },
];
/** @nocollapse */
AmexioCardCEActionComponent.ctorParameters = () => [
    { type: FormBuilder }
];
AmexioCardCEActionComponent.propDecorators = {
    align: [{ type: Input, args: ['align',] }],
    bgimage: [{ type: Input, args: ['bg-image',] }],
    color: [{ type: Input, args: ['color',] }],
    background: [{ type: Input, args: ['background',] }],
    height: [{ type: Input, args: ['height',] }],
    bordertop: [{ type: Input, args: ['border-top',] }],
    direction: [{ type: Input, args: ['direction',] }],
    icon: [{ type: Input, args: ['icon',] }],
    btns: [{ type: ContentChildren, args: [AmexioButtonComponent,] }],
    btngrp: [{ type: ContentChildren, args: [AmexioButtonGroupComponent,] }],
    formAction: [{ type: ViewChild, args: [AmexioFormActionCEComponent,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*  Created by sagar on 4/02/2019.
*/
class AmexioCardCEBodyComponent {
    constructor() {
        this.cardclass = 'card-container-body';
        this.align = '';
        this.ribbonType = false;
    }
}
AmexioCardCEBodyComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-body-ce',
                template: `
      <div [ngStyle]="{'justify-content': (align === 'start' || align === 'end') ? 'flex-'+align:align,'background': ' url(' + bgimage + ') center/cover no-repeat', 'color': color,'background-color':background, 'height': height }">
          <ng-content></ng-content>
      </div>
      <ng-container *ngIf="ribbonType">
          <div class="ce-header-ribbon ce-header-ribbon-l"></div>
          <div class="ce-header-ribbon ce-header-ribbon-r"></div>
      </ng-container>
    `,
            },] },
];
AmexioCardCEBodyComponent.propDecorators = {
    cardclass: [{ type: HostBinding, args: ['attr.class',] }],
    align: [{ type: Input, args: ['align',] }],
    bgimage: [{ type: Input, args: ['bg-image',] }],
    color: [{ type: Input, args: ['color',] }],
    background: [{ type: Input, args: ['background',] }],
    height: [{ type: Input, args: ['height',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*  Created by sagar on 4/02/2019.
*/
class AmexioCardCEHeaderComponent {
    /**
     * @param {?} document
     */
    constructor(document) {
        this.document = document;
        this.align = '';
        this.verticalalign = '';
        this.direction = 'row';
        this.applyThemeColor = false;
        this.minimizeWindow = new EventEmitter();
        this.maximizeWindow = new EventEmitter();
        this.maximizeWindow1 = new EventEmitter();
        this.minimizeWindow1 = new EventEmitter();
        this.closeDataEmit = new EventEmitter();
        this.cclass = '';
        this.closeable = false;
        this.maximizeCe = false;
        this.minimize = false;
        this.isFullWindowCe = false;
        this.closeableBehaiour = new rxjs_6(false);
        this.maximizeBehaiourCe = new rxjs_6(false);
        // desktopFlag: boolean;
        this.maximize = false;
        this.ribbonType = false;
        // super(document)
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.borderbottom) {
            this.cclass = 'card-header-border';
        }
        this.setIconPosition();
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.textName = this.content.nativeElement.innerText;
        if (this.textName && this.minimizeIcon) {
            return this.textName;
        }
        if (this.textName && !this.minimizeIcon) {
            return this.textName;
        }
        else if (!this.textName && this.minimizeIcon) {
            return this.minimizeIcon;
        }
        else if (!this.minimizeIcon && !this.textName) {
            this.textName = [];
            this.minimizeIcon = 'fa fa-file';
        }
    }
    /**
     * @return {?}
     */
    onMinimizeClick() {
        this.closeableBehaiour.next(false);
        this.minimizeWindow.emit(this);
    }
    /**
     * @param {?} maximize
     * @param {?} isFullWindow
     * @return {?}
     */
    setMaximizeDataCE(maximize, isFullWindow) {
        this.maximizeCe = maximize;
        this.isFullWindowCe = isFullWindow;
        this.maximizeBehaiourCe.next(this.isFullWindowCe);
    }
    // On maximize click
    /**
     * @return {?}
     */
    sizeChange() {
        this.isFullWindowCe = !this.isFullWindowCe;
        this.maximizeBehaiourCe.next(this.isFullWindowCe);
        this.maximizeWindow.emit(this, this.isFullWindowCe);
    }
    /**
     * @return {?}
     */
    onCloseClick() {
        this.closeableBehaiour.next(false);
        this.closeDataEmit.emit(this);
    }
    /**
     * @return {?}
     */
    setIconPosition() {
        switch (this.verticalalign) {
            case 'top': {
                this.iconPosition = {
                    top: '0',
                    bottom: '',
                };
                break;
            }
            case 'center': {
                this.iconPosition = {
                    top: '',
                    bottom: '',
                };
                break;
            }
            case 'bottom': {
                this.iconPosition = {
                    top: '',
                    bottom: '0',
                };
                break;
            }
        }
    }
    /**
     * @param {?} themeClass
     * @return {?}
     */
    setColorPalette(themeClass) {
        this.themeCss = themeClass;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    maxScreenChange1(event) {
        this.maximizeWindow1.emit({ tempEvent: event, tempThis: this });
    }
    /**
     * @param {?} event
     * @return {?}
     */
    minScreenChange1(event) {
        this.minimizeWindow1.emit({ tempEvent: event, tempThis: this });
    }
}
AmexioCardCEHeaderComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-header-ce',
                template: `
    <div [ngClass]="cclass" class="creative-header-div" [ngStyle]="{'background': ' url(' + bgimage + ') center/cover no-repeat' }">
        <div *ngIf="ribbonType"> &nbsp;</div>
        <header class="creative-header {{themeCss}}" [style.flex-direction]="direction" [ngStyle]="{'justify-content': (align === 'start' || align === 'end') ? 'flex-'+align:align ,
         'color': color,'background':background,'height': height}"
            [ngClass]="{'card-container-ce-theme-color': applyThemeColor}">

            <span #contentWrapper>
                <ng-content ></ng-content>
            </span>
        
        
            <span *ngIf="windowFlag" class="creative-header-icon-div" [ngStyle]="iconPosition">
                <amexio-c-icon class="cursor-style" *ngIf="((isFullWindowCe && maximize))" [key]="'window_restore'" (onClick)="sizeChange()"></amexio-c-icon>
                <amexio-c-icon class="cursor-style" *ngIf="((!isFullWindowCe && maximize))" [key]="'window_maximize'" (click)="sizeChange()"></amexio-c-icon>
                <em  *ngIf="minimize" class="fa fa-window-minimize" (click)="onMinimizeClick($event)"
                style = "cursor: pointer;padding-left:5px;"></em>
                <amexio-c-icon class="cursor-style" style="padding-left:5px;" *ngIf="closeable" [key]="'window_close'"
                    (onClick)="onCloseClick()"></amexio-c-icon>
            </span>
            <span *ngIf="fullScreenFlag" class="creative-header-icon-div-full-screen" [ngStyle]="iconPosition">
                <amexio-c-icon class="cursor-style" *ngIf="((fullScreenFlag && !fullscreenMaxCard))" [key]="'full-screen-min-icon'" (onClick)="minScreenChange1($event)"></amexio-c-icon>
                <amexio-c-icon class="cursor-style" *ngIf="((fullScreenFlag && fullscreenMaxCard))" [key]="'full-screen-max-icon'" (click)="maxScreenChange1($event)"></amexio-c-icon>
            </span>
        </header>
    </div>
  `,
                styles: [
                    `
  .cursor-style {
  cursor:pointer;
  }
  `,
                ],
            },] },
];
/** @nocollapse */
AmexioCardCEHeaderComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
];
AmexioCardCEHeaderComponent.propDecorators = {
    align: [{ type: Input, args: ['align',] }],
    verticalalign: [{ type: Input, args: ['icon-align',] }],
    bgimage: [{ type: Input, args: ['bg-image',] }],
    color: [{ type: Input, args: ['color',] }],
    background: [{ type: Input, args: ['background',] }],
    height: [{ type: Input, args: ['height',] }],
    borderbottom: [{ type: Input, args: ['border-bottom',] }],
    direction: [{ type: Input, args: ['direction',] }],
    applyThemeColor: [{ type: Input, args: ['apply-theme-color',] }],
    content: [{ type: ViewChild, args: ['contentWrapper',] }],
    minimizeWindow: [{ type: Output }],
    maximizeWindow: [{ type: Output }],
    maximizeWindow1: [{ type: Output }],
    minimizeWindow1: [{ type: Output }],
    closeDataEmit: [{ type: Output }],
    minimizeIcon: [{ type: Input, args: ['minimized-icon',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*  Created by sagar on 4/02/2019.
*/
class AmexioCardCEComponent extends LifeCycleBaseComponent {
    /**
     * @param {?} document
     */
    constructor(document) {
        super(document);
        this.document = document;
        this.zoomtransitionorigin = 'center center';
        this.showcoverimg = false;
        this.zoomflipflag = false;
        this.slidereffecton = false;
        this.ishover = false;
        this.amexioComponentId = 'amexio-card-ce';
        this.windowFlag = false;
        this.slidercss = '';
        this.maximizeflagchanged = false;
        this.innerCardCss = '';
        this.slidereffect = 'slider-effect';
        this.height = '100%';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.instance = this;
        if (this.zoomflipflag) {
            this.zoom = true;
            this.flip = true;
        }
        this.cclass = ' card-container-ce-main ';
        this.innerCardCss = ' card-container-ce ';
        if (!this.color) {
            this.cclass = this.cclass + 'card-container-ce-color';
        }
        if (!this.background) {
            this.cclass = this.cclass + ' card-container-ce-bg-color';
        }
        if (this.overlaytype) {
            this.cclass = this.cclass + '  card-ce-overflowhidden';
            if (this.overlaytype === this.slidereffect) {
                this.innerCardCss = this.innerCardCss + ' card-ce-overlay-slideeffect ';
            }
            else if (this.overlaytype === 'fade-effect') {
                this.innerCardCss = this.innerCardCss + ' card-ce-overlay-fadeeffect ';
            }
        }
        this.setWiderAndNarrower();
        super.ngOnInit();
        this.setFlipCard();
        this.setZoomCard();
        this.polarideStyleMapCE = new Map();
        this.polarideStyleMapCE.set('tilted-minus-2-degree', 'card-container-pol-styl');
        this.polarideStyleMapCE.set('tilted-2-degree', 'card-container-pol-styl2');
        this.polarideStyleMapCE.set('tilted-4-degree', 'card-container-pol-styl3');
        this.polarideStyleMapCE.set('tilted-minus-4-degree', 'card-container-pol-styl4');
        this.polarideStyleMapCE.forEach((/**
         * @param {?} ele
         * @param {?} key
         * @return {?}
         */
        (ele, key) => {
            if (key === this.transformType) {
                this.cclass = this.cclass + ' ' + ele;
            }
        }));
        return 'this.tempPolaideCE';
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        super.ngAfterViewInit();
    }
    /**
     * @private
     * @return {?}
     */
    setFlipCard() {
        if (this.flip) {
            this.cclass = this.cclass + ' card-container-ce-main-flip';
            this.innerCardCss = this.innerCardCss + ' card-container-ce-flip ';
        }
    }
    /**
     * @private
     * @return {?}
     */
    setZoomCard() {
        if (this.zoom) {
            this.cclass = this.cclass + ' card-container-ce-main-zoom';
            this.innerCardCss = this.innerCardCss + ' card-container-ce-zoom ';
        }
    }
    // THIS METHOD CALLL FOR HEADER AND ACTION STYLE
    /**
     * @return {?}
     */
    setWiderAndNarrower() {
        switch (this.styleType) {
            case 'wider-header':
                this.cclass = this.cclass + ' card-container-wider-header';
                break;
            case 'narrower-header':
                this.cclass = this.cclass + ' card-container-narrower-header';
                break;
            case 'wider-action':
                this.cclass = this.cclass + ' card-container-wider-action';
                break;
            case 'narrower-action':
                this.cclass = this.cclass + ' card-container-narrower-action';
                break;
            case 'wider-all':
                this.cclass = this.cclass + ' card-container-wider-header card-container-wider-action';
                break;
            case 'narrower-all':
                this.cclass = this.cclass + ' card-container-narrower-header card-container-narrower-action';
                break;
            case 'wider-header-narrower-action':
                this.cclass = this.cclass + ' card-container-wider-header card-container-narrower-action';
                break;
            case 'narrower-header-wider-action':
                this.cclass = this.cclass + ' card-container-narrower-header card-container-wider-action';
                break;
            default:
                break;
        }
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (this.AmexioCardCEHeaderQueryList) {
            this.amexioCardHeaderList = this.AmexioCardCEHeaderQueryList.toArray();
            if (this.amexioCardHeaderList && this.amexioCardHeaderList.length > 0) {
                this.amexioCardHeaderList.forEach((/**
                 * @param {?} element
                 * @return {?}
                 */
                (element) => {
                    element.amexioComponentId = this.amexioComponentId;
                    element.fullScreenFlag = this.yesFullScreen;
                    element.fullscreenMaxCard = true;
                }));
                if (this.styleType === 'ribbon-style') {
                    this.amexioCardHeaderList[0].ribbonType = true;
                }
            }
        }
        if (this.yesFullScreen) {
            this.AmexioCardCEHeaderQueryList.toArray()[0].maximizeWindow1.subscribe((/**
             * @param {?} obj
             * @return {?}
             */
            (obj) => {
                this.headerinst = obj.tempThis;
                this.maximizeflagchanged = this.maxScreenChange(obj.tempEvent);
                obj.tempThis.fullscreenMaxCard = !this.maximizeflagchanged;
            }));
            this.AmexioCardCEHeaderQueryList.toArray()[0].minimizeWindow1.subscribe((/**
             * @param {?} obj
             * @return {?}
             */
            (obj) => {
                this.headerinst = obj.tempThis;
                this.maximizeflagchanged = this.minScreenChange(obj.tempEvent);
                obj.tempThis.fullscreenMaxCard = !this.maximizeflagchanged;
            }));
        }
        if (this.AmexioCardCEBodyQueryList) {
            this.amexioCardBodyList = this.AmexioCardCEBodyQueryList.toArray();
            if (this.styleType === 'ribbon-style') {
                this.amexioCardBodyList[0].ribbonType = true;
                this.cclass = this.cclass + ' card-container-wider-header card-container-ribbon-style';
            }
        }
        this.setCardAligementForAllInnerComponent();
    }
    // TO SET ALIGN TO ALL INNER COMPONENT IN CARD
    /**
     * @return {?}
     */
    setCardAligementForAllInnerComponent() {
        this.amexioCardHeaderList = this.AmexioCardCEHeaderQueryList.toArray();
        if (this.amexioCardHeaderList[0]) {
            this.amexioCardHeaderList[0].windowFlag = false;
        }
        if (this.amexioCardHeaderList[0] !== undefined && !this.amexioCardHeaderList[0].align &&
            this.amexioCardHeaderList[0].align.length > 0) {
            this.amexioCardHeaderList[0].align = this.align;
        }
        this.amexioCardBodyList = this.AmexioCardCEBodyQueryList.toArray();
        if (this.amexioCardBodyList[0] !== undefined && !this.amexioCardBodyList[0].align && this.amexioCardBodyList[0].align.length > 0) {
            this.amexioCardBodyList[0].align = this.align;
        }
        this.amexioCardActionList = this.AmexioCardCEActionQueryList.toArray();
        if (this.amexioCardActionList[0] !== undefined && !this.amexioCardActionList[0].align &&
            this.amexioCardActionList[0].align.length > 0) {
            this.amexioCardActionList[0].align = this.align;
        }
        else if (this.amexioCardActionList[0] !== undefined &&
            this.amexioCardActionList[0].align === '') {
            this.amexioCardActionList[0].align = 'end';
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        super.ngOnDestroy();
    }
    /**
     * @return {?}
     */
    onmouseover() {
        if ((!this.flip || !this.zoom) && this.overlaytype === this.slidereffect) {
            this.ishover = true;
        }
    }
    /**
     * @return {?}
     */
    onmouseleave() {
        if ((!this.flip || !this.zoom) && this.overlaytype === this.slidereffect) {
            this.ishover = false;
        }
    }
}
AmexioCardCEComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-card-ce',
                template: `
    <div (mouseover)="onmouseover()" (mouseleave)="onmouseleave()" [ngStyle]="{'background': bgimage ? 'url(' + bgimage + ') center/cover no-repeat' : null,

                'height': height, 'transform-origin': zoom ? zoomtransitionorigin: null, 'position':(maximizeflagchanged) ? 'fixed' :'relative', 'z-index':(maximizeflagchanged) ? '500' :'0', 'width':(maximizeflagchanged) ? '100%' : width}"
            [ngClass]="cclass">
            <div class="{{roundedgeclass}} {{innerCardCss}}" [ngClass]="{'card-ce-overlay-slideeffect-hover': ishover }" [ngStyle]="{'justify-content': (align === 'start' || align === 'end') ? 'flex-'+align:align ,
                    'color':color, 
                    'background': background}">

                    <div [ngClass]="{'ce-flip-card-front': flip,
                                     'ce-flip-card-zoom' : zoom}" class="ce-flip-card-front" *ngIf="flip || zoom" [ngStyle]="{'height': height , 'width': width }">
                            <img [src]="coverimage" alt="" class="img-fluid" style="height: 100%; width: 100%" />
                    </div>

                    <div [ngClass]="{'ce-flip-card-back': flip , 'ce-zoom-card-back':zoom, 'card-container-ce ' : !(flip && !zoom)}" [ngStyle]="{'height': height,'width': width, 'background': (coverimage && zoom && !zoomflipflag && !flip) ? 'url(' + coverimage + ') center/cover no-repeat' : null}">
                            <ng-content></ng-content>
                    </div>
                    <div>

                    </div>
  `,
            },] },
];
/** @nocollapse */
AmexioCardCEComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
];
AmexioCardCEComponent.propDecorators = {
    bgimage: [{ type: Input, args: ['bg-image',] }],
    overlaytype: [{ type: Input, args: ['overlay-type',] }],
    color: [{ type: Input, args: ['color',] }],
    background: [{ type: Input, args: ['background',] }],
    height: [{ type: Input, args: ['height',] }],
    width: [{ type: Input, args: ['width',] }],
    align: [{ type: Input, args: ['align',] }],
    styleType: [{ type: Input, args: ['style-type',] }],
    transformType: [{ type: Input, args: ['polaroid-type',] }],
    flip: [{ type: Input, args: ['flip',] }],
    zoom: [{ type: Input, args: ['zoom',] }],
    coverimage: [{ type: Input, args: ['cover-image',] }],
    zoomtransitionorigin: [{ type: Input, args: ['zoom-transition-origin',] }],
    showcoverimg: [{ type: Input, args: ['show-cover-image',] }],
    zoomflipflag: [{ type: Input, args: ['zoom-flip',] }],
    AmexioCardCEHeaderQueryList: [{ type: ContentChildren, args: [AmexioCardCEHeaderComponent,] }],
    AmexioCardCEBodyQueryList: [{ type: ContentChildren, args: [AmexioCardCEBodyComponent,] }],
    AmexioCardCEActionQueryList: [{ type: ContentChildren, args: [AmexioCardCEActionComponent,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AmexioFormCEComponent extends LifeCycleBaseComponent {
    /**
     * @param {?} formBuilder
     */
    constructor(formBuilder) {
        super();
        this.formBuilder = formBuilder;
        this.showError = false;
        this.showErrorMsg = new EventEmitter();
        this.componentError = [];
        this.windowFlag = false;
        this.checkForm = false;
        this.isFormValid = false;
        this.showDialogue = false;
        this.errorMsgArray = [];
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.setCardAligementForAllInnerComponent();
    }
    /**
     * @return {?}
     */
    onResize() {
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        /** @type {?} */
        const ngContentModels = this.models.toArray();
        /** @type {?} */
        const innerModelArray = [];
        this.fb.forEach((/**
         * @param {?} fbnode
         * @return {?}
         */
        (fbnode) => {
            /** @type {?} */
            const modelarray = fbnode.modelsarray;
            /** @type {?} */
            const fgc = {};
            modelarray.forEach((/**
             * @param {?} m
             * @return {?}
             */
            (m) => {
                fgc[m.name] = m.control;
                innerModelArray.push(m);
            }));
            /** @type {?} */
            const grp = this.formBuilder.group(fgc);
            this.form.form.registerControl(fbnode.group, grp);
        }));
        ngContentModels.forEach((/**
         * @param {?} model
         * @return {?}
         */
        (model) => {
            if (!this.isFieldPresentInParentAndChildBoth(innerModelArray, model.name)) {
                if (!model.name || model.name === null) {
                    model.name = model.valueAccessor['name'];
                }
                this.form.control.registerControl(model.name, model.control);
            }
        }));
        this.clearTimeout = setTimeout((/**
         * @return {?}
         */
        () => {
            this.form.form.updateValueAndValidity();
        }), 100);
        this.btns.toArray().forEach((/**
         * @param {?} btnCom
         * @return {?}
         */
        (btnCom) => {
            if ((btnCom.formbind === this.fname) && !btnCom.disabled) {
                this.buttons.push(btnCom);
            }
        }));
        this.AmexioCardCEActionQueryList.toArray()[0].formFlag = true;
        this.AmexioCardCEActionQueryList.toArray()[0].showError = this.showError;
        this.validateForm();
        this.onResize();
        super.ngAfterViewInit();
    }
    /**
     * @param {?} innerModelArray
     * @param {?} name
     * @return {?}
     */
    isFieldPresentInParentAndChildBoth(innerModelArray, name) {
        /** @type {?} */
        let isPresent = false;
        innerModelArray.forEach((/**
         * @param {?} innerModel
         * @return {?}
         */
        (innerModel) => {
            if (name === innerModel.name) {
                isPresent = true;
            }
        }));
        return isPresent;
    }
    // THIS METHOD IS USED FOR DISABLE BUTTON
    /**
     * @return {?}
     */
    validateForm() {
        if (this.form && this.form.status === 'INVALID') {
            this.disableButton(true);
        }
        else {
            this.disableButton(false);
        }
    }
    /**
     * @param {?} flag
     * @return {?}
     */
    disableButton(flag) {
        this.buttons.forEach((/**
         * @param {?} btn
         * @return {?}
         */
        (btn) => {
            btn.disabled = flag;
        }));
    }
    /**
     * @return {?}
     */
    ngAfterContentChecked() {
        this.validateForm();
        /** @type {?} */
        let form;
        form = this.form;
        this.AmexioCardCEActionQueryList.toArray()[0].checkFormValidation(form);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        clearTimeout(this.clearTimeout);
        super.ngOnDestroy();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.buttons = [];
        if (!this.color) {
            this.cclass = 'card-container-ce-color';
        }
        if (!this.background) {
            this.cclass = this.cclass + ' card-container-ce-bg-color';
        }
        this.setWiderAndNarrower();
        super.ngOnInit();
    }
    // THIS METHOD CALLL FOR HEADER AND ACTION STYLE
    /**
     * @return {?}
     */
    setWiderAndNarrower() {
        switch (this.styleType) {
            case 'wider-header':
                this.cclass = this.cclass + ' card-container-wider-header';
                break;
            case 'narrower-header':
                this.cclass = this.cclass + ' card-container-narrower-header';
                break;
            case 'wider-action':
                this.cclass = this.cclass + ' card-container-wider-action';
                break;
            case 'narrower-action':
                this.cclass = this.cclass + ' card-container-narrower-action';
                break;
            case 'wider-all':
                this.cclass = this.cclass + ' card-container-wider-header card-container-wider-action';
                break;
            case 'narrower-all':
                this.cclass = this.cclass + ' card-container-narrower-header card-container-narrower-action';
                break;
            case 'wider-header-narrower-action':
                this.cclass = this.cclass + ' card-container-wider-header card-container-narrower-action';
                break;
            case 'narrower-header-wider-action':
                this.cclass = this.cclass + ' card-container-narrower-header card-container-wider-action';
                break;
            default:
                break;
        }
    }
    // TO SET ALIGN TO ALL INNER COMPONENT IN CARD
    /**
     * @return {?}
     */
    setCardAligementForAllInnerComponent() {
        this.amexioCardHeaderList = this.AmexioCardCEHeaderQueryList.toArray();
        if (this.amexioCardHeaderList[0] !== undefined && !this.amexioCardHeaderList[0].align &&
            this.amexioCardHeaderList[0].align.length > 0) {
            this.amexioCardHeaderList[0].align = this.align;
        }
        this.amexioCardBodyList = this.AmexioCardCEBodyQueryList.toArray();
        if (this.amexioCardBodyList[0] !== undefined && !this.amexioCardBodyList[0].align && this.amexioCardBodyList[0].align.length > 0) {
            this.amexioCardBodyList[0].align = this.align;
        }
        this.amexioCardActionList = this.AmexioCardCEActionQueryList.toArray();
        if (this.amexioCardActionList[0] !== undefined && !this.amexioCardActionList[0].align &&
            this.amexioCardActionList[0].align.length > 0) {
            this.amexioCardActionList[0].align = this.align;
        }
        else if (this.amexioCardActionList[0] !== undefined &&
            this.amexioCardActionList[0].align === '') {
            this.amexioCardActionList[0].align = 'end';
        }
    }
}
AmexioFormCEComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-form-ce',
                template: `
      <div [ngStyle]="{'background': bgimage ? 'url(' + bgimage + ') center/cover no-repeat' : null}" [ngClass]="cclass">
          <div [ngStyle]="{'justify-content': (align === 'start' || align === 'end') ? 'flex-'+align:align , 'color':color, 'background': background}">
              <form name="fname" class="form-container-ce form-group">
                  <ng-content></ng-content>
              </form>
          <div>
      </div>
    `,
            },] },
];
/** @nocollapse */
AmexioFormCEComponent.ctorParameters = () => [
    { type: FormBuilder }
];
AmexioFormCEComponent.propDecorators = {
    fname: [{ type: Input, args: ['form-name',] }],
    showError: [{ type: Input, args: ['show-error',] }],
    showErrorMsg: [{ type: Output }],
    bgimage: [{ type: Input, args: ['bg-image',] }],
    color: [{ type: Input, args: ['color',] }],
    background: [{ type: Input, args: ['background',] }],
    height: [{ type: Input, args: ['height',] }],
    align: [{ type: Input, args: ['align',] }],
    styleType: [{ type: Input, args: ['style-type',] }],
    AmexioCardCEHeaderQueryList: [{ type: ContentChildren, args: [AmexioCardCEHeaderComponent,] }],
    AmexioCardCEBodyQueryList: [{ type: ContentChildren, args: [AmexioCardCEBodyComponent,] }],
    AmexioCardCEActionQueryList: [{ type: ContentChildren, args: [AmexioCardCEActionComponent,] }],
    btns: [{ type: ContentChildren, args: [AmexioButtonComponent, { descendants: true },] }],
    form: [{ type: ViewChild, args: [NgForm,] }],
    models: [{ type: ContentChildren, args: [NgModel, { descendants: true },] }],
    fb: [{ type: ContentChildren, args: [AmexioFormGroupDirective, { descendants: true },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AmexioHomePageCenterPanelComponent {
    /**
     * @param {?} matchMediaService
     */
    constructor(matchMediaService) {
        this.matchMediaService = matchMediaService;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
}
AmexioHomePageCenterPanelComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-homepage-centerpanel',
                template: `
    <div class="homepage-centerpanel">
        <ng-content></ng-content>
    </div>
  `,
            },] },
];
/** @nocollapse */
AmexioHomePageCenterPanelComponent.ctorParameters = () => [
    { type: DeviceQueryService }
];
AmexioHomePageCenterPanelComponent.propDecorators = {
    type: [{ type: Input, args: ['type',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AmexioHomePageEastPanelComponent {
    /**
     * @param {?} matchMediaService
     */
    constructor(matchMediaService) {
        this.matchMediaService = matchMediaService;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
    }
}
AmexioHomePageEastPanelComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-homepage-eastpanel',
                template: `
    <div>
        <ng-content></ng-content>
    </div>
  `,
            },] },
];
/** @nocollapse */
AmexioHomePageEastPanelComponent.ctorParameters = () => [
    { type: DeviceQueryService }
];
AmexioHomePageEastPanelComponent.propDecorators = {
    type: [{ type: Input, args: ['type',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ViewportBackgroundComponent {
    constructor() { }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        // IMAGE
        if (this.imageTemplate) {
            this.imagePath = this.imageTemplate.path;
            this.bgCss = 'bgCss' + window.crypto.getRandomValues(new Uint32Array(1))[0] + 'background';
        }
        // VIDEO
        if (this.videoTemplate) {
            this.videoPath = this.videoTemplate.path;
        }
    }
}
ViewportBackgroundComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-viewport-background',
                template: `

  `,
            },] },
];
/** @nocollapse */
ViewportBackgroundComponent.ctorParameters = () => [];
ViewportBackgroundComponent.propDecorators = {
    imageTemplate: [{ type: ContentChild, args: [AmexioImageComponent,] }],
    videoTemplate: [{ type: ContentChild, args: [AmexioVideoPlayerComponent,] }],
    backgroundColor: [{ type: Input, args: ['background-color',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ViewportContentBodyComponent {
    constructor() {
        this.scrollable = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() { }
    /**
     * @param {?} type
     * @return {?}
     */
    setRoundEdge(type) {
        if (type === 'round-edge') {
            this.roundedgeclass = 'roundEdgeCommonCss';
        }
        else {
            this.roundedgeclass = 'classicCommonCss';
        }
    }
}
ViewportContentBodyComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-viewport-content-body',
                template: `

            <div class="{{roundedgeclass}}">
                    <ng-content></ng-content>
            </div>
  `,
            },] },
];
/** @nocollapse */
ViewportContentBodyComponent.ctorParameters = () => [];
ViewportContentBodyComponent.propDecorators = {
    navTemplate: [{ type: ContentChild, args: [AmexioNavBarComponent,] }],
    scrollable: [{ type: Input, args: ['scrollable',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ViewportContentComponent {
    constructor() {
        this.scrollable = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (this.bgImageTemplate.backgroundColor) {
            this.backgroundColor = this.bgImageTemplate.backgroundColor;
        }
        // IMAGE
        if (this.bgImageTemplate.imagePath) {
            this.backgroundCss = 'bgCss' + window.crypto.getRandomValues(new Uint32Array(1))[0] + 'backgound';
            this.insertStyleSheetRule('.' + this.backgroundCss + '{ background-image: url(' + this.bgImageTemplate.imagePath + ')}');
        }
        // VIDEO
        if (this.bgImageTemplate.videoPath) {
            this.bgImageTemplate.videoTemplate.rederVideo = false;
            this.bgvid = 'videoId' + window.crypto.getRandomValues(new Uint32Array(1))[0];
            this.tempUrl = this.bgImageTemplate.videoPath;
            this.playVideo();
        }
    }
    /**
     * @return {?}
     */
    playVideo() {
        /** @type {?} */
        const media = this.videoId.nativeElement;
        media.muted = true;
        media.play();
    }
    /**
     * @param {?} ruleText
     * @return {?}
     */
    insertStyleSheetRule(ruleText) {
        /** @type {?} */
        const sheets = document.styleSheets;
        if (sheets.length === 0) {
            /** @type {?} */
            const style = document.createElement('style');
            style.appendChild(document.createTextNode(''));
            document.head.appendChild(style);
        }
        /** @type {?} */
        const sheet = sheets[sheets.length - 1];
        sheet.insertRule(ruleText, sheet.rules ? sheet.rules.length : sheet.cssRules.length);
    }
}
ViewportContentComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-viewport-content',
                template: `
    <div class="viewportContent {{backgroundCss}}" [ngStyle]="{'height':height}" onscroll="myFunction()">
        <video class="viewportvideo" #videoId src="{{tempUrl}}" muted="muted" poster="" loop="" autoplay="true" webkit-playsinline="true"
            playsinline="true">
            <track label="English" kind="captions" srclang="en" src="" default>
        </video>
        <div class="viewportBody" [ngStyle]="{'overflow-y': internalScroll ? 'scroll' : 'hidden',
    'background-color':backgroundColor, 'height':height}">
            <ng-content select="amexio-viewport-content-body"></ng-content>

        </div>
    </div>
  `,
            },] },
];
/** @nocollapse */
ViewportContentComponent.ctorParameters = () => [];
ViewportContentComponent.propDecorators = {
    videoId: [{ type: ViewChild, args: ['videoId',] }],
    bgImageTemplate: [{ type: ContentChild, args: [ViewportBackgroundComponent,] }],
    contentTemplate: [{ type: ContentChild, args: [ViewportContentBodyComponent,] }],
    scrollable: [{ type: Input, args: ['scrollable',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class ViewportComponent {
    constructor() {
        this.scrollable = true;
        this.type = '1';
        this.pageColor = 'black';
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onWindowScroll(event) {
        if ((this.type === '2') && (this.scrollable && window.scrollY > 0)) {
            this.contentCollection.forEach((/**
             * @param {?} element
             * @return {?}
             */
            (element) => {
                if (element.contentTemplate.navTemplate) {
                    element.contentTemplate.navTemplate.transparent = false;
                    element.contentTemplate.navTemplate.top = 0;
                }
            }));
        }
        if (window.scrollY === 0) {
            this.contentCollection.forEach((/**
             * @param {?} element
             * @return {?}
             */
            (element) => {
                if (element.contentTemplate.navTemplate) {
                    element.contentTemplate.navTemplate.transparent = true;
                    element.contentTemplate.navTemplate.top = 'unset';
                }
            }));
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        document.body.style.backgroundColor = this.pageColor;
        if (this.scrollable) {
            this.overflow = 'auto';
        }
        else {
            this.overflow = 'hidden';
        }
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.contentCollection = this.queryContent.toArray();
        if (this.type === '2') {
            this.contentCollection.forEach((/**
             * @param {?} element
             * @return {?}
             */
            (element) => {
                if (element.contentTemplate.navTemplate) {
                    element.contentTemplate.navTemplate.opacity = 0.8;
                    element.contentTemplate.navTemplate.top = 'unset';
                }
            }));
        }
        if (this.scrollable) {
            this.contentCollection.forEach((/**
             * @param {?} element
             * @return {?}
             */
            (element) => {
                element.internalScroll = false;
                this.getType(element);
            }));
        }
        else {
            this.contentCollection.forEach((/**
             * @param {?} element
             * @return {?}
             */
            (element) => {
                this.getType(element);
                if (element.scrollable) {
                    element.internalScroll = true;
                    element.height = 100 / this.contentCollection.length + '%';
                }
                else {
                    element.internalScroll = false;
                }
            }));
        }
        this.insertStyleSheetRule('body' + '{ overflow-y:' + this.overflow + '}');
    }
    /**
     * @param {?} ruleText
     * @return {?}
     */
    insertStyleSheetRule(ruleText) {
        /** @type {?} */
        const sheets = document.styleSheets;
        if (sheets.length === 0) {
            /** @type {?} */
            const style = document.createElement('style');
            style.appendChild(document.createTextNode(''));
            document.head.appendChild(style);
        }
        /** @type {?} */
        const sheet = sheets[sheets.length - 1];
        sheet.insertRule(ruleText, sheet.rules ? sheet.rules.length : sheet.cssRules.length);
    }
    /**
     * @param {?} element
     * @return {?}
     */
    getType(element) {
        if (this.type === '1' && element.contentTemplate.navTemplate) {
            element.contentTemplate.navTemplate.transparent = true;
        }
        if (this.type === '2' && element.contentTemplate.navTemplate) {
            element.contentTemplate.navTemplate.transparent = true;
        }
        if (this.type === '3' && element.contentTemplate.navTemplate) {
            element.contentTemplate.navTemplate.transparent = false;
        }
    }
}
ViewportComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-viewport',
                template: `
        <ng-content select="amexio-viewport-content"></ng-content>
  `,
            },] },
];
/** @nocollapse */
ViewportComponent.ctorParameters = () => [];
ViewportComponent.propDecorators = {
    queryContent: [{ type: ContentChildren, args: [ViewportContentComponent,] }],
    scrollable: [{ type: Input, args: ['scrollable',] }],
    type: [{ type: Input, args: ['type',] }],
    pageColor: [{ type: Input, args: ['page-color',] }],
    onWindowScroll: [{ type: HostListener, args: ['window:scroll', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by kedarkokil on 26/09/18.
*/
class AmexioBreadcrumbComponent extends LifeCycleBaseComponent {
    /**
     * @param {?} element
     * @param {?} dataService
     */
    constructor(element, dataService) {
        super();
        this.element = element;
        this.dataService = dataService;
        /*
           Events
           name : onListItemClick
           datatype : any
           version : none
           default :
           description : On click event
           */
        this.onListItemClick = new EventEmitter();
        /*
           Events
           name : onClick
           datatype : any
           version : none
           default :
           description : On click event
           */
        this.onClick = new EventEmitter();
        this.buttonAngleRightCss = 'button_angle-right';
        this.displaykey = 'text';
        this.childarraykey = 'children';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.arrowKey = this.buttonAngleRightCss;
        if (this.httpmethod && this.httpurl) {
            this.dataService.fetchData(this.httpurl, this.httpmethod).subscribe((/**
             * @param {?} response
             * @return {?}
             */
            (response) => {
                this.responseData = response;
            }), (/**
             * @param {?} error
             * @return {?}
             */
            (error) => {
            }), (/**
             * @return {?}
             */
            () => {
                this.setData(this.responseData);
            }));
        }
        else if (this.data) {
            this.setData(this.data);
        }
    }
    // ICON ADDED WHEN THE ICON IS NOT GIVEN
    /**
     * @param {?} nodeArray
     * @return {?}
     */
    iconAddedMethod(nodeArray) {
        console.log('nodeArray', nodeArray);
        if (nodeArray && nodeArray.length > 0) {
            nodeArray.forEach((/**
             * @param {?} node
             * @return {?}
             */
            (node) => {
                if (node[this.childarraykey]) {
                    node[this.childarraykey].forEach((/**
                     * @param {?} element
                     * @param {?} index
                     * @return {?}
                     */
                    (element, index) => {
                        element['id'] = Math.floor(window.crypto.getRandomValues(new Uint32Array(1))[0]) + '_id';
                        if (node[this.childarraykey]) {
                            this.iconAddedMethod(node[this.childarraykey]);
                        }
                        this.setTabindex(index, element);
                        this.childIconCheckMethod(element);
                    }));
                }
            }));
        }
    }
    /**
     * @param {?} index
     * @param {?} element
     * @return {?}
     */
    setTabindex(index, element) {
        if (index === 0) {
            element['tabindex'] = 1;
        }
        else {
            element['tabindex'] = -1;
        }
    }
    /**
     * @param {?} element
     * @return {?}
     */
    childIconCheckMethod(element) {
        if (element.hasOwnProperty([this.childarraykey])) {
            element[this.childarraykey].forEach((/**
             * @param {?} childIcon
             * @return {?}
             */
            (childIcon) => {
                if (childIcon.icon == null || childIcon.icon === '') {
                    childIcon.icon = 'fa fa-file-o';
                }
            }));
            if (element.icon == null || element.icon === '') {
                element.icon = 'fa fa-folder-o';
            }
            this.iconAddedMethod(element);
        }
    }
    // THIS METHOD   IS USED FOR ADDING CHILDREN IN OPTIONS
    /**
     * @param {?} event
     * @return {?}
     */
    getSelectedItem(event) {
        /** @type {?} */
        const arrayOnly = [event.data];
        this.childItem = arrayOnly;
        event.parentRef.show = true;
        event.parentRef.expand = false;
        this.arrowKey = this.buttonAngleRightCss;
        this.onListItemClick.emit(event.data);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    getEventEmitClick(event) {
        this.onListItemClick.emit(event);
    }
    /**
     * @param {?} item
     * @return {?}
     */
    onArrowClick(item) {
        item.expand = !item.expand;
        if (item.expand) {
            this.arrowKey = 'button_angle-down';
        }
        else {
            this.arrowKey = this.buttonAngleRightCss;
        }
    }
    /**
     * @param {?} nodeArray
     * @param {?} node
     * @param {?} index
     * @return {?}
     */
    onArrowDown(nodeArray, node, index) {
        /** @type {?} */
        let currentindex;
        if (index < nodeArray[this.childarraykey].length - 1) {
            nodeArray[this.childarraykey].forEach((/**
             * @param {?} element
             * @return {?}
             */
            (element) => {
                if (node['id'] === element['id']) {
                    currentindex = index + 1;
                }
            }));
        }
        else if (index === nodeArray[this.childarraykey].length - 1) {
            currentindex = 0;
        }
        /** @type {?} */
        const itemid = nodeArray[this.childarraykey][currentindex];
        document.getElementById(itemid['id']).focus();
    }
    /**
     * @param {?} nodeArray
     * @param {?} node
     * @param {?} index
     * @return {?}
     */
    onArrowUp(nodeArray, node, index) {
        /** @type {?} */
        let currentindex;
        if (index !== 0) {
            nodeArray[this.childarraykey].forEach((/**
             * @param {?} element
             * @return {?}
             */
            (element) => {
                if (node['id'] === element['id']) {
                    currentindex = index - 1;
                }
            }));
        }
        else if (index === 0) {
            currentindex = nodeArray[this.childarraykey].length - 1;
        }
        /** @type {?} */
        const itemid = nodeArray[this.childarraykey][currentindex];
        document.getElementById(itemid['id']).focus();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onButtonClick(event) {
        event.show = false;
        event.expand = false;
        this.onClick.emit(event);
    }
    /**
     * @param {?} httpResponse
     * @return {?}
     */
    setData(httpResponse) {
        /** @type {?} */
        let responsedata = httpResponse;
        // Check if key is added?
        if (this.datareader != null) {
            /** @type {?} */
            const dr = this.datareader.split('.');
            for (const ir of dr) {
                responsedata = responsedata[ir];
            }
        }
        else {
            responsedata = httpResponse;
        }
        this.data = responsedata;
        this.iconAddedMethod(this.data);
    }
    /**
     * @param {?} targetElement
     * @return {?}
     */
    onElementOutClick(targetElement) {
        /** @type {?} */
        let parentFound = false;
        while (targetElement !== null && !parentFound) {
            if (targetElement === this.element.nativeElement) {
                parentFound = true;
            }
            targetElement = targetElement.parentElement;
        }
        if (!parentFound) {
            /** @type {?} */
            let expandData;
            this.data.forEach((/**
             * @param {?} dataObject
             * @return {?}
             */
            (dataObject) => {
                if (dataObject) {
                    expandData = dataObject;
                }
                if (expandData && expandData.expand != null) {
                    expandData.expand = false;
                }
            }));
        }
    }
}
AmexioBreadcrumbComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-breadcrumb',
                template: `
    <ng-container *ngIf="data">

        <div *ngFor="let nodeObject of data">

            <div   class="breadcrum-rightshift-css {{roundedgeclass}}">
                <div class="breadcrumb-group" tabindex="1" aria-label="breadcrum">
                    <label tabindex="1" (click)="onButtonClick(nodeObject)" (keyup.enter)="onButtonClick(nodeObject)" class="label-icon-css">
                        <ng-container *ngIf="nodeObject && nodeObject.icon">
                            <span [ngClass]="nodeObject.icon"></span>
                        </ng-container>&nbsp;
                        <span>{{nodeObject[displaykey]}}&nbsp;&nbsp;</span>
                    </label>
                    <ng-container *ngIf="nodeObject[childarraykey]">
                        <amexio-c-icon tabindex="1" aria-label="button clickable" (click)="onArrowClick(nodeObject)"
                            (keyup.enter)="onArrowClick(nodeObject)" class="arrow-group-css" [key]="arrowKey"></amexio-c-icon>
                    </ng-container>
                    <div class="context-menu-list1" [@breadCrumbStateState]="nodeObject.expand ? 'visible':'hidden'">
                        <ng-container *ngFor="let node of nodeObject[childarraykey] let rowindex = index">
                            <div tabindex="{{node.tabindex}}" id="{{node.id}}" class="context-menu-list-items1" [ngStyle]="{'cursor': node.disabled ? 'not-allowed':'pointer'}"
                                (click)="getSelectedItem({data:node,parentRef:nodeObject})" (keyup.arrowdown)="onArrowDown(nodeObject,node,rowindex)"
                                (keyup.arrowup)="onArrowUp(nodeObject,node,rowindex)" (keyup.enter)="getSelectedItem({data:node,parentRef:nodeObject})">
                                <div class="dropdown-icon-css">
                                    <ng-container *ngIf="node.icon">
                                        <amexio-c-icon [ngClass]="node.icon"></amexio-c-icon>
                                    </ng-container>&nbsp;
                                </div>
                                <div class="dropdown-label-css">
                                    <span>{{node[displaykey]}}&nbsp;</span>
                                </div>
                            </div>
                        </ng-container>
                    </div>
                </div>
                <ng-container *ngIf="nodeObject.show">
                    <amexio-breadcrumb [data]="childItem" [display-key]="displaykey" [childarray-key]="childarraykey"
                        (onListItemClick)="getEventEmitClick($event)" (onClick)="onButtonClick($event)">
                    </amexio-breadcrumb>
                </ng-container>
            </div>
        </div>
    </ng-container>
  `,
                animations: [
                    trigger('breadCrumbStateState', [
                        state('hidden', style({
                            'transform': 'scale(0)',
                            'transform-origin': 'left top 0px',
                        })),
                        state('visible', style({
                            'transform-origin': 'left top 0px',
                            'transform': 'scale(1)',
                        })),
                        transition('*=>hidden', animate('0ms')),
                        transition('*=>visible', animate('200ms')),
                    ]),
                ],
            },] },
];
/** @nocollapse */
AmexioBreadcrumbComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: CommonDataService }
];
AmexioBreadcrumbComponent.propDecorators = {
    data: [{ type: Input }],
    httpurl: [{ type: Input, args: ['http-url',] }],
    datareader: [{ type: Input, args: ['data-reader',] }],
    httpmethod: [{ type: Input, args: ['http-method',] }],
    displaykey: [{ type: Input, args: ['display-key',] }],
    childarraykey: [{ type: Input, args: ['childarray-key',] }],
    onListItemClick: [{ type: Output }],
    onClick: [{ type: Output }],
    onElementOutClick: [{ type: HostListener, args: ['document:click', ['$event.target'],] }, { type: HostListener, args: ['document: touchstart', ['$event.target'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by sagar on 6/9/17.
*/
class DockbarComponent {
    constructor() {
    }
    // Close the  dockbar item
    /**
     * @return {?}
     */
    onBarIconClick() {
        this.active = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.elementId = 'dockbar-item-id' + Math.floor(window.crypto.getRandomValues(new Uint32Array(1))[0]);
    }
}
DockbarComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-dockbar-item', template: `
    <div *ngIf="active"  [style.width]="width"
    class="dockbar-active-content dockbar-height"
    [style.min-height]="height"  [style.max-height]="height">
      <ng-container *ngIf="active && title">
        <div class="dockbar-title">
          {{title}}
          <span class="dockbar-item-close-bar" (click)="onBarIconClick()">
            <amexio-c-icon key="dockbar_close"></amexio-c-icon>
            <!--
                        <i class="fa fa-times" aria-hidden="true"></i>
            -->
          </span>
        </div>
      </ng-container>
      <ng-content>
      </ng-content>
    </div>
  `,
            },] },
];
/** @nocollapse */
DockbarComponent.ctorParameters = () => [];
DockbarComponent.propDecorators = {
    active: [{ type: Input }],
    label: [{ type: Input }],
    icon: [{ type: Input }],
    mda: [{ type: Input }],
    width: [{ type: Input }],
    title: [{ type: Input }],
    path: [{ type: Input }],
    height: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by Ketan Gote on 8/21/17.
*/
class DockedBarToolComponent extends LifeCycleBaseComponent {
    constructor() {
        super();
    }
    // on docker bar click event
    /**
     * @param {?} event
     * @return {?}
     */
    onClick(event) {
        /** @type {?} */
        const tabs = this.dockbarArray;
        tabs.forEach((/**
         * @param {?} tab
         * @return {?}
         */
        (tab) => {
            tab.active = false;
            if (tab.elementId === event.elementId) {
                tab.active = true;
            }
        }));
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.dockbarArray = this.dockbars.toArray();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
}
DockedBarToolComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-dockbar', template: `
    <div class="dockbar" [style.min-height]="height">
      <ng-container *ngFor="let dockbar of dockbarArray">
        <button [ngClass]="{'active':dockbar.active}" (click)="onClick(dockbar)">

          <!--Normal image-->
          <ng-container *ngIf="dockbar.path">
            <img [src]="dockbar.path">
          </ng-container>

          <!--this is for fontawesome-->
          <ng-container *ngIf="(!(dockbar.icon && dockbar.mda) && dockbar.icon)">
            <amexio-image [icon-class]="dockbar.icon" [c-class]=""></amexio-image>
            <!--<i [ngClass]="dockbar.icon"></i>-->
          </ng-container>

          <!--if dockbar have label instead of icon -->
          <ng-container *ngIf="dockbar.label && dockbar.active">
            <p><strong class="dockbar-label-highlight">{{dockbar.label}}</strong></p>
          </ng-container>

          <ng-container *ngIf="dockbar.label && !dockbar.active">
            <p>{{dockbar.label}}</p>
          </ng-container>

        </button>
      </ng-container>
    </div>
    <div class="dockbar-content {{roundedgeclass}}" [style.min-height]="height">
      <ng-content></ng-content>
    </div>

  `,
            },] },
];
/** @nocollapse */
DockedBarToolComponent.ctorParameters = () => [];
DockedBarToolComponent.propDecorators = {
    dockbars: [{ type: ContentChildren, args: [DockbarComponent,] }],
    height: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by ketangote on 12/8/17.
*/
class AmexioMenuBarComponent extends LifeCycleBaseComponent {
    /**
     * @param {?} matchMediaService
     * @param {?} dataService
     */
    constructor(matchMediaService, dataService) {
        super();
        this.matchMediaService = matchMediaService;
        this.dataService = dataService;
        /*
        Events
        name : nodeClick
        datatype : any
        version : none
        default : none
        description : Fire when menubar bar click.
        */
        this.nodeClick = new EventEmitter();
        this.xposition = false;
        this.expand = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.httpmethod && this.httpurl) {
            this.dataService.fetchData(this.httpurl, this.httpmethod).subscribe((/**
             * @param {?} response
             * @return {?}
             */
            (response) => {
                this.responseData = response;
            }), (/**
             * @param {?} error
             * @return {?}
             */
            (error) => {
            }), (/**
             * @return {?}
             */
            () => {
                this.setData(this.responseData);
            }));
        }
        else if (this.data) {
            this.setData(this.data);
        }
    }
    /**
     * @param {?} node
     * @return {?}
     */
    onClick(node) {
        node['expandflag'] = !node['expandflag'];
        if (this.matchMediaService.IsPhone() || this.matchMediaService.IsTablet()) {
            for (const i of 'length') {
                if (this.data[i] === node) {
                    this.data[i].expand = !this.data[i].expand;
                }
                else {
                    this.data[i].expand = false;
                }
            }
        }
        this.nodeClick.emit(node);
    }
    /**
     * @param {?} subinnernode
     * @param {?} mainnode
     * @return {?}
     */
    onSubInnerNodeClick(subinnernode, mainnode) {
        if (mainnode['expandflag']) {
            mainnode['expandflag'] = false;
        }
        this.nodeClick.emit(subinnernode);
    }
    /**
     * @param {?} subnode
     * @param {?} mainnode
     * @return {?}
     */
    onInnerNodeClick(subnode, mainnode) {
        if (mainnode['expandflag']) {
            mainnode['expandflag'] = false;
        }
        this.nodeClick.emit(subnode);
    }
    /**
     * @param {?} event
     * @param {?} flag
     * @param {?} rowindex
     * @param {?} node
     * @param {?} data
     * @return {?}
     */
    onMenubarKeyup(event, flag, rowindex, node, data) {
        if (event.keyCode === 37) {
            this.NavigateMenubarLeft(event, flag, rowindex, node, data);
        }
        else if (event.keyCode === 39) {
            this.NavigateMenubarRight(event, flag, rowindex, node, data);
        }
        else if (event.keyCode === 13) {
            this.onEnterClick(rowindex, node);
        }
    }
    /**
     * @param {?} event
     * @param {?} flag
     * @param {?} rowindex
     * @param {?} node
     * @param {?} data
     * @return {?}
     */
    NavigateMenubarLeft(event, flag, rowindex, node, data) {
        if (node['expand']) {
            node['expand'] = false;
        }
        if (rowindex !== 0) {
            /** @type {?} */
            const currentindex = rowindex - 1;
            /** @type {?} */
            const itemid = currentindex;
            document.getElementById(itemid).focus();
            /** @type {?} */
            const currentnode = data[itemid];
            if (currentnode) {
                currentnode['expand'] = true;
                currentnode['expandflag'] = true;
                this.currentnode = currentnode;
            }
        }
        else if (rowindex === 0) {
            /** @type {?} */
            const currentindex = this.data.length - 1;
            /** @type {?} */
            const itemid = currentindex;
            document.getElementById(itemid).focus();
        }
    }
    /**
     * @param {?} event
     * @param {?} flag
     * @param {?} rowindex
     * @param {?} node
     * @param {?} data
     * @return {?}
     */
    NavigateMenubarRight(event, flag, rowindex, node, data) {
        if (node['expand']) {
            node['expand'] = false;
        }
        if (rowindex < data.length - 1) {
            /** @type {?} */
            const currentindex = rowindex + 1;
            /** @type {?} */
            const itemid = currentindex;
            document.getElementById(itemid).focus();
            /** @type {?} */
            const currentnode = data[itemid];
            if (currentnode) {
                currentnode['expand'] = true;
                currentnode['expandflag'] = true;
                this.currentnode = currentnode;
            }
        }
        else if (rowindex === data.length - 1) {
            /** @type {?} */
            const currentindex = 0;
            /** @type {?} */
            const itemid = currentindex;
            document.getElementById(itemid).focus();
        }
    }
    /**
     * @param {?} event
     * @param {?} flag
     * @param {?} rowindex
     * @param {?} node
     * @param {?} data
     * @param {?} nodedata
     * @return {?}
     */
    navigateChild(event, flag, rowindex, node, data, nodedata) {
        if (event.keyCode === 37) {
            this.navigateChildMenuitemLeft(event, rowindex, node, data);
        }
        else if (event.keyCode === 39) {
            this.navigateChildMenuitemRight(event, rowindex, node, data);
        }
        else if (event.keyCode === 13) {
            this.onnavigateChildEnterClick(event, rowindex, node, data, nodedata);
        }
    }
    /**
     * @param {?} event
     * @param {?} rowindex
     * @param {?} node
     * @param {?} data
     * @return {?}
     */
    navigateChildMenuitemLeft(event, rowindex, node, data) {
        event.stopImmediatePropagation();
        if (rowindex === 0) {
            /** @type {?} */
            const currentindex = data.length - 1;
            /** @type {?} */
            const itemid = currentindex;
            /** @type {?} */
            const childindex = data[itemid]['text'] + itemid;
            document.getElementById(childindex).focus();
        }
        else {
            /** @type {?} */
            const currentindex = rowindex - 1;
            /** @type {?} */
            const itemid = currentindex;
            /** @type {?} */
            const childindex = data[itemid]['text'] + itemid;
            document.getElementById(childindex).focus();
        }
    }
    /**
     * @param {?} event
     * @param {?} rowindex
     * @param {?} node
     * @param {?} data
     * @return {?}
     */
    navigateChildMenuitemRight(event, rowindex, node, data) {
        event.stopImmediatePropagation();
        if (rowindex < data.length - 1) {
            /** @type {?} */
            const currentindex = rowindex + 1;
            /** @type {?} */
            const itemid = currentindex;
            /** @type {?} */
            const childindex = data[itemid]['text'] + itemid;
            document.getElementById(childindex).focus();
        }
        else if (rowindex === data.length - 1) {
            /** @type {?} */
            const itemid = 0;
            /** @type {?} */
            const childindex = data[itemid]['text'] + itemid;
            document.getElementById(childindex).focus();
        }
    }
    /**
     * @param {?} event
     * @param {?} rowindex
     * @param {?} node
     * @param {?} data
     * @param {?} nodedata
     * @return {?}
     */
    onnavigateChildEnterClick(event, rowindex, node, data, nodedata) {
        event.stopImmediatePropagation();
        if (nodedata['expandflag']) {
            nodedata['expandflag'] = false;
        }
        this.nodeClick.emit(node);
    }
    /**
     * @param {?} rowindex
     * @param {?} node
     * @return {?}
     */
    onEnterClick(rowindex, node) {
        if (node['expandflag']) {
            node['expandflag'] = false;
        }
        this.nodeClick.emit(node);
    }
    /**
     * @param {?} event
     * @param {?} subinnerindex
     * @param {?} data
     * @param {?} subinnernode
     * @param {?} mainnode
     * @return {?}
     */
    updownInnerChildNavigation(event, subinnerindex, data, subinnernode, mainnode) {
        if (event.keyCode === 38) {
            this.onUpInnerChildNavigate(event, subinnerindex, data);
        }
        else if (event.keyCode === 40) {
            this.onDownInnerChildNavigate(event, subinnerindex, data);
        }
        else if (event.keyCode === 13) {
            this.onInnerChildEnterClick(subinnernode, mainnode);
        }
    }
    /**
     * @param {?} event
     * @param {?} subinnerindex
     * @param {?} data
     * @return {?}
     */
    onUpInnerChildNavigate(event, subinnerindex, data) {
        event.stopImmediatePropagation();
        if (subinnerindex === 0) {
            /** @type {?} */
            const currentindex = data.length - 1;
            /** @type {?} */
            const itemid = currentindex;
            /** @type {?} */
            const innerchild = data[itemid]['text'] + itemid;
            document.getElementById(innerchild).focus();
        }
        else {
            /** @type {?} */
            const currentindex = subinnerindex - 1;
            /** @type {?} */
            const itemid = currentindex;
            /** @type {?} */
            const innerchild = data[itemid]['text'] + itemid;
            document.getElementById(innerchild).focus();
        }
    }
    /**
     * @param {?} event
     * @param {?} subinnerindex
     * @param {?} data
     * @return {?}
     */
    onDownInnerChildNavigate(event, subinnerindex, data) {
        event.stopImmediatePropagation();
        if (subinnerindex < data.length - 1) {
            /** @type {?} */
            const currentindex = subinnerindex + 1;
            /** @type {?} */
            const itemid = currentindex;
            /** @type {?} */
            const innerchild = data[itemid]['text'] + itemid;
            document.getElementById(innerchild).focus();
        }
        else if (subinnerindex === data.length - 1) {
            /** @type {?} */
            const itemid = 0;
            /** @type {?} */
            const innerchild = data[itemid]['text'] + itemid;
            document.getElementById(innerchild).focus();
        }
    }
    /**
     * @param {?} subinnernode
     * @param {?} mainnode
     * @return {?}
     */
    onInnerChildEnterClick(subinnernode, mainnode) {
        event.stopImmediatePropagation();
        mainnode['expandflag'] = false;
        this.nodeClick.emit(subinnernode);
    }
    /**
     * @param {?} data
     * @return {?}
     */
    generateIndex(data) {
        if (data) {
            data.forEach((/**
             * @param {?} element
             * @param {?} index
             * @return {?}
             */
            (element, index) => {
                if (index === 0) {
                    element['tabindex'] = '0';
                    element['expandflag'] = true;
                }
                else {
                    element['tabindex'] = '-1';
                    element['expandflag'] = true;
                }
                if (element.children) {
                    element.children.forEach((/**
                     * @param {?} innerelement
                     * @param {?} innerindex
                     * @return {?}
                     */
                    (innerelement, innerindex) => {
                        this.generateInnerIndex(innerindex, innerelement);
                        if (innerelement.children) {
                            innerelement.children.forEach((/**
                             * @param {?} subinnerelement
                             * @param {?} subinnerindex
                             * @return {?}
                             */
                            (subinnerelement, subinnerindex) => {
                                this.generateSunInnerIndex(subinnerindex, subinnerelement);
                            }));
                        }
                    }));
                }
            }));
        }
    }
    /**
     * @param {?} innerindex
     * @param {?} innerelement
     * @return {?}
     */
    generateInnerIndex(innerindex, innerelement) {
        if (innerindex === 0) {
            innerelement['tabindex'] = '0';
            innerelement['index'] = innerelement['text'] + innerindex;
        }
        else {
            innerelement['tabindex'] = '-1';
            innerelement['index'] = innerelement['text'] + innerindex;
        }
    }
    /**
     * @param {?} subinnerindex
     * @param {?} subinnerelement
     * @return {?}
     */
    generateSunInnerIndex(subinnerindex, subinnerelement) {
        if (subinnerindex === 0) {
            subinnerelement['tabindex'] = '0';
            subinnerelement['index'] = subinnerelement['text'] + subinnerindex;
        }
        else {
            subinnerelement['tabindex'] = '-1';
            subinnerelement['index'] = subinnerelement['text'] + subinnerindex;
        }
    }
    /**
     * @param {?} httpResponse
     * @return {?}
     */
    setData(httpResponse) {
        // Check if key is added?
        /** @type {?} */
        if (this.datareader != null) {
            /** @type {?} */
            const dr = this.datareader.split('.');
            
        }
        this.data = httpResponse;
        this.generateIndex(this.data);
    }
    /**
     * @param {?} event
     * @param {?} node
     * @return {?}
     */
    onMouseOver(event, node) {
        if (!(this.matchMediaService.IsPhone() || this.matchMediaService.IsTablet())) {
            if ((this.matchMediaService.browserWindow().innerWidth - event.clientX) < 200) {
                this.xposition = true;
            }
            else {
                this.xposition = false;
            }
        }
        else {
            this.xposition = false;
        }
        node['expandflag'] = true;
    }
}
AmexioMenuBarComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-menu',
                template: `
    <div class="menu-container">
        <div class="menubar">
            <ul role="menubar" class="menuheader">
                <li class="menulink">{{label}}</li>
                <div>
                    <li role="menuitem" tabindex="{{node.tabindex}}" id="{{rowindex}}" *ngFor="let node of data let rowindex = index "
                        (keyup)="onMenubarKeyup($event,false,rowindex,node,data)" class="menulink">
                        <a (click)="onClick(node)" (mouseover)="onMouseOver($event, node)">
                            <amexio-c-icon *ngIf="node.icon" [customclass]="node.icon"></amexio-c-icon>&nbsp;&nbsp;{{node.text}}
                        </a>
                         <span *ngIf="(node.children && node.children[0].children)" class="{{roundedgeclass}}">
                            <div *ngIf="(node.children && node.children.length>0)" class="menu-content" [ngClass]="{'menu-content-display':node.expand,'menu-content-hide':!node.expandflag,
                      ' menu-content-left': (node.children && node.children.length>3),'menu-right':xposition}">
                                <ul class="menu-content-cols">
                                    <li class="col-menu-nodes" [ngClass]="{'col-menu-nodes-fixed': (node.children && node.children.length<4),
                        'col-menu-nodes-percentage': (node.children && node.children.length>3)}"
                                        *ngFor="let subnode of node.children let rowindex = index">
                                        <div class="content">
                                            <div *ngIf="(subnode.text && subnode.text.length>0)" id="{{subnode.index}}"
                                                tabindex="{{subnode.tabindex}}" (click)="onInnerNodeClick(subnode,node)"
                                                (keyup)="navigateChild($event,true,rowindex,subnode,node.children,node)"
                                                class="menu-links-header">
                                                <amexio-c-icon *ngIf="subnode.icon" [customclass]="subnode.icon"></amexio-c-icon>&nbsp;&nbsp;{{subnode.text}}
                                             </div>
                                            <div *ngIf="subnode.image" style="padding: 10px;">
                                                <img [attr.src]="subnode.image" alt="">
                                            </div>
                                            <ul class="menu-content-cols">
                                                <li *ngFor="let subinnernode of subnode.children let subinnerindex = index"
                                                    tabindex="{{subinnernode.tabindex}}" (click)="onSubInnerNodeClick(subinnernode,node)"
                                                    id={{subinnernode.index}} (keyup)="updownInnerChildNavigation($event,subinnerindex,subnode.children,subinnernode,node)"
                                                    class="menulinks">
                                                    <div *ngIf="subinnernode.image" style="padding: 10px;">
                                                        <img [attr.src]="subinnernode.image" alt="">
                                                    </div>
                                                 
                                                    <amexio-c-icon *ngIf="subinnernode.icon" key="menubar_ravelry">
                                                    </amexio-c-icon>
                                                    &nbsp;&nbsp;{{subinnernode.text}}{{subinnernode.template}}
                                                </li>
                                            </ul>
                                        </div>
                                    </li>

                                </ul>
                            </div>

                        </span>
                        <ng-container *ngIf="(node.children && !node.children[0].children)">
                            <div class="menu-content" [ngClass]="{'menu-content-display':node.expand}">
                                <ul class="menu-content-cols">
                                    <li class="col-menu-nodes col-menu-nodes-fixed">
                                        <div class="content">
                                            <ul class="menu-content-cols">
                                                <li *ngFor="let subnode of node.children" class="menulinks">
                                                    <div *ngIf="subnode.image" style="padding: 10px;">
                                                        <img [attr.src]="subnode.image" alt="">
                                                    </div>
                                                     <amexio-c-icon *ngIf="subnode.icon" key="menubar_ravelry"></amexio-c-icon>&nbsp;&nbsp;{{subnode.text}}
                                                </li>
                                            </ul>
                                        </div>
                                    </li>
                                </ul>
                            </div>
                        </ng-container>


                    </li>
                </div>

            </ul>
        </div>
    </div>
  `,
                providers: [CommonDataService],
            },] },
];
/** @nocollapse */
AmexioMenuBarComponent.ctorParameters = () => [
    { type: DeviceQueryService },
    { type: CommonDataService }
];
AmexioMenuBarComponent.propDecorators = {
    data: [{ type: Input }],
    label: [{ type: Input }],
    httpurl: [{ type: Input, args: ['http-url',] }],
    httpmethod: [{ type: Input, args: ['http-method',] }],
    datareader: [{ type: Input, args: ['data-reader',] }],
    nodeClick: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*  Created by ketangote on 1/4/18.
*/
class AmexioNavActionComponent {
    constructor() {
        /*
        Events
        name : navLinkClick
        datatype : any
        version : none
        default : none
        description : Fire when nav item is clicked, This event is fired when nav item type is defined as 'link/button/menu'
        
        */
        this.navLinkClick = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onClick(event) {
        /** @type {?} */
        const node = {
        // 'title': this.title,
        // 'type' : this.type,
        // 'icon' : this.icon,
        };
        this.navLinkClick.emit({ node, event });
    }
}
AmexioNavActionComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-nav-action',
                template: `
    <a *ngIf="(type=='link')" [ngStyle]="{'color':color}" class="top-nav-link" style="margin-right:20px"
    (click)="onClick($event)"><i *ngIf="icon" [ngClass]="icon"></i>{{title}}</a>

    <button *ngIf="(type=='button')" [ngStyle]="{'color':color}" class="top-nav-button" style="cursor: pointer" (click)="onClick($event)">
    <i *ngIf="icon" style="padding-right:10px" [ngClass]="icon"></i>{{title}}</button>

    <div  *ngIf="(type=='slider')" style="width: 60px;
    padding-bottom: 20px;" class="top-nav-button">
    <amexio-darkmode [type]="2"  [mode]="'sepia'" [size]="'small'"></amexio-darkmode>
    </div>
    <div  *ngIf="(type=='toggle')" class="top-nav-button">
    <amexio-darkmode [type]="2"  [mode]="'day-night'" [size]="'small'"></amexio-darkmode>
    </div>
    `,
            },] },
];
/** @nocollapse */
AmexioNavActionComponent.ctorParameters = () => [];
AmexioNavActionComponent.propDecorators = {
    type: [{ type: Input }],
    title: [{ type: Input }],
    icon: [{ type: Input }],
    navLinkClick: [{ type: Output }],
    color: [{ type: Input, args: ['color',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AmexioNavDesktopMenuComponent {
    constructor() {
        this.position = 'left';
        this.onNavItemClick = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        setTimeout((/**
         * @return {?}
         */
        () => {
            if (this.menus && this.menus.nativeElement) {
                if ((window.innerWidth - this.menus.nativeElement.getBoundingClientRect().right) < 300) {
                    this.position = 'right';
                }
                else {
                    this.position = 'left';
                }
            }
        }), 100);
    }
    /**
     * @param {?} event
     * @param {?} node
     * @return {?}
     */
    onMouseOver(event, node) {
        if (node.submenus && node.submenus.length > 0) {
            node['showInnerMenus'] = true;
        }
    }
    /**
     * @param {?} event
     * @param {?} node
     * @return {?}
     */
    onMouseLeave(event, node) {
        if (node.submenus && node.submenus.length > 0) {
            node['showInnerMenus'] = false;
        }
        this.nodes.forEach((/**
         * @param {?} innernode
         * @return {?}
         */
        (innernode) => {
            innernode['showInnerMenus'] = false;
        }));
    }
    /**
     * @param {?} _event
     * @param {?} node
     * @return {?}
     */
    onClick(_event, node) {
        this.onNavItemClick.emit({ data: node, event: _event });
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onInnerClick(event) {
        this.onNavItemClick.emit(event);
    }
    /**
     * @return {?}
     */
    onScroll() {
        /** @type {?} */
        const scrollBottom = this.divRef.nativeElement.scrollHeight - this.divRef.nativeElement.clientHeight;
        /** @type {?} */
        const marginTop = 330 - (scrollBottom - this.divRef.nativeElement.scrollTop);
        this.marginTop = '-' + marginTop + 'px';
    }
}
AmexioNavDesktopMenuComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-nav-desktop',
                template: `
      <div #divRef class="scroll-class" (scroll)="onScroll()" [ngClass]="{'navbar-scroll': (nodes &&(nodes.length > 6))}" [ngStyle]="{'height': (nodes &&(nodes.length > 6)) ?'300px':'auto'}">
      <div #menus style="display: flex; flex-direction: column;" *ngFor="let node of nodes">
          <div *ngIf="node.separatorHeader" class="nav-menu-separator">
              <!-- Add only border separator -->
          </div>
          <div *ngIf="node.separatorHeader" class="nav-menu-header">
              {{node.separatorHeader}}
          </div>
          <div class="nav-desktop-link" (click)="onClick($event,node)" (mouseover)="onMouseOver($event, node)"   (mouseleave)="onMouseLeave($event,node)"
              [ngClass]="{'nav-menu-separator': (node.separator && !node.separatorHeader)}">

              <span class="flex-inline" [ngStyle]="{'flex-direction': (position === 'left') ?'row':'row-reverse'}">
                  <em *ngIf="node.icon" [ngClass]="node.icon"></em>
                  <span style="flex-grow: 1; margin: 0px 5px; ">{{node.text}}</span>
                  <i *ngIf="node.submenus" class="fa " aria-hidden="true" [ngClass]="{'fa-angle-right': (position === 'left'), 
                                                   'fa-angle-left':(position === 'right')}"></i>
              </span>

        

              <amexio-nav-desktop  *ngIf="node.showInnerMenus" (onNavItemClick)="onInnerClick($event)"
               class=" amexio-nav-submenus amexio-nav-desktop-submenus"
                [nodes]="node.submenus" 
                [ngStyle]="{'left': (position === 'left') ? '100%':null,
                                                               'right': (position === 'right') ? '100%':null,'margin-top': ((nodes &&(nodes.length > 6)) &&  node.submenus) ? marginTop :'-50px'}">
              </amexio-nav-desktop>

          </div>

      </div>
      </div>
    `,
                styles: [`
      .amexio-nav-desktop{margin-top:-50px}.amexio-nav-desktop>*{cursor:pointer}.scroll-class{overflow-x:hidden;padding:10px}.amexio-nav-submenus{padding:0!important}
    `],
            },] },
];
AmexioNavDesktopMenuComponent.propDecorators = {
    nodes: [{ type: Input, args: ['nodes',] }],
    menus: [{ type: ViewChild, args: ['menus', { read: ElementRef },] }],
    divRef: [{ type: ViewChild, args: ['divRef', { read: ElementRef },] }],
    onNavItemClick: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AmexioNavMobileMenuComponent {
    constructor() {
        this.onNavItemClick = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
    }
    /**
     * @param {?} _event
     * @param {?} node
     * @return {?}
     */
    toggleMenu(_event, node) {
        node['showInnerMenus'] = !node['showInnerMenus'];
        this.onNavItemClick.emit({ data: node, event: _event });
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onInnerClick(event) {
        this.onNavItemClick.emit(event);
    }
}
AmexioNavMobileMenuComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-nav-mobile',
                template: `
      <div #menus style="display: flex; flex-direction: column;" *ngFor="let node of nodes">
          <div *ngIf="node.separatorHeader" class="nav-menu-separator">
              <!-- Add only border separator -->
          </div>
          <div *ngIf="node.separatorHeader" class="nav-menu-header">
              {{node.separatorHeader}}
          </div>
          <div class="nav-mobile-link"  [ngClass]="{'nav-menu-mobile-separator': (node.separator && !node.separatorHeader)}">

              <span class="flex-inline" (click)="toggleMenu($event,node)">
                  <em *ngIf="node.icon" [ngClass]="node.icon"></em>
                  <span style="flex-grow: 1;">{{node.text}}</span>
                  <i *ngIf="node.submenus" class="fa fa-angle-down" aria-hidden="true"></i>
              </span>

        

              <amexio-nav-mobile *ngIf="node.showInnerMenus" (onNavItemClick)="onInnerClick($event)"  class="amexio-nav-mobile amexio-nav-submenus amexio-nav-mobile-submenus" 
              [nodes]="node.submenus" >
              </amexio-nav-mobile>

          </div>

      </div>
    `,
            },] },
];
AmexioNavMobileMenuComponent.propDecorators = {
    nodes: [{ type: Input, args: ['nodes',] }],
    onNavItemClick: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/
/** @type {?} */
const noop$11 = (/**
 * @return {?}
 */
() => {
});
class AmexioNavTextFieldComponent {
    constructor() {
        this.innerValue = '';
        this.onTouchedCallback = noop$11;
        this.onChangeCallback = noop$11;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    // The internal dataviews model
    // Placeholders for the callbacks which are later provided
    // by the Control Value Accessor
    // get accessor
    /**
     * @return {?}
     */
    get value() {
        return this.innerValue;
    }
    // set accessor including call the onchange callback
    /**
     * @param {?} v
     * @return {?}
     */
    set value(v) {
        if (v !== this.innerValue) {
            this.innerValue = v;
            this.onChangeCallback(v);
        }
    }
    // From ControlValueAccessor interface
    /**
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (value !== this.innerValue) {
            this.innerValue = value;
        }
    }
    // From ControlValueAccessor interface
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this.onChangeCallback = fn;
    }
    // From ControlValueAccessor interface
    /**
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this.onTouchedCallback = fn;
    }
}
AmexioNavTextFieldComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-nav-textfield',
                template: `
  <input  [ngStyle]="{'color':color}" type="text" class="top-nav-input-control" [(ngModel)]="value"/>

  `,
                providers: [{
                        provide: NG_VALUE_ACCESSOR, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => AmexioNavTextFieldComponent)), multi: true,
                    }],
                encapsulation: ViewEncapsulation.None,
            },] },
];
/** @nocollapse */
AmexioNavTextFieldComponent.ctorParameters = () => [];
AmexioNavTextFieldComponent.propDecorators = {
    color: [{ type: Input, args: ['color',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by ketangote on 12/18/17.
*/
/** @enum {number} */
const KEY_CODE_notify = {
    esc: 27,
};
KEY_CODE_notify[KEY_CODE_notify.esc] = 'esc';
class AmexioNotificationComponent extends LifeCycleBaseComponent {
    /**
     * @param {?} ref
     */
    constructor(ref) {
        super();
        this.ref = ref;
        /*
         Properties
         name : data
         datatype : any
         version : 4.2 onwards
         default : none
         description :  what you want to display on notification window by using data.
         */
        this.messageData = [];
        /*
        Properties
        name : closable
        datatype : boolean
        version : 4.0 onwards
        default : false
        description : User can close the window.
        */
        this.closable = true;
        this.notificationVertialCss = 'notification-vertical-';
        this.notificationHorizontalCss = ' notification-horizontal-';
    }
    // Escape Key Functionality
    /**
     * @param {?} event
     * @return {?}
     */
    keyEvent(event) {
        if (this.closeonescape === true) {
            this.messageData.length = 0;
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.componentID = Math.floor(window.crypto.getRandomValues(new Uint32Array(1))[0]);
        if (this.autodismissmsg) {
            if (!this.autodismissmsginterval) {
                this.autodismissmsginterval = 1500;
            }
            if (this.messageData !== null) {
                setInterval((/**
                 * @return {?}
                 */
                () => {
                    if (this.messageData && this.messageData.length > 0) {
                        this.messageData.shift();
                        this.ref.markForCheck();
                    }
                }), this.autodismissmsginterval);
            }
        }
        if (this.verticalposition === null) {
            this.verticalposition = 'top';
        }
        else if (this.horizontalposition === null) {
            this.horizontalposition = 'right';
        }
        this.positionclass = this.notificationVertialCss + this.verticalposition + this.notificationHorizontalCss + this.horizontalposition;
    }
    /**
     * @param {?} msg
     * @return {?}
     */
    closeNotification(msg) {
        /** @type {?} */
        const count = this.messageData.length;
        for (let i = 0; i < count; i++) {
            if (this.messageData[i] === msg) {
                this.messageData.splice(msg, 1);
            }
        }
    }
}
AmexioNotificationComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-notification', template: `
    <div class="notification-content {{roundedgeclass}}" [ngClass]="positionclass">

        <ng-container *ngIf="!notificationTemplate">
            <div id="{{componentID}}" role="alert" [attr.aria-label]="'notification is'+ messageData" class="notification" *ngFor="let msg of messageData"
                [style.color]="foregroundColor" [style.background-color]="backgroundColor">
                <span class="float-right" (click)="closeNotification(msg)">
                    <ng-container *ngIf="closable">
                        <amexio-c-icon style="cursor: pointer" key="notify_close"></amexio-c-icon>
                    </ng-container>
                </span>

                <table aria-describedby="table">
                    <ng-container *ngIf="icon">
                        <th scope="col">
                            <amexio-c-icon style=" padding-right: 18px;" [ngClass]="icon">
                            </amexio-c-icon>
                        </th>
                    </ng-container>

                    <th scope="col" style=" text-align: left;">

                        <span>{{msg}}</span>&nbsp;&nbsp;&nbsp;&nbsp;
                    </th>

                </table>

            </div>
        </ng-container>

        <ng-container *ngIf="notificationTemplate">
            <div id="{{componentID}}" role="alert" [attr.aria-label]="'notification is'+ messageData" class="notification" *ngFor="let msg of messageData"
                [style.color]="foregroundColor" [style.background-color]="backgroundColor">

                <span class="float-right" (click)="closeNotification(msg)">
                    <ng-container *ngIf="closable">
                        <amexio-c-icon style="cursor: pointer" key="notify_close"></amexio-c-icon>
                    </ng-container>
                </span>

                <table aria-describedby="table">
                    <ng-container *ngIf="icon">
                        <th scope="col">
                            <amexio-c-icon style=" padding-right: 18px;" [ngClass]="icon">
                            </amexio-c-icon>
                        </th>
                    </ng-container>
                    <th scope="col" style=" text-align: left;">
                        <ng-template [ngTemplateOutlet]="notificationTemplate" [ngTemplateOutletContext]="{data:msg}">
                        </ng-template>
                    </th>
                </table>
            </div>
        </ng-container>
    </div>
  `,
            },] },
];
/** @nocollapse */
AmexioNotificationComponent.ctorParameters = () => [
    { type: ChangeDetectorRef }
];
AmexioNotificationComponent.propDecorators = {
    messageData: [{ type: Input, args: ['data',] }],
    icon: [{ type: Input, args: ['icon',] }],
    closable: [{ type: Input }],
    verticalposition: [{ type: Input, args: ['vertical-position',] }],
    horizontalposition: [{ type: Input, args: ['horizontal-position',] }],
    autodismissmsg: [{ type: Input, args: ['auto-dismiss-msg',] }],
    autodismissmsginterval: [{ type: Input, args: ['auto-dismiss-msg-interval',] }],
    closeonescape: [{ type: Input, args: ['close-on-escape',] }],
    backgroundColor: [{ type: Input, args: ['background-color',] }],
    foregroundColor: [{ type: Input, args: ['foreground-color',] }],
    notificationTemplate: [{ type: ContentChild, args: ['amexioNotificationTemp',] }],
    keyEvent: [{ type: HostListener, args: ['window:keyup.esc', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/
class AmexioSideNavInnerNodeComponent {
    constructor() {
        this.onClick = new EventEmitter();
        this.onDrag = new EventEmitter();
        this.emitNode = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @param {?} node
     * @return {?}
     */
    onNodeClick(node) {
        node.expand = !node.expand;
        if (node.children && node.expand === false) {
            node.children.forEach((/**
             * @param {?} element
             * @return {?}
             */
            (element) => {
                element['tabindex'] = '-1';
            }));
        }
        else if (node.children && node.expand === true) {
            node.children.forEach((/**
             * @param {?} element
             * @return {?}
             */
            (element) => {
                element['tabindex'] = '1';
            }));
        }
        this.getOnClick(node);
        this.emitNode.emit(this.data);
    }
    /**
     * @param {?} event
     * @param {?} node
     * @return {?}
     */
    onenterNodeClick(event, node) {
        event.stopImmediatePropagation();
        node.expand = !node.expand;
        if (node.children && node.expand === true) {
            node.children.forEach((/**
             * @param {?} element
             * @param {?} index
             * @return {?}
             */
            (element, index) => {
                element['tabindex'] = '1';
            }));
        }
        this.getOnClick(node);
        this.emitNode.emit(this.data);
    }
    /**
     * @param {?} node
     * @return {?}
     */
    getOnClick(node) {
        this.onClick.emit(node);
        this.activateNode(this.data, node);
    }
    /**
     * @param {?} data
     * @param {?} node
     * @return {?}
     */
    activateNode(data, node) {
        for (const i of data) {
            if (node === i && !i[this.childarraykey]) {
                i['active'] = true;
            }
            else {
                i['active'] = false;
            }
            if (i[this.childarraykey]) {
                this.activateNode(i[this.childarraykey], node);
            }
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    dragStartEvent(event) {
        if (this.enabledrag) {
            event.event.dataTransfer.setData('dragData', JSON.stringify(event.data));
            this.onDrag.emit(event);
        }
    }
}
AmexioSideNavInnerNodeComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-sidenav-innernode',
                template: `
    <ul>
        <li role="option" *ngFor="let node of data">
            <div [attr.tabindex]="node.tabindex" (keyup.enter)="onenterNodeClick($event,node)" [attr.draggable]="enabledrag"
                (dragstart)="dragStartEvent({event:$event,data:node})" class="defaultnode" [ngClass]="{'activenode':node.active}"
                (click)="onNodeClick(node)">

                <span *ngIf="node.icon" class="sideInnerNodeCss">
                    <amexio-c-icon class="node-icon" [customclass]="node.icon" [color]="node.iconcolor"></amexio-c-icon>
                    <span  class="sideInnerNodeFlex">{{node[displaykey]}}
                        <ng-container *ngIf="node.badge">
                            <span class="nav-badge">{{node.badge}}</span>
                        </ng-container>
                    </span>

                <ng-container *ngIf="node[childarraykey] && (node[childarraykey].length>0)">
                    <span style="padding-right: 10px; float: right" *ngIf="node.expand">
                        <amexio-c-icon key="sidenav-angle-up"></amexio-c-icon>
                    </span>
                    <span style="padding-right: 10px;float: right;" *ngIf="!node.expand">
                        <amexio-c-icon key="sidenav-angle-down"></amexio-c-icon>
                    </span>
                </ng-container>
                </span>


                <span *ngIf="!node.icon" class="sideInnerNodeCss">
                    <amexio-c-icon class="node-icon" [customclass]="node.icon" [color]="node.iconcolor"></amexio-c-icon>
                    <span class="sideInnerNodeFlex">{{node[displaykey]}}
                        <ng-container *ngIf="node.badge">
                            <span class="nav-badge">{{node.badge}}</span>
                        </ng-container>
                    </span>

                <ng-container *ngIf="node[childarraykey] && (node[childarraykey].length>0)">
                    <span style="padding-right: 10px; float: right" *ngIf="node.expand">
                        <amexio-c-icon key="sidenav-angle-up"></amexio-c-icon>
                    </span>
                    <span style="padding-right: 10px;float: right;" *ngIf="!node.expand">
                        <amexio-c-icon key="sidenav-angle-down"></amexio-c-icon>
                    </span>
                </ng-container>
                </span>



            </div>
            <div class="submenu-details" [ngClass]="{'sidenav-submenu-expanded':node.expand}">
                <amexio-sidenav-innernode *ngIf="node[childarraykey] && (node[childarraykey].length>0)" [enable-drag]="enabledrag"
                    (onDrag)="dragStartEvent($event)" [display-key]="displaykey" [child-array-key]="childarraykey" [data]="node[childarraykey]"
                    (onDrag)="dragStartEvent($event)" (onClick)="getOnClick($event)">
                </amexio-sidenav-innernode>
            </div>
        </li>
    </ul>
  `,
            },] },
];
AmexioSideNavInnerNodeComponent.propDecorators = {
    displaykey: [{ type: Input, args: ['display-key',] }],
    icon: [{ type: Input, args: ['icon',] }],
    childarraykey: [{ type: Input, args: ['child-array-key',] }],
    data: [{ type: Input, args: ['data',] }],
    onClick: [{ type: Output }],
    enabledrag: [{ type: Input, args: ['enable-drag',] }],
    onDrag: [{ type: Output }],
    emitNode: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AmexioTaskbarItemComponent {
    constructor() {
        this.widthOfItem = 100;
        this.heightOfItem = 200;
        this.relativePosition = false;
        this.close = false;
        this.displayFlag = false;
        this.iconClose = false;
        this.onCloseEvent = new EventEmitter();
        this.displayFlag = true;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @return {?}
     */
    taskbarItemClick() {
        this.displayFlag = !this.displayFlag;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    iconClick(event) {
        if (this.close) {
            this.iconClose = true;
            this.displayFlag = false;
            if (event) {
                this.taskbarItemId.nativeElement.parentNode.remove();
            }
        }
        this.onCloseEvent.emit(this.taskbarItemId);
    }
}
AmexioTaskbarItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-task-bar-item',
                template: `
    <div #taskbarItemId>

      <div *ngIf="!iconClose">
        <amexio-button  *ngIf="close" 
          [label]="title"
          [type]="'theme-color'"
          [closable-icon]="true"
          (onIconClick)="iconClick(taskbarItemId)"
          (onClick)="taskbarItemClick()">
      </amexio-button>
      <amexio-button  *ngIf="!close"
          [label]="title"
          [type]="'theme-color'"
          (onClick)="taskbarItemClick()">
      </amexio-button>
  
      </div>
  
      <ng-container *ngIf="displayFlag">
        <div [ngStyle]="{'width.px': relativePosition ? widthOfItem: ''}" 
        (onClick)="taskbarItemClick()"
          [ngClass]="{'taskbar-item-display-relative': relativePosition , 'taskbar-item-display-fixed': !relativePosition }">
          <amexio-panel [ngStyle]="{'width.px': !relativePosition ? widthOfItem: ''}" 
          amexioColorPalette
            (onClick)="taskbarItemClick()" 
            [title]="title" [color-palette]="'vibrant'" 
            [gradient]="true" [border]="true"
            [height]="heightOfItem" [header]="true"
             [expanded]="false">
             <amexio-panel-header>
              <amexio-image 
              style="margin-top : auto;" 
              [icon-class]="taskbarIcon"
              [tooltip]="'Information'">
              </amexio-image>
          </amexio-panel-header>
            <ng-content></ng-content>
          </amexio-panel>
        </div>
      </ng-container>
  
      </div>
  `,
            },] },
];
/** @nocollapse */
AmexioTaskbarItemComponent.ctorParameters = () => [];
AmexioTaskbarItemComponent.propDecorators = {
    title: [{ type: Input, args: ['title',] }],
    widthOfItem: [{ type: Input, args: ['width',] }],
    heightOfItem: [{ type: Input, args: ['height',] }],
    relativePosition: [{ type: Input, args: ['relative',] }],
    close: [{ type: Input, args: ['close',] }],
    taskbarIcon: [{ type: Input, args: ['taskbar-Icon',] }],
    taskbarItemId: [{ type: ViewChild, args: ['taskbarItemId',] }],
    onCloseEvent: [{ type: Output, args: ['onCloseEvent',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AmexioTaskbarComponent {
    constructor() {
        this.align = 'left';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
}
AmexioTaskbarComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-task-bar',
                template: `

    <div class="taskbar" [style.justify-content]="align">

      <ng-content></ng-content>
  
    </div>
  `,
            },] },
];
/** @nocollapse */
AmexioTaskbarComponent.ctorParameters = () => [];
AmexioTaskbarComponent.propDecorators = {
    align: [{ type: Input, args: ['align',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Created by pratik on 27/11/17.
 */
/** @type {?} */
const NAV_COMPONENTS = [
    AmexioSideNavComponent,
    SideNavNodeComponent,
    AmexioNavBarComponent,
    AmexioNavItemComponent,
    AmexioNotificationComponent,
    AmexioNavActionComponent,
    AmexioNavTextFieldComponent,
    AmexioNavMenuComponent,
    AmexioNavDesktopMenuComponent,
    AmexioNavMobileMenuComponent,
    AmexioNavItemComponent,
    DockbarComponent,
    DockedBarToolComponent,
    AmexioMenuBarComponent,
    AmexioBreadcrumbComponent,
    AmexioSideNavInnerNodeComponent,
    AmexioBannerComponent,
    AmexioTaskbarComponent,
    AmexioTaskbarItemComponent,
];
class AmexioNavModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: AmexioNavModule,
            providers: [CommonDataService, DeviceQueryService],
        };
    }
}
AmexioNavModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    FormsModule,
                    AmexioMediaModule,
                    AmexioLayoutModule,
                    AmexioFormsModule,
                    AmexioPaneModule,
                    HttpClientModule,
                    AmexioCommonModule.forRoot(),
                ],
                exports: NAV_COMPONENTS,
                declarations: NAV_COMPONENTS,
                providers: [CommonDataService, DeviceQueryService],
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 * Copyright [2019] [Metamagic]
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Created by Ashwini Agre on 06/03/19.
 */
class AmexioWindowCEComponent extends LifeCycleBaseComponent {
    /**
     * @param {?} injector
     * @param {?} componentFactoryResolver
     * @param {?} appRef
     * @param {?} renderer
     * @param {?} miniService
     */
    constructor(injector, componentFactoryResolver, appRef, renderer, miniService) {
        super();
        this.injector = injector;
        this.componentFactoryResolver = componentFactoryResolver;
        this.appRef = appRef;
        this.renderer = renderer;
        this.miniService = miniService;
        this.maximizeflagchanged = true;
        this.verticalposition = 'center';
        this.closeonescape = true;
        this.showChange = new EventEmitter();
        this.maximize = false;
        this.minimize = false;
        this.closable = true;
        this.width = '90%';
        this.windowModel = true;
        this.close = new EventEmitter();
        this.amexioComponentId = 'ce-amexio-window' + window.crypto.getRandomValues(new Uint32Array(1))[0];
        this.x = 0;
        this.y = 0;
        this.px = 0;
        this.py = 0;
        this.minArea = 20000;
        this.draggingWindow = false;
        this.transitionOptions = '400ms cubic-bezier(0.86, 0, 0.07, 1)';
    }
    /**
     * @return {?}
     */
    onCloseClick() {
        if (this.closable) {
            this.showWindow = false;
            this.show = false;
            this.showChange.emit(false);
            this.close.emit(this.showWindow);
            if (this.windowposition) {
                this.x = 0;
                this.y = 0;
            }
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.appendComponentToBody(CeMinimizeWindowComponent);
        if (!this.color) {
            this.cclass = 'card-container-ce-color';
        }
        if (!this.background) {
            this.cclass = this.cclass + ' card-container-ce-bg-color';
        }
        this.setVerticlePosition();
        this.setHorizontalPosition();
        if (this.maximize) {
            this.dummyWidth = this.width;
            this.isFullWindow = true;
            this.maximumWindowStyle = this.setMaximizeClass(this.isFullWindow);
        }
        if (this.showWindow) {
            this.show = this.showWindow;
        }
        this.globalDragListenFunc = this.renderer.listen('document', 'mouseup', (/**
         * @param {?} e
         * @return {?}
         */
        (e) => {
            this.draggingWindow = false;
        }));
        super.ngOnInit();
    }
    /**
     * @param {?} component
     * @return {?}
     */
    appendComponentToBody(component) {
        // 1. Create a component reference from the component
        this.componentRef = this.componentFactoryResolver
            .resolveComponentFactory(CeMinimizeWindowComponent)
            .create(this.injector);
        // 2. Attach component to the appRef so that it's inside the ng component tree
        this.appRef.attachView(this.componentRef.hostView);
        // 3. Get DOM element from component
        /** @type {?} */
        const domElem = (/** @type {?} */ (((/** @type {?} */ (this.componentRef.hostView)))
            .rootNodes[0]));
        /** @type {?} */
        const element1 = document.getElementById('minimizeId');
        if (element1) {
            element1.parentNode.removeChild(element1);
        }
        // 4. Append DOM element to the body
        domElem.setAttribute('id', 'minimizeId');
        document.body.appendChild(domElem);
        // 5. Wait some time and remove it from the component tree and from the DOM
        // setTimeout(() => {
        //     this.appRef.detachView(componentRef.hostView);
        //     componentRef.destroy();
        // }, 3000);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onWindowPress(event) {
        if (this.draggable) {
            this.draggingWindow = true;
            this.px = event.clientX;
            this.py = event.clientY;
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onWindowDrag(event) {
        if (this.draggable) {
            if (!this.draggingWindow) {
                return;
            }
            /** @type {?} */
            const offsetX = event.clientX - this.px;
            /** @type {?} */
            const offsetY = event.clientY - this.py;
            this.x += offsetX;
            this.y += offsetY;
            this.px = event.clientX;
            this.py = event.clientY;
        }
    }
    /**
     * @param {?} isFullWindow
     * @return {?}
     */
    setMaximizeClass(isFullWindow) {
        this.isFullWindow = isFullWindow;
        if (isFullWindow) {
            this.width = '100%';
            return {
                'margin-top': '0', 'height': '100%',
            };
        }
        else {
            this.width = this.dummyWidth;
            return {
                'margin-top': '1%', 'height': '96%',
            };
        }
    }
    /**
     * @return {?}
     */
    setVerticlePosition() {
        switch (this.verticalposition) {
            case 'top': {
                this.verticalposition = 'flex-start';
                break;
            }
            case 'center': {
                this.verticalposition = 'center';
                break;
            }
            case 'bottom': {
                this.verticalposition = 'flex-end';
                break;
            }
            default: {
                this.verticalposition = 'center';
                break;
            }
        }
    }
    /**
     * @return {?}
     */
    setHorizontalPosition() {
        switch (this.horizontalposition) {
            case 'left': {
                this.horizontalposition = 'flex-start';
                break;
            }
            case 'center': {
                this.horizontalposition = 'center';
                break;
            }
            case 'right': {
                this.horizontalposition = 'flex-end';
                break;
            }
            default: {
                this.horizontalposition = 'center';
                break;
            }
        }
    }
    /* ASSIGN PROPERTIES TO FOOTER AND HEADER*/
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (this.amexioHeader && this.amexioHeader.toArray().length > 0) {
            if (this.minimize) {
                this.amexioHeader.toArray()[0].minimize = this.minimize;
                this.amexioHeader.toArray()[0].minimizeWindow.subscribe((/**
                 * @param {?} event
                 * @return {?}
                 */
                (event) => {
                    this.textName = event.textName;
                    this.miniService.onMinimizeClick(this);
                }));
                this.amexioHeader.toArray()[0].closeDataEmit.subscribe((/**
                 * @param {?} event
                 * @return {?}
                 */
                (event) => {
                    this.miniService.onCloseClick(this);
                }));
            }
            if (this.maximize) {
                this.amexioHeader.toArray()[0].maximize = this.maximize;
                this.amexioHeader.toArray()[0].maximizeWindow.subscribe((/**
                 * @param {?} event
                 * @return {?}
                 */
                (event) => {
                    this.maximizeflagchanged = event.isFullWindowCe;
                }));
            }
            setTimeout((/**
             * @return {?}
             */
            () => {
                this.amexioHeader.toArray()[0].amexioComponentId = 'amexio-window';
                this.amexioHeader.toArray()[0].closeable = this.closable;
                this.amexioHeader.toArray()[0].windowFlag = true;
            }), 1000);
            if (this.maximize) {
                this.amexioHeader.toArray()[0].setMaximizeDataCE(this.maximize, this.isFullWindow);
                this.amexioHeader.toArray()[0].maximizeBehaiourCe.subscribe((/**
                 * @param {?} max
                 * @return {?}
                 */
                (max) => {
                    this.maximumWindowStyle = this.setMaximizeClass(max);
                }));
            }
            this.amexioHeader.toArray()[0].closeableBehaiour.subscribe((/**
             * @param {?} close
             * @return {?}
             */
            (close) => {
                this.onCloseClick();
            }));
        }
        this.setCardAligementForAllInnerComponent();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes['show']) {
            this.setShowFlag(changes.show.currentValue);
        }
        if (changes['showWindow']) {
            this.setShowFlag(changes.showWindow.currentValue);
        }
    }
    /**
     * @param {?} changedValue
     * @return {?}
     */
    setShowFlag(changedValue) {
        this.show = changedValue;
        if (this.closeonescape) {
            this.globalListenFunc = this.renderer.listen('document', 'keyup.esc', (/**
             * @param {?} e
             * @return {?}
             */
            (e) => {
                this.showWindow = false;
                this.show = false;
                this.showChange.emit(false);
                this.close.emit(this.showWindow);
            }));
        }
        else if (this.globalListenFunc) {
            this.globalListenFunc();
        }
    }
    /**
     * @param {?} elementRef
     * @return {?}
     */
    getListPosition(elementRef) {
        /** @type {?} */
        const height = 240;
        if ((window.screen.height - elementRef.getBoundingClientRect().bottom) < height) {
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        super.ngAfterViewInit();
    }
    // TO SET ALIGN TO ALL INNER COMPONENT IN CARD
    /**
     * @return {?}
     */
    setCardAligementForAllInnerComponent() {
        this.amexioCardHeaderList = this.amexioHeader.toArray();
        if (this.amexioCardHeaderList[0] !== undefined && !this.amexioCardHeaderList[0].align &&
            this.amexioCardHeaderList[0].align.length > 0) {
            this.amexioCardHeaderList[0].align = this.align;
        }
        this.amexioCardBodyList = this.amexioBody.toArray();
        if (this.amexioCardBodyList[0] !== undefined && !this.amexioCardBodyList[0].align && this.amexioCardBodyList[0].align.length > 0) {
            this.amexioCardBodyList[0].align = this.align;
        }
        this.amexioCardActionList = this.amexioFooter.toArray();
        if (this.amexioCardActionList[0] !== undefined && !this.amexioCardActionList[0].align &&
            this.amexioCardActionList[0].align.length > 0) {
            this.amexioCardActionList[0].align = this.align;
        }
        else if (this.amexioCardActionList[0] !== undefined &&
            this.amexioCardActionList[0].align === '') {
            this.amexioCardActionList[0].align = 'end';
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        super.ngOnDestroy();
        if (this.globalDragListenFunc) {
            this.globalDragListenFunc();
        }
    }
}
AmexioWindowCEComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-window-ce',
                template: `
    <div *ngIf="show" 
    [ngClass]="{'amexio-root-window-ce': windowModel, 'amexio-root-window-ce-windowModel': !windowModel}"
 
    class="{{roundedgeclass}}"
     [style.justify-content]="horizontalposition">

      <div  

      [ngClass]="{'content-max-height': (maximize && isFullWindow), 'amexio-root-window-content-ce': windowModel, 'amexio-root-window-content-ce-windowModel': !windowModel}"
  
      (mousedown)='onWindowPress($event)' (mousemove)='onWindowDrag($event)'

        [@animation]="{value: 'visible', params: {transitionParams: transitionOptions}}" [style.width]="width"
        [style.height]="height" [style.top.px]='y' [style.left.px]='x' [style.justify-content]="verticalposition"
        [ngStyle]="maximumWindowStyle" >
    
    
        <div
          [ngStyle]="{'background': bgimage ? 'url(' + bgimage + ') center/cover no-repeat' : null,'resize': resizable ? 'both':'','overflow':resizable ?'auto':'', 'height':(maximize && maximizeflagchanged) ? '100%' :'' }"
          [ngClass]="cclass">
          <div
            [ngStyle]="{'justify-content': (align === 'start' || align === 'end') ? 'flex-'+align:align , 'color':color, 'background': background, 'cursor': draggable ? 'all-scroll':''}">
            <ng-content></ng-content>
          </div>
        </div>
      </div>
    </div>
  `,
                animations: [
                    trigger('animation', [
                        state('void', style({
                            transform: 'translate3d(0, 25%, 0) scale(0.9)',
                            opacity: 0,
                        })),
                        state('visible', style({
                            transform: 'none',
                            opacity: 1,
                        })),
                        transition('* => *', animate('400ms cubic-bezier(0.25, 0.8, 0.25, 1)')),
                    ]),
                ],
            },] },
];
/** @nocollapse */
AmexioWindowCEComponent.ctorParameters = () => [
    { type: Injector },
    { type: ComponentFactoryResolver },
    { type: ApplicationRef },
    { type: Renderer2 },
    { type: MinimizeService }
];
AmexioWindowCEComponent.propDecorators = {
    bgimage: [{ type: Input, args: ['bg-image',] }],
    color: [{ type: Input, args: ['color',] }],
    background: [{ type: Input, args: ['background',] }],
    height: [{ type: Input, args: ['height',] }],
    align: [{ type: Input, args: ['align',] }],
    verticalposition: [{ type: Input, args: ['vertical-position',] }],
    horizontalposition: [{ type: Input, args: ['horizontal-position',] }],
    closeonescape: [{ type: Input, args: ['close-on-escape',] }],
    top: [{ type: Input, args: ['position-top',] }],
    showWindow: [{ type: Input, args: ['show-window',] }],
    show: [{ type: Input }],
    showChange: [{ type: Output }],
    maximize: [{ type: Input }],
    minimize: [{ type: Input }],
    closable: [{ type: Input }],
    width: [{ type: Input, args: ['width',] }],
    windowModel: [{ type: Input, args: ['window-model',] }],
    amexioHeader: [{ type: ContentChildren, args: [AmexioCardCEHeaderComponent,] }],
    amexioFooter: [{ type: ContentChildren, args: [AmexioCardCEActionComponent,] }],
    amexioBody: [{ type: ContentChildren, args: [AmexioCardCEBodyComponent,] }],
    close: [{ type: Output }],
    draggable: [{ type: Input }],
    resizable: [{ type: Input }],
    windowposition: [{ type: Input, args: ['remember-window-position',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*  Created by sagar on 4/02/2019.
*/
/** @type {?} */
const CREATIVE_COMPONENTS = [
    AmexioCardCEHeaderComponent,
    AmexioCardCEBodyComponent,
    AmexioCardCEActionComponent,
    AmexioCardCEComponent,
    AmexioFormActionCEComponent,
    AmexioFormCEComponent,
    AmexioProgressCEComponent,
    AmexioHomePageComponent,
    AmexioHomePageCenterPanelComponent,
    AmexioHomePageEastPanelComponent,
    AmexioHomePageNorthPanelComponent,
    AmexioHomePageWestPanelComponent,
    AmexioWindowCEComponent,
    CeMinimizeWindowComponent,
    ColorPickerComponent,
    ColorPaletteComponent,
    ColorsliderComponent,
    ViewportComponent,
    ViewportBackgroundComponent,
    ViewportContentComponent,
    ViewportContentBodyComponent,
    AmexioCarouselCEComponent,
    AmexioMenuCEComponent,
];
class AmexioCreativeModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: AmexioCreativeModule,
            providers: [IconLoaderService],
        };
    }
}
AmexioCreativeModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    FormsModule,
                    ReactiveFormsModule,
                    AmexioFormsModule,
                    AmexioNavModule,
                    AmexioLayoutModule,
                    AmexioPaneModule,
                    AmexioMediaModule,
                    AmexioCommonModule.forRoot(),
                ],
                exports: CREATIVE_COMPONENTS,
                declarations: CREATIVE_COMPONENTS,
                entryComponents: [CeMinimizeWindowComponent],
                providers: [IconLoaderService],
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AmexioVirtualScrollerComponent {
    /**
     * @param {?} renderer
     */
    constructor(renderer) {
        this.renderer = renderer;
        this.windowScroll = true;
        this.onScrollDown = new EventEmitter();
        this.currentViewData = [];
        this.isOverloaded = false;
        this.show = true;
        this.newheight = '100%';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        setTimeout((/**
         * @return {?}
         */
        () => {
            this.pageAndTotalCountCal();
            this.initLoad();
            this.bindDocumentClickListener();
        }), 500);
    }
    // TO CALCULATE PAGE AND TOTAL SIZE
    /**
     * @private
     * @return {?}
     */
    pageAndTotalCountCal() {
        /** @type {?} */
        const el = this.virtualscoller.nativeElement;
        this.height = this.windowScroll ? el.clientHeight : this.height;
        if (this.height === 0) {
            this.height = 450;
        }
        if (this.data && this.height && this.itemSize && this.data.length > 0) {
            this.totalCount = this.data.length;
            this.pageSize = Math.round(this.height / this.itemSize);
        }
        this.newheight = this.height + ' px';
    }
    // TO INIT LOAD DATA
    /**
     * @private
     * @return {?}
     */
    initLoad() {
        if (this.currentViewData && this.currentViewData.length === 0) {
            for (let i = 0; i < this.pageSize; i++) {
                if (this.data && i < this.totalCount) {
                    this.currentViewData.push(this.data[i]);
                }
            }
        }
    }
    // ON SCROLL HANDLE
    /**
     * @param {?} event
     * @return {?}
     */
    handleDivScrollListener(event) {
        if (!this.windowScroll) {
            /** @type {?} */
            const scroller = this.virtualscoller.nativeElement;
            /** @type {?} */
            const height = scroller.clientHeight;
            /** @type {?} */
            const scrollHeight = scroller.scrollHeight - height;
            /** @type {?} */
            const scrollTop = scroller.scrollTop;
            /** @type {?} */
            const percent = Math.floor((scrollTop / scrollHeight) * 100);
            this.isOverloaded = false;
            this.loadNewData(percent);
        }
    }
    //  TO LAOD NEW DATA ONCE SCROLL IS 80 to 90 %
    // tslint:disable-next-line:cognitive-complexity
    /**
     * @private
     * @param {?} percent
     * @return {?}
     */
    loadNewData(percent) {
        if (percent >= 80 && percent <= 100) {
            this.isOverloaded = true;
            // EMIT EVENT WHEN TOTAL RECORDS ARE SHOWN
            if (this.currentViewData.length === this.totalCount - 1) {
                this.onScrollDown.emit();
            }
        }
        if (this.isOverloaded &&
            this.currentViewData &&
            this.currentViewData.length > 0 &&
            (this.currentViewData.length + this.pageSize) <= this.totalCount) {
            /** @type {?} */
            const currentViewDataLength = this.currentViewData.length;
            /** @type {?} */
            const currentPageSize = currentViewDataLength + this.pageSize;
            for (let i = currentViewDataLength; i < currentPageSize; i++) {
                if (i <= this.totalCount) {
                    this.currentViewData.push(this.data[i]);
                }
            }
        }
        if ((this.totalCount - this.currentViewData.length) < this.pageSize) {
            for (let i = this.currentViewData.length; i < this.totalCount; i++) {
                if (i <= this.totalCount) {
                    this.currentViewData.push(this.data[i]);
                }
            }
        }
    }
    // TO ADD DYAMIC NEW RECORDS
    /**
     * @param {?} newData
     * @return {?}
     */
    addData(newData) {
        if (newData && newData.length > 0) {
            newData.forEach((/**
             * @param {?} record
             * @return {?}
             */
            (record) => {
                this.data.push(record);
            }));
        }
    }
    // Listener FOR WINDOW
    /**
     * @return {?}
     */
    bindDocumentClickListener() {
        if (this.windowScroll) {
            this.windowscrolllistener = this.renderer
                .listen('window', 'scroll', (/**
             * @param {?} event
             * @return {?}
             */
            (event) => this.handleDocumentListener(event)));
        }
    }
    // UNBIND DOCUMENT
    /**
     * @return {?}
     */
    unbindDocumentClickListener() {
        if (this.windowscrolllistener) {
            this.bindDocumentClickListener();
            this.windowscrolllistener = null;
        }
    }
    //  TO HANDEL DOCUMENT LISTNER
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    handleDocumentListener(event) {
        if (this.windowScroll) {
            /** @type {?} */
            const percent = Math.floor(this.getScrollPercent());
            this.isOverloaded = false;
            this.loadNewData(percent);
        }
    }
    // GET WINDOW GET SCROLLER PERCENTAGE
    /**
     * @private
     * @return {?}
     */
    getScrollPercent() {
        // tslint:disable-next-line:one-variable-per-declaration
        /** @type {?} */
        const h = document.documentElement;
        /** @type {?} */
        const b = document.body;
        /** @type {?} */
        const st = 'scrollTop';
        /** @type {?} */
        const sh = 'scrollHeight';
        return (h[st] || b[st]) / ((h[sh] || b[sh]) - h.clientHeight) * 100;
    }
    // TO DESTROY
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.unbindDocumentClickListener();
    }
}
AmexioVirtualScrollerComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-virtual-scroller',
                template: `
   <div #virtualscoller id="scroll-content" [ngStyle]="{'height':newheight, 'overflow-y': !windowScroll ? 'scroll' : 'none' }" (scroll)="handleDivScrollListener($event)">
       <div *ngFor="let row of currentViewData" [ngStyle]="{ 'min-height': itemSize + 'px' }">
           <ng-template *ngIf="bodyTemplate" [ngTemplateOutlet]="bodyTemplate" [ngTemplateOutletContext]="{ row: row }">
           </ng-template>
       </div>
   </div>
 `,
            },] },
];
/** @nocollapse */
AmexioVirtualScrollerComponent.ctorParameters = () => [
    { type: Renderer2 }
];
AmexioVirtualScrollerComponent.propDecorators = {
    height: [{ type: Input, args: ['height',] }],
    data: [{ type: Input, args: ['data',] }],
    itemSize: [{ type: Input, args: ['item-size',] }],
    windowScroll: [{ type: Input, args: ['window-scroll',] }],
    onScrollDown: [{ type: Output }],
    bodyTemplate: [{ type: ContentChild, args: ['amexioBodyTmpl',] }],
    virtualscoller: [{ type: ViewChild, args: ['virtualscoller',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Created by pratik on 10/1/18.
 */
/*
 * Copyright 2016-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Author - Ketan Gote, Pratik Kelwalkar, Dattaram Gawas, Rashmi Thakkar
 *
 */
/*
Component Name : Amexio data grid
Component Selector : <amexio-data-table-column>
Component Description : Data grid component to render large
amount of data-set with various options like sorting in ascending or descending order,
client-side pagination, column hide/unhide, single/multi selection, user define template
for rendering for column header and column data, displaying summation of numeric column.
*/
class AmexioGridColumnComponent {
    constructor() {
        /*
           Properties
           name : sort
           datatype : boolean
           version : 4.2.6 onwards
           default : true
           description : Set column Sortable.
           */
        this.sort = true;
        /*
        Properties
        name : hidden
        datatype : boolean
        version : 4.0 onwards
        default : none
        description : Hide column
        */
        this.hidden = false;
    }
}
AmexioGridColumnComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-data-table-column', template: ``,
            },] },
];
AmexioGridColumnComponent.propDecorators = {
    text: [{ type: Input }],
    sort: [{ type: Input }],
    dataindex: [{ type: Input, args: ['data-index',] }],
    hidden: [{ type: Input }],
    datatype: [{ type: Input, args: ['data-type',] }],
    contextmenu: [{ type: Input, args: ['context-menu',] }],
    summarytype: [{ type: Input, args: ['summary-type',] }],
    summarycaption: [{ type: Input, args: ['summary-caption',] }],
    width: [{ type: Input }],
    headerTemplate: [{ type: ContentChild, args: ['amexioHeaderTmpl',] }],
    bodyTemplate: [{ type: ContentChild, args: ['amexioBodyTmpl',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by Pratik on 2/01/18.
*/
/*
Component Name : Amexio data grid filter
Component Selector : <data-grid-filter>
Component Description : Data grid component to render large amount of
data-set with various options like sorting in ascending or descending order,
client-side pagination, column hide/unhide, single/multi selection,Filtering
(enable only for string and number type data) user define template for rendering
for column header and column data, displaying summation of numeric column.
*/
class DataGridFilterComponent {
    /**
     * @param {?} dataTableService
     * @param {?} renderer
     */
    constructor(dataTableService, renderer) {
        this.dataTableService = dataTableService;
        this.renderer = renderer;
        /*
          for internal use
          */
        this.filterObject = new EventEmitter();
        this.onFilterClick = new EventEmitter();
        this.showToolTip = false;
        this.checkIcon = 'fa fa-check';
        this.numberFilterArray = [];
        this.stringFilterArray = [];
        this.model1 = 'OR';
        this.option = 'OR';
        this.radioGroupData = {
            response: {
                data: [{
                        filterOption: 'AND',
                    }, {
                        filterOption: 'OR',
                    }],
            },
        };
        this.filterOptions = [{
                key: 'Is Equal To', value: '==', type: 'string', checkedStatus: '',
            }, {
                key: 'Is Not Equal To', value: '!=', type: 'string', checkedStatus: '',
            }, {
                key: 'Start With', value: '1', type: 'string', checkedStatus: this.checkIcon,
            },
            {
                key: 'Ends With', value: '2', type: 'string', checkedStatus: '',
            }, {
                key: 'Contains', value: '3', type: 'string', checkedStatus: '',
            }, {
                key: 'Is Equal To', value: '==', type: 'number', checkedStatus: '',
            }, {
                key: 'Is Not Equal To', value: '!=', type: 'number', checkedStatus: '',
            }, {
                key: 'Is greater Than', value: '<', type: 'number', checkedStatus: '',
            }, {
                key: 'Is less Than', value: '>', type: 'number', checkedStatus: '',
            }, {
                key: 'Is less Than or equal to', value: '>=', type: 'number', checkedStatus: '',
            }, {
                key: 'Is greater Than or equal to', value: '=<', type: 'number', checkedStatus: this.checkIcon,
            }];
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.sortFilterData();
    }
    /**
     * @param {?} col
     * @param {?} opt
     * @return {?}
     */
    selectedOption(col, opt) {
        this.checkStatus();
        /** @type {?} */
        const filter = {
            key: col.dataindex,
            value: this.filterValue,
            filter: opt.value,
            type: col.datatype,
            index: col.columnIndex,
            option: this.option,
            lastColumn: col.lastColumn,
        };
        opt.checkedStatus = this.checkIcon;
        if (this.filterValue) {
            col.filterIcon = true;
            this.filterDataObject(filter, col);
        }
        this.showToolTip = false;
    }
    /**
     * @param {?} col
     * @return {?}
     */
    keyUpSearch(col) {
        this.showToolTip = false;
        if (this.filterValue == null || this.filterValue === '') {
            this.removeFilter(col);
        }
        else {
            col.filterIcon = true;
            /** @type {?} */
            const filter = {
                key: col.dataindex,
                value: this.filterValue,
                type: col.datatype,
                index: col.columnIndex,
                option: this.option,
                lastColumn: col.lastColumn,
            };
            this.filterOptions.forEach((/**
             * @param {?} opt
             * @return {?}
             */
            (opt) => {
                if (opt.checkedStatus === this.checkIcon && col.datatype === opt.type) {
                    filter['filter'] = opt.value;
                }
            }));
            this.filterDataObject(filter, col);
        }
    }
    /**
     * @param {?} column
     * @return {?}
     */
    removeFilter(column) {
        this.filterValue = '';
        column.filterIcon = false;
        this.dataTableService.filteredObject.forEach((/**
         * @param {?} option
         * @param {?} index
         * @return {?}
         */
        (option, index) => {
            if (option.key === column.dataindex) {
                this.dataTableService.filteredObject.splice(index, 1);
            }
        }));
        this.filterObject.emit(this.dataTableService.filteredObject);
    }
    /**
     * @return {?}
     */
    checkStatus() {
        this.filterOptions.forEach((/**
         * @param {?} opt
         * @return {?}
         */
        (opt) => {
            opt.checkedStatus = '';
        }));
    }
    /**
     * @param {?} filter
     * @param {?} col
     * @return {?}
     */
    filterDataObject(filter, col) {
        this.dataTableService.filteredObject.forEach((/**
         * @param {?} option
         * @param {?} index
         * @return {?}
         */
        (option, index) => {
            if (option.key === col.dataindex) {
                this.dataTableService.filteredObject.splice(index, 1);
            }
        }));
        this.dataTableService.filteredObject.push(filter);
        this.filterObject.emit(this.dataTableService.filteredObject);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onDataFilterIconClick(event) {
        event.stopImmediatePropagation();
        this.onFilterClick.emit();
        this.addListner();
        this.showToolTip = !this.showToolTip;
    }
    /**
     * @return {?}
     */
    addListner() {
        this.globalClickListenFunc = this.renderer.listen('document', 'click', (/**
         * @param {?} e
         * @return {?}
         */
        (e) => {
            this.showToolTip = false;
            if (!this.showToolTip) {
                this.removeListner();
            }
        }));
    }
    /**
     * @return {?}
     */
    removeListner() {
        if (this.globalClickListenFunc) {
            this.globalClickListenFunc();
        }
    }
    /**
     * @param {?} listId
     * @param {?} datatype
     * @return {?}
     */
    onArrowUpList(listId, datatype) {
        /** @type {?} */
        const unitId = parseInt(listId, 10);
        /** @type {?} */
        const previousId = unitId - 1;
        /** @type {?} */
        let nextId;
        if (previousId >= 0) {
            document.getElementById(previousId.toString()).focus();
        }
        else {
            if (datatype === 'string') {
                nextId = this.stringFilterArray.length;
            }
            else {
                nextId = this.numberFilterArray.length;
            }
            listId = nextId.toString();
            this.onArrowUpList(listId, datatype);
        }
    }
    /**
     * @param {?} listId
     * @param {?} datatype
     * @return {?}
     */
    onArrowdownList(listId, datatype) {
        /** @type {?} */
        const unitId = parseInt(listId, 10);
        /** @type {?} */
        const nextId = unitId + 1;
        /** @type {?} */
        let datatypeLength;
        if (datatype === 'string') {
            datatypeLength = this.stringFilterArray.length;
        }
        else if (datatype === 'number') {
            datatypeLength = this.numberFilterArray.length;
        }
        if (nextId < datatypeLength) {
            document.getElementById(nextId.toString()).focus();
        }
        else {
            listId = '-1';
            this.onArrowdownList(listId, datatype);
        }
    }
    /**
     * @return {?}
     */
    sortFilterData() {
        this.stringFilterArray = [];
        this.numberFilterArray = [];
        this.filterOptions.forEach((/**
         * @param {?} element
         * @return {?}
         */
        (element) => {
            if (element.type === 'string') {
                this.stringFilterArray.push(element);
            }
            else {
                this.numberFilterArray.push(element);
            }
        }));
    }
    // On AND or OR Selection
    /**
     * @param {?} col
     * @param {?} event
     * @return {?}
     */
    setSelectedOption(col, event) {
        if (event.filterOption === 'AND') {
            this.option = 'AND';
            this.keyUpSearch(col);
        }
        else {
            this.option = 'OR';
            this.keyUpSearch(col);
        }
    }
}
DataGridFilterComponent.decorators = [
    { type: Component, args: [{
                selector: 'data-grid-filter',
                template: `
    <ng-container *ngIf="column.datatype==='string'">
        <div class="inputgroup">
            <input style="text-align:left; padding-left: 25px;" tabindex="1" type="text" [(ngModel)]="filterValue" [attr.placeholder]="column.text" (keyup)="keyUpSearch(column)"
                type="text" class="input-control" aria-label="Text input with dropdown button">
            <span style=" cursor: pointer;" tabindex="1" (keyup.enter)="onDataFilterIconClick($event)" (click)="onDataFilterIconClick($event)"
                class="datatable-filter-icon1">
                <amexio-c-icon key="datagrid_filter"></amexio-c-icon>
            </span>
            <span *ngIf="showToolTip" class="dropdown" style="width: 250px">
                    <ng-container *ngIf="column.columnIndex > 0">
                            <div style="padding-bottom: 5px">
                                <amexio-radio-group name="filterOption" [data-reader]="'response.data'" [display-field]="'filterOption'" [value-field]="'filterOption'"
                                    [horizontal]="false" [data]="radioGroupData" [(ngModel)]="model1" (onSelection)="setSelectedOption(column, $event)">
                                </amexio-radio-group>
                            </div>
                        </ng-container>
                <ul class="dropdown-list" *ngFor="let opt of stringFilterArray; let i = index">
                    <ng-container *ngIf="opt.type===column.datatype">
                        <li #listId id={{i}} tabindex="1" (keyup.enter)="selectedOption(column,opt)" (keyup.arrowup)="onArrowUpList(listId.id, column.datatype)"
                            (keyup.arrowdown)="onArrowdownList(listId.id, column.datatype)" role="option" class="list-items">
                            <div (click)="selectedOption(column,opt)">
                                {{opt.key}}&nbsp;
                                <i [class]="opt.checkedStatus" aria-hidden="true"></i>
                            </div>
                        </li>
                    </ng-container>
                </ul>
            </span>
        </div>
    </ng-container>

    <ng-container *ngIf="column.datatype==='number'">
        <div class="inputgroup">
            <input style="text-align:left; padding-left: 25px;" tabindex="1" type="text" [(ngModel)]="filterValue" [attr.placeholder]="column.text" (keyup)="keyUpSearch(column)"
                type="number" class="input-control" aria-label="Text input with dropdown button">
            <span style=" cursor: pointer;" tabindex="1" (keyup.enter)="onDataFilterIconClick($event)" (click)="onDataFilterIconClick($event)"
                class="datatable-filter-icon1">
                <amexio-c-icon key="datagrid_filter"></amexio-c-icon>
            </span>
            <span *ngIf="showToolTip" class="dropdown" style="width: 250px;">
                    <ng-container *ngIf="column.columnIndex > 0">
                            <div style="padding-bottom: 5px">
                                <amexio-radio-group name="filterOption" [data-reader]="'response.data'" [display-field]="'filterOption'" [value-field]="'filterOption'"
                                    [horizontal]="false" [data]="radioGroupData" [(ngModel)]="model1" (onSelection)="setSelectedOption(column, $event)">
                                </amexio-radio-group>
                            </div>
                        </ng-container>
                <ul class="dropdown-list" *ngFor="let opt of numberFilterArray; let i = index">
                    <ng-container *ngIf="opt.type===column.datatype">
                        <li #listId id={{i}} tabindex="1" (keyup.enter)="selectedOption(column,opt)" (keyup.arrowup)="onArrowUpList(listId.id, column.datatype)"
                            (keyup.arrowdown)="onArrowdownList(listId.id, column.datatype)" role="option" class="list-items">
                            <div (click)="selectedOption(column,opt)">
                                {{opt.key}}&nbsp;
                                <i [class]="opt.checkedStatus" aria-hidden="true"></i>
                            </div>
                        </li>
                    </ng-container>
                </ul>
            </span>
        </div>
    </ng-container>
  `,
            },] },
];
/** @nocollapse */
DataGridFilterComponent.ctorParameters = () => [
    { type: CommonDataService },
    { type: Renderer2 }
];
DataGridFilterComponent.propDecorators = {
    column: [{ type: Input }],
    filterObject: [{ type: Output }],
    onFilterClick: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/
/*
 Component Name : Amexio data grid
 Component Selector : <amexio-datagrid>
 Component Description : Data grid component to render large amount of data-set with
 various options like sorting in ascending or descending order, client-side pagination,
 column hide/unhide, single/multi selection, user define template for rendering for column
 header and column data, displaying summation of numeric column.
 */
class AmexioDatagridComponent extends LifeCycleBaseComponent {
    /**
     * @param {?} element
     * @param {?} dataTableService
     * @param {?} cd
     * @param {?} renderer
     * @param {?} document
     */
    constructor(element, dataTableService, cd, renderer, document) {
        super(document);
        this.element = element;
        this.dataTableService = dataTableService;
        this.cd = cd;
        this.renderer = renderer;
        this.document = document;
        /*
           Events
           name : rowSelect
           datatype : none
           version : none
           default : none
           description : It will gives you row clicked data.
           */
        this.rowSelect = new EventEmitter();
        /*
           Events
           name : selectedRowData
           datatype : none
           version : none
           default : none
           description : It will fire only on selection of checkbox and gives you selected record data.
           */
        this.selectedRowData = new EventEmitter();
        /*
           Events
           name : onHeaderClick
           datatype : none
           version : none
           default : none
           description : It will gives you click event and column info.
           */
        this.onHeaderClick = new EventEmitter();
        /*
           Properties
           name : groupby
           datatype :
           version : 4.0 onwards
           default : none
           description : Set True for Enable group by functionality.
           */
        this.groupby = false;
        this.serverSidePaging = false;
        this.rightClick = new EventEmitter();
        /*
           Events
           name : onPageChange
           datatype : none
           version : none
           default : none
           description : It will gives you current and next page info
           */
        this.onPageChange = new EventEmitter();
        this.amexioComponentId = 'amexio-grid';
        this.columns = [];
        this.viewRows = [];
        this.selectAll = false;
        this.globalFilterOptions = [];
        this.tempContextMenu = [];
        this.mouseLocation = { left: 0, top: 0 };
        this.isExpanded = false;
        this.mask = true;
        this.checkIcon = 'fa fa-check';
        this.plusIcon = 'fa fa-plus';
        this.checkDefaultIcon = 'checkbox default';
        this.checkBoxActive = 'checkbox active';
        this.checkBoxSelectClass = '';
        this.showEnableColumnFilter = false;
        this.filterComRef = [];
        this.columnCountArray = [];
        this.arrayTabIndex = [];
        this.tabindex = '-1';
        this.columnHiddenIndexArray = [];
        this.prevlistindex = -1;
        this.listindex = -1;
        this.stringFilterArray = [];
        this.numberFilterArray = [];
        this.fliterFlag = false;
        this.filteredObject = [];
        this.resultData = [];
        this.selectedRows = [];
        this.sortBy = -1;
        this.globalFilterOptions = [{
                key: 'Start With', value: '1', checkedStatus: this.checkIcon, type: 'string',
            }, {
                key: 'Ends With', value: '2', checkedStatus: '', type: 'string',
            }, {
                key: 'Contains', value: '3', checkedStatus: '', type: 'string',
            }];
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set data(value) {
        this._data = value;
        if (this.componentLoaded) {
            this.updateComponent();
        }
    }
    /**
     * @return {?}
     */
    get data() {
        return this._data;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set columndefintion(value) {
        this._columndefintion = value;
        if (this.componentLoaded) {
            this.updateComponent();
        }
    }
    /**
     * @return {?}
     */
    get columndefintion() {
        return this._columndefintion;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
        if (this.enablecolumnfiter) {
            this.enablecolumnfilter = this.enablecolumnfiter;
        }
        this.isExpanded = true;
        this.iconclassKey = this.plusIcon;
        if (this.enabledatafilter === true) {
            this.globalfilter = false;
        }
        if (this.selectedrowcolor == null || this.selectedrowcolor === '') {
            this.selectedrowcolor = '#dcecf7';
        }
        if (this.httpmethod && this.httpurl) {
            this.dataTableService.fetchData(this.httpurl, this.httpmethod).subscribe((/**
             * @param {?} response
             * @return {?}
             */
            (response) => {
                this.cloneResponseData = response;
                this.responseData = JSON.parse(JSON.stringify(this.cloneResponseData));
            }), (/**
             * @param {?} error
             * @return {?}
             */
            (error) => {
            }), (/**
             * @return {?}
             */
            () => {
                this.setData(this.responseData);
            }));
        }
        else if (this.data) {
            this.setData(this.data);
            this.previousData = JSON.parse(JSON.stringify(this.data));
        }
        this.componentLoaded = true;
        this.componentId = 'gridcolumn' + window.crypto.getRandomValues(new Uint32Array(1))[0];
        this.gridId = 'grid' + window.crypto.getRandomValues(new Uint32Array(1))[0];
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (this.enabledatafilter) {
            this.filterComRef = this.filterRef.toArray();
        }
    }
    /**
     * @return {?}
     */
    updateComponent() {
        if (!this.fliterFlag && this.previousData != null && JSON.stringify(this.previousData) !== JSON.stringify(this.data)) {
            this.previousData = JSON.parse(JSON.stringify(this.data));
            this.setChangeData(this.data);
        }
        if (this.columnPreviewData != null && this.columndefintion != null &&
            JSON.stringify(this.columnPreviewData) !== JSON.stringify(this.columndefintion)) {
            this.columnPreviewData = JSON.parse(JSON.stringify(this.columndefintion));
            this.columns = this.columndefintion;
        }
        this.fliterFlag = false;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        if (this.columndefintion) {
            this.columns = this.columndefintion;
            this.columnPreviewData = JSON.parse(JSON.stringify(this.columndefintion));
        }
        else {
            this.createConfig();
        }
        this.getColumnCount();
        this.checkFirstTabIndex(1);
    }
    /**
     * @return {?}
     */
    createConfig() {
        this.columns = [];
        /** @type {?} */
        let columnRefArray;
        columnRefArray = this.columnRef.toArray();
        columnRefArray.forEach((/**
         * @param {?} cr
         * @param {?} index
         * @return {?}
         */
        (cr, index) => {
            /** @type {?} */
            const columnConfig = cr;
            /** @type {?} */
            let columnData;
            if (columnConfig.headerTemplate != null && columnConfig.bodyTemplate != null) {
                columnData = {
                    text: columnConfig.text,
                    dataindex: columnConfig.dataindex,
                    hidden: columnConfig.hidden,
                    datatype: columnConfig.datatype,
                    headerTemplate: columnConfig.headerTemplate,
                    width: columnConfig.width,
                    sort: columnConfig.sort,
                    bodyTemplate: columnConfig.bodyTemplate,
                    contextmenu: columnConfig.contextmenu,
                    columnIndex: index,
                    lastColumn: columnRefArray.length,
                };
            }
            else if (columnConfig.headerTemplate != null && columnConfig.bodyTemplate == null) {
                columnData = {
                    text: columnConfig.text,
                    dataindex: columnConfig.dataindex,
                    hidden: columnConfig.hidden,
                    datatype: columnConfig.datatype,
                    width: columnConfig.width,
                    sort: columnConfig.sort,
                    headerTemplate: columnConfig.headerTemplate,
                    contextmenu: columnConfig.contextmenu,
                    columnIndex: index,
                    lastColumn: columnRefArray.length,
                };
            }
            else if (columnConfig.bodyTemplate != null && columnConfig.headerTemplate == null) {
                columnData = {
                    text: columnConfig.text,
                    dataindex: columnConfig.dataindex,
                    hidden: columnConfig.hidden,
                    datatype: columnConfig.datatype,
                    width: columnConfig.width,
                    sort: columnConfig.sort,
                    bodyTemplate: columnConfig.bodyTemplate,
                    contextmenu: columnConfig.contextmenu,
                    columnIndex: index,
                    lastColumn: columnRefArray.length,
                };
            }
            else if (columnConfig.bodyTemplate == null && columnConfig.headerTemplate == null) {
                columnData = {
                    text: columnConfig.text,
                    dataindex: columnConfig.dataindex,
                    hidden: columnConfig.hidden,
                    width: columnConfig.width,
                    sort: columnConfig.sort,
                    datatype: columnConfig.datatype,
                    contextmenu: columnConfig.contextmenu,
                    columnIndex: index,
                    lastColumn: columnRefArray.length,
                };
            }
            if (columnConfig.summarytype) {
                columnData['summarytype'] = columnConfig.summarytype;
            }
            if (columnConfig.summarycaption) {
                columnData['summarycaption'] = columnConfig.summarycaption;
            }
            this.columns.push(columnData);
            this.enableHeaderMethod();
        }));
    }
    // Enables header if text to any of the column is given
    /**
     * @return {?}
     */
    enableHeaderMethod() {
        this.columns.forEach((/**
         * @param {?} element
         * @return {?}
         */
        (element) => {
            if (element.text) {
                this.enableHeader = true;
            }
        }));
    }
    /**
     * @param {?} httpResponse
     * @return {?}
     */
    setChangeData(httpResponse) {
        this.setSelectedFlag(httpResponse);
        if (this.groupby) {
            this.cloneData = JSON.parse(JSON.stringify(this.data));
            /** @type {?} */
            const groups = {};
            this.commonMethod(this.cloneData, groups);
        }
        if (this.enabledatafilter) {
            this.filterCloneData = JSON.parse(JSON.stringify(this.data));
        }
        if (this.globalfilter) {
            this.filterCloneData = JSON.parse(JSON.stringify(this.data));
        }
        if (!this.groupby) {
            this.renderData();
        }
        this.setPaginatorData();
        this.mask = false;
        if (this.filteredObject.length > 0) {
            this.getFilteredData(this.filteredObject);
        }
    }
    /**
     * @param {?} httpResponse
     * @return {?}
     */
    setData(httpResponse) {
        this.viewRows = this.getResponseData(httpResponse);
        this.setSelectedFlag(this.viewRows);
        this.data = this.viewRows;
        if (this.groupby) {
            this.cloneData = JSON.parse(JSON.stringify(this.data));
        }
        if (this.enabledatafilter) {
            this.filterCloneData = JSON.parse(JSON.stringify(this.data));
        }
        if (this.globalfilter) {
            this.filterCloneData = JSON.parse(JSON.stringify(this.data));
        }
        this.renderData();
        if (this.groupby) {
            this.setColumnData();
        }
        this.setPaginatorData();
        this.mask = false;
    }
    /**
     * @return {?}
     */
    setPaginatorData() {
        if (this.serverSidePaging && this.totalDataCount && this.viewRows.length > 0) {
            if (!this.pagesize && !this.totalPages) {
                this.pagesize = this.viewRows.length;
                this.totalPages = Math.ceil(this.totalDataCount / this.pagesize);
            }
        }
        else {
            this.totalPages = this.pageNumbers.length;
        }
    }
    /**
     * @param {?} viewRows
     * @return {?}
     */
    setSelectedFlag(viewRows) {
        viewRows.forEach((/**
         * @param {?} row
         * @return {?}
         */
        (row) => {
            if (!row.hasOwnProperty('isSelected')) {
                row['isSelected'] = false;
                row['checkBoxSelectClass'] = this.checkDefaultIcon;
            }
            else if (row.isSelected && this.enablecheckbox) {
                row.isSelected = false;
                row['checkBoxSelectClass'] = this.checkBoxActive;
            }
        }));
    }
    /**
     * @param {?} col
     * @return {?}
     */
    setGroupByColumn(col) {
        this.groupbydataindex = col.dataindex;
        this.selectAll = false;
        this.setColumnData();
    }
    // Method required for global filter
    /**
     * @return {?}
     */
    keyUpSearch() {
        if (this.filterValue == null || this.filterValue === '') {
            this.removeGlobalFilter();
        }
        /** @type {?} */
        const filter = {
            value: this.filterValue,
        };
        this.globalFilterOptions.forEach((/**
         * @param {?} opt
         * @return {?}
         */
        (opt) => {
            if (opt.checkedStatus === this.checkIcon) {
                filter['filter'] = opt.value;
            }
        }));
        this.getGlobalFilteredData(filter);
    }
    /**
     * @param {?} opt
     * @return {?}
     */
    checkStatus(opt) {
        this.globalFilterOptions.forEach((/**
         * @param {?} item
         * @return {?}
         */
        (item) => {
            item.checkedStatus = '';
        }));
        opt.checkedStatus = this.checkIcon;
    }
    /**
     * @param {?} opt
     * @return {?}
     */
    selectedOption(opt) {
        this.checkStatus(opt);
        /** @type {?} */
        const filter = {
            value: this.filterValue,
            filter: opt.value,
            type: opt.type,
        };
        if (this.filterValue) {
            this.getGlobalFilteredData(filter);
        }
        this.showToolTip = false;
    }
    /**
     * @return {?}
     */
    removeGlobalFilter() {
        this.filterValue = '';
    }
    /**
     * @param {?} filteredObj
     * @return {?}
     */
    getGlobalFilteredData(filteredObj) {
        this.fliterFlag = true;
        /** @type {?} */
        const resultData = [];
        if (filteredObj) {
            this.filterCloneData.forEach((/**
             * @param {?} row
             * @return {?}
             */
            (row) => {
                if (this.checkValueInColumn(row, filteredObj)) {
                    resultData.push(row);
                }
            }));
            if (resultData.length < (1 * this.pagesize)) {
                this.currentPage = 1;
                this.maxPage = 1;
            }
            this.data = resultData;
        }
        else {
            this.data = this.filterCloneData;
        }
        this.renderData();
    }
    /**
     * @param {?} row
     * @param {?} filteredObj
     * @return {?}
     */
    checkValueInColumn(row, filteredObj) {
        /** @type {?} */
        let searchStatus = false;
        /** @type {?} */
        const statusCollection = [];
        this.columns.forEach((/**
         * @param {?} opt
         * @return {?}
         */
        (opt) => {
            /** @type {?} */
            let optvalue = '';
            /** @type {?} */
            let filtervalue = '';
            if (typeof row[opt.dataindex] === 'string') {
                optvalue = row[opt.dataindex].toLowerCase();
            }
            if (typeof filteredObj.value === 'string') {
                filtervalue = filteredObj.value.toLowerCase();
            }
            if (filteredObj.filter === '1') {
                statusCollection.push(optvalue.startsWith(filtervalue));
            }
            else if (filteredObj.filter === '2') {
                statusCollection.push(optvalue.endsWith(filtervalue));
            }
            else if (filteredObj.filter === '3') {
                statusCollection.push(optvalue.includes(filtervalue));
            }
        }));
        if (statusCollection.filter((/**
         * @param {?} status
         * @return {?}
         */
        (status) => status === true)).length > 0) {
            searchStatus = true;
        }
        return searchStatus;
    }
    /**
     * @param {?} filteredObj
     * @param {?} option
     * @param {?} opt
     * @return {?}
     */
    filterConditionMethod(filteredObj, option, opt) {
        /** @type {?} */
        this.data = [];
        /** @type {?} */
        let condition;
        if (filteredObj.filter === '1') {
            condition = option[opt.dataindex].toLowerCase().startsWith(filteredObj.value.toLowerCase());
            this.setstatus(condition);
        }
        if (filteredObj.filter === '2') {
            condition = option[opt.dataindex].toLowerCase().endsWith(filteredObj.value.toLowerCase());
            this.setstatus(condition);
        }
        if (filteredObj.filter === '3') {
            condition = option[opt.dataindex].toLowerCase().includes(filteredObj.value.toLowerCase());
            this.setstatus(condition);
        }
    }
    // Refactored code to avoid duplication: for filter grid
    /**
     * @param {?} condition
     * @return {?}
     */
    setstatus(condition) {
        if (condition) {
            status = condition;
        }
    }
    /**
     * @return {?}
     */
    setColumnData() {
        this.data = this.cloneData;
        /** @type {?} */
        const groups = {};
        this.commonMethod(this.data, groups);
    }
    /**
     * @param {?} data
     * @param {?} groups
     * @return {?}
     */
    commonMethod(data, groups) {
        data.forEach((/**
         * @param {?} option
         * @return {?}
         */
        (option) => {
            /** @type {?} */
            const groupName = option[this.groupbydataindex];
            if (!groups[groupName]) {
                groups[groupName] = [];
            }
            groups[groupName].push(option);
        }));
        data = [];
        for (const groupName in groups) {
            if (groups.hasOwnProperty(groupName)) {
                data.push({ expanded: false, isSelected: false, group: groupName, groupData: groups[groupName] });
            }
        }
        this._data = data;
        /*-------Aggregation---------*/
        this.renderData();
        this.cd.detectChanges();
    }
    /**
     * @return {?}
     */
    renderData() {
        if (this.data) {
            this.maxPage = 0;
            this.pageNumbers = [];
            if (this.data.length > (1 * this.pagesize)) {
                this.maxPage = Math.floor((this.data.length / this.pagesize));
                if ((this.data.length % this.pagesize) > 0) {
                    this.maxPage++;
                }
            }
            for (let pageNo = 1; pageNo <= this.maxPage; pageNo++) {
                this.pageNumbers.push(pageNo);
            }
            this.totalPages = this.pageNumbers.length;
        }
        if (this.pagesize >= 1) {
            this.getPageSize();
        }
        else {
            this.viewRows = this.data;
        }
        this.selectedRowNo = -1;
    }
    // Method Calls when page size is more than 1
    /**
     * @private
     * @return {?}
     */
    getPageSize() {
        /** @type {?} */
        const rowsTemp = this.data;
        /** @type {?} */
        const newRows = [];
        /** @type {?} */
        let startIndex = 0;
        /** @type {?} */
        let endIndex = this.pagesize;
        if (this.currentPage > 1) {
            startIndex = (this.currentPage - 1) * this.pagesize;
            endIndex = startIndex + this.pagesize;
        }
        while (startIndex <= endIndex - 1) {
            if (rowsTemp[startIndex]) {
                newRows.push(rowsTemp[startIndex]);
            }
            startIndex++;
        }
        this.viewRows = newRows;
    }
    /**
     * @param {?} httpResponse
     * @return {?}
     */
    getResponseData(httpResponse) {
        /** @type {?} */
        let responsedata = httpResponse;
        if (this.datareader != null) {
            /** @type {?} */
            const dr = this.datareader.split('.');
            for (const ir of dr) {
                responsedata = responsedata[ir];
            }
        }
        else {
            responsedata = httpResponse;
        }
        return responsedata;
    }
    /**
     * @return {?}
     */
    selectAllRecord() {
        this.selectAll = !this.selectAll;
        if (this.selectAll) {
            for (const vr of this.viewRows) {
                vr.checkBoxSelectClass = this.checkBoxActive;
                this.selectedRows.push(vr);
            }
        }
        else {
            for (const vr of this.viewRows) {
                vr.checkBoxSelectClass = this.checkDefaultIcon;
            }
            this.selectedRows = [];
        }
        this.emitSelectedRows();
        if (this.groupby) {
            if (!this.selectAll) {
                this.viewRows.forEach((/**
                 * @param {?} row
                 * @return {?}
                 */
                (row) => {
                    row.isSelected = false;
                    row.groupData.forEach((/**
                     * @param {?} node
                     * @return {?}
                     */
                    (node) => {
                        node.isSelected = false;
                    }));
                }));
            }
            else {
                this.viewRows.forEach((/**
                 * @param {?} row
                 * @return {?}
                 */
                (row) => {
                    row.isSelected = true;
                    row.groupData.forEach((/**
                     * @param {?} node
                     * @return {?}
                     */
                    (node) => {
                        node.isSelected = true;
                    }));
                }));
            }
        }
    }
    /**
     * @param {?} column
     * @return {?}
     */
    onColumnCheck(column) {
        column.hidden = !column.hidden;
        this.getColumnCount();
        this.checkFirstTabIndex(1);
    }
    /**
     * @param {?} rowData
     * @param {?} rowIndex
     * @return {?}
     */
    onRowClick(rowData, rowIndex) {
        this.viewRows.forEach((/**
         * @param {?} opt
         * @return {?}
         */
        (opt) => {
            opt.isSelected = false;
            if (opt.hasOwnProperty('groupData')) {
                opt.groupData.forEach((/**
                 * @param {?} optChild
                 * @return {?}
                 */
                (optChild) => {
                    optChild.isSelected = false;
                }));
            }
        }));
        rowData.isSelected = !rowData.isSelected;
        rowIndex = 'row' + rowIndex;
        this.rowId = rowIndex;
        /** @type {?} */
        const emitData = JSON.parse(JSON.stringify(rowData));
        delete emitData['checkBoxSelectClass'];
        this.rowSelect.emit(emitData);
        this.selectedRowNo = rowIndex;
    }
    /**
     * @param {?} pageInfo
     * @return {?}
     */
    loadPageData(pageInfo) {
        if (this.serverSidePaging) {
            this.onPageChange.emit(pageInfo);
        }
        else {
            this.currentPage = pageInfo.pageNumber;
            this.renderData();
        }
    }
    /**
     * @param {?} filteredObj
     * @return {?}
     */
    getFilteredData(filteredObj) {
        this.resultData = [];
        this.filteredObject = filteredObj;
        this.fliterFlag = true;
        if (filteredObj.length > 0) {
            filteredObj.sort((/**
             * @param {?} a
             * @param {?} b
             * @return {?}
             */
            (a, b) => {
                return a.index - b.index;
            }));
            filteredObj.forEach((/**
             * @param {?} element
             * @return {?}
             */
            (element) => {
                if (element.option === 'OR') {
                    /** @type {?} */
                    const orData = JSON.parse(JSON.stringify(this.filterCloneData));
                    this.callFilterOperation(orData, element);
                }
                else {
                    /** @type {?} */
                    const andData = JSON.parse(JSON.stringify(this.resultData));
                    this.resultData = [];
                    this.callFilterOperation(andData, element);
                }
            }));
            if (this.resultData.length < (1 * this.pagesize)) {
                this.currentPage = 1;
                this.maxPage = 1;
            }
            this.data = this.resultData;
        }
        else {
            this.data = this.filterCloneData;
        }
        this.renderData();
    }
    /**
     * @param {?} dataforfilter
     * @param {?} element
     * @return {?}
     */
    callFilterOperation(dataforfilter, element) {
        dataforfilter.forEach((/**
         * @param {?} option
         * @return {?}
         */
        (option) => {
            if (this.filterOpertion(option, element)) {
                this.resultData.push(option);
            }
        }));
    }
    /**
     * @param {?} data
     * @param {?} filterOpt
     * @return {?}
     */
    filterOpertion(data, filterOpt) {
        /** @type {?} */
        const statusCollection = [];
        /** @type {?} */
        let condition = false;
        if (filterOpt.type === 'string') {
            if (filterOpt.value && data[filterOpt.key] && typeof data[filterOpt.key] === 'string') {
                statusCollection.push(this.checkStringFilter(filterOpt.filter, data[filterOpt.key].toLowerCase(), filterOpt.value.toLowerCase()));
            }
        }
        else if (filterOpt.type === 'number') {
            statusCollection.push(this.checkNumberFilter(filterOpt.filter, data[filterOpt.key], filterOpt.value));
        }
        if (statusCollection.filter((/**
         * @param {?} status
         * @return {?}
         */
        (status) => status === true)).length > 0) {
            condition = true;
        }
        return condition;
    }
    /**
     * @param {?} filter
     * @param {?} key
     * @param {?} value
     * @return {?}
     */
    checkNumberFilter(filter, key, value) {
        if (filter === '<') {
            return key > value;
        }
        else if (filter === '>') {
            return key < value;
        }
        else if (filter === '>=') {
            return key <= value;
        }
        else if (filter === '=<') {
            return key >= value;
        }
        else if (filter === '==') {
            return key === value;
        }
        else if (filter === '!=') {
            return key !== value;
        }
        else {
            return key !== value;
        }
    }
    /**
     * @param {?} filter
     * @param {?} key
     * @param {?} value
     * @return {?}
     */
    checkStringFilter(filter, key, value) {
        if (filter === '3') {
            return key.includes(value);
        }
        else if (filter === '1') {
            return key.startsWith(value);
        }
        else if (filter === '2') {
            return key.endsWith(value);
        }
        else {
            return key !== value;
        }
    }
    /**
     * @param {?} rowData
     * @param {?} event
     * @return {?}
     */
    setSelectedRow(rowData, event) {
        if (event.classList.value === this.checkDefaultIcon) {
            this.selectedRows.push(rowData);
            event.classList.value = this.checkBoxActive;
        }
        else {
            /** @type {?} */
            const indexOf = this.selectedRows.indexOf(rowData);
            this.selectedRows.splice(indexOf, 1);
            event.classList.value = this.checkDefaultIcon;
        }
        this.emitSelectedRows();
    }
    /**
     * @return {?}
     */
    emitSelectedRows() {
        /** @type {?} */
        const sRows = [];
        for (const sr of this.selectedRows) {
            if (sr) {
                sRows.push(sr);
            }
        }
        /** @type {?} */
        const selectedAllData = JSON.parse(JSON.stringify(sRows));
        selectedAllData.forEach((/**
         * @param {?} select
         * @return {?}
         */
        (select) => {
            delete select['checkBoxSelectClass'];
        }));
        this.selectedRowData.emit(selectedAllData);
    }
    /**
     * @return {?}
     */
    setCheckBoxSelectClass() {
        if (this.selectAll) {
            return this.checkBoxActive;
        }
        else {
            return this.checkDefaultIcon;
        }
    }
    /**
     * @param {?} sortCol
     * @param {?} clickEvent
     * @return {?}
     */
    sortOnColHeaderClick(sortCol, clickEvent) {
        this.onHeaderClick.emit({ event: clickEvent, data: sortCol });
        if (sortCol.sort) {
            if (this.sortBy === -1) {
                this.sortBy = 1;
            }
            else if (this.sortBy === 1) {
                this.sortBy = 2;
            }
            else if (this.sortBy === 2) {
                this.sortBy = 1;
            }
            this.setSortColumn(sortCol, this.sortBy);
        }
    }
    /**
     * @param {?} sortCol
     * @param {?} _sortBy
     * @return {?}
     */
    setSortColumn(sortCol, _sortBy) {
        /*------set column sort false for other column--------*/
        this.columns.forEach((/**
         * @param {?} opt
         * @return {?}
         */
        (opt) => {
            opt['isColumnSort'] = false;
        }));
        this.sortBy = _sortBy;
        this.sortColumn = sortCol;
        this.sortColumn.sort = true;
        this.sortColumn.isColumnSort = true;
        this.sortData();
    }
    /**
     * @return {?}
     */
    sortData() {
        if (this.sortColumn) {
            /** @type {?} */
            let sortColDataIndex;
            /** @type {?} */
            const sortOrder = this.sortBy;
            if (this.sortColumn.dataindex && this.sortColumn.datatype) {
                /** @type {?} */
                const dataindex = this.sortColumn.dataindex;
                sortColDataIndex = dataindex;
                if (this.sortColumn.datatype === 'string') {
                    if (this.groupby) {
                        this.sortOrderGrpBy(sortOrder);
                    }
                    else {
                        this.sortDataFunc(sortColDataIndex, sortOrder);
                    }
                }
                else if (this.sortColumn.datatype === 'number') {
                    this.sortOrderByNumber(sortColDataIndex, sortOrder);
                }
                else if (this.sortColumn.datatype === 'boolean') {
                    this.sortOrderByBoolean(sortColDataIndex, sortOrder);
                }
            }
        }
        this.renderData();
    }
    /**
     * @param {?} sortColDataIndex
     * @param {?} sortOrder
     * @return {?}
     */
    sortDataFunc(sortColDataIndex, sortOrder) {
        this.data.sort((/**
         * @param {?} a
         * @param {?} b
         * @return {?}
         */
        (a, b) => {
            /** @type {?} */
            let x;
            /** @type {?} */
            let y;
            if (this.sortColumn.dataindex.includes('.')) {
                x = this.sortInnerFunc(this.sortColumn.dataindex, a).toLowerCase();
                y = this.sortInnerFunc(this.sortColumn.dataindex, b).toLowerCase();
            }
            else {
                x = a[sortColDataIndex].toLowerCase();
                y = b[sortColDataIndex].toLowerCase();
            }
            return this.noGrpBySortOrder(sortOrder, x, y);
        }));
    }
    /**
     * @param {?} sortOrder
     * @param {?} sortColDataIndex
     * @return {?}
     */
    sortOrderByBoolean(sortOrder, sortColDataIndex) {
        this.data.sort((/**
         * @param {?} a
         * @param {?} b
         * @return {?}
         */
        (a, b) => {
            /** @type {?} */
            let x;
            /** @type {?} */
            let y;
            if (this.sortColumn.dataindex.includes('.')) {
                x = this.sortInnerFunc(this.sortColumn.dataindex, a);
                y = this.sortInnerFunc(this.sortColumn.dataindex, b);
            }
            else {
                x = a[sortColDataIndex];
                y = b[sortColDataIndex];
            }
            if (sortOrder === 1) {
                return (x === y) ? 0 : x ? -1 : 1;
            }
        }));
        if (sortOrder === 2) {
            this.data.reverse();
        }
    }
    // Sort Order for number field
    /**
     * @param {?} sortOrder
     * @param {?} sortColDataIndex
     * @return {?}
     */
    sortOrderByNumber(sortOrder, sortColDataIndex) {
        if (this.groupby) {
            this.data.sort((/**
             * @param {?} a
             * @param {?} b
             * @return {?}
             */
            (a, b) => {
                /** @type {?} */
                let x;
                /** @type {?} */
                let y;
                if (this.sortColumn.dataindex.includes('.')) {
                    x = this.sortInnerFunc(this.sortColumn.dataindex, a);
                    y = this.sortInnerFunc(this.sortColumn.dataindex, b);
                }
                else {
                    x = a[sortColDataIndex];
                    y = b[sortColDataIndex];
                }
                if (sortOrder === 2) {
                    return y - x;
                }
                else {
                    return x - y;
                }
            }));
        }
        else {
            this.data.sort((/**
             * @param {?} a
             * @param {?} b
             * @return {?}
             */
            (a, b) => {
                /** @type {?} */
                const x = a[sortColDataIndex];
                /** @type {?} */
                const y = b[sortColDataIndex];
                if (sortOrder === 2) {
                    return y - x;
                }
                else {
                    return x - y;
                }
            }));
        }
    }
    // Sort order if group by is false
    /**
     * @param {?} sortOrder
     * @param {?} x
     * @param {?} y
     * @return {?}
     */
    noGrpBySortOrder(sortOrder, x, y) {
        if (sortOrder === 2) {
            if (x < y) {
                return 1;
            }
            if (x > y) {
                return -1;
            }
        }
        else {
            if (x < y) {
                return -1;
            }
            if (x > y) {
                return 1;
            }
        }
        return 0;
    }
    // Sort Order if group by is true
    /**
     * @param {?} sortOrder
     * @return {?}
     */
    sortOrderGrpBy(sortOrder) {
        this.data.sort((/**
         * @param {?} a
         * @param {?} b
         * @return {?}
         */
        (a, b) => {
            /** @type {?} */
            const x = a.group.toLowerCase();
            /** @type {?} */
            const y = b.group.toLowerCase();
            if (sortOrder === 2) {
                if (x < y) {
                    return 1;
                }
                if (x > y) {
                    return -1;
                }
            }
            else {
                if (x < y) {
                    return -1;
                }
                if (x > y) {
                    return 1;
                }
            }
            return 0;
        }));
    }
    /* grouby column methods*/
    /**
     * @param {?} btn
     * @return {?}
     */
    onTabClick(btn) {
        btn.classList.toggle('active-accordion');
        /** @type {?} */
        const panel = btn.nextElementSibling;
        if (this.iconclassKey === this.plusIcon) {
            this.iconclassKey = 'fa fa-minus';
        }
        else if (this.iconclassKey === 'fa fa-minus') {
            this.iconclassKey = this.plusIcon;
        }
        if (panel.style.maxHeight) {
            panel.style.maxHeight = null;
        }
        else {
            panel.style.maxHeight = panel.scrollHeight;
        }
    }
    /**
     * @param {?} row
     * @param {?} index
     * @return {?}
     */
    toogle(row, index) {
        row.expanded = !row.expanded;
        if (row.expanded) {
            if (row.hasOwnProperty('groupData')) {
                this.addRows(row, index);
            }
        }
        else {
            if (row.hasOwnProperty('groupData')) {
                this.removeRows(row);
            }
        }
    }
    /**
     * @param {?} row
     * @param {?} index
     * @return {?}
     */
    addRows(row, index) {
        row.level = window.crypto.getRandomValues(new Uint32Array(1))[0];
        row.groupData.forEach((/**
         * @param {?} node
         * @param {?} index1
         * @return {?}
         */
        (node, index1) => {
            node.level = row.level;
            this.viewRows.splice(index + (index1 + 1), 0, node);
        }));
    }
    /**
     * @param {?} row
     * @return {?}
     */
    removeRows(row) {
        /** @type {?} */
        let count = 0;
        this.viewRows.forEach((/**
         * @param {?} node
         * @return {?}
         */
        (node) => {
            if (!node.hasOwnProperty('group') && node.level === row.level) {
                count++;
            }
        }));
        this.viewRows.forEach((/**
         * @param {?} node
         * @param {?} index
         * @return {?}
         */
        (node, index) => {
            if (!node.hasOwnProperty('group') && node.level === row.level) {
                this.viewRows.splice(index, count);
            }
        }));
    }
    /**
     * @param {?} row
     * @return {?}
     */
    isGroupChecking(row) {
        if (row.hasOwnProperty('group')) {
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * @param {?} row
     * @return {?}
     */
    selectParent(row) {
        if (this.groupby) {
            row.isSelected = !row.isSelected;
            row.groupData.forEach((/**
             * @param {?} node
             * @return {?}
             */
            (node) => {
                node.isSelected = !node.isSelected;
            }));
            this.selectedRows = [];
            this.viewRows.forEach((/**
             * @param {?} rows
             * @return {?}
             */
            (rows) => {
                if (rows.isSelected) {
                    this.selectedRows.push(rows);
                }
            }));
            this.emitSelectedRows();
        }
    }
    /**
     * @param {?} event
     * @param {?} row
     * @param {?} col
     * @param {?} ref
     * @return {?}
     */
    loadContextMenu(event, row, col, ref) {
        if (this.contextmenu && this.contextmenu.length > 0) {
            this.tempContextMenu = [];
            this.tempSelectedFlag(this.viewRows);
            this.mouseLocation.left = event.clientX;
            this.mouseLocation.top = event.clientY;
            row.isSelected = true;
            if (col.contextmenu && col.contextmenu.length > 0) {
                this.flag = true;
                this.tempContextMenu = col.contextmenu;
                this.addListner();
            }
            else if (this.contextmenu && this.contextmenu.length > 0) {
                this.tempContextMenu = this.contextmenu;
                this.flag = true;
                this.addListner();
            }
            this.posixUp = this.getListPosition(ref);
            event.preventDefault();
            event.stopPropagation();
            this.rightClickRowData = row;
        }
    }
    /**
     * @param {?} Data
     * @return {?}
     */
    rightClickDataEmit(Data) {
        this.rightClick.emit(Data);
    }
    // Method to get List position
    /**
     * @private
     * @param {?} elementRef
     * @return {?}
     */
    getListPosition(elementRef) {
        /** @type {?} */
        const height = 240;
        if ((window.screen.height - elementRef.getBoundingClientRect().bottom) < height) {
            return true;
        }
        else {
            return false;
        }
    }
    // Method to get Selected Row
    /**
     * @private
     * @param {?} viewRows
     * @return {?}
     */
    tempSelectedFlag(viewRows) {
        viewRows.forEach((/**
         * @param {?} row
         * @return {?}
         */
        (row) => {
            if (row.isSelected) {
                row.isSelected = false;
            }
        }));
    }
    /**
     * @return {?}
     */
    addListner() {
        this.globalClickListenFunc = this.renderer.listen('document', 'click', (/**
         * @param {?} e
         * @return {?}
         */
        (e) => {
            this.flag = false;
            this.showToolTip = false;
            this.showEnableColumnFilter = false;
            if (!this.flag || !this.showToolTip || !this.showEnableColumnFilter) {
                this.removeListner();
            }
        }));
    }
    /**
     * @return {?}
     */
    removeListner() {
        if (this.globalClickListenFunc) {
            this.globalClickListenFunc();
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.removeListner();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onFilterIconClick(event) {
        event.stopImmediatePropagation();
        this.addListner();
        this.showEnableColumnFilter = false;
        this.showToolTip = !this.showToolTip;
    }
    /**
     * @return {?}
     */
    groupbyIconClick() {
        this.showEnableColumnFilter = false;
        this.showGroupByColumn = !this.showGroupByColumn;
        this.showToolTip = false;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onEnableColumnClick(event) {
        event.stopImmediatePropagation();
        this.addListner();
        this.showToolTip = false;
        this.showEnableColumnFilter = !this.showEnableColumnFilter;
        this.showGroupByColumn = false;
    }
    /**
     * @return {?}
     */
    getFilterClick() {
        this.filterComRef.forEach((/**
         * @param {?} com
         * @return {?}
         */
        (com) => {
            com.showToolTip = false;
        }));
    }
    // TAB NAVIGATION
    // LEFT ARROW
    /**
     * @param {?} ref
     * @return {?}
     */
    arrowLeft(ref) {
        /** @type {?} */
        const intId = (ref.id).substring(ref.id.search('-') + 1, (ref.id).length);
        /** @type {?} */
        const unitId = parseInt(intId, 10) % 10;
        /** @type {?} */
        const firstId = intId.slice(0, -1);
        this.findPreviousColumn(unitId, firstId);
    }
    // RIGHT ARROW
    /**
     * @param {?} ref
     * @return {?}
     */
    arrowRight(ref) {
        /** @type {?} */
        const intId = (ref.id).substring(ref.id.search('-') + 1, (ref.id).length);
        /** @type {?} */
        const unitId = parseInt(intId, 10) % 10;
        /** @type {?} */
        const firstId = intId.slice(0, -1);
        this.findNextColumn(unitId, firstId);
    }
    // UP ARROW
    /**
     * @param {?} ref
     * @return {?}
     */
    arrowUp(ref) {
        /** @type {?} */
        const intId = (ref.id).substring(ref.id.search('-') + 1, (ref.id).length);
        /** @type {?} */
        const unitId = intId.slice(0, -1);
        if (unitId > 1 && document.getElementById(this.title + '-' + (parseInt(intId, 10) - 10).toString())) {
            document.getElementById(this.title + '-' + (parseInt(intId, 10) - 10).toString()).focus();
        }
    }
    // DOWN ARROW
    /**
     * @param {?} ref
     * @return {?}
     */
    arrowDown(ref) {
        /** @type {?} */
        const intId = (ref.id).substring(ref.id.search('-') + 1, (ref.id).length);
        /** @type {?} */
        const firstId = parseInt(intId.slice(0, -1), 10);
        if ((this.pagesize && firstId < this.pagesize && firstId < this.viewRows.length || (firstId <= this.viewRows.length - 1))
            && document.getElementById(this.title + '-' + (parseInt(intId, 10) + 10).toString())) {
            document.getElementById(this.title + '-' + (parseInt(intId, 10) + 10).toString()).focus();
        }
    }
    // END
    /**
     * @param {?} ref
     * @return {?}
     */
    keyEnd(ref) {
        /** @type {?} */
        const intId = (ref.id).substring(ref.id.search('-') + 1, (ref.id).length);
        /** @type {?} */
        const unitId = parseInt(intId, 10) % 10;
        /** @type {?} */
        const firstId = intId.slice(0, -1);
        /** @type {?} */
        const newLastId = this.columns.length;
        this.findHomeColumn(unitId, firstId, newLastId);
    }
    // END: TO FIND LAST COLUMN
    /**
     * @param {?} unitId
     * @param {?} firstId
     * @param {?} newLastId
     * @return {?}
     */
    findLastColumn(unitId, firstId, newLastId) {
        if (this.columnHiddenIndexArray.length >= 1 && this.columnHiddenIndexArray.includes(newLastId)) {
            this.findHomeColumn(unitId, firstId, newLastId - 1);
        }
        else {
            /** @type {?} */
            const generatedId = firstId + '' + newLastId;
            document.getElementById(this.title + '-' + (parseInt(generatedId, 10)).toString()).focus();
        }
    }
    // HOME
    /**
     * @param {?} ref
     * @return {?}
     */
    keyHome(ref) {
        /** @type {?} */
        const intId = (ref.id).substring(ref.id.search('-') + 1, (ref.id).length);
        /** @type {?} */
        const unitId = parseInt(intId, 10) % 10;
        this.findHomeColumn(unitId, intId.slice(0, -1), 1);
    }
    // HOME: TO FIND FIRST COLUMN
    /**
     * @param {?} unitId
     * @param {?} firstId
     * @param {?} newFirstId
     * @return {?}
     */
    findHomeColumn(unitId, firstId, newFirstId) {
        if (this.columnHiddenIndexArray.length >= 1 && this.columnHiddenIndexArray.includes(newFirstId)) {
            this.findHomeColumn(unitId, firstId, newFirstId + 1);
        }
        else {
            /** @type {?} */
            const generatedId = firstId + '' + newFirstId;
            document.getElementById(this.title + '-' + (parseInt(generatedId, 10)).toString()).focus();
        }
    }
    // CONTROL HOME
    /**
     * @return {?}
     */
    keyControlHome() {
        /** @type {?} */
        const unitId = 1;
        /** @type {?} */
        const firstId = 1;
        this.findControlHomeColumn(unitId, firstId);
    }
    // CONTROL HOME COLUMN
    /**
     * @param {?} unitId
     * @param {?} firstId
     * @return {?}
     */
    findControlHomeColumn(unitId, firstId) {
        if (this.columnHiddenIndexArray.length >= 1 && this.columnHiddenIndexArray.includes(unitId)) {
            this.findControlHomeColumn(unitId + 1, firstId);
        }
        else {
            /** @type {?} */
            const generatedId = firstId + '' + unitId;
            document.getElementById(this.title + '-' + (parseInt(generatedId, 10)).toString()).focus();
        }
    }
    // CONTROL END
    /**
     * @return {?}
     */
    keyControlEnd() {
        /** @type {?} */
        const unitId = this.columns.length;
        if (this.pagesize && this.viewRows.length >= this.pagesize) {
            /** @type {?} */
            const firstId = this.pagesize;
            this.findControlEndColumn(unitId, firstId);
        }
        else {
            /** @type {?} */
            const firstId = this.viewRows.length;
            this.findControlEndColumn(unitId, firstId);
        }
    }
    // CONTROL END COLUMN
    /**
     * @param {?} unitId
     * @param {?} firstId
     * @return {?}
     */
    findControlEndColumn(unitId, firstId) {
        if (this.columnHiddenIndexArray.length >= 1 && this.columnHiddenIndexArray.includes(unitId)) {
            this.findControlHomeColumn(unitId - 1, firstId);
        }
        else {
            /** @type {?} */
            const generatedId = firstId + '' + unitId;
            document.getElementById(this.title + '-' + (parseInt(generatedId, 10)).toString()).focus();
        }
    }
    // TO GET COLUMN COUNT EXCLUDING HIDDEN COLUMNS
    /**
     * @return {?}
     */
    getColumnCount() {
        if (this.columns) {
            this.columnHiddenIndexArray = [];
            this.columns.forEach((/**
             * @param {?} element
             * @param {?} index
             * @return {?}
             */
            (element, index) => {
                if (!element.hidden) {
                    this.columnCountArray.push(element);
                }
                else {
                    this.columnHiddenIndexArray.push(index + 1);
                }
            }));
        }
    }
    // TO FIND NEXT COLUMN: RIGHT ARROW
    /**
     * @param {?} index
     * @param {?} firstId
     * @return {?}
     */
    findNextColumn(index, firstId) {
        if (index < this.columns.length) {
            if (this.columnHiddenIndexArray.length >= 1 && this.columnHiddenIndexArray.includes(index + 1)) {
                index = index + 1;
                this.findNextColumn(index, firstId);
            }
            else {
                /** @type {?} */
                const generatedId = firstId + '' + (index + 1);
                document.getElementById(this.title + '-' + (parseInt(generatedId, 10)).toString()).focus();
            }
        }
    }
    // TO FIND PREVIOUS COLUMN: LEFT ARROW
    /**
     * @param {?} index
     * @param {?} firstId
     * @return {?}
     */
    findPreviousColumn(index, firstId) {
        if (index > 1) {
            if (this.columnHiddenIndexArray.length >= 1 && this.columnHiddenIndexArray.includes(index - 1)) {
                index = index - 1;
                this.findPreviousColumn(index, firstId);
            }
            else {
                /** @type {?} */
                const generatedId = firstId + '' + (index - 1);
                document.getElementById(this.title + '-' + (parseInt(generatedId, 10)).toString()).focus();
            }
        }
    }
    // DEFAULT FIRST TAB
    /**
     * @param {?} index
     * @return {?}
     */
    checkFirstTabIndex(index) {
        if (this.columnHiddenIndexArray.length >= 1) {
            if (this.columnHiddenIndexArray.includes(index)) {
                this.firstIndex = index + 1;
                this.checkFirstTabIndex(this.firstIndex);
            }
        }
        else {
            this.firstIndex = 1;
        }
    }
    // DOWN COLUMN: DOWN ARROW
    /**
     * @param {?} listId
     * @return {?}
     */
    onArrowdownList(listId) {
        /** @type {?} */
        const unitId = parseInt(listId, 10);
        /** @type {?} */
        const nextId = unitId + 1;
        if (nextId < this.columns.length) {
            document.getElementById(nextId.toString()).focus();
        }
        else {
            listId = '-1';
            this.onArrowdownList(listId);
        }
    }
    // UP COLUMN: UP ARROW
    /**
     * @param {?} listId
     * @return {?}
     */
    onArrowUpList(listId) {
        /** @type {?} */
        const unitId = parseInt(listId, 10);
        /** @type {?} */
        const previousId = unitId - 1;
        if (previousId >= 0) {
            document.getElementById(previousId.toString()).focus();
        }
        else {
            /** @type {?} */
            const nextId = this.columns.length;
            listId = nextId.toString();
            this.onArrowUpList(listId);
        }
    }
    /**
     * @param {?} listId
     * @return {?}
     */
    onArrowUpGlobalList(listId) {
        /** @type {?} */
        const unitId = parseInt(listId, 10);
        /** @type {?} */
        const previousId = unitId - 1;
        if (previousId >= 0) {
            document.getElementById(previousId.toString()).focus();
        }
        else {
            /** @type {?} */
            const nextId = this.globalFilterOptions.length;
            listId = nextId.toString();
            this.onArrowUpGlobalList(listId);
        }
    }
    /**
     * @param {?} listId
     * @return {?}
     */
    onArrowdownGlobalList(listId) {
        /** @type {?} */
        const unitId = parseInt(listId, 10);
        /** @type {?} */
        const nextId = unitId + 1;
        if (nextId < this.globalFilterOptions.length) {
            document.getElementById(nextId.toString()).focus();
        }
        else {
            listId = '-1';
            this.onArrowdownGlobalList(listId);
        }
    }
    /**
     * @return {?}
     */
    onPageDownClick() {
        if (this.pageId.activePage < this.pagesize) {
            this.pageId.onPageClick(this.pageId.activePage + 1, this.pageId.activePage);
            /** @type {?} */
            const pageInfo = { pageNumber: this.pageId.activePage, current: this.pageId.activePage, next: this.pageId.activePage + 1 };
            this.loadPageData(pageInfo);
            this.checkFirstTabIndex(1);
            setTimeout((/**
             * @return {?}
             */
            () => {
                this.keyControlHome();
            }), 100);
        }
    }
    /**
     * @return {?}
     */
    onPageUpClick() {
        if (this.pageId.activePage > 1) {
            this.pageId.onPageClick(this.pageId.activePage - 1, this.pageId.activePage - 2);
            /** @type {?} */
            const pageInfo = { pageNumber: this.pageId.activePage - 1, current: this.pageId.activePage, next: this.pageId.activePage + 1 };
            this.loadPageData(pageInfo);
            setTimeout((/**
             * @return {?}
             */
            () => {
                this.keyControlEnd();
            }), 100);
        }
    }
    /**
     * @return {?}
     */
    showGroupCol() {
        this.showGroupByColumn = !this.showGroupByColumn;
    }
    /**
     * @return {?}
     */
    findContolEndGrpBy() {
        if (this.viewRows && this.viewRows.length > 0) {
            /** @type {?} */
            const firstLevelGrid = [];
            /** @type {?} */
            const unitId = this.columns.length;
            /** @type {?} */
            const firstId = this.viewRows.length;
            this.viewRows.forEach((/**
             * @param {?} element
             * @param {?} index
             * @return {?}
             */
            (element, index) => {
                if (element.hasOwnProperty('expanded')) {
                    firstLevelGrid.push(element);
                }
            }));
            if (!firstLevelGrid[firstLevelGrid.length - 1].expanded) {
                this.findControlEndColumn(1, firstId);
            }
            else {
                this.findControlEndColumn(unitId, firstId);
            }
        }
    }
    /**
     * @param {?} themeClass
     * @return {?}
     */
    setColorPalette(themeClass) {
        this.themeCss = themeClass;
    }
    /**
     * @param {?} filteredObj
     * @param {?} dataForFilter
     * @return {?}
     */
    filterOperation(filteredObj, dataForFilter) {
        /** @type {?} */
        const resultData = [];
        dataForFilter.forEach((/**
         * @param {?} option
         * @return {?}
         */
        (option) => {
            if (this.filterOpertion(option, filteredObj)) {
                resultData.push(option);
            }
        }));
        if (resultData.length < (1 * this.pagesize)) {
            this.currentPage = 1;
            this.maxPage = 1;
        }
        this.data = resultData;
        this.filterResultData = resultData;
        dataForFilter = resultData;
        return dataForFilter;
    }
    /**
     * @param {?} temp
     * @param {?} data
     * @return {?}
     */
    sortInnerFunc(temp, data) {
        /** @type {?} */
        let value;
        /** @type {?} */
        let i = 0;
        /** @type {?} */
        const strarr = temp.split('.');
        for (i = 0; i < strarr.length; i++) {
            if (i === 0) {
                value = data[strarr[i]];
            }
            else {
                /** @type {?} */
                const tmp = strarr[i];
                value = value[tmp];
                return value;
            }
        }
    }
}
AmexioDatagridComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-datagrid',
                template: `
    <div [style.height]="height" [ngClass]="{'datagrid-full-screen': yesFullScreen && fullscreenMax}">
      <div class="datagrid">
        <div class="datatabletitle">
          <span *ngIf="title" id="{{gridId}}"> {{title}} </span>
          <span class="dataheaderFilter" class="float-right" style="padding-bottom:1.1%">
            <ng-content select="amexio-datagrid-header"></ng-content>
            <span tabindex='1' *ngIf="enablecolumnfilter ? true:false" (keyup.enter)="onEnableColumnClick($event)" class="enablecolumnfilter"
              (click)="onEnableColumnClick($event)" style=" cursor: pointer;">
              &nbsp;
              <span style="padding-right: 10px" *ngIf="!show">
                <em class="fa fa-bars"></em>
              </span>
              <amexio-c-icon class="float-right" style="cursor:pointer; padding-left:10px" *ngIf="((yesFullScreen && fullscreenMax))" [key]="'full-screen-min-icon'"
                (onClick)="minScreenChange($event)"></amexio-c-icon>

              <amexio-c-icon class="float-right" style="cursor:pointer; padding-left:10px" *ngIf="((yesFullScreen && !fullscreenMax))"
                [key]="'full-screen-max-icon'" (onClick)="maxScreenChange($event)"></amexio-c-icon>
            </span>

          </span>
          <span *ngIf="groupby ? true : false" class="float-right-datagridlist" tabindex="1" (keyup.enter)="showGroupCol()" (click)="groupbyIconClick()"
            style=" cursor: pointer;">
            <amexio-c-icon key="datagrid_list"></amexio-c-icon>
          </span>
        </div>
        <!--Filter with Checkbox datagrid start-->

        <ng-container *ngIf="enabledatafilter ? true : false">
          <div class="datatable datatable-row">
            <ng-container *ngIf="enablecheckbox">
              <div class="datatable-col col-group datatable-checkbox-width">
                <div class="inputgroup">
                  <div class="input-box">
                    <div *ngIf="!selectAll" (click)="selectAllRecord()" class="checkbox default"></div>
                    <div *ngIf="selectAll" (click)="selectAllRecord()" class="checkbox active">&#10004;</div>
                  </div>
                </div>
              </div>
            </ng-container>

            <!--Filter datagrid start-->

            <ng-container *ngIf="enabledatafilter ? true : false">
              <ng-container *ngFor="let cols of columns">
                <ng-container *ngIf="!cols.hidden">
                  <div class="datatable-col col-group" [style.width.%]="cols.width">
                    <data-grid-filter (onFilterClick)="getFilterClick()" [column]="cols" (filterObject)="getFilteredData($event)">
                    </data-grid-filter>
                  </div>
                </ng-container>
              </ng-container>
            </ng-container>

          </div>
        </ng-container>

        <!--Filter datagrid start-->
        <ng-container *ngIf="globalfilter ? true : false">
          <div class="datatable datatable-row">
            <ng-container class="datatable datatable-column">
              <div class="inputgroup" style="padding-left: 1%; padding-right: 1%">
                <input type="text" tabindex="1" [(ngModel)]="filterValue" (keyup)="keyUpSearch()" type="text" class="input-control" aria-label="Text input with dropdown button">
                <span style=" cursor: pointer;" tabindex="1" (click)="onFilterIconClick($event)" (keyup.enter)="onFilterIconClick($event)"
                  class="datatable-filter-icon">
                  <amexio-c-icon key="datagrid_filter"></amexio-c-icon>
                </span>
                <span *ngIf="showToolTip" class="dropdown" style="width: 250px; right: 0">
                  <ul class="dropdown-list" *ngFor="let opt of globalFilterOptions;  let i = index">
                    <li #listId id={{i}} (keyup.enter)="selectedOption(opt)" (keyup.arrowup)="onArrowUpGlobalList(listId.id)" (keyup.arrowdown)="onArrowdownGlobalList(listId.id)"
                      role="option" tabindex="1" class="list-items">
                      <div (click)="selectedOption(opt)">
                        {{opt.key}}&nbsp;
                        <i [class]="opt.checkedStatus" aria-hidden="true"></i>
                      </div>
                    </li>
                  </ul>
                </span>
              </div>
            </ng-container>
          </div>
        </ng-container>

        <ng-container *ngIf="enablecolumnfilter ? true : false">
          <span *ngIf="showEnableColumnFilter" class="dropdown dropdown-right" [ngStyle]="{'top': globalfilter || enabledatafilter ? '10%':''}"
            style="width: 250px;">
            <ul role="listbox" class="dropdown-list">
              <li #listId id={{i}} (keyup.arrowup)="onArrowUpList(listId.id)" (keyup.arrowdown)="onArrowdownList(listId.id)" role="option"
                tabindex="1" class="list-items" *ngFor="let cols of columns;let i = index;">
                <div [attr.aria-checked]="!cols.hidden">
                  <input tabindex="1" role="checkbox" id="{{componentId}}" type="checkbox" [attr.checked]="!cols.hidden ? true: null" (click)="onColumnCheck(cols)"
                    (keyup.enter)="onColumnCheck(cols)" />
                  <label>{{cols.text}}</label>
                </div>
              </li>
            </ul>
          </span>
        </ng-container>

        <ng-container *ngIf="groupby ? true : false">
          <span *ngIf="showGroupByColumn" class="dropdown dropdown-right" style="width: 250px;">
            <ul class="dropdown-list">
              <li #listId id={{i}} (keyup.arrowup)="onArrowUpList(listId.id)" (keyup.arrowdown)="onArrowdownList(listId.id)" role="option"
                tabindex="1" class="list-items" *ngFor="let cols of columns;let i = index;" (click)="showGroupByColumn = !showGroupByColumn">
                <div (click)="setGroupByColumn(cols)">
                  <label>{{cols.text}}</label>
                </div>
              </li>
            </ul>
          </span>
        </ng-container>
      </div>

      <!--Checkbox datagrid with datatypes condition start-->
      <ng-container *ngIf="enableHeader">
        <div class="{{roundedgeclass}}">

          <div class="datatable" role="grid" attr.aria-labelledby="{{gridId}}">
            <div class="datatable-header" [ngClass]="themeCss">
              <ng-container *ngIf="enablecheckbox">
                <div class="datatable-col datatable-checkbox-width checkbox-col">
                  <div class="inputgroup">
                    <div class="input-box">
                      <div *ngIf="!selectAll" (click)="selectAllRecord()" class="checkbox default"></div>
                      <div *ngIf="selectAll" (click)="selectAllRecord()" class="checkbox active">&#10004;</div>
                    </div>
                  </div>
                </div>
              </ng-container>
              <!--datagrid start unhidden-->
              <ng-container *ngFor="let cols of columns">
                <ng-container *ngIf="!cols.hidden">
                  <ng-container *ngIf="(cols.datatype=='string' || cols.datatype == 'boolean')">
                    <div class="datatable-col" tabindex="1" [style.width.%]="cols.width" (click)="sortOnColHeaderClick(cols, $event)" (keyup.enter)="sortOnColHeaderClick(cols, $event)">

                      <ng-container *ngIf="cols.headerTemplate">
                        <ng-template [ngTemplateOutlet]="cols.headerTemplate" [ngTemplateOutletContext]="{column:cols}"></ng-template>
                      </ng-container>
                      <ng-container *ngIf="!cols.headerTemplate">
                        {{cols.text}} &nbsp;

                      </ng-container>
                      <ng-container *ngIf="this.sortBy==1   && cols.isColumnSort">
                        <amexio-c-icon key="datagrid_arrowup"></amexio-c-icon>
                      </ng-container>
                      <ng-container *ngIf="this.sortBy==2  && cols.isColumnSort">
                        <amexio-c-icon key="datagrid_arrowdown"></amexio-c-icon>
                      </ng-container>
                    </div>
                  </ng-container>
                  <ng-container *ngIf="cols.datatype=='number'">
                    <div class="datatable-col" tabindex="1" [style.width.%]="cols.width" (keyup.enter)="sortOnColHeaderClick(cols, $event)" (click)="sortOnColHeaderClick(cols, $event)">
                      <ng-container *ngIf="cols.headerTemplate">
                        <ng-template [ngTemplateOutlet]="cols.headerTemplate" [ngTemplateOutletContext]="{column:cols}"></ng-template>
                      </ng-container>
                      <ng-container *ngIf="!cols.headerTemplate">
                        <span class="float-right">
                          {{cols.text}} &nbsp;
                          <ng-container *ngIf="this.sortBy==1 && cols.isColumnSort">
                            <amexio-c-icon key="datagrid_arrowup"></amexio-c-icon>
                          </ng-container>
                          <ng-container *ngIf="this.sortBy==2 && cols.isColumnSort">
                            <amexio-c-icon key="datagrid_arrowdown"></amexio-c-icon>
                          </ng-container>
                        </span>
                      </ng-container>
                    </div>
                  </ng-container>
                </ng-container>
              </ng-container>
            </div>
          </div>
        </div>
      </ng-container>

      <!--Group BY datagrid start-->
      <ng-container *ngIf="!groupby">
        <div class="datatable-height {{roundedgeclass}}" [style.height]="height">
          <div class="datatable" role="grid">
            <div style="height: 300px;" *ngIf="mask">
              <div class="spinner"></div>
            </div>
            <ng-container *ngIf="!mask">
              <div #id class="datatable-row" *ngFor="let row of viewRows;let i=index" id="{{'row'+i}}" [ngClass]="{'datatable-row-active':row.isSelected}"
                (click)="onRowClick(row, i)">

                <ng-container *ngIf="enablecheckbox">
                  <div class="datatable-col datatable-checkbox-width checkbox-col">
                    <div class="inputgroup">
                      <div class="input-box">
                        <div (click)="setSelectedRow(row, check)" [class]="row.checkBoxSelectClass" #check>
                          {{((row.checkBoxSelectClass == 'checkbox active') && (check.classList.value == 'checkbox active')) || ((row.checkBoxSelectClass
                          == 'checkbox default') && (check.classList.value == 'checkbox active')) ? '&#10004;' : ''}}
                        </div>
                      </div>
                    </div>
                  </div>
                </ng-container>

                <ng-container *ngFor="let cols of columns;let colIndex = index">
                  <ng-container *ngIf="!cols.hidden">
                    <ng-container *ngIf="cols.datatype=='number'">
                      <div #ref id="{{title}}-{{i+1}}{{colIndex+1}}" class="datatable-col" [attr.tabindex]="(((i+1== 1) && (colIndex + 1 == firstIndex))? 1: tabindex)"
                        [style.width.%]="cols.width" scope="row" [attr.data-label]="cols.text" (keyup.arrowright)="arrowRight(ref)"
                        (keyup.arrowleft)="arrowLeft(ref)" (keyup.arrowdown)="arrowDown(ref)" (keyup.arrowup)="arrowUp(ref)" (keyup.end)="keyEnd(ref)"
                        (keyup.home)="keyHome(ref)" (keyup.control.end)="keyControlEnd()" (keyup.control.home)="keyControlHome()"
                        (keyup.pagedown)="onPageDownClick()" (keyup.pageup)="onPageUpClick()" (keyup.enter)="onRowClick(row, i)"
                        [style.width.%]="cols.width" scope="row" [attr.data-label]="cols.text">
                        <span class="float-right">
                          <ng-container *ngIf="row[cols.dataindex]!= '';else elseBlock">
                            <div (contextmenu)="loadContextMenu($event,row, cols, id)">
                              <amexio-display-field [data]="row" [data-index]="cols.dataindex"></amexio-display-field>
                            </div>
                          </ng-container>
                          <ng-template #elseBlock>
                            &nbsp;
                          </ng-template>
                        </span>
                      </div>
                    </ng-container>
                    <ng-container *ngIf="!cols?.bodyTemplate && (cols.datatype == 'string' || cols.datatype == 'boolean')">
                      <div #ref id="{{title}}-{{i+1}}{{colIndex+1}}" class="datatable-col" [attr.tabindex]="(((i+1== 1) && (colIndex + 1 == firstIndex))? 1: tabindex)"
                        [style.width.%]="cols.width" scope="row" [attr.data-label]="cols.text" (keyup.arrowright)="arrowRight(ref)"
                        (keyup.arrowleft)="arrowLeft(ref)" (keyup.enter)="onRowClick(row, i)" (keyup.arrowdown)="arrowDown(ref)"
                        (keyup.arrowup)="arrowUp(ref)" (keyup.end)="keyEnd(ref)" (keyup.home)="keyHome(ref)" (keyup.control.end)="keyControlEnd()"
                        (keyup.control.home)="keyControlHome()" (keyup.pageup)="onPageUpClick()" (keyup.pagedown)="onPageDownClick()">
                        <div (contextmenu)="loadContextMenu($event,row, cols, id)">
                          <amexio-display-field [data]="row" [data-index]="cols.dataindex"></amexio-display-field>
                        </div>
                        <ng-template #elseBlock>
                          &nbsp;
                        </ng-template>
                      </div>
                    </ng-container>
                    <ng-container *ngIf="cols.bodyTemplate">
                      <div #ref id="{{title}}-{{i+1}}{{colIndex+1}}" class="datatable-col" [attr.tabindex]="(((i+1== 1) && (colIndex + 1 == firstIndex))? 1: tabindex)"
                        [style.width.%]="cols.width" scope="row" [attr.data-label]="cols.text" (keyup.arrowright)="arrowRight(ref)"
                        (keyup.arrowleft)="arrowLeft(ref)" (keyup.arrowdown)="arrowDown(ref)" (keyup.arrowup)="arrowUp(ref)" (keyup.end)="keyEnd(ref)"
                        (keyup.home)="keyHome(ref)" (keyup.control.end)="keyControlEnd()" (keyup.control.home)="keyControlHome()"
                        (keyup.pagedown)="onPageDownClick()" (keyup.pageup)="onPageUpClick()" class="datatable-col" [style.width.%]="cols.width"
                        scope="row" [attr.data-label]="cols.text">
                        <ng-template [ngTemplateOutlet]="cols.bodyTemplate" [ngTemplateOutletContext]="{ $implicit: { text : row[cols.dataindex] }, row: row }"></ng-template>
                      </div>
                    </ng-container>
                  </ng-container>

                </ng-container>
              </div>
            </ng-container>

          </div>
        </div>

      </ng-container>

      <!--Group BY datagrid end-->

      <!--Group BY and Filter Data datagrid start-->
      <ng-container *ngIf="groupby && !enabledatafilter">
        <div class="datatable-height {{roundedgeclass}}" [style.height]="height">
          <div class="datatable" role="grid" style="table-layout: inherit !important;">
            <div style="height: 300px;" *ngIf="mask">
              <div class="spinner"></div>
            </div>
            <ng-container *ngIf="!mask">
              <div class="datatable-row" *ngFor="let row of viewRows;let i=index" id="{{'row'+i}}" [ngClass]="{'datatable-row-active':row.isSelected}"
                (click)="toogle(row, i)">
                <ng-container *ngIf="enablecheckbox">
                  <div class="datatable-col datatable-checkbox-width checkbox-col">
                    <div class="inputgroup">
                      <div class="input-box">
                        <div (click)="selectParent(row)" [class]="row.isSelected ?'checkbox active':'checkbox default'">
                          {{row.isSelected ? '&#10004;' : ''}}
                        </div>
                      </div>
                    </div>
                  </div>
                </ng-container>
                <ng-container *ngFor="let cols of columns;let colIndex = index">
                  <ng-container *ngIf="isGroupChecking(row)">

                    <ng-container *ngIf="colIndex == 0">
                      <div #grpref class="datatable-col col-group" class="datatable-col col-group" id="{{title}}-{{i+1}}{{colIndex+1}}" tabindex="1"
                        (keyup.arrowdown)="arrowDown(grpref)" (keyup.arrowup)="arrowUp(grpref)" (keyup.control.end)="findContolEndGrpBy()"
                        (keyup.control.home)="keyControlHome()" (keyup.enter)="toogle(row, i)">
                        <ng-container *ngIf="!row.expanded">
                          <amexio-c-icon key="datagrid_expand"></amexio-c-icon>
                        </ng-container>
                        <ng-container *ngIf="row.expanded">
                          <amexio-c-icon key="datagrid_collapse"></amexio-c-icon>
                        </ng-container>
                        {{row.group}}
                      </div>
                    </ng-container>

                    <ng-container *ngIf="colIndex != 0">
                      <div class="datatable-col col-hidden">
                      </div>
                    </ng-container>
                  </ng-container>
                  <ng-container *ngIf="!isGroupChecking(row)">
                    <ng-container *ngIf="cols.datatype=='string' || cols.datatype == 'boolean'">
                      <div #grpref id="{{title}}-{{i+1}}{{colIndex+1}}" (keyup.arrowdown)="arrowDown(grpref)" (keyup.arrowup)="arrowUp(grpref)"
                        (keyup.arrowright)="arrowRight(grpref)" (keyup.arrowleft)="arrowLeft(grpref)" (keyup.end)="keyEnd(grpref)"
                        (keyup.home)="keyHome(grpref)" (keyup.control.end)="findContolEndGrpBy()" (keyup.control.home)="keyControlHome()"
                        class="datatable-col" tabindex="1" [style.width.%]="cols.width" [attr.data-label]="cols.text">
                        <ng-container *ngIf="colIndex == 0">
                          <span style="padding-left: 20px">
                            <amexio-display-field [data]="row" [data-index]="cols.dataindex"></amexio-display-field>
                          </span>
                        </ng-container>
                        <ng-container *ngIf="colIndex != 0">
                          <amexio-display-field [data]="row" [data-index]="cols.dataindex"></amexio-display-field>
                        </ng-container>
                      </div>
                    </ng-container>
                    <ng-container *ngIf="cols.datatype=='number'">

                      <div #grpref id="{{title}}-{{i+1}}{{colIndex+1}}" (keyup.arrowdown)="arrowDown(grpref)" (keyup.arrowup)="arrowUp(grpref)"
                        (keyup.arrowright)="arrowRight(grpref)" (keyup.arrowleft)="arrowLeft(grpref)" (keyup.end)="keyEnd(grpref)"
                        (keyup.home)="keyHome(grpref)" (keyup.control.end)="findContolEndGrpBy()" (keyup.control.home)="keyControlHome()"
                        class="datatable-col" tabindex="1" [style.width.%]="cols.width" [attr.data-label]="cols.text">

                        <ng-container *ngIf="colIndex == 0">
                          <span style="padding-left: 20px">
                            <ng-container *ngIf="row[cols.dataindex]!= '' ;else elseBlock">
                              <amexio-display-field [data]="row" [data-index]="cols.dataindex"></amexio-display-field>
                            </ng-container>
                            <ng-template #elseBlock>
                              &nbsp;
                            </ng-template>

                          </span>
                        </ng-container>
                        <ng-container *ngIf="colIndex != 0">
                          <span class="float-right">
                            <ng-container *ngIf="row[cols.dataindex]!= '' ;else elseBlock">
                              <amexio-display-field [data]="row" [data-index]="cols.dataindex"></amexio-display-field>
                            </ng-container>
                            <ng-template #elseBlock>
                              &nbsp;
                            </ng-template>
                          </span>
                        </ng-container>

                      </div>

                    </ng-container>

                  </ng-container>
                </ng-container>
              </div>
            </ng-container>

          </div>
        </div>
      </ng-container>

      <ng-container *ngIf="flag">
        <base-contextmenu [base-context-menu]="contextmenu" [mouse-location-top]="mouseLocation.top" [mouse-location-left]="mouseLocation.left"
          [is-FlagShow]="flag" [right-click-data]="rightClickRowData" (onRightClick)="rightClickDataEmit($event)" [position-up]="posixUp">
        </base-contextmenu>
      </ng-container>

      <!-- Footer of the grid -->
      <div class="footer">
        <ng-container *ngIf="(pagesize && (data && data.length > pagesize)) || (serverSidePaging && totalPages)">
          <amexio-paginator #pageId [server-side-paging]="serverSidePaging" [pages]="totalPages" [rows]="pagesize" (onPageChange)="loadPageData($event)"></amexio-paginator>
        </ng-container>
      </div>
    </div>
  `,
                providers: [CommonDataService],
            },] },
];
/** @nocollapse */
AmexioDatagridComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: CommonDataService },
    { type: ChangeDetectorRef },
    { type: Renderer2 },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
];
AmexioDatagridComponent.propDecorators = {
    title: [{ type: Input }],
    pagesize: [{ type: Input, args: ['page-size',] }],
    httpurl: [{ type: Input, args: ['http-url',] }],
    httpmethod: [{ type: Input, args: ['http-method',] }],
    datareader: [{ type: Input, args: ['data-reader',] }],
    enablecheckbox: [{ type: Input, args: ['enable-checkbox',] }],
    data: [{ type: Input, args: ['data',] }],
    rowSelect: [{ type: Output }],
    selectedRowData: [{ type: Output }],
    onHeaderClick: [{ type: Output }],
    height: [{ type: Input }],
    groupby: [{ type: Input }],
    groupbydataindex: [{ type: Input, args: ['groupby-data-index',] }],
    enabledatafilter: [{ type: Input, args: ['enable-data-filter',] }],
    cclass: [{ type: Input, args: ['c-class',] }],
    tableHeadercclass: [{ type: Input }],
    tableTitlecclass: [{ type: Input }],
    tableDatacclass: [{ type: Input }],
    selectedrowcolor: [{ type: Input, args: ['selected-row-color',] }],
    totalDataCount: [{ type: Input, args: ['total-data-count',] }],
    serverSidePaging: [{ type: Input, args: ['server-side-paging',] }],
    columndefintion: [{ type: Input, args: ['column-defintion',] }],
    enablecolumnfiter: [{ type: Input, args: ['enable-column-fiter',] }],
    enablecolumnfilter: [{ type: Input, args: ['enable-column-filter',] }],
    globalfilter: [{ type: Input, args: ['global-filter',] }],
    contextmenu: [{ type: Input, args: ['context-menu',] }],
    rightClick: [{ type: Output }],
    onPageChange: [{ type: Output }],
    filterRef: [{ type: ViewChildren, args: [DataGridFilterComponent,] }],
    columnRef: [{ type: ContentChildren, args: [AmexioGridColumnComponent,] }],
    pageId: [{ type: ViewChild, args: ['pageId',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/
class AmexioDataGridHeaderComponent {
    constructor() {
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
}
AmexioDataGridHeaderComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-datagrid-header', template: `
    <ng-content></ng-content>
  `,
            },] },
];
/** @nocollapse */
AmexioDataGridHeaderComponent.ctorParameters = () => [];
AmexioDataGridHeaderComponent.propDecorators = {
    padding: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class GoogleMapScriptService {
    /**
     * @param {?} id
     * @return {?}
     */
    loadScript(id) {
        /** @type {?} */
        const script = document.createElement('script');
        script.innerHTML = '';
        script.src = 'https://maps.google.com/maps/api/js?key=' + id;
        script.async = true;
        script.defer = true;
        return script;
    }
    // THIS METHOD IS USED FOR CHEKING SCIRPT IS PRESENT IN BODY OT NOT
    /**
     * @param {?} script
     * @return {?}
     */
    isScriptAlreadyPresent(script) {
        /** @type {?} */
        const scripts = document.getElementsByTagName('script');
        /** @type {?} */
        let isScriptLoaded;
        // tslint:disable-next-line:prefer-for-of
        for (let i = 0; i < scripts.length; i++) {
            /** @type {?} */
            const scriptData = scripts[i];
            if (scriptData.src === script) {
                isScriptLoaded = true;
            }
        }
        return isScriptLoaded;
    }
}
GoogleMapScriptService.decorators = [
    { type: Injectable },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const GOOGLEMAP_CONSTANT = {
    GOOGLE_MAP_URL: 'https://maps.google.com/maps/api/js?key=',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AmexioGoogleMapComponent {
    /**
     * @param {?} el
     * @param {?} differs
     * @param {?} _loadGoogleMapService
     */
    constructor(el, differs, _loadGoogleMapService) {
        this.el = el;
        this._loadGoogleMapService = _loadGoogleMapService;
        this.height = '250px';
        this.minheight = '250px';
        this.width = '100%';
        this.initiallat = 51.507351;
        this.initiallng = -0.127758;
        this.initialzoomlevel = 2;
        this.stockColor = '#FF0000';
        this.fillColor = '#f5f5f5';
        this.fillOpacity = 0.45;
        this.strokeOpacity = 0.6;
        this.onMarkerClick = new EventEmitter();
        this.onReady = new EventEmitter();
        this.differ = differs.find([]).create(null);
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set data(v) {
        if (v) {
            this._data = v;
            this.initalize();
        }
    }
    /**
     * @return {?}
     */
    get data() {
        return this._data;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set coordinates(v) {
        if (v) {
            this._coordinates = v;
        }
    }
    /**
     * @return {?}
     */
    get coordinates() {
        return this._coordinates;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.componentId = +window.crypto.getRandomValues(new Uint32Array(1))[0] + 'google';
        if (this.googlemapkey) {
            /** @type {?} */
            const fullScriptTag = GOOGLEMAP_CONSTANT.GOOGLE_MAP_URL + this.googlemapkey;
            /** @type {?} */
            const isScriptPresent = this._loadGoogleMapService.isScriptAlreadyPresent(fullScriptTag);
            /** @type {?} */
            const options = {
                center: { lat: this.initiallat, lng: this.initiallng },
                zoom: this.initialzoomlevel,
            };
            if (!isScriptPresent) {
                /** @type {?} */
                const script = this._loadGoogleMapService.loadScript(this.googlemapkey);
                this.loadScriptWithMap(script, options);
            }
            else {
                this.loadMap(options);
            }
        }
    }
    // HERE LOAD SCRIPT + MAP
    /**
     * @private
     * @param {?} script
     * @param {?} options
     * @return {?}
     */
    loadScriptWithMap(script, options) {
        if (script != null) {
            /** @type {?} */
            const body = (/** @type {?} */ (document.body));
            script.onload = (/**
             * @return {?}
             */
            () => {
                this.loadMap(options);
            });
            body.appendChild(script);
        }
        else {
            this.loadMap(options);
        }
    }
    // THIS FUNCTION IS LOADING MAP
    /**
     * @private
     * @param {?} options
     * @return {?}
     */
    loadMap(options) {
        this.map = new google.maps.Map(this.el.nativeElement.children[0], options);
        this.onReady.emit({
            map: this.map,
        });
        if (!this.map && this.el.nativeElement.offsetParent) {
            this.infoWindow = new google.maps.InfoWindow();
        }
        this.initalize();
    }
    // INITALIZATION OF DATA AND SEND DATA TO MAP
    /**
     * @return {?}
     */
    initalize() {
        /** @type {?} */
        const flightPlanCoordinates = this.getCoordinates();
        if (flightPlanCoordinates && flightPlanCoordinates.length > 0) {
            /** @type {?} */
            const flightPath = new google.maps.Polygon({
                paths: flightPlanCoordinates,
                strokeColor: this.stockColor,
                strokeOpacity: this.strokeOpacity,
                strokeWeight: 2,
                fillColor: this.fillColor,
                fillOpacity: this.fillOpacity,
            });
            flightPath.setMap(this.map);
        }
        if (this.data && this.map) {
            this.localoverlays = [];
            for (const overlay of this.data) {
                this.localoverlays.push(new google.maps.Marker({
                    position: { lat: overlay.lat, lng: overlay.lng },
                    icon: overlay.icon,
                    title: overlay.title,
                    data: overlay.data,
                }));
            }
            for (const overlay of this.localoverlays) {
                overlay.setMap(this.map);
                this.bindOverlayEvents(overlay);
            }
        }
        /** @type {?} */
        const changes = this.differ.diff(this.localoverlays);
        if (changes && this.map) {
            changes.forEachRemovedItem((/**
             * @param {?} record
             * @return {?}
             */
            (record) => {
                google.maps.event.clearInstanceListeners(record.item);
                record.item.setMap(null);
            }));
        }
    }
    /**
     * @param {?} overlay
     * @return {?}
     */
    bindOverlayEvents(overlay) {
        overlay.addListener('click', (/**
         * @param {?} event
         * @return {?}
         */
        (event) => {
            this.onMarkerClick.emit(overlay.data);
            if (overlay && overlay.title && this.infoWindow) {
                this.infoWindow.setContent('<div>' + overlay.title + '</div>');
                this.infoWindow.open(this.map, overlay);
            }
        }));
    }
    /**
     * @return {?}
     */
    getMap() {
        return this.map;
    }
    // TO GET COORDINATES
    /**
     * @return {?}
     */
    getCoordinates() {
        /** @type {?} */
        const flightPlanCoordinates = [];
        if (this._coordinates && this._coordinates.length > 0) {
            for (const co of this._coordinates) {
                /** @type {?} */
                const str = co.split(' ', 2);
                if (str && str.length === 2) {
                    flightPlanCoordinates.push({
                        lat: parseFloat(str[0]),
                        lng: parseFloat(str[1]),
                    });
                }
                else {
                    console.log('Wrong Lat-Long format ' + co);
                }
            }
        }
        return flightPlanCoordinates;
    }
}
AmexioGoogleMapComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-google-map',
                template: `
    <div [style.width]="width" [style.height]="height" [style.min-height]="minheight"></div>
  `,
            },] },
];
/** @nocollapse */
AmexioGoogleMapComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: IterableDiffers },
    { type: GoogleMapScriptService }
];
AmexioGoogleMapComponent.propDecorators = {
    googlemapkey: [{ type: Input, args: ['google-map-key',] }],
    style: [{ type: Input }],
    height: [{ type: Input }],
    minheight: [{ type: Input, args: ['min-height',] }],
    width: [{ type: Input }],
    initiallat: [{ type: Input, args: ['initial-lat',] }],
    initiallng: [{ type: Input, args: ['initial-lng',] }],
    initialzoomlevel: [{ type: Input, args: ['initial-zoom-level',] }],
    stockColor: [{ type: Input, args: ['stroke-color',] }],
    fillColor: [{ type: Input, args: ['fill-color',] }],
    fillOpacity: [{ type: Input, args: ['fill-opacity',] }],
    strokeOpacity: [{ type: Input, args: ['stroke-opacity',] }],
    onMarkerClick: [{ type: Output }],
    onReady: [{ type: Output }],
    data: [{ type: Input, args: ['data',] }],
    coordinates: [{ type: Input, args: ['co-ordinates',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Created by pratik on 27/12/17.
 */
/*
Component Name : Amexio item selector
Component Selector : <amexio-item-selector>
Component Description : ItemSelector is a specialized MultiSelect
field that renders as a pair of MultiSelect field, one with available options
and the other with selected options. A set of buttons in between allows items to be
moved between the fields and reordered within the selection.
*/
class AmexioItemSelectorComponent {
    /**
     * @param {?} itemSelectorService
     */
    constructor(itemSelectorService) {
        this.itemSelectorService = itemSelectorService;
        this.mask = true;
        /*
           Properties
           name : enable-drop
           datatype : boolean
           version : 5.0.0 onwards
           default : false
           description : any node can be dropped in the selector structure
           */
        this.enabledrop = false;
        /*
           Properties
           name : across-itemselector
           datatype : boolean
           version : 5.0.0 onwards
           default : false
           description : Dragging and dropping is possible across list.
           */
        this.acrossitemselector = false;
        /*
           Events
           name : availableRecords
           datatype : none
           version : none
           default : none
           description :  Get available values objects.
           */
        this.availableRecords = new EventEmitter();
        /*
           Events
           name : selectedRecords
           datatype : none
           version : none
           default : none
           description :  Get selected value Object.
           */
        this.selectedRecords = new EventEmitter();
        this.onDrag = new EventEmitter(); // Emits at drag
        // Emits at drag
        this.dragover = new EventEmitter(); // Emits at drag over
        this.selectedData = [];
        this.leftactive = true;
        this.rightactive = true;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set data(value) {
        this._data = value;
        if (this.componentLoaded) {
            this.updateComponent();
        }
    }
    /**
     * @return {?}
     */
    get data() {
        return this._data;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.httpmethod && this.httpurl) {
            this.itemSelectorService.fetchData(this.httpurl, this.httpmethod).subscribe((/**
             * @param {?} response
             * @return {?}
             */
            (response) => {
                this.response = response;
            }), (/**
             * @param {?} error
             * @return {?}
             */
            (error) => {
            }), (/**
             * @return {?}
             */
            () => {
                this.setData(this.response);
            }));
        }
        else if (this.data) {
            this.previousValue = JSON.parse(JSON.stringify(this.data));
            this.setData(this.data);
        }
        this.componentLoaded = true;
    }
    /**
     * @return {?}
     */
    updateComponent() {
        if (JSON.stringify(this.previousValue) !== JSON.stringify(this.data)) {
            this.previousValue = JSON.parse(JSON.stringify(this.data));
            this.setData(this.data);
        }
    }
    /**
     * @param {?} httpResponse
     * @return {?}
     */
    setData(httpResponse) {
        /** @type {?} */
        let responsedata = httpResponse;
        if (this.datareader != null) {
            /** @type {?} */
            const dr = this.datareader.split('.');
            for (const ir of dr) {
                responsedata = responsedata[ir];
            }
            responsedata.forEach((/**
             * @param {?} option
             * @param {?} index
             * @return {?}
             */
            (option, index) => {
                if (!option['isSelected']) {
                    option['isSelected'] = false;
                }
            }));
        }
        else {
            responsedata = httpResponse;
        }
        this.availableData = responsedata;
        this.generateIndex(this.availableData);
        this.mask = false;
    }
    /**
     * @param {?} getAvailableData
     * @return {?}
     */
    generateIndex(getAvailableData) {
        if (getAvailableData) {
            getAvailableData.forEach((/**
             * @param {?} element
             * @param {?} index
             * @return {?}
             */
            (element, index) => {
                element['id'] = 'itemselector' + window.crypto.getRandomValues(new Uint32Array(1))[0];
            }));
        }
    }
    /**
     * @param {?} data
     * @param {?} index
     * @param {?} left
     * @param {?} right
     * @return {?}
     */
    itemClick(data, index, left, right) {
        this.leftactive = left;
        this.rightactive = right;
        this.switchingObject = data;
        this.objectIndex = index;
        for (const ir of this.availableData) {
            if ((ir)[this.valuefield] === data[this.valuefield]) {
                ir['isSelected'] = true;
            }
            else {
                ir['isSelected'] = false;
            }
        }
        if (right) {
            for (const ir of this.selectedData) {
                if ((ir)[this.valuefield] === data[this.valuefield]) {
                    ir['selectedClick'] = true;
                }
                else {
                    ir['selectedClick'] = false;
                }
            }
        }
    }
    /**
     * @param {?} dragData
     * @return {?}
     */
    dataFormLeftToRightMove(dragData) {
        this.itemClick(dragData.data, dragData.index, true, false);
        /** @type {?} */
        let currentNode;
        if (this.availableData && this.availableData.length !== 1) {
            this.availableData.forEach((/**
             * @param {?} element
             * @param {?} index
             * @return {?}
             */
            (element, index) => {
                if (element.id && dragData.data.id) {
                    if (element.id === dragData.data.id) {
                        currentNode = index - 1;
                    }
                    if (index === 0) {
                        currentNode = index + 1;
                    }
                }
            }));
            /** @type {?} */
            const focusId = (this.availableData[currentNode]);
            document.getElementById(focusId['id']).focus();
        }
        this.rightSwitch();
    }
    /**
     * @param {?} focus
     * @return {?}
     */
    enterFocus(focus) {
        this.itemClick(focus.data, focus.index, false, true);
    }
    /**
     * @param {?} dragData
     * @return {?}
     */
    shiftFocusMethod(dragData) {
        /** @type {?} */
        let currentIndex;
        if (this.selectedData && this.selectedData.length > 0) {
            this.selectedData.forEach((/**
             * @param {?} element
             * @param {?} index
             * @return {?}
             */
            (element, index) => {
                if (element.id === dragData.data.id) {
                    currentIndex = index - 1;
                }
                if (index === 0) {
                    currentIndex = index + 1;
                }
            }));
        }
        /** @type {?} */
        const focusId = (this.selectedData[currentIndex]);
        document.getElementById(focusId['id']).focus();
    }
    /**
     * @param {?} event
     * @param {?} index
     * @return {?}
     */
    downArrowPress(event, index) {
        if (this.availableData[index] === 0) {
            this.focusDetectionOnAvailableData(event, index);
        }
        else {
            /** @type {?} */
            const nextitem = this.availableData[index + 1];
            document.getElementById(nextitem['id']).focus();
        }
    }
    /**
     * @param {?} event
     * @param {?} index
     * @return {?}
     */
    upArrowPress(event, index) {
        if (this.availableData[index] === 0) {
            this.focusDetectionOnAvailableData(event, index);
        }
        else {
            /** @type {?} */
            const nextitem = this.availableData[index - 1];
            document.getElementById(nextitem['id']).focus();
        }
    }
    /**
     * @param {?} event
     * @param {?} index
     * @return {?}
     */
    downSwitchOnTab(event, index) {
        if (this.selectedData[index] === 0) {
            this.focusDetectionOnSelected(event, index);
        }
        else {
            /** @type {?} */
            const nextitem = this.selectedData[index + 1];
            document.getElementById(nextitem['id']).focus();
        }
    }
    /**
     * @param {?} event
     * @param {?} index
     * @return {?}
     */
    upSwitchOnTab(event, index) {
        if (this.selectedData[index] === 0) {
            this.focusDetectionOnSelected(event, index);
        }
        else {
            /** @type {?} */
            const nextitem = this.selectedData[index - 1];
            document.getElementById(nextitem['id']).focus();
        }
    }
    /**
     * @param {?} event
     * @param {?} index
     * @return {?}
     */
    focusDetectionOnAvailableData(event, index) {
        /** @type {?} */
        const nextitem = this.availableData[0];
        document.getElementById(nextitem['id']).focus();
    }
    /**
     * @param {?} event
     * @param {?} index
     * @return {?}
     */
    focusDetectionOnSelected(event, index) {
        /** @type {?} */
        const nextitem = this.selectedData[0];
        document.getElementById(nextitem['id']).focus();
    }
    /**
     * @return {?}
     */
    rightSwitch() {
        this.selectedData.forEach((/**
         * @param {?} element
         * @return {?}
         */
        (element) => {
            this.dragDropValidation(element);
        }));
        if (this.switchingObject != null && this.switchingObject.hasOwnProperty('isSelected') && this.switchingObject['isSelected']) {
            this.selectedData.push(this.switchingObject);
            this.selectedData[0]['selectedClick'] = true;
            this.switchingObject['isSelected'] = true;
            this.availableData.forEach((/**
             * @param {?} option
             * @param {?} index
             * @return {?}
             */
            (option, index) => {
                if (option['isSelected']) {
                    this.availableData.splice(index, 1);
                    option['selectedClick'] = false;
                }
            }));
            this.switchingObject = null;
            this.dataEmitter();
        }
    }
    /**
     * @param {?} element
     * @return {?}
     */
    dragDropValidation(element) {
        if (this.switchingObject === element) {
            this.switchingObject.isSelected = false;
        }
    }
    /**
     * @return {?}
     */
    leftSwitch() {
        this.setLeftSwitch();
    }
    // Method called in left switch if flag is false
    /**
     * @private
     * @return {?}
     */
    setLeftSwitch() {
        /** @type {?} */
        const flag = false;
        this.availableData.forEach((/**
         * @param {?} element
         * @return {?}
         */
        (element) => {
            this.dragDropValidation(element);
        }));
        if (!flag && this.switchingObject != null && this.switchingObject.hasOwnProperty('isSelected') && this.switchingObject['isSelected']) {
            this.availableData.push(this.switchingObject);
            this.switchingObject['isSelected'] = false;
            this.selectedData.forEach((/**
             * @param {?} option
             * @param {?} index
             * @return {?}
             */
            (option, index) => {
                if (!option['isSelected']) {
                    this.selectedData.splice(index, 1);
                }
            }));
            this.switchingObject = null;
            this.dataEmitter();
        }
    }
    /**
     * @return {?}
     */
    upSwitch() {
        if (this.switchingObject != null && this.switchingObject.hasOwnProperty('isSelected') && this.switchingObject['isSelected']) {
            this.selectedData.forEach((/**
             * @param {?} opt
             * @param {?} i
             * @return {?}
             */
            (opt, i) => {
                this.getIndexObject(opt, i);
            }));
            if (this.objectIndex !== 0) {
                /** @type {?} */
                const index = this.selectedData[this.objectIndex];
                this.selectedData[this.objectIndex] = this.selectedData[this.objectIndex - 1];
                this.selectedData[this.objectIndex - 1] = index;
                this.dataEmitter();
            }
        }
    }
    /**
     * @return {?}
     */
    downSwitch() {
        if (this.switchingObject != null && this.switchingObject.hasOwnProperty('isSelected') && this.switchingObject['isSelected']) {
            this.selectedData.forEach((/**
             * @param {?} opt
             * @param {?} i
             * @return {?}
             */
            (opt, i) => {
                this.getIndexObject(opt, i);
            }));
            if (this.selectedData.length - 1 !== this.objectIndex) {
                /** @type {?} */
                const index = this.selectedData[this.objectIndex];
                this.selectedData[this.objectIndex] = this.selectedData[this.objectIndex + 1];
                this.selectedData[this.objectIndex + 1] = index;
                this.dataEmitter();
            }
        }
    }
    /**
     * @return {?}
     */
    moveTop() {
        /** @type {?} */
        const tempArray = [];
        if (this.switchingObject != null && this.switchingObject['isSelected']) {
            this.selectedData.forEach((/**
             * @param {?} opt
             * @param {?} i
             * @return {?}
             */
            (opt, i) => {
                this.getIndexObject(opt, i);
            }));
            if (this.selectedData.length > 1) {
                tempArray[0] = this.selectedData[this.objectIndex];
                this.selectedData.splice(this.objectIndex, 1);
                this.selectedData.forEach((/**
                 * @param {?} option
                 * @return {?}
                 */
                (option) => {
                    tempArray.push(option);
                }));
                this.selectedData = tempArray;
                this.dataEmitter();
            }
        }
    }
    /**
     * @return {?}
     */
    moveBottom() {
        if (this.switchingObject != null && this.switchingObject.hasOwnProperty('isSelected')) {
            this.selectedData.forEach((/**
             * @param {?} opt
             * @param {?} i
             * @return {?}
             */
            (opt, i) => {
                this.getIndexObject(opt, i);
            }));
            if (this.switchingObject['isSelected'] && this.selectedData.length > 1) {
                this.selectedData.splice(this.objectIndex, 1);
                this.selectedData[this.selectedData.length] = this.switchingObject;
            }
        }
        this.dataEmitter();
    }
    /**
     * @return {?}
     */
    dataEmitter() {
        this.availableRecords.emit(this.availableData);
        this.selectedRecords.emit(this.selectedData);
    }
    /**
     * @param {?} opt
     * @param {?} i
     * @return {?}
     */
    getIndexObject(opt, i) {
        if (opt[this.valuefield] === this.switchingObject[this.valuefield]) {
            this.objectIndex = i;
        }
    }
    // Method to drag parent with node
    /**
     * @param {?} dragData
     * @return {?}
     */
    onDragStartLeft(dragData) {
        if (!this.acrossitemselector) {
            this.itemClick(dragData.data, dragData.index, true, false);
        }
        else {
            dragData.event.dataTransfer.setData('itemnodedata', JSON.stringify(dragData.data));
            this.onDrag.emit(dragData);
        }
    }
    /**
     * @param {?} dragData
     * @return {?}
     */
    onDragStartRight(dragData) {
        if (!this.acrossitemselector) {
            this.itemClick(dragData.data, dragData.index, false, true);
        }
        else {
            dragData.event.dataTransfer.setData('itemnodedata', JSON.stringify(dragData.data));
            this.onDrag.emit(dragData);
        }
    }
    /**
     * @param {?} dragOverData
     * @return {?}
     */
    allowDrop(dragOverData) {
        dragOverData.event.preventDefault();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    dropRight(event) {
        if (this.enabledrop) {
            this.rightSwitch();
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    dropLeft(event) {
        if (this.enabledrop) {
            this.leftSwitch();
        }
    }
}
AmexioItemSelectorComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-item-selector', template: `
    <amexio-row>
        <amexio-column [size]="'45pt'">
            <amexio-card [header]="true">
                <amexio-header>Available</amexio-header>
                <amexio-body>
                    <div style="height: 220px;" *ngIf="mask">
                        <div class="spinner"></div>
                    </div>
                    <div tabindex="1" role="listbox" [style.height.px]="height" (dragover)="allowDrop({event:$event,data:data})" (drop)="dropLeft($event)"
                        *ngIf="!mask" style="overflow: auto;outline: none;">
                        <div id="{{data.id}}" tabindex="1" role="option"
                         (keyup.enter)="dataFormLeftToRightMove({event:$event,data:data,index:i})"
                         (keyup.arrowdown)="downArrowPress($event,i)" 
                        (keyup.arrowup)="upArrowPress($event,i)"
                            class="itemselector-list" [ngClass]="data['isSelected'] ? 'itemselector-list-active':''" *ngFor="let data of availableData; let i = index"
                            (click)="itemClick(data,i, true,false)" [attr.draggable]="enabledrag" (dragstart)="onDragStartLeft({event:$event,data:data,index:i})">
                            {{data[displayfield]}}
                        </div>
                    </div>
                </amexio-body>
            </amexio-card>
        </amexio-column>


        <amexio-column [size]="'10pt'">

            <div class="item-selector-action-panel">

                <amexio-card [header]="true">
                    <amexio-header>&nbsp;</amexio-header>
                    <amexio-body>

                        <div class="actionbar">
                            <div [style.height.px]="height" class="actionbarinner">
                                <div tabindex="1" (keyup.enter)="moveTop()" [ngClass]="{'actiondisable':!rightactive}"
                                    (click)="moveTop()" class="action movetop ">
                                    <amexio-c-icon key="itemselector_caretup"></amexio-c-icon>
                                </div>
                                <div tabindex="1" (keyup.enter)="upSwitch()" [ngClass]="{'actiondisable':!rightactive}"
                                    (click)="upSwitch()" class="action moveup">
                                    <amexio-c-icon key="itemselector_arrowup"></amexio-c-icon>
                                </div>
                                <div tabindex="1" (keyup.enter)="leftSwitch()" [ngClass]="{'actiondisable':!rightactive}"
                                    (click)="leftSwitch()" class="action moveleft">
                                    <amexio-c-icon key="itemselector_arrowleft"></amexio-c-icon>
                                </div>
                                <div tabindex="1" (keyup.enter)="rightSwitch()" [ngClass]="{'actiondisable':!leftactive}"
                                    (click)="rightSwitch()" class="action moveright">
                                    <amexio-c-icon key="itemselector_arrowright"></amexio-c-icon>
                                </div>
                                <div tabindex="1" (keyup.enter)="downSwitch()" [ngClass]="{'actiondisable':!rightactive}"
                                    (click)="downSwitch()" class="action movedown">
                                    <amexio-c-icon key="itemselector_arrowdown"></amexio-c-icon>
                                </div>
                                <div tabindex="1" (keyup.enter)="moveBottom()" [ngClass]="{'actiondisable':!rightactive}"
                                    (click)="moveBottom()" class="action movebottom">
                                    <amexio-c-icon key="itemselector_caretdown"></amexio-c-icon>
                                </div>
                            </div>
                        </div>
                    </amexio-body>
                </amexio-card>
            </div>

        </amexio-column>

        <amexio-column [size]="'45pt'">
            <amexio-card [header]="true">
                <amexio-header>Selected</amexio-header>
                <amexio-body>
                    <div role="listbox" [style.height.px]="height" style="overflow: auto" (dragover)="allowDrop({event:$event,data:data})"
                        (drop)="dropRight($event)">
                        <div [attr.tabindex]="data['selectedClick'] ? 2 : -1" role="option" contenteditable="false"
                            (keyup.enter)="enterFocus({event:$event,data:data,index:i})" id="{{data.id}}" [attr.draggable]="enabledrag"
                            (keyup.arrowdown)="downSwitchOnTab($event,i)" (keyup.arrowup)="upSwitchOnTab( $event,i)" class="itemselector-list"
                            *ngFor="let data of selectedData; let i = index" (click)="itemClick(data,i, false,true)"
                            [ngClass]="data['selectedClick'] ? 'itemselector-list-active':''" (dragstart)="onDragStartRight({event:$event,data:data,index:i})">
                            <label>
                                {{data[displayfield]}}

                            </label>
                        </div>
                    </div>
                </amexio-body>
            </amexio-card>
        </amexio-column>
    </amexio-row>
  `,
            },] },
];
/** @nocollapse */
AmexioItemSelectorComponent.ctorParameters = () => [
    { type: CommonDataService }
];
AmexioItemSelectorComponent.propDecorators = {
    data: [{ type: Input, args: ['data',] }],
    height: [{ type: Input }],
    datareader: [{ type: Input, args: ['data-reader',] }],
    httpmethod: [{ type: Input, args: ['http-method',] }],
    httpurl: [{ type: Input, args: ['http-url',] }],
    displayfield: [{ type: Input, args: ['display-field',] }],
    valuefield: [{ type: Input, args: ['value-field',] }],
    enabledrag: [{ type: Input, args: ['enable-drag',] }],
    enabledrop: [{ type: Input, args: ['enable-drop',] }],
    acrossitemselector: [{ type: Input, args: ['across-itemselector',] }],
    availableRecords: [{ type: Output }],
    selectedRecords: [{ type: Output }],
    onDrag: [{ type: Output }],
    dragover: [{ type: Output }],
    dragData: [{ type: Input }],
    parentRef: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Created by ketangote on 11/22/17.
 */
/*
Component Name : Amexio listbox
Component Selector : <amexio-listbox>
Component Description : Simple list box which allows user to select one of
more items from list based on configuration. User can provide custom template to
change look and feel.
*/
class AmexioListBoxComponent extends LifeCycleBaseComponent {
    /**
     * @param {?} dataService
     * @param {?} renderer
     */
    constructor(dataService, renderer) {
        super();
        this.dataService = dataService;
        this.renderer = renderer;
        /*
        Properties
        name : enable-header
        datatype : boolean
        version : 4.2.4 onwards
        default : true
        description : User can disabled header of listbox to false..
        */
        this.enableHeader = true;
        /*
        Events
        name : selectedRows
        datatype : none
        version : none
        default : none
        description : It will fire only on selection of checkbox and gives you selected record data.
        */
        this.selectedRows = new EventEmitter();
        /*
        Events
        name : onRowClick
        datatype : none
        version : none
        default : none
        description : It will gives you row clicked data.
        */
        this.onRowClick = new EventEmitter();
        /*
          Events
          name : rightClick
          datatype : none
          version : 5.0.1
          default : none
          description : It will gives you row clicked data.
          */
        this.rightClick = new EventEmitter();
        this.filterText = '';
        this.selectAll = false;
        this.maskloader = true;
        this.ishoverselected = true;
        this.mouseLocation = { left: 0, top: 0 };
        this.activedescendant = 'aria-activedescendant';
        this.flag = false;
        this.prevlistindex = -1;
        this.listindex = -1;
        this.filter = false;
        this.enablecheckbox = false;
        this.selectedData = [];
        this.searchplaceholder = 'Search';
        this.flag = true;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set data(value) {
        this._data = value;
        if (this.componentLoaded) {
            this.updateComponent();
        }
    }
    /**
     * @return {?}
     */
    get data() {
        return this._data;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.httpmethod && this.httpurl) {
            this.dataService.fetchData(this.httpurl, this.httpmethod).subscribe((/**
             * @param {?} response
             * @return {?}
             */
            (response) => {
                this.response = response;
            }), (/**
             * @param {?} error
             * @return {?}
             */
            (error) => {
            }), (/**
             * @return {?}
             */
            () => {
                this.setData(this.response);
            }));
        }
        else if (this.data) {
            this.previousData = JSON.parse(JSON.stringify(this.data));
            this.setData(this.data);
        }
        this.componentLoaded = true;
        this.componentId = 'listbox' + window.crypto.getRandomValues(new Uint32Array(1))[0];
        this.listenListboxOutClick();
    }
    /**
     * @return {?}
     */
    listenListboxOutClick() {
        this.documentClickListener = this.renderer
            .listen('document', 'click', (/**
         * @param {?} event
         * @return {?}
         */
        (event) => {
            if (this.viewData && this.viewData.length > 0) {
                this.viewData.forEach((/**
                 * @param {?} element
                 * @param {?} index
                 * @return {?}
                 */
                (element, index) => {
                    if (this.prevlistindex !== -1 && this.viewData[this.prevlistindex].hasOwnProperty('ishoverselected')
                        && this.viewData[this.prevlistindex]['ishoverselected'] === true) {
                        this.viewData[this.prevlistindex]['ishoverselected'] = false;
                        this.prevlistindex = -1;
                        this.listindex = -1;
                    }
                }));
            }
        }));
    }
    /**
     * @return {?}
     */
    onArrowdown() {
        if (this.prevlistindex > -1) {
            this.viewData[this.prevlistindex]['ishoverselected'] = false;
        }
        this.listindex++;
        this.prevlistindex = this.listindex;
        if (this.listindex >= this.viewData.length) {
            this.listindex = 0;
            this.prevlistindex = 0;
        }
        this.viewData[this.listindex]['ishoverselected'] = true;
        if (this.viewData[this.listindex]['ishoverselected']) {
            /** @type {?} */
            const divid = document.getElementById(this.componentId);
            divid.setAttribute(this.activedescendant, this.viewData[this.listindex].index);
        }
    }
    /**
     * @return {?}
     */
    onArrowUp() {
        if (this.prevlistindex > -1) {
            this.viewData[this.prevlistindex]['ishoverselected'] = false;
        }
        this.prevlistindex--;
        if (this.prevlistindex === -1) {
            this.prevlistindex = this.viewData.length - 1;
            this.listindex = -1;
        }
        this.viewData[this.prevlistindex]['ishoverselected'] = true;
        if (this.viewData[this.prevlistindex]['ishoverselected']) {
            /** @type {?} */
            const divid = document.getElementById(this.componentId);
            divid.setAttribute(this.activedescendant, this.viewData[this.prevlistindex].index);
        }
        if (this.prevlistindex === 0) {
            this.listindex = 0;
        }
    }
    /**
     * @return {?}
     */
    onEnterPress() {
        this.viewData.forEach((/**
         * @param {?} element
         * @param {?} index
         * @return {?}
         */
        (element, index) => {
            if (element.ishoverselected === true) {
                if (element.isSelected === true) {
                    element.isSelected = false;
                }
                else {
                    element.isSelected = true;
                }
            }
        }));
    }
    /**
     * @return {?}
     */
    updateComponent() {
        if (JSON.stringify(this.previousData) !== JSON.stringify(this.data)) {
            this.previousData = JSON.parse(JSON.stringify(this.data));
            this.setData(this.data);
        }
    }
    /**
     * @param {?} httpResponse
     * @return {?}
     */
    setData(httpResponse) {
        /** @type {?} */
        let responsedata = httpResponse;
        if (this.datareader) {
            /** @type {?} */
            const dr = this.datareader.split('.');
            for (const ir of dr) {
                responsedata = responsedata[ir];
            }
        }
        else {
            responsedata = httpResponse;
        }
        this.viewData = responsedata;
        this.setSelectedFlag(this.viewData);
        this.onSelectClick(this.viewData);
        this.orgData = JSON.parse(JSON.stringify(this.viewData));
    }
    /**
     * @param {?} viewRows
     * @return {?}
     */
    onSelectClick(viewRows) {
        this.viewData.forEach((/**
         * @param {?} elem
         * @return {?}
         */
        (elem) => {
            elem['onClickFlag'] = false;
        }));
    }
    /**
     * @param {?} viewRows
     * @return {?}
     */
    setSelectedFlag(viewRows) {
        viewRows.forEach((/**
         * @param {?} row
         * @param {?} index
         * @return {?}
         */
        (row, index) => {
            if (!row.hasOwnProperty('isSelected')) {
                row['isSelected'] = false;
            }
            row['index'] = 'listbox' + window.crypto.getRandomValues(new Uint32Array(1))[0] + index;
        }));
        this.maskloader = false;
    }
    /**
     * @return {?}
     */
    filterData() {
        /** @type {?} */
        const tData = JSON.parse(JSON.stringify(this.orgData));
        /** @type {?} */
        const nodes = this.searchTree(tData, this.filterText);
        this.viewData = nodes;
    }
    /**
     * @param {?} data
     * @param {?} matchingTitle
     * @return {?}
     */
    searchTree(data, matchingTitle) {
        /** @type {?} */
        const disp = this.displayfield;
        return data.filter((/**
         * @param {?} node
         * @return {?}
         */
        function f(node) {
            if (node[disp] && node[disp].toLowerCase().startsWith(matchingTitle.toLowerCase())) {
                return true;
            }
            if (node.children) {
                return (node.children = node.children.filter(f)).length;
            }
        }));
        // return res;
    }
    /**
     * @param {?} rowData
     * @return {?}
     */
    selectedCheckBox(rowData) {
        rowData.isSelected = !rowData.isSelected;
        this.selectedData = [];
        this.viewData.forEach((/**
         * @param {?} node
         * @return {?}
         */
        (node) => {
            if (node.isSelected) {
                this.selectedData.push(node);
            }
        }));
        /** @type {?} */
        const tempData = JSON.parse(JSON.stringify(rowData));
        delete tempData['index'];
        delete tempData['onClickFlag'];
        delete tempData['isSelected'];
        this.selectedRows.emit(tempData);
    }
    /**
     * @return {?}
     */
    selectAllRecord() {
        this.selectedData = [];
        this.selectAll = !this.selectAll;
        if (this.selectAll) {
            this.viewData.forEach((/**
             * @param {?} node
             * @return {?}
             */
            (node) => {
                node.isSelected = true;
            }));
            this.selectedData = this.viewData;
        }
        else {
            this.viewData.forEach((/**
             * @param {?} node
             * @return {?}
             */
            (node) => {
                node.isSelected = false;
            }));
        }
        this.selectedRows.emit(this.selectedData);
    }
    /**
     * @param {?} data
     * @return {?}
     */
    onClick(data) {
        if (!this.enablecheckbox) {
            this.viewData.forEach((/**
             * @param {?} elem
             * @return {?}
             */
            (elem) => {
                elem.onClickFlag = false;
            }));
            this.viewData.forEach((/**
             * @param {?} ele
             * @return {?}
             */
            (ele) => {
                if (ele.index === data.index) {
                    ele.onClickFlag = true;
                }
            }));
        }
        /** @type {?} */
        const tempData = JSON.parse(JSON.stringify(data));
        delete tempData['index'];
        delete tempData['onClickFlag'];
        delete tempData['isSelected'];
        this.onRowClick.emit(tempData);
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
    }
    /**
     * @param {?} event
     * @param {?} row
     * @param {?} id
     * @return {?}
     */
    loadContextMenu(event, row, id) {
        if (this.contextmenu && this.contextmenu.length > 0) {
            this.tempSelectedFlag(this.viewData);
            this.mouseLocation.left = event.clientX;
            this.mouseLocation.top = event.clientY;
            row.isSelected = true;
            this.getContextMenu();
            this.posixUp = this.getListPosition(id);
            event.preventDefault();
            event.stopPropagation();
            this.rightClickRowData = row;
        }
    }
    // getcontextmenu
    /**
     * @return {?}
     */
    getContextMenu() {
        if (this.contextmenu && this.contextmenu.length > 0) {
            this.contextMenuFlag = true;
            this.addListner();
        }
    }
    /**
     * @param {?} rows
     * @return {?}
     */
    tempSelectedFlag(rows) {
        rows.forEach((/**
         * @param {?} row
         * @return {?}
         */
        (row) => {
            if (row.isSelected) {
                row.isSelected = false;
            }
        }));
    }
    /**
     * @param {?} elementRef
     * @return {?}
     */
    getListPosition(elementRef) {
        /** @type {?} */
        const height = 240;
        if ((window.screen.height - elementRef.getBoundingClientRect().bottom) < height) {
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * @param {?} Data
     * @return {?}
     */
    rightClickDataEmit(Data) {
        this.rightClick.emit(Data);
    }
    /**
     * @return {?}
     */
    addListner() {
        this.globalClickListenFunc = this.renderer.listen('document', 'click', (/**
         * @param {?} e
         * @return {?}
         */
        (e) => {
            this.contextMenuFlag = false;
            if (!this.contextMenuFlag) {
                this.removeListner();
            }
        }));
    }
    /**
     * @return {?}
     */
    removeListner() {
        if (this.globalClickListenFunc) {
            this.globalClickListenFunc();
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.removeListner();
    }
}
AmexioListBoxComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-listbox', template: `
    <div class="listbox {{roundedgeclass}}" [style.border]="border">
      <div *ngIf="enableHeader" class="header" style="display: flex; justify-content: space-between">
        <div style="display: flex;justify-content: flex-start;">
          <div role="checkbox" tabindex="0" *ngIf="enablecheckbox" (keyup.enter)="selectAllRecord()" class="input-box">
            <div *ngIf="!selectAll" (click)="selectAllRecord()" class="checkbox default"></div>
            <div *ngIf="selectAll" (click)="selectAllRecord()" class="checkbox active">&#10004;</div>
          </div>
          <div tabindex="0" attr.aria-label="{{header}} list" class="title">&nbsp;&nbsp;{{header}}</div>
        </div>

        <div *ngIf="(filter == true)">
          <input type="text" [(ngModel)]="filterText" [placeholder]="searchplaceholder" (keyup)="filterData()" class="search " />
        </div>
      </div>
      <div class="listbox-height" tabindex="0" (keyup.arrowdown)="onArrowdown()" (keyup.arrowup)="onArrowUp()"
        (keyup.enter)="onEnterPress()" [style.height.px]="height">
        <ul id="{{componentId}}" tabindex="0" role="listbox" class="list" [ngClass]="{'loading-mask' : maskloader}">
          <li #id role="option" [attr.aria-selected]="row.isSelected"
           class="list-items" *ngFor="let row of viewData let rowno = index "
            [ngClass]="{'tree-node-label-selected':row.isSelected ,
            'list-box-items':row.ishoverselected, 'list-items-click': row.onClickFlag,
            'tree-node-label-not-selected':row.isSelected==false}"
            id="{{row.index}}">
            <div (click)="onClick(row)" (contextmenu)="loadContextMenu($event,row, id)">
              <ng-container *ngIf="enablecheckbox">
                <div class="inputgroup" style="float: left; height: 100%;">
                  <div class="input-box">
                    <div role="checkbox" [attr.checked]="row.isSelected" (click)="selectedCheckBox(row)" [class]="row.isSelected ?'checkbox active':'checkbox default'">
                      {{row.isSelected ? '&#10004;' : ''}}
                    </div>
                  </div>
                </div>&nbsp;
              </ng-container>
              <ng-container *ngIf="!bodyTemplate"> {{row[displayfield]}}</ng-container>
              <ng-template *ngIf="bodyTemplate" [ngTemplateOutlet]="bodyTemplate" [ngTemplateOutletContext]="{ row: row }"></ng-template>
            </div>
          </li>
        </ul>
      </div>
    </div>
    <ng-container *ngIf="contextMenuFlag">
      <base-contextmenu [base-context-menu]="contextmenu" [mouse-location-top]="mouseLocation.top" [mouse-location-left]="mouseLocation.left"
        [is-FlagShow]="contextMenuFlag" [right-click-data]="rightClickRowData" (onRightClick)="rightClickDataEmit($event)"
        [position-up]="posixUp">
      </base-contextmenu>
    </ng-container>
  `,
            },] },
];
/** @nocollapse */
AmexioListBoxComponent.ctorParameters = () => [
    { type: CommonDataService },
    { type: Renderer2 }
];
AmexioListBoxComponent.propDecorators = {
    enablecheckbox: [{ type: Input, args: ['enable-checkbox',] }],
    header: [{ type: Input }],
    enableHeader: [{ type: Input, args: ['enable-header',] }],
    searchplaceholder: [{ type: Input, args: ['search-placeholder',] }],
    filter: [{ type: Input }],
    data: [{ type: Input, args: ['data',] }],
    httpurl: [{ type: Input, args: ['http-url',] }],
    datareader: [{ type: Input, args: ['data-reader',] }],
    httpmethod: [{ type: Input, args: ['http-method',] }],
    displayfield: [{ type: Input, args: ['display-field',] }],
    height: [{ type: Input }],
    selectedRows: [{ type: Output }],
    onRowClick: [{ type: Output }],
    border: [{ type: Input }],
    contextmenu: [{ type: Input, args: ['context-menu',] }],
    rightClick: [{ type: Output }],
    bodyTemplate: [{ type: ContentChild, args: ['amexioBodyTmpl',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Created by dattaram on 13/2/19.
 */
class PageInfo {
    /**
     * @param {?} pN
     * @param {?} eI
     * @param {?} rows
     */
    constructor(pN, eI, rows) {
        this.pageNumber = pN;
        this.endIndex = eI;
        this.startIndex = (this.endIndex - rows + 1);
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Created by ketangote on 11/23/17.
 */
/*
 Component Name : Amexio paginator
 Component Selector : <amexio-paginator>
 Component Description : Paginator is a generic widget to display content in paged format.
*/
class AmexioPaginatorComponent extends LifeCycleBaseComponent {
    constructor() {
        super();
        this.serverSidePaging = false;
        /*
           Properties
           name : rows
           datatype : any
           version : 4.0 onwards
           default : none
           description : number of records on one page
           */
        this.rows = 10;
        /*
           Events
           name : onRowChange
           datatype : none
           version : none
           default : none
           description : if you click on '<<' will get 1st record and if you click on '>>' will get last record.
           */
        this.onRowChange = new EventEmitter();
        /*
           Events
           name : onPageChange
           datatype : none
           version : none
           default : none
           description : It will gives you current page number
           */
        this.onPageChange = new EventEmitter();
        this.fullPageSet = [];
        this.activePages = [];
        this.pageIndex = [];
        this.cloneRow = null;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.size == null || this.size === '') {
            this.size = 'medium';
        }
        this.dummyRowData = JSON.parse(JSON.stringify(this.rows));
        this.initializePages();
        this.componentId = this.createCompId('paginator', this.pages);
    }
    /**
     * @param {?} inputType
     * @param {?} name
     * @return {?}
     */
    createCompId(inputType, name) {
        return inputType + '_' + name + '_' + window.crypto.getRandomValues(new Uint32Array(1))[0];
    }
    /**
     * @param {?} change
     * @return {?}
     */
    ngOnChanges(change) {
        if (change.pages && !change.pages.isFirstChange()) {
            this.initializePages();
        }
        if (change.rows && !change.rows.isFirstChange()) {
            this.dummyRowData = change.rows.currentValue;
            this.initializePages();
        }
    }
    /**
     * @return {?}
     */
    initializePages() {
        this.resetData();
        if (this.rows > 10 && this.serverSidePaging) {
            this.isCustomLogic = true;
            this.cloneRow = this.rows;
            this.rows = 10;
        }
        if (this.rows && this.rows != null) {
            if (this.rows > this.pages) {
                this.rows = this.pages;
            }
            for (let i = 0; i < this.pages; i++) {
                this.fullPageSet.push(i + 1);
            }
            for (let i = 0; i < this.rows; i++) {
                this.activePages.push(i + 1);
            }
            this.calculateRows();
            this.setRows(this.rows);
        }
        else {
            for (let i = 0; i < this.pages; i++) {
                this.fullPageSet.push(i + 1);
                this.activePages.push(i + 1);
            }
        }
        this.activePageIndex = 0;
        this.currentRowIndex = 0;
        this.activePage = this.activePageIndex + 1;
    }
    /**
     * @return {?}
     */
    onFirstClick() {
        this.setAndEmitPageState(this.activePage, 1);
        this.activePageIndex = 0;
        this.changeRows(this.pageIndex[0], 0, null);
    }
    /**
     * @return {?}
     */
    onLastClick() {
        this.changeRows(this.pageIndex[this.pageIndex.length - 1], this.pageIndex.length - 1, null);
        this.activePageIndex = this.activePages.length - 1;
        this.activePage = this.activePages[this.activePages.length - 1];
        this.setAndEmitPageState(this.activePage, this.pageIndex[this.pageIndex.length - 1]);
    }
    /**
     * @return {?}
     */
    onPrevious() {
        if (this.activePageIndex !== 0) { // within row bounds
            this.setNextOrPreviewsPage(this.activePageIndex -= 1);
        }
        else {
            // load prev rows
            /** @type {?} */
            let sIndx;
            if (this.fullPageSet.indexOf(this.activePage) === 1) {
                sIndx = this.fullPageSet.indexOf(this.activePage);
            }
            else {
                sIndx = this.fullPageSet.indexOf(this.activePage) - 1;
            }
            if (sIndx > 0) {
                this.changeRows(this.pageIndex[this.currentRowIndex - 1], this.currentRowIndex - 1, null);
                this.setNextOrPreviewsPage(this.activePages.length - 2);
            }
        }
    }
    /**
     * @return {?}
     */
    onNext() {
        if (this.activePageIndex !== this.activePages.length - 1) { // within row bounds
            this.setNextOrPreviewsPage(this.activePageIndex += 1);
        }
        else {
            // load next rows
            /** @type {?} */
            const sIndx = this.fullPageSet.indexOf(this.activePage) + 1;
            if (sIndx <= this.fullPageSet.length - 1) {
                this.changeRows(this.pageIndex[this.currentRowIndex + 1], this.currentRowIndex + 1, null);
                this.setNextOrPreviewsPage(1);
            }
        }
    }
    /**
     * @param {?} index
     * @return {?}
     */
    setNextOrPreviewsPage(index) {
        this.activePageIndex = index;
        this.activePage = this.activePages[index];
        this.setAndEmitPageState(index, this.activePage);
    }
    /* If page size is less then row*/
    /**
     * @param {?} rowNumber
     * @param {?} inDx
     * @param {?} event
     * @return {?}
     */
    changeRows(rowNumber, inDx, event) {
        if (rowNumber != null) {
            this.activePages = [];
            if (this.pages <= rowNumber) {
                this.currentRow = this.pages;
                for (let i = this.currentRow - this.rows + 1; i <= this.currentRow; i++) {
                    if (i !== 0) {
                        this.activePages.push(i);
                    }
                }
            }
            else {
                this.getCurrentRow(rowNumber);
            }
            this.onPageChangeMethod(inDx);
            if (event) {
                this.show = !this.show;
            }
        }
    }
    // Method to get current row
    /**
     * @private
     * @param {?} rowNumber
     * @return {?}
     */
    getCurrentRow(rowNumber) {
        this.currentRow = rowNumber;
        for (let i = this.currentRow - this.rows; i <= this.currentRow; i++) {
            if (i !== 0) {
                this.activePages.push(i);
            }
        }
    }
    // Method called on on change and emits onchange event
    /**
     * @private
     * @param {?} inDx
     * @return {?}
     */
    onPageChangeMethod(inDx) {
        this.currentRowIndex = inDx;
        this.onRowChange.emit(this.currentRow);
        this.activePageIndex = 0;
        this.activePage = this.activePages[0];
    }
    /**
     * @param {?} page
     * @param {?} index
     * @return {?}
     */
    onPageClick(page, index) {
        this.setAndEmitPageState(this.activePageIndex + 1, page);
        this.activePageIndex = index;
        this.activePage = page;
    }
    /**
     * @return {?}
     */
    calculateRows() {
        this.currentRow = this.rows;
        /** @type {?} */
        const loopI = Math.ceil(this.pages / this.rows);
        for (let i = 1; i <= loopI; i++) {
            if ((this.rows * i) > this.pages) {
                this.pageIndex.push(this.pages);
            }
            else {
                this.pageIndex.push(this.rows * i);
            }
        }
    }
    /**
     * @param {?} rowNumber
     * @return {?}
     */
    setRows(rowNumber) {
        this.activePages = [];
        if (rowNumber > this.pages) {
            this.currentRow = this.pages;
        }
        else {
            this.currentRow = rowNumber;
        }
        for (let i = 0; i < this.currentRow; i++) {
            this.activePages.push(i + 1);
        }
    }
    /**
     * @return {?}
     */
    showColumnOptions() {
        this.show = !this.show;
    }
    /**
     * @param {?} currentPageIndex
     * @param {?} futurePageIndex
     * @return {?}
     */
    setAndEmitPageState(currentPageIndex, futurePageIndex) {
        if (this.isCustomLogic) {
            this.currentState = new PageInfo(currentPageIndex, (this.cloneRow * currentPageIndex), this.cloneRow);
            this.futureState = new PageInfo(futurePageIndex, (this.cloneRow * futurePageIndex), this.cloneRow);
        }
        else {
            this.currentState = new PageInfo(currentPageIndex, (this.rows * currentPageIndex), this.rows);
            this.futureState = new PageInfo(futurePageIndex, (this.rows * futurePageIndex), this.rows);
        }
        this.onPageChange.emit(this.createOnPageEmitObject(this.futureState.pageNumber));
    }
    // CREATE ON PAGE EMIT OBJECT
    /**
     * @param {?} activePage
     * @return {?}
     */
    createOnPageEmitObject(activePage) {
        return {
            pageNumber: activePage,
            current: this.currentState,
            next: this.futureState,
        };
    }
    /**
     * @return {?}
     */
    resetData() {
        this.fullPageSet.length = 0;
        this.activePages.length = 0;
        this.pageIndex.length = 0;
        this.rows = this.dummyRowData;
    }
}
AmexioPaginatorComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-paginator', template: `
    <div role="navigation" attr.aria-labelledby="componentId" aria-label="pagination" class="paginator {{roundedgeclass}}">
      <span class="paginator-pages">
        <a role="radiogroup" id="{{componentId}}" aria-label="previous page" tabindex="1" class="paginator-page" (click)="onPrevious()">&lt;</a>
        <a role="radiogroup" id="{{componentId}}" aria-label="previous set page" tabindex="1" class="paginator-page" (click)="onFirstClick()">&lt;&lt;</a>
      </span>
      <span id="{{componentId}}" tabindex="1" attr.aria-label="Page{{i+1}}" role="link" (keyup.enter)="onPageClick(page,i)" class="paginator-pages" *ngFor="let page of activePages;let i = index">
        <a class="paginator-page" [ngClass]="{'active' : activePageIndex == i  }"  (click)="onPageClick(page,i)">{{page}}</a>
      </span>
      <span role="presentation" class="paginator-pages">
        <a role="radiogroup" id="{{componentId}}" aria-label="next set page" tabindex="1" class="paginator-page" (click)="onLastClick()">&gt;&gt;</a>
        <a role="radiogroup" id="{{componentId}}" aria-label="next page" tabindex="1" class="paginator-page" (click)="onNext()">&gt;</a>
      </span>
      <ng-container *ngIf="!serverSidePaging">
        <ng-container *ngIf="pages > rows">
        <span class="paginator-pages">
          <a class="paginator-page" (click)="showColumnOptions()" style=" cursor: pointer;">{{currentRow}} &nbsp; &#9660;</a>
          <span *ngIf="show" class="dropdown" style="width: 50px;">
            <ul class="dropdown-list">
              <li class="list-items" *ngFor="let row of pageIndex;let i = index" (click)="changeRows(row,i, $event)">
                <div>{{row}}</div>
              </li>
            </ul>
          </span>
        </span>
        </ng-container>
      </ng-container>
    </div>
  `,
            },] },
];
/** @nocollapse */
AmexioPaginatorComponent.ctorParameters = () => [];
AmexioPaginatorComponent.propDecorators = {
    serverSidePaging: [{ type: Input, args: ['server-side-paging',] }],
    pages: [{ type: Input }],
    rows: [{ type: Input }],
    size: [{ type: Input }],
    onRowChange: [{ type: Output }],
    onPageChange: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Created by pratik on 27/12/17.
 */
class AmexioProgressMultiBarComponent {
    constructor() {
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
}
AmexioProgressMultiBarComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-multi-bar', template: `

  `,
            },] },
];
/** @nocollapse */
AmexioProgressMultiBarComponent.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Created by pratik on 27/12/17.
 */
/*
Component Name : Amexio progress bar
Component Selector : <amexio-progress-bar>
Component Description : Progress Bar Component Provides up-to-date feedback
on the progress of a workflow or action with simple yet flexible progress bars
and easy to configure.
*/
class AmexioProgressBarComponent extends LifeCycleBaseComponent {
    constructor() {
        super();
        /*
          Properties
          name : show
          datatype : boolean
          version : 4.0 onwards
          default : true
          description :  Shows / Hides the progress bar.
          */
        this.showProgress = true;
        this.progressclass = '';
        this.strippedCss = 'stripped ';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.height) {
            this.height = this.height + 'px';
        }
        else {
            this.height = '20px';
        }
        if (this.stripped) {
            this.progressclass = this.progressclass + this.strippedCss;
        }
        if (this.type && !this.amexiocolor) {
            this.progressclass = this.progressclass + this.type.toLocaleLowerCase();
        }
        else if (this.amexiocolor && !this.type) {
            this.progressclass = this.progressclass + this.amexiocolor.toLocaleLowerCase();
        }
    }
}
AmexioProgressBarComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-progress-bar',
                template: `
    <div class="{{roundedgeclass}}">
    <div *ngIf="showProgress" class="progress" [ngStyle]="{'height':height}">

      <span [ngClass]="progressclass" *ngIf="infinite" style="width: 100%;" tabindex="1" role="progressbar" aria-readonly="true"
        attr.aria-label="'inprogress {{label}}'">
        {{label != null ? label : 'Loading...'}}
      </span>
      <span tabindex="1" attr.aria-label="'progressbar {{tooltip}}'" role="progressbar" attr.aria-valuenow="{{currentvalue}}"
        aria-valuemin="0" aria-valuemax="100" [ngClass]="progressclass" *ngIf="!infinite" [ngStyle]="{'width.%' : currentvalue}">
      </span>
    </div>
    </div>
  `,
            },] },
];
/** @nocollapse */
AmexioProgressBarComponent.ctorParameters = () => [];
AmexioProgressBarComponent.propDecorators = {
    showProgress: [{ type: Input, args: ['show',] }],
    infinite: [{ type: Input }],
    type: [{ type: Input }],
    amexiocolor: [{ type: Input, args: ['amexio-color',] }],
    currentvalue: [{ type: Input, args: ['current-value',] }],
    label: [{ type: Input }],
    height: [{ type: Input }],
    stripped: [{ type: Input }],
    multi: [{ type: Input }],
    tooltip: [{ type: Input, args: ['tooltip',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PropertyGridComponent {
    constructor() {
        this.hasBorder = false;
        this.hasColon = false;
        this.enableKeyBold = false;
        this.enableValueClick = false;
        this.onValueClick = new EventEmitter();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onClick(event) {
        if (event.link && event.link.length > 0) {
            this.onValueClick.emit(event);
        }
    }
}
PropertyGridComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-property-grid',
                template: `
      <ng-container *ngIf="data && data.length > 0">
        <table aria-describedby="propertyGrid" [ngClass]="{'borderStyle': hasBorder}" style="width: 100%">
            <ng-container *ngIf="data && data.length == 0">
            <tr>
                <th scope="col"></th>
                <th scope="col"></th>
            </tr>      
            </ng-container>
          <tr *ngFor="let item of data">
            <td class="field-name-align" [ngClass]="{'borderStyle': hasBorder}">
              <span *ngIf="item.fieldIcon" style="padding-right: 5px">
                <amexio-c-icon class="fa + {{item.fieldIcon}}"></amexio-c-icon>
              </span>
              <span *ngIf="!item.onlyIcon"
                [ngStyle]="{'font-weight': enableKeyBold ? 'bold': 'normal'}">{{item.fieldName}}</span>
              <span *ngIf="hasColon"> :</span>
            </td>
            <td class="field-name-align"
              [ngClass]="{'borderStyle': hasBorder, 'isclickenabled':(item.link && item.link.length>0)}"
              (click)="onClick(item)">
              {{item.fieldValue}}
            </td>
          </tr>
        </table>
      </ng-container>
    `,
                styles: [`
      .isclickenabled{cursor:pointer;color:#0366d6;text-decoration:underline}
    `],
            },] },
];
/** @nocollapse */
PropertyGridComponent.ctorParameters = () => [];
PropertyGridComponent.propDecorators = {
    data: [{ type: Input, args: ['key-value-data',] }],
    hasBorder: [{ type: Input, args: ['has-border',] }],
    hasColon: [{ type: Input, args: ['has-colon',] }],
    enableKeyBold: [{ type: Input, args: ['enable-key-bold',] }],
    enableValueClick: [{ type: Input, args: ['enable-value-click',] }],
    onValueClick: [{ type: Output, args: ['onValueClick',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class SpeechBubbleComponent extends EventBaseComponent {
    /**
     * @param {?} element
     * @param {?} renderer
     * @param {?} _cd
     */
    constructor(element, renderer, _cd) {
        super(renderer, element, _cd);
        this.element = element;
        this.renderer = renderer;
        this.contextmenu = [];
        this.today = new Date();
        this.jstoday = '';
        this.width = '50%';
        this.onClick = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.todaydate = new Date();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onarrowClick(event) {
        if (this.arrowpress) {
            this.arrowpress = false;
        }
        this.arrowpress = !this.arrowpress;
        this.dropdownstyle = { visibility: 'visible' };
        this.onBaseFocusEvent({});
    }
    /**
     * @param {?} itemConfig
     * @return {?}
     */
    onBubbleNodeClick(itemConfig) {
        this.onClick.emit(itemConfig);
        this.dropdownstyle = { visibility: 'hidden' };
    }
}
SpeechBubbleComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-speech-bubble',
                template: `
    <div class="bubble" [style.width]="width" [ngClass]="{speecharrowleft:(position == 'left' ),speecharrowright:(position == 'right'),speecharrowbottomleft:(position == 'bottom-left'),speecharrowbottomright:(position == 'bottom-right'),speecharrowtopleft:(position == 'top-left'),speecharrowtopright:(position == 'top-right')}">
      <ng-container *ngIf="data">
        <amexio-c-icon style="float:right;font-size:25px;cursor: pointer;" key="sidenav-angle-down" (onClick)="onarrowClick($event)"></amexio-c-icon>
        <div class="sidedivclass" [ngStyle]="dropdownstyle">
          <ng-container [ngStyle]="{'cursor': arrowpress ? 'all-scroll':''}" *ngIf="arrowpress">
            <span>
              <ul style="right:10px;margin-top:18px" class="context-menu-list">
                <li (click)="onBubbleNodeClick(itemConfig)" class="context-menu-list-items" *ngFor="let itemConfig of data">
                  <span style="white-space: nowrap;display: inline ; padding-left:5px">{{itemConfig.label}}</span>
                  <amexio-c-icon style="float:left;padding:5px" class="fa + {{itemConfig.icon}}"></amexio-c-icon>
                </li>
              </ul>
            </span>
          </ng-container>
        </div>
      </ng-container>
      <ng-content></ng-content>
      <div class="time" *ngIf="enabletime" [ngClass]="{timeclass:(position =='top-right'||position =='bottom-right'||position=='right'),timeleft:(position=='bottom-left'),timeright:(position=='bottom-right')}">
        {{todaydate | date: 'MMM d, y, h:mm:ss a'}}
      </div>
    </div>
  `,
            },] },
];
/** @nocollapse */
SpeechBubbleComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: ChangeDetectorRef }
];
SpeechBubbleComponent.propDecorators = {
    width: [{ type: Input, args: ['width',] }],
    position: [{ type: Input, args: ['arrow-direction',] }],
    data: [{ type: Input, args: ['menu-option',] }],
    enabletime: [{ type: Input, args: ['enable-time',] }],
    onClick: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Created by pratik on 11/12/17.
 */
/*
Component Name : Amexio tree filter
Component Selector : <amexio-tree-filter-view>
Component Description : A Expandable Tree Component for Angular, having
Filtering functionality.
*/
class AmexioFilterTreeComponent {
    /**
     * @param {?} _http
     * @param {?} cdf
     * @param {?} treeViewFilterService
     */
    constructor(_http, cdf, treeViewFilterService) {
        this._http = _http;
        this.cdf = cdf;
        this.treeViewFilterService = treeViewFilterService;
        /*
        Properties
        name : enable-checkbox
        datatype : false
        version : 4.0 onwards
        default : false
        description : Enables checkbox for each row, this allows user for multi selection.
        */
        this.enablecheckbox = false;
        /*
        Events
        name : nodeClick
        datatype : none
        version : none
        default : none
        description : It will gives you clicked node data.
        */
        this.nodeClick = new EventEmitter();
        /*
        Events
        name : onTreeNodeChecked
        datatype : none
        version : none
        default : none
        description : It will gives whole tree data with checked flag status.
        */
        this.onTreeNodeChecked = new EventEmitter();
        /*
          Properties
          name : trigger-char
          datatype : number
          version : 4.0 onwards
          default : none
          description : it will search for text relevant to entered character
          */
        this.nodeRightClick = new EventEmitter();
        this.rightClick = new EventEmitter();
        this.wordwrap = true;
        this.filtertreeflag = false;
        this.isDataFound = true;
        this.onClickSearch = false;
        this.mask = true;
        this.isexpandAll = false;
        this.filterIndex = 3;
        this.triggerchar = 1;
        this.displaykey = 'text';
        this.childarraykey = 'children';
        this.filterOptionData = [{
                key: 'Is Equal To', value: '1', type: 'string', checkedStatus: '',
            }, {
                key: 'Is Not Equal To', value: '2', type: 'string', checkedStatus: '',
            }, {
                key: 'Start With', value: '3', type: 'string', checkedStatus: 'fa fa-check',
            }, {
                key: 'Ends With', value: '4', type: 'string', checkedStatus: '',
            }, {
                key: 'Contains', value: '5', type: 'string', checkedStatus: '',
            }];
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set data(value) {
        this._data = value;
        if (this.componentLoaded) {
            this.updateComponent();
        }
    }
    /**
     * @return {?}
     */
    get data() {
        return this._data;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.parentTmp != null) {
            this.templates = { treeNodeTemplate: this.parentTmp };
        }
        else if (this.templates != null) {
            this.parentTmp = this.templates.treeNodeTemplate;
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        if (this.parentTmp != null) {
            this.templates = { treeNodeTemplate: this.parentTmp };
        }
        else if (this.templates != null) {
            this.parentTmp = this.templates.treeNodeTemplate;
        }
        if (this.httpmethod && this.httpurl) {
            this.callService();
        }
        else if (this.data) {
            this.previousValue = JSON.parse(JSON.stringify(this.data));
            this.setData(this.data);
        }
        this.componentLoaded = true;
    }
    /**
     * @return {?}
     */
    updateComponent() {
        if (this.data != null && JSON.stringify(this.previousValue) !== JSON.stringify(this.data)) {
            this.previousValue = JSON.parse(JSON.stringify(this.data));
            this.setData(this.data);
        }
    }
    /**
     * @return {?}
     */
    filterData() {
        this.showToolTip = false;
        if (this.filterText.length >= this.triggerchar) {
            /** @type {?} */
            const tData = JSON.parse(JSON.stringify(this.orgTreeData));
            /** @type {?} */
            const treeNodes = this.searchTree(tData, this.filterText);
            this.treeData = treeNodes;
            if (this.treeData.length === 0) {
                this.isDataFound = false;
            }
            else {
                this.isDataFound = true;
            }
        }
        else if (this.onClickSearch) {
            /** @type {?} */
            const tData = JSON.parse(JSON.stringify(this.orgTreeData));
            /** @type {?} */
            const treeNodes = this.searchTree(tData, this.filterText);
            this.treeData = treeNodes;
            this.onClickSearch = false;
            if (this.treeData.length === 0) {
                this.isDataFound = false;
            }
            else {
                this.isDataFound = true;
            }
        }
        else {
            this.isDataFound = true;
            this.treeData = this.orgTreeData;
        }
        if (this.isexpandAll) {
            this.expandAll(this.treeData);
        }
        this.generatefilterIndex(this.treeData, 1, window.crypto.getRandomValues(new Uint32Array(1))[0]);
    }
    /**
     * @param {?} data
     * @param {?} matchingTitle
     * @return {?}
     */
    searchTree(data, matchingTitle) {
        /** @type {?} */
        const fi = this.filterIndex;
        return this.filterActualData(data, fi, matchingTitle);
    }
    /**
     * @param {?} data
     * @param {?} fi
     * @param {?} matchingTitle
     * @return {?}
     */
    filterActualData(data, fi, matchingTitle) {
        /** @type {?} */
        let tempdisplay;
        /** @type {?} */
        let tempchildarrayKey;
        tempdisplay = this.displaykey;
        tempchildarrayKey = this.childarraykey;
        return data.filter((/**
         * @param {?} node
         * @return {?}
         */
        function f(node) {
            if ((fi === 5 && node[tempdisplay].toLowerCase().includes(matchingTitle.toLowerCase())) ||
                (fi === 3 && node[tempdisplay].toLowerCase().startsWith(matchingTitle.toLowerCase())) ||
                (fi === 1 && node[tempdisplay].toLowerCase() === matchingTitle.toLowerCase()) ||
                (fi === 2 && node[tempdisplay].toLowerCase() !== matchingTitle.toLowerCase()) ||
                (fi === 4 && node[tempdisplay].toLowerCase().endsWith(matchingTitle.toLowerCase()))) {
                return true;
            }
            if (node[tempchildarrayKey]) {
                return (node[tempchildarrayKey] = node[tempchildarrayKey].filter(f)).length;
            }
        }));
    }
    /**
     * @param {?} data
     * @return {?}
     */
    filterOption(data) {
        this.onClickSearch = true;
        this.filterIndex = data.value;
        this.filterOptionData.forEach((/**
         * @param {?} opt
         * @return {?}
         */
        (opt) => {
            if (opt.value !== data.value) {
                opt.checkedStatus = '';
            }
            else {
                opt.checkedStatus = 'fa fa-check';
            }
        }));
        this.filterData();
        this.showToolTip = false;
    }
    /**
     * @return {?}
     */
    renderServiceData() {
        this.setData(this.data);
    }
    /**
     * @param {?} httpResponse
     * @return {?}
     */
    setData(httpResponse) {
        /** @type {?} */
        const tdata = this.getData(httpResponse);
        if (tdata) {
            this.orgTreeData = JSON.parse(JSON.stringify(tdata));
            this.treeData = tdata;
        }
        this.mask = false;
    }
    /**
     * @param {?} httpResponse
     * @return {?}
     */
    getData(httpResponse) {
        /** @type {?} */
        let responsedata = httpResponse;
        if (this.datareader != null) {
            /** @type {?} */
            const dr = this.datareader.split('.');
            for (const ir of dr) {
                responsedata = responsedata[ir];
            }
        }
        else {
            responsedata = httpResponse;
        }
        return responsedata;
    }
    /**
     * @return {?}
     */
    callService() {
        this.treeViewFilterService.fetchData(this.httpurl, this.httpmethod).subscribe((/**
         * @param {?} response
         * @return {?}
         */
        (response) => {
            this.data = response;
        }), (/**
         * @return {?}
         */
        () => {
            this.renderServiceData();
        }));
    }
    /**
     * @param {?} data
     * @return {?}
     */
    onRowSelect(data) {
        this.nodeClick.emit(data);
    }
    /**
     * @param {?} data
     * @return {?}
     */
    onCheckSelect(data) {
        this.onTreeNodeChecked.emit(data);
    }
    /**
     * @param {?} data
     * @return {?}
     */
    OnRightClickMenu(data) {
        this.rightClick.emit(data);
    }
    /**
     * @param {?} data
     * @return {?}
     */
    loadContextMenu(data) {
        this.nodeRightClick.emit(data);
    }
    /**
     * @param {?} data
     * @param {?} parentId
     * @param {?} rannumber
     * @return {?}
     */
    generatefilterIndex(data, parentId, rannumber) {
        data.forEach((/**
         * @param {?} element
         * @param {?} index
         * @return {?}
         */
        (element, index) => {
            element['id'] = '' + rannumber + '-' + parentId + (index + 1);
            if (element[this.childarraykey]) {
                this.generatefilterIndex(element[this.childarraykey], element.id.split('-')[1], rannumber);
            }
        }));
    }
    /**
     * @param {?} node
     * @return {?}
     */
    expandAll(node) {
        this.isexpandAll = true;
        this.destroyExpandAll = setTimeout((/**
         * @return {?}
         */
        () => {
            if (this.treeData) {
                this.expandAllCall(this.treeData);
            }
        }), 0);
    }
    /**
     * @param {?} node
     * @return {?}
     */
    expandAllCall(node) {
        node.forEach((/**
         * @param {?} childCheck
         * @return {?}
         */
        (childCheck) => {
            if (childCheck.hasOwnProperty('expand')) {
                if (!childCheck.expand) {
                    childCheck.expand = true;
                }
            }
            else {
                childCheck['expand'] = true;
            }
            if (childCheck.hasOwnProperty(this.childarraykey) && childCheck[this.childarraykey] != null) {
                this.expandAllCall(childCheck[this.childarraykey]);
            }
        }));
    }
}
AmexioFilterTreeComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-tree-filter-view', template: `
    <div>
      <div>
        <div class="inputgroup">
          <input type="text" class="input-control text-input-width" aria-label="Text input with dropdown button" [(ngModel)]="filterText"
                 placeholder="Search" (keyup)="filterData()">
          <!--<i class="fa fa-filter" aria-hidden="true" (click)="showToolTip = !showToolTip"></i>-->
          <span class="datatable-filter-icon">
          <amexio-c-icon key="tree_filter" (click)="showToolTip = !showToolTip"></amexio-c-icon>
          </span>
          <!--  <div class="input-group-btn">-->
          <!-- <button type="button"
          class="btn" data-toggle="dropdown"
          (click)="showToolTip = !showToolTip"
          aria-haspopup="true" aria-expanded="false">
           </button>-->
          <span *ngIf="showToolTip" class="dropdown">
              <ul class="dropdown-list">
                <li class="list-items" *ngFor="let opt of filterOptionData" (click)="filterOption(opt)">{{opt.key}}&nbsp;
                  <!--<i [class]="opt.checkedStatus" aria-hidden="true"></i>-->
                  <amexio-c-icon key="opt.checkedStatus"></amexio-c-icon>
                </li>
              </ul>
            </span>
          <!-- </div>-->
        </div>
        <ng-container *ngIf="isDataFound">
          <amexio-treeview
            [filter-tree-flag]="true"
            [data]="treeData"
            [parentRef] ="treeData"
            [word-wrap]="wordwrap"
            [child-array-key]="childarraykey"
            [display-key]="displaykey"
            [enable-checkbox]="enablecheckbox"
            (onTreeNodeChecked)="onCheckSelect($event)"
            (rightClick)="OnRightClickMenu($event)"
            (nodeRightClick)="loadContextMenu($event)"
            (nodeClick)="onRowSelect($event)" [templates]="templates">
          </amexio-treeview>
        </ng-container>
        <ng-container *ngIf="!isDataFound">
          <p>No Data Found.</p>
        </ng-container>

      </div>
    </div>


  `,
            },] },
];
/** @nocollapse */
AmexioFilterTreeComponent.ctorParameters = () => [
    { type: HttpClient },
    { type: ChangeDetectorRef },
    { type: CommonDataService }
];
AmexioFilterTreeComponent.propDecorators = {
    httpurl: [{ type: Input, args: ['http-url',] }],
    httpmethod: [{ type: Input, args: ['http-method',] }],
    datareader: [{ type: Input, args: ['data-reader',] }],
    data: [{ type: Input, args: ['data',] }],
    enablecheckbox: [{ type: Input, args: ['enable-checkbox',] }],
    nodeClick: [{ type: Output }],
    onTreeNodeChecked: [{ type: Output }],
    nodeRightClick: [{ type: Output }],
    rightClick: [{ type: Output }],
    triggerchar: [{ type: Input, args: ['trigger-char',] }],
    childarraykey: [{ type: Input, args: ['child-array-key',] }],
    displaykey: [{ type: Input, args: ['display-key',] }],
    wordwrap: [{ type: Input, args: ['word-wrap',] }],
    contextmenu: [{ type: Input, args: ['context-menu',] }],
    filtertreeflag: [{ type: Input, args: ['filter-tree-flag',] }],
    parentRef: [{ type: Input }],
    parentTmp: [{ type: ContentChild, args: ['amexioTreeTemplate',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Created by ketangote on 12/1/17.
 */
/*
Component Name : Amexio horizontal tree
Component Selector : <amexio-horizontal-treeviewnode>
Component Description : A Horizontal Tree Component.
*/
class HorizontalTreeViewNodeComponent {
    constructor() {
        /*
        Events
        name : onNodeClick
        datatype : none
        version : none
        default : none
        description : It will gives you clicked node data.
        */
        this.onNodeClick = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @param {?} node
     * @return {?}
     */
    onClick(node) {
        node.expand = !node.expand;
        this.onNodeClick.emit(node);
    }
    /**
     * @param {?} node
     * @return {?}
     */
    onInnerClick(node) {
        this.onNodeClick.emit(node);
    }
    /**
     * @param {?} data
     * @param {?} node
     * @param {?} index
     * @return {?}
     */
    onArrowUp(data, node, index) {
        /** @type {?} */
        const newindex = index - 1;
        if (newindex >= 0) {
            /** @type {?} */
            const previousindex = data[newindex];
            this.setFocus(previousindex);
            this.focusToInnerLastItem(previousindex);
        }
        else {
            /** @type {?} */
            const id = node.id;
            /** @type {?} */
            const spiltID = this.splitID(id);
            /** @type {?} */
            const randomnumber = spiltID[0];
            /** @type {?} */
            const currentid = spiltID[1];
            /** @type {?} */
            const newid = parseInt(currentid.slice(0, -1), 10);
            /** @type {?} */
            const id2 = newid;
            /** @type {?} */
            const focusid1 = randomnumber + '-' + id2;
            if (document.getElementById(focusid1)) {
                document.getElementById(focusid1).focus();
            }
        }
    }
    /**
     * @param {?} focuselement
     * @return {?}
     */
    setFocus(focuselement) {
        if (document.getElementById(focuselement.id)) {
            document.getElementById(focuselement.id).focus();
        }
    }
    /**
     * @param {?} node
     * @return {?}
     */
    focusToInnerLastItem(node) {
        if (node.hasOwnProperty('expand') && node.expand && node['children']) {
            node['children'].forEach((/**
             * @param {?} innernode
             * @return {?}
             */
            (innernode) => {
                this.focusToInnerLastItem(innernode);
            }));
        }
        else {
            this.setFocus(node);
        }
    }
    /**
     * @param {?} id
     * @return {?}
     */
    splitID(id) {
        return id.split('-');
    }
    /**
     * @param {?} event
     * @param {?} data
     * @param {?} node
     * @param {?} index
     * @return {?}
     */
    onArrowDown(event, data, node, index) {
        /** @type {?} */
        const incrementindex = index + 1;
        /** @type {?} */
        const itemid = data[incrementindex];
        if (node.expand === true && node['children']) {
            /** @type {?} */
            const data1 = node['children'][0];
            this.setFocus(data1);
        }
        else {
            if (incrementindex < data.length) {
                this.setFocus(itemid);
            }
            else {
                this.focusTONextParent(node);
            }
        }
    }
    /**
     * @param {?} node
     * @return {?}
     */
    focusTONextParent(node) {
        /** @type {?} */
        const sliceId = this.splitID(node.id);
        /** @type {?} */
        const randomnumber = sliceId[0];
        /** @type {?} */
        const currentid = sliceId[1];
        /** @type {?} */
        const newid = parseInt(currentid.slice(0, -1), 10);
        /** @type {?} */
        const currentitem = newid + 1;
        /** @type {?} */
        const focusid1 = randomnumber + '-' + currentitem;
        if (document.getElementById(focusid1)) {
            document.getElementById(focusid1).focus();
        }
        else {
            /** @type {?} */
            const nextnewid = parseInt(currentitem.toString().slice(0, -1), 10);
            /** @type {?} */
            const id3 = nextnewid + 1;
            /** @type {?} */
            const focusid2 = randomnumber + '-' + id3;
            if (document.getElementById(focusid2)) {
                document.getElementById(focusid2).focus();
            }
        }
    }
    /**
     * @param {?} node
     * @return {?}
     */
    onEnterClick(node) {
        this.onClick(node);
        if (node.hasOwnProperty('expand') && node.expand && node['children']) {
            /** @type {?} */
            const sliceId = this.splitID(node.id);
            /** @type {?} */
            const randomnumber = sliceId[0];
            /** @type {?} */
            const currentid = sliceId[1];
            /** @type {?} */
            const nextId = currentid + 1;
            /** @type {?} */
            const focusid = randomnumber + '-' + nextId;
            if (document.getElementById(focusid)) {
                document.getElementById(focusid).focus();
            }
        }
    }
}
HorizontalTreeViewNodeComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-horizontal-treeviewnode', template: `
  <div #id class="horizontaltreeview-node">
  <div class="horizontaltreeview-node-entry" [ngClass]="{'sole':data.length==1}" *ngFor="let node of data; let i = index">
    <span id={{node.id}} tabindex="1" [attr.aria-expanded]="node.expand"
    class="horizontaltreeview-node-label" (click)="onClick(node)" (keyup.enter)="onEnterClick(node)"
    (keyup.arrowup)="onArrowUp(data,node,i)"
    (keyup.arrowdown)="onArrowDown($event,data,node,i)">
      {{node.text}}
      <span  *ngIf="node.children && (node.children.length>0)" class="float-right" (click)="onClick(node)" (keyup.enter)="onClick(node)">
        <amexio-c-icon *ngIf="node.expand" key="horizontal-tree-collapse"></amexio-c-icon>
        <amexio-c-icon *ngIf="!node.expand" key="horizontal-tree-expanded"></amexio-c-icon>
      </span>
    </span>
    <amexio-horizontal-treeviewnode *ngIf="node.expand && node.children && (node.children.length>0)"
                                    [data]="node.children"
                                    (onNodeClick)="onInnerClick($event)"></amexio-horizontal-treeviewnode>
  </div>
</div>
  `,
            },] },
];
/** @nocollapse */
HorizontalTreeViewNodeComponent.ctorParameters = () => [];
HorizontalTreeViewNodeComponent.propDecorators = {
    data: [{ type: Input }],
    onNodeClick: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Created by ketangote on 12/1/17.
 */
/*
Component Name : Amexio horizontal tree
Component Selector : <amexio-horizontal-treeview>
Component Description : A Horizontal Tree Component.
*/
class HorizontalTreeViewComponent {
    /**
     * @param {?} dataService
     */
    constructor(dataService) {
        this.dataService = dataService;
        /*
        Events
        name : nodeClick
        datatype : none
        version : none
        default : none
        description : It will gives you clicked node data.
        */
        this.nodeClick = new EventEmitter();
        this.mask = true;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.httpmethod && this.httpurl) {
            this.dataService.fetchData(this.httpurl, this.httpmethod).subscribe((/**
             * @param {?} response
             * @return {?}
             */
            (response) => {
                this.responseData = response;
            }), (/**
             * @param {?} error
             * @return {?}
             */
            (error) => {
            }), (/**
             * @return {?}
             */
            () => {
                this.setData(this.responseData);
            }));
        }
    }
    /**
     * @param {?} httpResponse
     * @return {?}
     */
    setData(httpResponse) {
        // Check if key is added?
        /** @type {?} */
        let responsedata = httpResponse;
        if (this.datareader != null) {
            /** @type {?} */
            const dr = this.datareader.split('.');
            for (const ir of dr) {
                responsedata = responsedata[ir];
            }
        }
        else {
            responsedata = httpResponse;
        }
        this.data = responsedata;
        this.mask = false;
        this.generateIndex(this.data, 1, window.crypto.getRandomValues(new Uint32Array(1))[0]);
    }
    /**
     * @param {?} node
     * @return {?}
     */
    nodeclick(node) {
        this.nodeClick.emit(node);
    }
    /**
     * @param {?} data
     * @param {?} parentId
     * @param {?} rannumber
     * @return {?}
     */
    generateIndex(data, parentId, rannumber) {
        data.forEach((/**
         * @param {?} element
         * @param {?} index
         * @return {?}
         */
        (element, index) => {
            element['id'] = '' + rannumber + '-' + parentId + (index + 1);
            if (element['children']) {
                this.generateIndex(element['children'], element.id.split('-')[1], rannumber);
            }
        }));
    }
}
HorizontalTreeViewComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-horizontal-treeview', template: `

    <div class="horizontaltreeview">
      <span tabindex="1" class="horizontaltreeview-node-label">{{label}}</span>
      <div style="height: 300px;" *ngIf="mask">
        <div class="spinner"></div>
      </div>
      <amexio-horizontal-treeviewnode *ngIf="!mask" [data]="data" (onNodeClick)="nodeclick($event)"></amexio-horizontal-treeviewnode>
    </div>
  `,
            },] },
];
/** @nocollapse */
HorizontalTreeViewComponent.ctorParameters = () => [
    { type: CommonDataService }
];
HorizontalTreeViewComponent.propDecorators = {
    label: [{ type: Input }],
    data: [{ type: Input }],
    httpurl: [{ type: Input, args: ['http-url',] }],
    httpmethod: [{ type: Input, args: ['http-method',] }],
    datareader: [{ type: Input, args: ['data-reader',] }],
    nodeClick: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Created by ketangote on 11/23/17.
 */
/*
Component Name : Amexio tree filter
Component Selector : <amexio-tree-filter-view>
Component Description : A Expandable Tree Component for Angular, having Filtering functionality.
*/
class AmexioTreeViewComponent {
    /**
     * @param {?} element
     * @param {?} dataService
     * @param {?} cdf
     * @param {?} renderer
     */
    constructor(element, dataService, cdf, renderer) {
        this.element = element;
        this.dataService = dataService;
        this.cdf = cdf;
        this.renderer = renderer;
        /*
            Events
            name : nodeClick
            datatype : none
            version : none
            default : none
            description : It will gives you clicked node data.
            */
        this.nodeClick = new EventEmitter();
        /*
           Properties
           name : enable-checkbox
           datatype : false
           version : 4.0 onwards
           default : none
           description : Enables checkbox for each row, this allows user for multi selection.
           */
        this.enablecheckbox = false;
        /*
            Properties
            name : enable-drop
            datatype : boolean
            version : 5.0.0 onwards
            default : false
            description : any node can be dropped in the tree structure
            */
        this.enabledrop = false;
        /*
           Properties
           name : across-tree
           datatype : boolean
           version : 5.0.0 onwards
           default : false
           description : Dragging and dropping is possible across tree.
           */
        this.acrosstree = false;
        this.filtertreeflag = false;
        this.wordwrap = true;
        /*
            Events
            name : onTreeNodeChecked
            datatype : any
            version : 4.0 onwards
            default : none
            description : It will gives whole tree data with checked flag status.
            */
        this.onTreeNodeChecked = new EventEmitter();
        this.onDrag = new EventEmitter(); // Emits at drag
        // Emits at drag
        this.onDrop = new EventEmitter(); // emits at drop
        // emits at drop
        this.dragover = new EventEmitter(); // Emits at drag over
        this.nodeRightClick = new EventEmitter();
        this.rightClick = new EventEmitter();
        this.mouseLocation = { left: 0, top: 0 };
        this.globalTreeData = [];
        this.cloneContextMenuData = [];
        this.isNode = true;
        this.acrosstree = false;
        this.displaykey = 'text';
        this.childarraykey = 'children';
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set data(value) {
        this._data = value;
        if (this.componentLoaded) {
            this.updateComponent();
        }
    }
    /**
     * @return {?}
     */
    get data() {
        return this._data;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.contextmenu && this.contextmenu.length > 0) {
            this.cloneContextMenuData = JSON.parse(JSON.stringify(this.contextmenu));
        }
        if (this.httpmethod && this.httpurl) {
            this.dataService.fetchData(this.httpurl, this.httpmethod).subscribe((/**
             * @param {?} response
             * @return {?}
             */
            (response) => {
                this.responseData = response;
            }), (/**
             * @param {?} error
             * @return {?}
             */
            (error) => {
            }), (/**
             * @return {?}
             */
            () => {
                this.setData(this.responseData);
            }));
        }
        else if (this.data) {
            this.setData(this.data);
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        setTimeout((/**
         * @return {?}
         */
        () => {
            if (this.parentTmp != null) {
                this.templates = { treeNodeTemplate: this.parentTmp };
            }
            else if (this.templates != null) {
                this.parentTmp = this.templates.treeNodeTemplate;
            }
        }));
        this.cdf.detectChanges();
        this.componentLoaded = true;
    }
    /**
     * @return {?}
     */
    updateComponent() {
        if (this.data != null && JSON.stringify(this.previousValue) !== JSON.stringify(this.data)) {
            this.previousValue = JSON.parse(JSON.stringify(this.data));
            this.setData(this.data);
        }
    }
    /**
     * @param {?} node
     * @return {?}
     */
    expandAll(node) {
        this.destroyExpandAll = setTimeout((/**
         * @return {?}
         */
        () => {
            if (this.parentRef) {
                this.expandAllCall(this.parentRef);
            }
        }), 0);
    }
    /**
     * @param {?} node
     * @return {?}
     */
    expandAllCall(node) {
        node.forEach((/**
         * @param {?} childCheck
         * @return {?}
         */
        (childCheck) => {
            if (childCheck.hasOwnProperty('expand')) {
                if (!childCheck.expand) {
                    childCheck.expand = true;
                }
            }
            else {
                childCheck['expand'] = true;
            }
            if (childCheck.hasOwnProperty(this.childarraykey) && childCheck[this.childarraykey] != null) {
                this.expandAllCall(childCheck[this.childarraykey]);
            }
        }));
    }
    /**
     * @param {?} node
     * @return {?}
     */
    collapseAll(node) {
        this.collapseAllCall(this.parentRef);
    }
    /**
     * @param {?} node
     * @return {?}
     */
    collapseAllCall(node) {
        node.forEach((/**
         * @param {?} childCheck
         * @return {?}
         */
        (childCheck) => {
            if (childCheck.expand) {
                childCheck.expand = false;
            }
            if (childCheck.hasOwnProperty(this.childarraykey)) {
                this.collapseAllCall(childCheck[this.childarraykey]);
            }
        }));
    }
    /**
     * @param {?} node
     * @return {?}
     */
    onClick(node) {
        node.expand = !node.expand;
    }
    /**
     * @param {?} event
     * @param {?} data
     * @param {?} node
     * @param {?} index
     * @return {?}
     */
    onArrowDown(event, data, node, index) {
        /** @type {?} */
        const incrementindex = index + 1;
        /** @type {?} */
        const itemid = data[incrementindex];
        if (node.expand === true && node[this.childarraykey]) {
            /** @type {?} */
            const data1 = node[this.childarraykey][0];
            this.setFocus(data1);
        }
        else {
            if (incrementindex < data.length) {
                this.setFocus(itemid);
            }
            else {
                this.focusTONextParent(node);
            }
        }
    }
    /**
     * @param {?} data
     * @param {?} node
     * @param {?} index
     * @return {?}
     */
    onArrowUp(data, node, index) {
        /** @type {?} */
        const newindex = index - 1;
        if (newindex >= 0) {
            /** @type {?} */
            const previousindex = data[newindex];
            this.setFocus(previousindex);
            this.focusToInnerLastItem(previousindex);
        }
        else {
            /** @type {?} */
            const id = node.elementId;
            /** @type {?} */
            const spiltID = this.splitID(id);
            /** @type {?} */
            const randomnumber = spiltID[0];
            /** @type {?} */
            const currentid = spiltID[1];
            /** @type {?} */
            const newid = parseInt(currentid.slice(0, -1), 10);
            /** @type {?} */
            const id2 = newid;
            /** @type {?} */
            const focusid1 = randomnumber + '-' + id2;
            if (document.getElementById(focusid1)) {
                document.getElementById(focusid1).focus();
            }
        }
    }
    /**
     * @param {?} node
     * @return {?}
     */
    focusToInnerLastItem(node) {
        if (node.hasOwnProperty('expand') && node.expand && node[this.childarraykey]) {
            node[this.childarraykey].forEach((/**
             * @param {?} innernode
             * @return {?}
             */
            (innernode) => {
                this.focusToInnerLastItem(innernode);
            }));
        }
        else {
            this.setFocus(node);
        }
    }
    /**
     * @param {?} node
     * @return {?}
     */
    focusTONextParent(node) {
        /** @type {?} */
        const sliceId = this.splitID(node.elementId);
        /** @type {?} */
        const randomnumber = sliceId[0];
        /** @type {?} */
        const currentid = sliceId[1];
        /** @type {?} */
        const newid = parseInt(currentid.slice(0, -1), 10);
        /** @type {?} */
        const currentitem = newid + 1;
        /** @type {?} */
        const focusid1 = randomnumber + '-' + currentitem;
        if (document.getElementById(focusid1)) {
            document.getElementById(focusid1).focus();
        }
        else {
            /** @type {?} */
            const nextnewid = parseInt(currentitem.toString().slice(0, -1), 10);
            /** @type {?} */
            const id3 = nextnewid + 1;
            /** @type {?} */
            const focusid2 = randomnumber + '-' + id3;
            if (document.getElementById(focusid2)) {
                document.getElementById(focusid2).focus();
            }
        }
    }
    /**
     * @param {?} id
     * @return {?}
     */
    splitID(id) {
        return id.split('-');
    }
    /**
     * @param {?} focuselement
     * @return {?}
     */
    setFocus(focuselement) {
        if (document.getElementById(focuselement.elementId)) {
            document.getElementById(focuselement.elementId).focus();
        }
    }
    /**
     * @param {?} node
     * @return {?}
     */
    onNodeClick(node) {
        /** @type {?} */
        const cloneNode = JSON.parse(JSON.stringify(node));
        this.cloneMethod(cloneNode);
        this.nodeClick.emit(cloneNode);
        this.activateNode(this.data, node);
    }
    /**
     * @param {?} cloneNode
     * @return {?}
     */
    cloneMethod(cloneNode) {
        delete cloneNode['elementId'];
        if (cloneNode.children) {
            cloneNode.children.forEach((/**
             * @param {?} element
             * @return {?}
             */
            (element) => {
                this.cloneMethod(element);
            }));
        }
    }
    /**
     * @param {?} data
     * @param {?} parentId
     * @param {?} rannumber
     * @return {?}
     */
    generateIndex(data, parentId, rannumber) {
        data.forEach((/**
         * @param {?} element
         * @param {?} index
         * @return {?}
         */
        (element, index) => {
            element['elementId'] = '' + rannumber + '-' + parentId + (index + 1);
            if (element[this.childarraykey]) {
                this.generateIndex(element[this.childarraykey], element.elementId.split('-')[1], rannumber);
            }
        }));
    }
    /**
     * @param {?} data
     * @param {?} node
     * @return {?}
     */
    activateNode(data, node) {
        for (const i of data) {
            if (node === data[i] && !i[this.childarraykey]) {
                i['active'] = true;
            }
            else {
                i['active'] = false;
            }
            if (i[this.childarraykey]) {
                this.activateNode(i[this.childarraykey], node);
            }
        }
    }
    /**
     * @param {?} httpResponse
     * @return {?}
     */
    setData(httpResponse) {
        // Check if key is added?
        /** @type {?} */
        let responsedata = httpResponse;
        if (this.datareader != null) {
            /** @type {?} */
            const dr = this.datareader.split('.');
            for (const ir of dr) {
                responsedata = responsedata[ir];
            }
        }
        else {
            responsedata = httpResponse;
        }
        this.data = responsedata;
        this.parentRef = this.data;
        if (this.globalTreeData.length === 0 && !this.filtertreeflag) {
            this.globalTreeData = this.data;
            this.generateIndex(this.globalTreeData, 1, window.crypto.getRandomValues(new Uint32Array(1))[0]);
        }
        this.setSelectedFlag();
        this.activateNode(this.data, null);
    }
    // To add isSelected flag explicitily in tree Data
    /**
     * @return {?}
     */
    setSelectedFlag() {
        if (this.parentRef && this.parentRef.length > 0) {
            this.parentRef.forEach((/**
             * @param {?} node
             * @return {?}
             */
            (node) => {
                if (node) {
                    if (node.hasOwnProperty('isSelected')) {
                        node.isSelected = false;
                    }
                    else {
                        node['isSelected'] = false;
                    }
                    if (node.hasOwnProperty(this.childarraykey) && node[this.childarraykey] && node[this.childarraykey].length > 0) {
                        this.setSelectedFlagInChild(node);
                    }
                }
            }));
        }
    }
    /**
     * @param {?} node
     * @return {?}
     */
    setSelectedFlagInChild(node) {
        if (node[this.childarraykey] && node[this.childarraykey].length > 0) {
            node[this.childarraykey].forEach((/**
             * @param {?} childcom
             * @return {?}
             */
            (childcom) => {
                if (childcom.hasOwnProperty('isSelected')) {
                    childcom.isSelected = false;
                }
                else {
                    childcom['isSelected'] = false;
                }
                if (childcom.hasOwnProperty(this.childarraykey)
                    && childcom[this.childarraykey] && childcom[this.childarraykey].length > 0) {
                    this.setSelectedFlagInChild(childcom);
                }
            }));
        }
    }
    /**
     * @param {?} checkedData
     * @return {?}
     */
    emitCheckedData(checkedData) {
        checkedData.checked = !checkedData.checked;
        if (checkedData.checked) {
            if (checkedData.hasOwnProperty(this.childarraykey)) {
                checkedData[this.childarraykey].forEach((/**
                 * @param {?} option
                 * @return {?}
                 */
                (option) => {
                    option.checked = true;
                    if (option.hasOwnProperty(this.childarraykey)) {
                        this.setCheckedStatusFromParent(option);
                    }
                }));
            }
            this.emitData(checkedData);
        }
        else {
            if (checkedData.hasOwnProperty(this.childarraykey)) {
                checkedData[this.childarraykey].forEach((/**
                 * @param {?} option
                 * @return {?}
                 */
                (option) => {
                    option.checked = false;
                    if (option.hasOwnProperty(this.childarraykey)) {
                        this.searchObject(option);
                    }
                }));
            }
            this.emitData(checkedData);
        }
    }
    /**
     * @param {?} data
     * @return {?}
     */
    emitData(data) {
        /** @type {?} */
        const obj = {};
        for (const [key, value] of Object.entries(data)) {
            if (key !== 'id') {
                obj[key] = value;
            }
        }
        this.onTreeNodeChecked.emit(obj);
    }
    /**
     * @param {?} object
     * @return {?}
     */
    searchObject(object) {
        object[this.childarraykey].forEach((/**
         * @param {?} childOption
         * @return {?}
         */
        (childOption) => {
            childOption.checked = false;
            if (childOption.hasOwnProperty(this.childarraykey)) {
                this.searchObject(childOption);
            }
        }));
    }
    /**
     * @param {?} object
     * @return {?}
     */
    setCheckedStatusFromParent(object) {
        object[this.childarraykey].forEach((/**
         * @param {?} childOption
         * @return {?}
         */
        (childOption) => {
            childOption.checked = true;
            if (childOption.hasOwnProperty(this.childarraykey)) {
                this.setCheckedStatusFromParent(childOption);
            }
        }));
    }
    /**
     * @param {?} data
     * @return {?}
     */
    onTreeNodeCheck(data) {
        this.onTreeNodeChecked.emit(data);
    }
    // Method to drag parent with node
    /**
     * @param {?} dragData
     * @return {?}
     */
    onDragStart(dragData) {
        dragData.event.dataTransfer.setData('treenodedata', JSON.stringify(dragData.data));
        dragData.event.dataTransfer.effectAllowed = 'copy';
        this.dragData = dragData;
        this.onDrag.emit(dragData);
    }
    /**
     * @param {?} dragOverData
     * @return {?}
     */
    allowDrop(dragOverData) {
        dragOverData.event.preventDefault();
        if (!this.enabledrop) {
            dragOverData.event.dataTransfer.dropEffect = 'none';
        }
        this.noDragMethod(this.dragData, dragOverData.data, dragOverData.event);
        this.dragover.emit(dragOverData);
    }
    /**
     * @param {?} dragData
     * @param {?} node
     * @param {?} event
     * @return {?}
     */
    noDragMethod(dragData, node, event) {
        if (!this.acrosstree) {
            if (dragData.data === node || node.leaf === true) {
                event.dataTransfer.dropEffect = 'none';
            }
            else {
                event.target.style.border = '3px dotted green';
            }
        }
        else {
            if (node.leaf === true) {
                event.dataTransfer.dropEffect = 'none';
            }
            else {
                event.target.style.border = '3px dotted green';
            }
        }
        if (dragData.data.hasOwnProperty(this.childarraykey)) {
            this.getDropNode(dragData, node, event);
        }
    }
    /**
     * @param {?} dragData
     * @param {?} node
     * @param {?} event
     * @return {?}
     */
    getDropNode(dragData, node, event) {
        if (JSON.stringify(dragData.data) === JSON.stringify(node)) {
            event.dataTransfer.dropEffect = 'none';
        }
        else if (dragData.data[this.childarraykey] && dragData.data[this.childarraykey].length > 0) {
            dragData.data[this.childarraykey].forEach((/**
             * @param {?} child
             * @return {?}
             */
            (child) => {
                if (JSON.stringify(child) === JSON.stringify(node) || node.leaf === true) {
                    event.dataTransfer.dropEffect = 'none';
                }
                else if (child.hasOwnProperty(this.childarraykey)) {
                    this.getDropNode({ data: child, event1: event }, node, event);
                }
            }));
        }
    }
    /**
     * @param {?} dropData
     * @return {?}
     */
    drop(dropData) {
        if (this.enabledrop) {
            dropData.event.target.style.border = '';
            dropData.event.preventDefault();
            if (this.acrosstree === false) {
                this.setDropAcrosstree(dropData);
                if (this.isNode === true) {
                    this.setDropNodeTree(dropData);
                }
            }
            else {
                if (dropData.data.hasOwnProperty(this.childarraykey)) {
                    this.removeNode(dropData);
                    dropData.data[this.childarraykey].push(JSON.parse(dropData.event.dataTransfer.getData('treenodedata')));
                    this.onDrop.emit(dropData);
                }
            }
        }
    }
    // drop method split into 2 other method setDropAcrosstree, setDropNodeTree
    // first method of drop
    /**
     * @param {?} dropData
     * @return {?}
     */
    setDropAcrosstree(dropData) {
        if (this.dragData.data === dropData.data) {
            this.isNode = false;
        }
        else if (this.dragData.data.hasOwnProperty(this.childarraykey)) {
            this.checkNode(this.dragData, dropData);
        }
    }
    // second method pf drop
    /**
     * @param {?} dropData
     * @return {?}
     */
    setDropNodeTree(dropData) {
        if (dropData.data.hasOwnProperty(this.childarraykey)) {
            this.removeNode(dropData);
            dropData.data[this.childarraykey].push(JSON.parse(dropData.event.dataTransfer.getData('treenodedata')));
            this.onDrop.emit(dropData);
        }
    }
    /**
     * @param {?} dragData
     * @param {?} dropData
     * @return {?}
     */
    checkNode(dragData, dropData) {
        this.dragData.data[this.childarraykey].forEach((/**
         * @param {?} child
         * @return {?}
         */
        (child) => {
            if (JSON.stringify(child) === JSON.stringify(dropData.data)) {
                this.isNode = false;
            }
            else if (child.hasOwnProperty(this.childarraykey)) {
                this.checkNode(child, dropData);
            }
        }));
    }
    /**
     * @param {?} data
     * @return {?}
     */
    removeNode(data) {
        this.removeDragNode(this.parentRef, JSON.parse(data.event.dataTransfer.getData('treenodedata')));
    }
    /**
     * @param {?} treeData
     * @param {?} dragNode
     * @return {?}
     */
    removeDragNode(treeData, dragNode) {
        treeData.forEach((/**
         * @param {?} childNode
         * @param {?} index
         * @return {?}
         */
        (childNode, index) => {
            if (JSON.stringify(childNode) === JSON.stringify(dragNode)) {
                treeData.splice(index, 1);
            }
            else if (childNode.hasOwnProperty(this.childarraykey)) {
                this.removeDragNode(childNode[this.childarraykey], dragNode);
            }
        }));
    }
    /**
     * @param {?} event
     * @return {?}
     */
    dragleave(event) {
        event.target.style.border = '';
    }
    /**
     * @return {?}
     */
    getContextMenu() {
        this.contextmenu = this.cloneContextMenuData;
        if (this.contextmenu && this.contextmenu.length > 0) {
            this.flag = true;
            this.addListner();
        }
    }
    /**
     * @return {?}
     */
    resetFlag() {
        if (this.flag) {
            this.flag = false;
            this.setSelectedFlag();
        }
    }
    /**
     * @param {?} rightClickData
     * @return {?}
     */
    loadContextMenu(rightClickData) {
        this.setSelectedFlag();
        this.mouseLocation.left = rightClickData.event.clientX;
        this.mouseLocation.top = rightClickData.event.clientY;
        rightClickData.data['isSelected'] = true;
        if (rightClickData.data.hasOwnProperty('rightClickData') && rightClickData.data.rightClickData.length > 0) {
            this.contextmenu = [];
            this.contextmenu = rightClickData.data.rightClickData;
            this.flag = true;
            this.addListner();
        }
        else {
            this.getContextMenu();
        }
        this.posixUp = this.getListPosition(rightClickData.ref);
        if (this.contextmenu && this.contextmenu.length > 0) {
            rightClickData.event.preventDefault();
            rightClickData.event.stopPropagation();
        }
        this.rightClickNodeData = rightClickData.data;
        this.nodeRightClick.emit(rightClickData);
    }
    /**
     * @param {?} elementRef
     * @return {?}
     */
    getListPosition(elementRef) {
        /** @type {?} */
        const height = 240;
        if ((window.screen.height - elementRef.getBoundingClientRect().bottom) < height) {
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * @param {?} Data
     * @return {?}
     */
    rightClickDataEmit(Data) {
        this.rightClick.emit(Data);
    }
    /**
     * @return {?}
     */
    addListner() {
        this.globalClickListenFunc = this.renderer.listen('document', 'click', (/**
         * @param {?} e
         * @return {?}
         */
        (e) => {
            this.resetFlag();
            if (!this.flag) {
                this.removeListner();
            }
        }));
    }
    /**
     * @return {?}
     */
    removeListner() {
        if (this.globalClickListenFunc) {
            this.globalClickListenFunc();
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.removeListner();
        if (this.destroyExpandAll) {
            clearTimeout(this.destroyExpandAll);
        }
    }
}
AmexioTreeViewComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-treeview', template: `
      <div *ngIf="data == null" style="height: 300px;width: 300px;">
        <div class="spinner"></div>
      </div>

      <div class="treenode" *ngFor="let node of data let rowindex = index">
        <div #id class="treenode-content" (click)="onClick(node)" (keyup.enter)="onClick(node)">
          <div style="white-space:nowrap">
            <div  aria-label="Dropdown button clickable" class="tree-node-label" *ngIf="node[childarraykey] && (node[childarraykey].length>0)">
              <em class="fa" [ngClass]="{'fa-angle-down':node.expand,'fa-angle-right':!node.expand}"></em>
            </div> &nbsp;
            <div tabindex="1" id={{node.elementId}} role="treeitem" (keyup.arrowup)="onArrowUp(data,node,rowindex)"
              (keyup.arrowdown)="onArrowDown($event,data,node,rowindex)" class="tree-node-label tree-node-label-hover"
              [attr.aria-expanded]="node.expand" [ngClass]="{'tree-node-label-selected':node.isSelected ,'tree-node-label-not-selected':node.isSelected==false}"
              [attr.draggable]="enabledrag" (dragleave)="dragleave($event)" (drop)="drop({event:$event,data:node})"
              (dragover)="allowDrop({event:$event,data:node})" (dragstart)="onDragStart({event:$event,data:node})"
              (contextmenu)="loadContextMenu({event:$event,data:node,ref:id})">
              <div class="tree-node-label" *ngIf="enablecheckbox">
                <input type="checkbox" [checked]="'checked'?node.checked:null" (click)="emitCheckedData(node)" />
              </div>
              <div class="tree-node-label" (click)="onNodeClick(node)">
                <div class="tree-node-label" *ngIf="templates == null">
                  <div class="tree-node-label" *ngIf="node.icon" [ngClass]="node.icon" aria-hidden="true" style="padding-right: 5px;">
                  </div>
                  <div class="tree-node-label" [ngClass]="{'a':!wordwrap}">
                    {{node[displaykey]}}
                    <ng-container *ngIf="badge && node.badge">
                      <span class="tree-badge">{{node.badge}}</span>
                    </ng-container>
                  </div>
                </div>
                <div class="tree-node-label" [ngClass]="{'a':!wordwrap}" *ngIf="templates != null">
                  <ng-template [ngTemplateOutlet]="templates.treeNodeTemplate" [ngTemplateOutletContext]="{ $implicit: { text: node.text } , icon: node.icon,node : node }">
                  </ng-template>
                </div>
              </div>

            </div>
          </div>
        </div>
        <div class="treenode-children" style="display: block;" *ngIf="node.expand && node[childarraykey] && (node[childarraykey].length>0)">
          <amexio-treeview [child-array-key]="childarraykey" [display-key]="displaykey" [enable-drag]="enabledrag"
            [enable-drop]="enabledrop" [word-wrap]="wordwrap" [data]="node[childarraykey]"  [dragData]="dragData" [parentRef]="parentRef" (onDrag)=onDragStart($event)
            (onDrop)=drop($event) (nodeClick)="onNodeClick($event)" (dragleave)="($event)" (nodeRightClick)="loadContextMenu($event)"
            [across-tree]="acrosstree" [templates]="templates"
             [global-tree-data]="globalTreeData"
             [filter-tree-flag]="filtertreeflag"
             [enable-checkbox]="enablecheckbox" [badge]="badge"
            (onTreeNodeChecked)="this.onTreeNodeCheck($event)">
          </amexio-treeview>
        </div>
      </div>
      <ng-container *ngIf="flag">
        <base-contextmenu [base-context-menu]="contextmenu" [mouse-location-top]="mouseLocation.top" [mouse-location-left]="mouseLocation.left"
          [is-FlagShow]="flag" [right-click-data]="rightClickNodeData" (onRightClick)="rightClickDataEmit($event)"
          [position-up]="posixUp">
        </base-contextmenu>
      </ng-container>
    `,
            },] },
];
/** @nocollapse */
AmexioTreeViewComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: CommonDataService },
    { type: ChangeDetectorRef },
    { type: Renderer2 }
];
AmexioTreeViewComponent.propDecorators = {
    data: [{ type: Input, args: ['data',] }],
    httpurl: [{ type: Input, args: ['http-url',] }],
    httpmethod: [{ type: Input, args: ['http-method',] }],
    datareader: [{ type: Input, args: ['data-reader',] }],
    displaykey: [{ type: Input, args: ['display-key',] }],
    childarraykey: [{ type: Input, args: ['child-array-key',] }],
    nodeClick: [{ type: Output }],
    enablecheckbox: [{ type: Input, args: ['enable-checkbox',] }],
    templates: [{ type: Input }],
    enabledrag: [{ type: Input, args: ['enable-drag',] }],
    enabledrop: [{ type: Input, args: ['enable-drop',] }],
    acrosstree: [{ type: Input, args: ['across-tree',] }],
    badge: [{ type: Input, args: ['badge',] }],
    contextmenu: [{ type: Input, args: ['context-menu',] }],
    parentRef: [{ type: Input }],
    filtertreeflag: [{ type: Input, args: ['filter-tree-flag',] }],
    wordwrap: [{ type: Input, args: ['word-wrap',] }],
    parentTmp: [{ type: ContentChild, args: ['amexioTreeTemplate',] }],
    onTreeNodeChecked: [{ type: Output }],
    onDrag: [{ type: Output }],
    onDrop: [{ type: Output }],
    dragover: [{ type: Output }],
    dragData: [{ type: Input }],
    nodeRightClick: [{ type: Output }],
    rightClick: [{ type: Output }],
    globalTreeData: [{ type: Input, args: ['global-tree-data',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 * Copyright 2016-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Author - Ketan Gote, Pratik Kelwalkar, Dattaram Gawas
 *
 */
/*
Component Name : Amexio tree data table
Component Selector : <amexio-tree-data-table>
Component Description :  A Simple Expandable Tree component which create Tree View based on standard datasource attached.
*/
class TreeDataTableComponent extends LifeCycleBaseComponent {
    /**
     * @param {?} treeDataTableService
     * @param {?} document
     */
    constructor(treeDataTableService, document) {
        super(document);
        this.treeDataTableService = treeDataTableService;
        this.document = document;
        /*
           Events
           name : selectedRecord
           datatype : none
           version : none
           default : none
           description : Get selected value Object.
           */
        this.selectedRecord = new EventEmitter();
        this.rowSelect = new EventEmitter();
        this.columns = [];
        this.mask = true;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set data(value) {
        this._data = value;
        if (this.componentLoaded) {
            this.updateComponent();
        }
    }
    /**
     * @return {?}
     */
    get data() {
        return this._data;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
        if (this.httpmethod && this.httpurl) {
            this.treeDataTableService.fetchData(this.httpurl, this.httpmethod).subscribe((/**
             * @param {?} response
             * @return {?}
             */
            (response) => {
                this.responseData = response;
            }), (/**
             * @param {?} error
             * @return {?}
             */
            (error) => {
            }), (/**
             * @return {?}
             */
            () => {
                this.setData(this.responseData);
            }));
        }
        else if (this.data) {
            this.previousValue = JSON.parse(JSON.stringify(this.data));
            this.setData(this.data);
        }
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.onResize();
        this.componentLoaded = true;
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.createConfig();
    }
    /**
     * @return {?}
     */
    createConfig() {
        /** @type {?} */
        const columnRefArray = this.columnRef.toArray();
        for (const cr of columnRefArray) {
            /** @type {?} */
            const columnConfig = cr;
            /** @type {?} */
            let columnData;
            if (columnConfig.headerTemplate != null && columnConfig.bodyTemplate != null) {
                columnData = {
                    text: columnConfig.text,
                    dataindex: columnConfig.dataindex,
                    hidden: columnConfig.hidden,
                    datatype: columnConfig.datatype,
                    headerTemplate: columnConfig.headerTemplate,
                    width: columnConfig.width,
                    bodyTemplate: columnConfig.bodyTemplate,
                };
            }
            else if (columnConfig.headerTemplate != null && columnConfig.bodyTemplate == null) {
                columnData = {
                    text: columnConfig.text,
                    dataindex: columnConfig.dataindex,
                    hidden: columnConfig.hidden,
                    datatype: columnConfig.datatype,
                    width: columnConfig.width,
                    headerTemplate: columnConfig.headerTemplate,
                };
            }
            else if (columnConfig.bodyTemplate != null && columnConfig.headerTemplate == null) {
                columnData = {
                    text: columnConfig.text,
                    dataindex: columnConfig.dataindex,
                    hidden: columnConfig.hidden,
                    datatype: columnConfig.datatype,
                    width: columnConfig.width,
                    bodyTemplate: columnConfig.bodyTemplate,
                };
            }
            else if (columnConfig.bodyTemplate == null && columnConfig.headerTemplate == null) {
                columnData = {
                    text: columnConfig.text,
                    dataindex: columnConfig.dataindex,
                    hidden: columnConfig.hidden,
                    width: columnConfig.width,
                    datatype: columnConfig.datatype,
                };
            }
            this.columns.push(columnData);
        }
    }
    /**
     * @return {?}
     */
    updateComponent() {
        if (this.data) {
            this.viewRows = this.getResponseData(this.data);
        }
    }
    /**
     * @param {?} httpResponse
     * @return {?}
     */
    setData(httpResponse) {
        if (httpResponse) {
            /** @type {?} */
            const treedata = this.getResponseData(httpResponse);
            this.viewRows = treedata;
            this.viewRows.forEach((/**
             * @param {?} row
             * @param {?} index
             * @return {?}
             */
            (row, index) => {
                this.viewRows[index].level = 1;
                this.viewRows[index].expanded = false;
            }));
            this.mask = false;
        }
        else {
            this.viewRows = [];
        }
        this.generateIndex(this.viewRows, 1, window.crypto.getRandomValues(new Uint32Array(1))[0]);
    }
    /**
     * @param {?} httpResponse
     * @return {?}
     */
    getResponseData(httpResponse) {
        /** @type {?} */
        let responsedata = httpResponse;
        if (this.datareader != null) {
            /** @type {?} */
            const dr = this.datareader.split('.');
            for (const ir of dr) {
                responsedata = responsedata[ir];
            }
        }
        else {
            responsedata = httpResponse;
        }
        return responsedata;
    }
    /**
     * @return {?}
     */
    removeAll() {
        this.viewRows.forEach((/**
         * @param {?} node
         * @return {?}
         */
        (node) => {
            node.expanded = false;
            this.removeRows(node);
        }));
    }
    /**
     * @return {?}
     */
    expandAll() {
        this.viewRows.forEach((/**
         * @param {?} node
         * @param {?} index
         * @return {?}
         */
        (node, index) => {
            node.expanded = true;
            this.addRows(node, index);
        }));
    }
    /**
     * @param {?} row
     * @param {?} index
     * @return {?}
     */
    toogle(row, index) {
        row.expanded = !row.expanded;
        if (row.expanded) {
            this.addRows(row, index);
        }
        else {
            this.removeRows(row);
        }
    }
    /**
     * @param {?} row
     * @param {?} index
     * @return {?}
     */
    addRows(row, index) {
        if (row.children) {
            for (let i = 0; i < row.children.length; i++) {
                /** @type {?} */
                const node = row.children[i];
                if (!row.level) {
                    row.level = 1;
                }
                if (node.children) {
                    node.expanded = false;
                }
                node.level = (row.level + 1);
                this.viewRows.splice(index + (i + 1), 0, node);
            }
        }
    }
    /**
     * @param {?} node
     * @return {?}
     */
    removeRows(node) {
        if (node.children) {
            for (const nc of node.children) {
                if (this.viewRows) {
                    this.setRemovedRows(nc);
                }
            }
        }
    }
    /**
     * @param {?} nc
     * @return {?}
     */
    setRemovedRows(nc) {
        for (const vr of this.viewRows) {
            if (vr === nc) {
                if (nc.children) {
                    this.removeRows(nc);
                }
                this.viewRows.splice(this.viewRows.indexOf(nc), 1);
            }
        }
    }
    /**
     * @param {?} rowData
     * @param {?} event
     * @return {?}
     */
    setSelectedRow(rowData, event) {
        this.selectedRecord.emit(rowData);
        this.rowSelect.emit(rowData);
    }
    /**
     * @return {?}
     */
    onResize() {
        if (this.height) {
            /** @type {?} */
            let h = (window.innerHeight / 100) * this.height;
            if (this.gridHeader && this.gridHeader.nativeElement && this.gridHeader.nativeElement.offsetHeight) {
                h = h - this.gridHeader.nativeElement.offsetHeight;
            }
            if (this.height === 100) {
                h = h - 40;
            }
            this.height = h;
        }
    }
    // Tab Navigation
    /**
     * @param {?} data
     * @param {?} parentId
     * @param {?} rannumber
     * @return {?}
     */
    generateIndex(data, parentId, rannumber) {
        data.forEach((/**
         * @param {?} element
         * @param {?} index
         * @return {?}
         */
        (element, index) => {
            element['id'] = '' + rannumber + '-';
            if (element['children']) {
                this.generateIndex(element['children'], element.id.split('-')[1], rannumber);
            }
        }));
    }
    /**
     * @param {?} id
     * @return {?}
     */
    splitID(id) {
        return id.split('-');
    }
    /**
     * @param {?} ref
     * @return {?}
     */
    arrowUp(ref) {
        /** @type {?} */
        const id = ref.id;
        /** @type {?} */
        const spiltID = this.splitID(id);
        /** @type {?} */
        const randomNo = spiltID[0];
        /** @type {?} */
        const currentId = spiltID[1];
        /** @type {?} */
        const unitId = currentId.slice(0, -1);
        if (unitId > 1 && document.getElementById(randomNo + '-' + (parseInt(currentId, 10) - 10).toString())) {
            document.getElementById(randomNo + '-' + (parseInt(currentId, 10) - 10).toString()).focus();
        }
    }
    /**
     * @param {?} ref
     * @return {?}
     */
    arrowDown(ref) {
        /** @type {?} */
        const id = ref.id;
        /** @type {?} */
        const spiltID = this.splitID(id);
        /** @type {?} */
        const randomNo = spiltID[0];
        /** @type {?} */
        const currentId = spiltID[1];
        /** @type {?} */
        const firstId = parseInt(currentId.slice(0, -1), 10);
        if ((firstId < this.viewRows.length || (firstId <= this.viewRows.length - 1))
            && document.getElementById(randomNo + '-' + (parseInt(currentId, 10) + 10).toString())) {
            document.getElementById(randomNo + '-' + (parseInt(currentId, 10) + 10).toString()).focus();
        }
    }
    /**
     * @param {?} ref
     * @return {?}
     */
    arrowRight(ref) {
        /** @type {?} */
        const id = ref.id;
        /** @type {?} */
        const spiltID = this.splitID(id);
        /** @type {?} */
        const randomNo = spiltID[0];
        /** @type {?} */
        const currentId = spiltID[1];
        /** @type {?} */
        const unitId = parseInt(currentId, 10) % 10;
        /** @type {?} */
        const firstId = currentId.slice(0, -1);
        this.findNextColumn(unitId, firstId, randomNo);
    }
    /**
     * @param {?} index
     * @param {?} firstId
     * @param {?} randomNo
     * @return {?}
     */
    findNextColumn(index, firstId, randomNo) {
        if (index < this.columns.length) {
            if (this.columns.length >= 1 && this.columns.includes(index + 1)) {
                index = index + 1;
                this.findNextColumn(index, firstId, randomNo);
            }
            else {
                /** @type {?} */
                const generatedId = firstId + '' + (index + 1);
                document.getElementById(randomNo + '-' + (parseInt(generatedId, 10)).toString()).focus();
            }
        }
    }
    /**
     * @param {?} ref
     * @return {?}
     */
    arrowLeft(ref) {
        /** @type {?} */
        const id = ref.id;
        /** @type {?} */
        const spiltID = this.splitID(id);
        /** @type {?} */
        const randomNo = spiltID[0];
        /** @type {?} */
        const currentId = spiltID[1];
        /** @type {?} */
        const unitId = parseInt(currentId, 10) % 10;
        /** @type {?} */
        const firstId = currentId.slice(0, -1);
        this.findPreviousColumn(unitId, firstId, randomNo);
    }
    /**
     * @param {?} index
     * @param {?} firstId
     * @param {?} randomNo
     * @return {?}
     */
    findPreviousColumn(index, firstId, randomNo) {
        if (index > 1) {
            if (this.columns.length >= 1 && this.columns.includes(index - 1)) {
                index = index - 1;
                this.findPreviousColumn(index, firstId, randomNo);
            }
            else {
                /** @type {?} */
                const generatedId = firstId + '' + (index - 1);
                document.getElementById(randomNo + '-' + (parseInt(generatedId, 10)).toString()).focus();
            }
        }
    }
    // HOME
    /**
     * @param {?} ref
     * @return {?}
     */
    keyHome(ref) {
        /** @type {?} */
        const id = ref.id;
        /** @type {?} */
        const spiltID = this.splitID(id);
        /** @type {?} */
        const randomNo = spiltID[0];
        /** @type {?} */
        const currentId = spiltID[1];
        /** @type {?} */
        const unitId = parseInt(currentId, 10) % 10;
        this.findHomeColumn(unitId, currentId.slice(0, -1), 1, randomNo);
    }
    // HOME: TO FIND FIRST COLUMN
    /**
     * @param {?} unitId
     * @param {?} firstId
     * @param {?} newFirstId
     * @param {?} randomNo
     * @return {?}
     */
    findHomeColumn(unitId, firstId, newFirstId, randomNo) {
        if (this.columns.length >= 1 && this.columns.includes(newFirstId)) {
            this.findHomeColumn(unitId, firstId, newFirstId + 1, randomNo);
        }
        else {
            /** @type {?} */
            const generatedId = firstId + '' + newFirstId;
            document.getElementById(randomNo + '-' + (parseInt(generatedId, 10)).toString()).focus();
        }
    }
    // END
    /**
     * @param {?} ref
     * @return {?}
     */
    keyEnd(ref) {
        /** @type {?} */
        const id = ref.id;
        /** @type {?} */
        const spiltID = this.splitID(id);
        /** @type {?} */
        const randomNo = spiltID[0];
        /** @type {?} */
        const currentId = spiltID[1];
        /** @type {?} */
        const unitId = parseInt(currentId, 10) % 10;
        /** @type {?} */
        const firstId = currentId.slice(0, -1);
        /** @type {?} */
        const newLastId = this.columns.length;
        this.findHomeColumn(unitId, firstId, newLastId, randomNo);
    }
    /**
     * @param {?} ref
     * @return {?}
     */
    keyControlHome(ref) {
        /** @type {?} */
        const id = ref.id;
        /** @type {?} */
        const spiltID = this.splitID(id);
        /** @type {?} */
        const randomNo = spiltID[0];
        this.findControlHomeColumn(1, 1, randomNo);
    }
    /**
     * @param {?} unitId
     * @param {?} firstId
     * @param {?} randomNo
     * @return {?}
     */
    findControlHomeColumn(unitId, firstId, randomNo) {
        if (this.columns.length >= 1 && this.columns.includes(unitId)) {
            this.findControlHomeColumn(unitId + 1, firstId, randomNo);
        }
        else {
            /** @type {?} */
            const generatedId = firstId + '' + unitId;
            document.getElementById(randomNo + '-' + (parseInt(generatedId, 10)).toString()).focus();
        }
    }
    /**
     * @param {?} ref
     * @return {?}
     */
    keyControlEnd(ref) {
        /** @type {?} */
        const id = ref.id;
        /** @type {?} */
        const spiltID = this.splitID(id);
        /** @type {?} */
        const randomNo = spiltID[0];
        /** @type {?} */
        const unitId = this.columns.length;
        /** @type {?} */
        const firstId = this.viewRows.length;
        this.findControlEndColumn(unitId, firstId, randomNo);
    }
    /**
     * @param {?} unitId
     * @param {?} firstId
     * @param {?} randomNo
     * @return {?}
     */
    findControlEndColumn(unitId, firstId, randomNo) {
        if (this.columns.length >= 1 && this.columns.includes(unitId)) {
            this.findControlHomeColumn(unitId - 1, firstId, randomNo);
        }
        else {
            /** @type {?} */
            const generatedId = firstId + '' + unitId;
            document.getElementById(randomNo + '-' + (parseInt(generatedId, 10)).toString()).focus();
        }
    }
}
TreeDataTableComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-tree-data-table',
                template: `
    <div (window:resize)="onResize()" [ngClass]="{'datagrid-full-screen': yesFullScreen && fullscreenMax}">
        <div #header class="datatable">
            <div class="datatable-header">
                <ng-container *ngFor="let cols of columns;let i = index">
                    <ng-container *ngIf="cols.datatype=='string'">
                        <div class="datatable-col" tabindex="1" [ngClass]="{'header' : i == 0}" [style.width.%]="cols.width">
                            <ng-container *ngIf="cols.headerTemplate">
                                <ng-template [ngTemplateOutlet]="cols.headerTemplate" [ngTemplateOutletContext]="{column:cols ,index: i}"></ng-template>
                            </ng-container>
                            <ng-container *ngIf="!cols.headerTemplate">
                                {{cols.text}}
                            </ng-container>
                        </div>
                    </ng-container>
                    <ng-container *ngIf="cols.datatype=='number'">
                        <ng-container *ngIf="cols.headerTemplate">
                            <ng-template [ngTemplateOutlet]="cols.headerTemplate" [ngTemplateOutletContext]="{column:cols ,index: i}"></ng-template>
                        </ng-container>
                        <ng-container *ngIf="!cols.headerTemplate">
                            <span class="float-right" style="display:flex">
                                <div class="datatable-col" tabindex="1" [style.width.%]="cols.width" [ngClass]="{'header' : i == 0}"> {{cols.text}}</div>
                                <span *ngIf="yesFullScreen" style="padding-right: 4px;">
                                    <amexio-c-icon class="cursor-style" *ngIf="((yesFullScreen && fullscreenMax))" [key]="'full-screen-min-icon'" (onClick)="minScreenChange($event)"></amexio-c-icon>
                                    <amexio-c-icon class="cursor-style" *ngIf="((yesFullScreen && !fullscreenMax))" [key]="'full-screen-max-icon'" (onClick)="maxScreenChange($event)"></amexio-c-icon>
                                </span>
                            </span>
                        </ng-container>
                    </ng-container>
                </ng-container>
            </div>
        </div>

        <div class="datatable-height" [style.height.px]="height">
            <div class="datatable">
                <div style="height: 300px;" *ngIf="mask">
                    <div class="spinner"></div>
                </div>
                <ng-container *ngIf="!mask">
                    <div class="datatable-row" (click)="toogle(row,i)" *ngFor="let row of viewRows;let i=index" (click)="setSelectedRow(row, $event)">
                        <ng-container *ngFor="let cols of columns;let colIndex = index">
                            <ng-container *ngIf="cols.datatype=='string' && !cols?.bodyTemplate">
                                <div #ref id="{{row.id}}{{i+1}}{{colIndex+1}}" [attr.tabindex]="(((i+1== 1) && (colIndex + 1 == 1))? 1: -1)" (keyup.enter)="toogle(row,i)"
                                    (keyup.enter)="setSelectedRow(row, $event)" class="datatable-col" (keyup.arrowright)="arrowRight(ref)"
                                    (keyup.arrowleft)="arrowLeft(ref)" (keyup.arrowup)="arrowUp(ref)" (keyup.arrowdown)="arrowDown(ref)"
                                    (keyup.end)="keyEnd(ref)" (keyup.home)="keyHome(ref)" (keyup.control.end)="keyControlEnd(ref)"
                                    (keyup.control.home)="keyControlHome(ref)" [attr.data-label]="cols.text" [style.width.%]="cols.width">
                                    <ng-container *ngIf="colIndex == 0">
                                        <span [style.padding-left.px]="(!row.level || row.level <= 1? 10 : (10+(10*row.level)) )">
                                            <ng-container *ngIf="!row.expanded && row.children">
                                                <amexio-c-icon class="iconPaddingStyle" key="tree_collapse"></amexio-c-icon>
                                            </ng-container>
                                            <ng-container *ngIf="row.expanded && row.children">
                                                <amexio-c-icon class="iconPaddingStyle" key="tree_expand"></amexio-c-icon>
                                            </ng-container>
                                            <ng-container *ngIf="row[cols.dataindex]!= null && row[cols.dataindex]!= '' ;else elseBlock">
                                                {{row[cols.dataindex]}}
                                            </ng-container>
                                            <ng-template #elseBlock>
                                                &nbsp;
                                            </ng-template>
                                        </span>
                                    </ng-container>

                                    <ng-container *ngIf="colIndex > 0">
                                        <ng-container *ngIf="row[cols.dataindex]!= null && row[cols.dataindex]!= '' ;else elseBlock">
                                            {{row[cols.dataindex]}}
                                        </ng-container>
                                        <ng-template #elseBlock>
                                            &nbsp;
                                        </ng-template>
                                    </ng-container>
                                </div>
                            </ng-container>
                            <ng-container *ngIf="cols.datatype=='number' && !cols?.bodyTemplate">
                                <div #ref class="datatable-col" id="{{row.id}}{{i+1}}{{colIndex+1}}" (keyup.end)="keyEnd(ref)" (keyup.home)="keyHome(ref)"
                                    (keyup.control.end)="keyControlEnd(ref)" (keyup.control.home)="keyControlHome(ref)" (keyup.arrowright)="arrowRight(ref)"
                                    (keyup.arrowleft)="arrowLeft(ref)" (keyup.arrowup)="arrowUp(ref)" (keyup.arrowdown)="arrowDown(ref)"
                                    [attr.tabindex]="(((i+1== 1) && (colIndex + 1 == 1))? 1: -1)" (keyup.enter)="toogle(row,i)" (keyup.enter)="setSelectedRow(row, $event)"
                                    [attr.data-label]="cols.text" [style.width.%]="cols.width">
                                    <ng-container *ngIf="colIndex == 0">
                                        <span [style.padding-left.px]="(!row.level || row.level <= 1? 10 : (10+(10*row.level)) )">
                                            <ng-container *ngIf="!row.expanded && row.children">
                                                <amexio-c-icon class="iconPaddingStyle" key="tree_collapse"></amexio-c-icon>
                                            </ng-container>
                                            <ng-container *ngIf="row.expanded && row.children">
                                                <amexio-c-icon class="iconPaddingStyle" key="tree_expand"></amexio-c-icon>
                                            </ng-container>
                                            <span class="float-right">
                                                <ng-container *ngIf="row[cols.dataindex]!= null;else elseBlock">
                                                    {{row[cols.dataindex]}}
                                                </ng-container>
                                                <ng-template #elseBlock>
                                                    &nbsp;
                                                </ng-template>
                                            </span>
                                        </span>
                                    </ng-container>

                                    <ng-container *ngIf="colIndex > 0">
                                        <span class="float-right">
                                            <ng-container *ngIf="row[cols.dataindex]!= null;else elseBlock">
                                                {{row[cols.dataindex]}}
                                            </ng-container>
                                            <ng-template #elseBlock>
                                                &nbsp;
                                            </ng-template>
                                        </span>
                                    </ng-container>
                                </div>

                            </ng-container>

                            <ng-container *ngIf="cols.bodyTemplate">

                                <div #ref class="datatable-col" id="{{row.id}}{{i+1}}{{colIndex+1}}" (keyup.end)="keyEnd(ref)" (keyup.home)="keyHome(ref)"
                                    (keyup.control.end)="keyControlEnd(ref)" (keyup.control.home)="keyControlHome(ref)" (keyup.arrowright)="arrowRight(ref)"
                                    (keyup.arrowleft)="arrowLeft(ref)" (keyup.arrowup)="arrowUp(ref)" (keyup.arrowdown)="arrowDown(ref)"
                                    [attr.tabindex]="(((i+1== 1) && (colIndex + 1 == 1))? 1: -1)" (keyup.enter)="toogle(row,i)" (keyup.enter)="setSelectedRow(row, $event)"
                                    [attr.data-label]="cols.text" [style.width.%]="cols.width">
                                    <ng-container *ngIf="colIndex == 0">
                                        <span [style.padding-left.px]="(!row.level || row.level <= 1? 10 : (10+(10*row.level)) )">
                                            <ng-container *ngIf="!row.expanded && row.children">
                                                <amexio-c-icon class="iconPaddingStyle" key="tree_collapse"></amexio-c-icon>
                                            </ng-container>
                                            <ng-container *ngIf="row.expanded && row.children">
                                                <amexio-c-icon class="iconPaddingStyle" key="tree_expand"></amexio-c-icon>
                                            </ng-container>
                                            <ng-template [ngTemplateOutlet]="cols.bodyTemplate" [ngTemplateOutletContext]="{ $implicit: { text : row[cols.dataindex] }, row: row }"></ng-template>
                                        </span>
                                    </ng-container>

                                    <ng-container *ngIf="colIndex > 0">
                                        <ng-template [ngTemplateOutlet]="cols.bodyTemplate" [ngTemplateOutletContext]="{ $implicit: { text : row[cols.dataindex] }, row: row }"></ng-template>
                                    </ng-container>

                                </div>
                            </ng-container>

                        </ng-container>

                    </div>
                </ng-container>

            </div>
        </div>
    </div>
  `,
            },] },
];
/** @nocollapse */
TreeDataTableComponent.ctorParameters = () => [
    { type: CommonDataService },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
];
TreeDataTableComponent.propDecorators = {
    data: [{ type: Input, args: ['data',] }],
    datareader: [{ type: Input, args: ['data-reader',] }],
    httpmethod: [{ type: Input, args: ['http-method',] }],
    httpurl: [{ type: Input, args: ['http-url',] }],
    displayfield: [{ type: Input, args: ['display-field',] }],
    valuefield: [{ type: Input, args: ['value-field',] }],
    selectedRecord: [{ type: Output }],
    height: [{ type: Input }],
    gridHeader: [{ type: ViewChild, args: ['header', { read: ElementRef },] }],
    rowSelect: [{ type: Output }],
    columnRef: [{ type: ContentChildren, args: [AmexioGridColumnComponent,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const DATA_COMPONENTS = [
    AmexioTreeViewComponent,
    AmexioListBoxComponent,
    AmexioDatagridComponent,
    AmexioDataGridHeaderComponent,
    AmexioGoogleMapComponent,
    DataGridFilterComponent,
    AmexioPaginatorComponent,
    AmexioGridColumnComponent,
    PropertyGridComponent,
    SpeechBubbleComponent,
    AmexioProgressMultiBarComponent,
    AmexioProgressBarComponent,
    HorizontalTreeViewNodeComponent,
    HorizontalTreeViewComponent,
    AmexioFilterTreeComponent,
    TreeDataTableComponent,
    AmexioItemSelectorComponent,
    AmexioVirtualScrollerComponent,
    AmexioRadioGroupComponent,
];
class AmexioDataModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: AmexioDataModule,
            providers: [CommonDataService, GoogleMapScriptService],
        };
    }
}
AmexioDataModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    FormsModule,
                    AmexioPaneModule,
                    AmexioLayoutModule,
                    HttpClientModule,
                    AmexioBaseContextMenuModule,
                    AmexioCommonModule.forRoot(),
                ],
                exports: DATA_COMPONENTS,
                declarations: DATA_COMPONENTS,
                providers: [CommonDataService, GoogleMapScriptService],
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by manish on 27/08/19
*/
class RouterService {
    constructor() {
        this.routerEvent = new BehaviorSubject(null);
    }
    /**
     * @param {?} router
     * @return {?}
     */
    initializeRouter(router) {
        this.routerEvent.next(router);
    }
}
RouterService.decorators = [
    { type: Injectable },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DynamicTextDirective {
    /**
     * @param {?} viewContainerRef
     */
    constructor(viewContainerRef) {
        this.viewContainerRef = viewContainerRef;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @return {?}
     */
    ngAfterContentChecked() {
        /** @type {?} */
        const hostelement = this.viewContainerRef.element.nativeElement;
        this.iterateHTMLDOM(hostelement);
    }
    /**
     * @param {?} element
     * @return {?}
     */
    iterateHTMLDOM(element) {
        if (element.nodeType === 3) {
            /** @type {?} */
            let str = element.textContent;
            /** @type {?} */
            const strarr = element.textContent.split(' ');
            for (const [key, value] of Object.entries(this.jsonData)) {
                strarr.forEach((/**
                 * @param {?} strelement
                 * @return {?}
                 */
                (strelement) => {
                    if (key === strelement) {
                        str = str.replace(key, (/** @type {?} */ (value)));
                    }
                }));
                element.textContent = str;
            }
        }
        else {
            if (element.hasChildNodes()) {
                element.childNodes.forEach((/**
                 * @param {?} innerElement
                 * @return {?}
                 */
                (innerElement) => {
                    this.iterateHTMLDOM(innerElement);
                }));
            }
        }
    }
}
DynamicTextDirective.decorators = [
    { type: Directive, args: [{
                selector: '[amexio-dynamic-text]',
            },] },
];
/** @nocollapse */
DynamicTextDirective.ctorParameters = () => [
    { type: ViewContainerRef }
];
DynamicTextDirective.propDecorators = {
    jsonData: [{ type: Input, args: ['placeholder',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AmexioFullScreenDirective {
    /**
     * @param {?} _viewContainerRef
     */
    constructor(_viewContainerRef) {
        this._viewContainerRef = _viewContainerRef;
        this.fullScreenType = 'browser';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.hostComponent = this._viewContainerRef['_data'].componentView.component;
        this.hostComponent.setFullScreen(this.fullScreenType);
    }
}
AmexioFullScreenDirective.decorators = [
    { type: Directive, args: [{
                selector: '[amexioFullScreen]',
            },] },
];
/** @nocollapse */
AmexioFullScreenDirective.ctorParameters = () => [
    { type: ViewContainerRef }
];
AmexioFullScreenDirective.propDecorators = {
    fullScreenType: [{ type: Input, args: ['full-screen-type',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class RoundEdgesDirective {
    /**
     * @param {?} _viewContainerRef
     */
    constructor(_viewContainerRef) {
        this._viewContainerRef = _viewContainerRef;
        this.themeStyle = 'classic';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.themeStyle === 'round-edge' || this.themeStyle === 'classic') {
            this.hostComponent = this._viewContainerRef['_data'].componentView.component;
            this.hostComponent.setRoundEdge(this.themeStyle);
        }
    }
}
RoundEdgesDirective.decorators = [
    { type: Directive, args: [{
                selector: '[amexioThemeStyle]',
            },] },
];
/** @nocollapse */
RoundEdgesDirective.ctorParameters = () => [
    { type: ViewContainerRef }
];
RoundEdgesDirective.propDecorators = {
    themeStyle: [{ type: Input, args: ['theme-style',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class RoutedirDirective {
    /**
     * @param {?} routerInstance
     * @param {?} el
     * @param {?} renderer
     */
    constructor(routerInstance, el, renderer) {
        this.routerInstance = routerInstance;
        this.el = el;
        this.renderer = renderer;
        this.slideTop = 'slide-top';
        this.slideBottom = 'slide-bottom';
        this.slideRight = 'slide-right';
        this.slideLeft = 'slide-left';
        this.animationTop = 'myanislidetop';
        this.animationBottom = 'myanislidebottom';
        this.animationLeft = 'myanislideleft';
        this.animationRight = 'myanislideright';
        this.animationClasses = [];
        this.animationClasses.push(this.animationTop);
        this.animationClasses.push(this.animationBottom);
        this.animationClasses.push(this.animationLeft);
        this.animationClasses.push(this.animationRight);
        this.routerInstance.routerEvent.subscribe((/**
         * @param {?} router
         * @return {?}
         */
        (router) => {
            if (router) {
                router.events.subscribe((/**
                 * @param {?} event1
                 * @return {?}
                 */
                (event1) => {
                    this.navigationMethod(event1);
                }));
            }
        }));
    }
    /**
     * @return {?}
     */
    addBottomCss() {
        if (this.routeAnimation === this.slideBottom) {
            this.addDynamicClass(this.animationBottom);
        }
    }
    /**
     * @return {?}
     */
    addTopCss() {
        if (this.routeAnimation === this.slideTop) {
            this.addDynamicClass(this.animationTop);
        }
    }
    /**
     * @return {?}
     */
    addRightCss() {
        if (this.routeAnimation === this.slideRight) {
            this.addDynamicClass(this.animationRight);
        }
    }
    /**
     * @return {?}
     */
    addLeftCss() {
        if (this.routeAnimation === this.slideLeft) {
            this.addDynamicClass(this.animationLeft);
        }
    }
    /**
     * @param {?} className
     * @return {?}
     */
    addDynamicClass(className) {
        setTimeout((/**
         * @return {?}
         */
        () => {
            this.animationClasses.forEach((/**
             * @param {?} cls
             * @return {?}
             */
            (cls) => {
                this.renderer.removeClass(this.el.nativeElement.parentNode, cls);
            }));
            this.renderer.addClass(this.el.nativeElement.parentNode, className);
        }), 0);
    }
    /**
     * @param {?} event1
     * @return {?}
     */
    navigationMethod(event1) {
        if (this.routeAnimation === 'slide-left') {
            this.addLeftCss();
        }
        if (this.routeAnimation === 'slide-right') {
            this.addRightCss();
        }
        if (this.routeAnimation === 'slide-top') {
            this.addTopCss();
        }
        if (this.routeAnimation === 'slide-bottom') {
            this.addBottomCss();
        }
    }
}
RoutedirDirective.decorators = [
    { type: Directive, args: [{
                selector: '[amexio-route-animation]',
            },] },
];
/** @nocollapse */
RoutedirDirective.ctorParameters = () => [
    { type: RouterService },
    { type: ElementRef },
    { type: Renderer2 }
];
RoutedirDirective.propDecorators = {
    routeAnimation: [{ type: Input, args: ['style-type',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AmexioGridModel {
    constructor() {
        this.name = '';
        this.desktop = [];
        this.mobile = [];
        this.tab = [];
        this.layoutType = '';
        this.count = 0;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class GridConfig {
    /**
     * @param {?} layoutName
     * @param {?} layoutType
     */
    constructor(layoutName, layoutType) {
        this.amexiogridmodel = new AmexioGridModel();
        this.amexiogridmodel.layoutType = layoutType;
        this.amexiogridmodel.name = layoutName;
        return this;
    }
    /**
     * @param {?} layout
     * @return {?}
     */
    addlayout(layout) {
        this.count = layout.length;
        if (this.amexiogridmodel.layoutType === '') {
            this.amexiogridmodel.layoutType = GridConstants.Desktop;
        }
        this.amexiogridmodel[this.amexiogridmodel.layoutType].push(layout);
        return this;
    }
    /**
     * @return {?}
     */
    getLayout() {
        return this.amexiogridmodel;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class GoogleMapOverlays {
    /**
     * @param {?} _lat
     * @param {?} _lng
     * @param {?} _title
     * @param {?} _showtitle
     * @param {?} _icon
     * @param {?} _data
     */
    constructor(_lat, _lng, _title, _showtitle, _icon, _data) {
        this.lat = _lat;
        this.lng = _lng;
        this.title = _title;
        this.showtitle = _showtitle;
        this.icon = _icon;
        this.data = (_data) ? _data : {};
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AvailableSlotsModel {
    /**
     * @param {?} datetime
     * @param {?} data
     */
    constructor(datetime, data) {
        this.datetime = datetime;
        this.data = data;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class DayModel {
    /**
     * @param {?} date
     * @param {?} twentyfourformat
     * @param {?} availableSlots
     */
    constructor(date, twentyfourformat, availableSlots) {
        this.date = date;
        this.twentyfourformat = twentyfourformat;
        this.availableSlots = availableSlots;
    }
    /**
     * @param {?} timeslots
     * @return {?}
     */
    setTimeSlots(timeslots) {
        this.timeslots = timeslots;
        this.markTimeSlots();
    }
    /**
     * @private
     * @return {?}
     */
    markTimeSlots() {
        if (this.availableSlots) {
            this.availableSlots.forEach((/**
             * @param {?} slot
             * @return {?}
             */
            (slot) => {
                if (slot.datetime.getDate() === this.date.getDate()
                    && slot.datetime.getMonth() === this.date.getMonth()
                    && slot.datetime.getFullYear() === this.date.getFullYear()) {
                    slot.data.forEach((/**
                     * @param {?} time
                     * @return {?}
                     */
                    (time) => {
                        this.checkTimeSlots(time);
                    }));
                }
            }));
        }
    }
    /**
     * @private
     * @param {?} time
     * @return {?}
     */
    checkTimeSlots(time) {
        this.timeslots.forEach((/**
         * @param {?} timeModel
         * @return {?}
         */
        (timeModel) => {
            if (time === timeModel.timeId) {
                timeModel.available = true;
                return true;
            }
        }));
        return false;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TimeModel {
    /**
     * @param {?} _id
     * @param {?} _time
     */
    constructor(_id, _time) {
        this.available = false;
        this.selected = false;
        this.selectedStyleClass = '';
        this.availableStyleClass = '';
        this.timeId = _id;
        this.time = _time;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TimeUtil {
    /**
     * @param {?} twentfourhourformatdata
     * @return {?}
     */
    timeData(twentfourhourformatdata) {
        if (twentfourhourformatdata) {
            return this.twentfourhourformatdata();
        }
        else {
            return this.ampmdata();
        }
    }
    /**
     * @private
     * @return {?}
     */
    twentfourhourformatdata() {
        return this.data(':00');
    }
    /**
     * @private
     * @return {?}
     */
    ampmdata() {
        return this.data(' am');
    }
    /**
     * @private
     * @param {?} appender
     * @return {?}
     */
    data(appender) {
        /** @type {?} */
        const timemodels = [];
        for (let i = 0; i < 10; i++) {
            timemodels.push(new TimeModel(i, '0' + i + appender));
        }
        for (let i = 10; i < 25; i++) {
            timemodels.push(new TimeModel(i, i + appender));
        }
        return timemodels;
    }
    /**
     * @return {?}
     */
    workingslot1() {
        /** @type {?} */
        const timemodels = [];
        timemodels.push(new TimeModel(10, '10 am'));
        timemodels.push(new TimeModel(11, '11 am'));
        timemodels.push(new TimeModel(12, '12 pm'));
        timemodels.push(new TimeModel(13, '01 pm'));
        timemodels.push(new TimeModel(14, '02 pm'));
        timemodels.push(new TimeModel(15, '03 pm'));
        timemodels.push(new TimeModel(16, '04 pm'));
        timemodels.push(new TimeModel(17, '05 pm'));
        timemodels.push(new TimeModel(18, '06 pm'));
        return timemodels;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class PropertyGridModel {
    /**
     * @param {?} _fieldName
     * @param {?} _fieldValue
     * @param {?} _fieldIcon
     * @param {?} _onlyIcon
     * @param {?=} _link
     * @param {?=} _data
     */
    constructor(_fieldName, _fieldValue, _fieldIcon, _onlyIcon, _link, _data) {
        this.fieldName = _fieldName;
        this.fieldValue = _fieldValue;
        this.fieldIcon = _fieldIcon;
        this.onlyIcon = _onlyIcon;
        this.link = _link;
        this.data = _data;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AmexioWidgetModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: AmexioWidgetModule,
            providers: [CommonDataService, DeviceQueryService, IconLoaderService, RouterService],
        };
    }
}
AmexioWidgetModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    AmexioFormsModule,
                    AmexioNavModule,
                    AmexioDataModule,
                    AmexioLayoutModule,
                    AmexioMediaModule,
                    AmexioPaneModule,
                    HttpClientModule,
                    AmexioCommonModule,
                    AmexioCreativeModule,
                    AmexioBaseContextMenuModule,
                    RouterModule,
                ],
                entryComponents: [AmexioTabPillComponent],
                exports: [
                    AmexioFormsModule,
                    AmexioNavModule,
                    AmexioDataModule,
                    AmexioLayoutModule,
                    AmexioMediaModule,
                    AmexioCommonModule,
                    AmexioPaneModule,
                    AmexioBaseContextMenuModule,
                    AmexioCreativeModule,
                    AmexioRuntimeModule,
                    RoundEdgesDirective,
                    AmexioFullScreenDirective,
                    RoutedirDirective,
                    DynamicTextDirective,
                ],
                declarations: [RoutedirDirective, DynamicTextDirective, RoundEdgesDirective, AmexioFullScreenDirective,
                ],
                providers: [CommonDataService, DeviceQueryService, IconLoaderService, RouterService],
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 * Copyright 2016-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Author - Sagar Jadhav
 *
 */
/*
 Component Name : Amexio dashboard
 Component Selector : <amexio-dashboard-title>
 Component Description : create dasshboard component
*/
class DashBoardTitleComponent {
    constructor() { }
    /**
     * @return {?}
     */
    ngOnInit() { }
}
DashBoardTitleComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-dashboard-title', template: ` `,
            },] },
];
/** @nocollapse */
DashBoardTitleComponent.ctorParameters = () => [];
DashBoardTitleComponent.propDecorators = {
    title: [{ type: Input }],
    position: [{ type: Input }],
    color: [{ type: Input }],
    fontname: [{ type: Input, args: ['font-name',] }],
    fontsize: [{ type: Input, args: ['font-size',] }],
    bold: [{ type: Input }],
    italic: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by ketangote on 7/25/17.
*/
/*
 Component Name : Amexio center datapoints
 Component Selector : <amexio-center>
 Component Description : Represent the summary of the data in bullet point format.
*/
class DataPointCenterComponent {
    constructor() {
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
}
DataPointCenterComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-center', template: `

    <div [ngClass]="cclass" [attr.align]="contentalign" [style.background-color]="backgroundcolor"
         [style.color]="fontcolor" [style.width]="width" [style.height]="height">
      <ng-content></ng-content>
    </div>`,
            },] },
];
/** @nocollapse */
DataPointCenterComponent.ctorParameters = () => [];
DataPointCenterComponent.propDecorators = {
    contentalign: [{ type: Input, args: ['content-align',] }],
    backgroundcolor: [{ type: Input, args: ['background-color',] }],
    fontcolor: [{ type: Input, args: ['font-color',] }],
    width: [{ type: Input }],
    height: [{ type: Input }],
    cclass: [{ type: Input, args: ['c-class',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by ketangote on 8/16/17.
*/
/*
 Component Name : Amexio datapoints
 Component Selector : < amexio-center >
 Component Description : create datapoints
*/
class DataPointsComponent extends LifeCycleBaseComponent {
    constructor() {
        super();
        this.colspan = 1;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.amexiocolor !== '') {
            this.dpClass = this.amexiocolor;
        }
        if (this.west) {
            this.colspan++;
        }
        if (this.east) {
            this.colspan++;
        }
    }
}
DataPointsComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-datapoints', template: `

  <div class="datapoints {{roundedgeclass}}" [ngClass]="dpClass">
      <table width="100%" [style.background-color]="backgroundcolor" [style.color]="fontcolor">
        <tr *ngIf="north">
          <td [attr.colspan]="colspan">
            <ng-content select="amexio-north"></ng-content>
          </td>
        </tr>
        <tr>
          <td *ngIf="west">
            <ng-content select="amexio-west"></ng-content>
          </td>
          <td *ngIf="center">
            <ng-content select="amexio-center"></ng-content>
          </td>
          <td *ngIf="east">
            <ng-content select="amexio-east"></ng-content>
          </td>
        </tr>
        <tr *ngIf="south">
          <td [attr.colspan]="colspan">
            <ng-content select="amexio-south"></ng-content>
          </td>
        </tr>
      </table>
    </div>


  `, styles: [`
    .amexio-datapoints {

    }
  `],
            },] },
];
/** @nocollapse */
DataPointsComponent.ctorParameters = () => [];
DataPointsComponent.propDecorators = {
    north: [{ type: Input }],
    south: [{ type: Input }],
    west: [{ type: Input }],
    center: [{ type: Input }],
    east: [{ type: Input }],
    backgroundcolor: [{ type: Input, args: ['background-color',] }],
    fontcolor: [{ type: Input, args: ['font-color',] }],
    amexiocolor: [{ type: Input, args: ['amexio-color',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by ketangote on 7/25/17.
*/
/*
 Component Name : Amexio east datapoints
 Component Selector : <amexio-east>
 Component Description : Represent the summary of the data in bullet point format.
*/
class DataPointEastComponent {
    constructor() {
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.cclass == null) {
            this.cclass = 'datapoint-east';
        }
    }
}
DataPointEastComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-east', template: `

    <div [ngClass]="cclass" class="datapoint-east" [attr.align]="contentalign" [style.background-color]="backgroundcolor"
         [style.color]="fontcolor" [style.width]="width" [style.height]="height">
      <ng-content></ng-content>
    </div>
  `,
            },] },
];
/** @nocollapse */
DataPointEastComponent.ctorParameters = () => [];
DataPointEastComponent.propDecorators = {
    contentalign: [{ type: Input, args: ['content-align',] }],
    backgroundcolor: [{ type: Input, args: ['background-color',] }],
    fontcolor: [{ type: Input, args: ['font-color',] }],
    width: [{ type: Input }],
    height: [{ type: Input }],
    cclass: [{ type: Input, args: ['c-class',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by ketangote on 7/25/17.
*/
/*
 Component Name : Amexio north datapoints
 Component Selector : <amexio-east>
 Component Description : Represent the summary of the data in bullet point format.
*/
class DataPointNorthComponent {
    constructor() {
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.cclass == null) {
            this.cclass = 'datapoints-north';
        }
    }
}
DataPointNorthComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-north', template: `

    <div [ngClass]="cclass" [attr.align]="contentalign" [style.background-color]="backgroundcolor"
         [style.color]="fontcolor" [style.width]="width" [style.height]="height">
      <ng-content></ng-content>
    </div>
  `,
            },] },
];
/** @nocollapse */
DataPointNorthComponent.ctorParameters = () => [];
DataPointNorthComponent.propDecorators = {
    contentalign: [{ type: Input, args: ['content-align',] }],
    backgroundcolor: [{ type: Input, args: ['background-color',] }],
    fontcolor: [{ type: Input, args: ['font-color',] }],
    width: [{ type: Input }],
    height: [{ type: Input }],
    cclass: [{ type: Input, args: ['c-class',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by ketangote on 7/25/17.
*/
/*
 Component Name : Amexio south datapoints
 Component Selector : <amexio-south>
 Component Description : Represent the summary of the data in bullet point format.
*/
class DataPointSouthComponent {
    constructor() {
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.cclass == null) {
            this.cclass = 'datapoint-south';
        }
    }
}
DataPointSouthComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-south', template: `

    <div [ngClass]="cclass" [attr.align]="contentalign" [style.background-color]="backgroundcolor"
         [style.color]="fontcolor" [style.width]="width" [style.height]="height">
      <ng-content></ng-content>
    </div>
  `,
            },] },
];
/** @nocollapse */
DataPointSouthComponent.ctorParameters = () => [];
DataPointSouthComponent.propDecorators = {
    contentalign: [{ type: Input, args: ['content-align',] }],
    backgroundcolor: [{ type: Input, args: ['background-color',] }],
    fontcolor: [{ type: Input, args: ['font-color',] }],
    width: [{ type: Input }],
    height: [{ type: Input }],
    cclass: [{ type: Input, args: ['c-class',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by ketangote on 7/25/17.
*/
/*
 Component Name : Amexio west datapoints
 Component Selector : <amexio-west>
 Component Description : Represent the summary of the data in bullet point format.
*/
class DataPointWestComponent {
    constructor() {
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.cclass == null) {
            this.cclass = 'datapoint-west';
        }
    }
}
DataPointWestComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-west', template: `

    <div [ngClass]="cclass" [attr.align]="contentalign" [style.background-color]="backgroundcolor"
         [style.color]="fontcolor" [style.width]="width" [style.height]="height">
      <ng-content></ng-content>
    </div>
  `,
            },] },
];
/** @nocollapse */
DataPointWestComponent.ctorParameters = () => [];
DataPointWestComponent.propDecorators = {
    contentalign: [{ type: Input, args: ['content-align',] }],
    backgroundcolor: [{ type: Input, args: ['background-color',] }],
    fontcolor: [{ type: Input, args: ['font-color',] }],
    width: [{ type: Input }],
    height: [{ type: Input }],
    cclass: [{ type: Input, args: ['c-class',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by Pratik on 07/08/17.
*/
class DashboardLoaderService {
    constructor() {
        this.chartPackage = {
            AreaChart: 'corechart',
            Bar: 'bar',
            BarChart: 'corechart',
            ColumnChart: 'corechart',
            PieChart: 'corechart',
            Gantt: 'gantt',
            Gauge: 'gauge',
            GeoChart: 'geochart',
            Histogram: 'corechart',
            Line: 'line',
            LineChart: 'corechart',
            Map: 'map',
            Timeline: 'timeline',
            BubbleChart: 'corechart',
            CandlestickChart: 'corechart',
            ComboChart: 'corechart',
            TreeMap: 'treemap',
        };
        this.googleScriptLoadingNotifier = new EventEmitter();
        this.isScriptLoading = false;
    }
    /**
     * @param {?} chartName
     * @return {?}
     */
    loadCharts(chartName) {
        return new rxjs_1((/**
         * @param {?} observer
         * @return {?}
         */
        (observer) => {
            this.loadScript().subscribe((/**
             * @param {?} val
             * @return {?}
             */
            (val) => console.log()), (/**
             * @param {?} error
             * @return {?}
             */
            (error) => console.error(error)), (/**
             * @return {?}
             */
            () => {
                this.loadRequiredChart(observer, chartName);
            }));
        }));
    }
    /**
     * @return {?}
     */
    loadScript() {
        return new rxjs_1((/**
         * @param {?} observer
         * @return {?}
         */
        (observer) => {
            if (!this.isScriptLoading) {
                // check if previously its loaded
                if (typeof google !== 'undefined' && google.charts) {
                    // check if chart package has been loaded using chartPackagename ?
                    this.loadBaseChart(observer);
                }
                else {
                    this.isScriptLoading = true;
                    /** @type {?} */
                    const script = document.createElement('script');
                    script.type = 'text/javascript';
                    script.src = 'https://www.gstatic.com/charts/loader.js';
                    script.async = true;
                    script.defer = true;
                    script.onload = (/**
                     * @return {?}
                     */
                    () => {
                        this.isScriptLoading = false;
                        this.googleScriptLoadingNotifier.emit(true);
                        this.loadBaseChart(observer);
                    });
                    script.onerror = (/**
                     * @return {?}
                     */
                    () => {
                        observer.error('Could Not Load google Script');
                    });
                    document.getElementsByTagName('head')[0].appendChild(script);
                }
            }
            else {
                this.googleScriptLoadingNotifier.subscribe((/**
                 * @param {?} loaded
                 * @return {?}
                 */
                (loaded) => {
                    if (loaded) {
                        this.loadBaseChart(observer);
                    }
                }));
            }
        }));
    }
    /**
     * Load Base Chart
     * @param {?} observer
     * @return {?}
     */
    loadBaseChart(observer) {
        google.charts.load('current', { packages: ['corechart'] });
        google.charts.setOnLoadCallback((/**
         * @return {?}
         */
        () => {
            observer.complete();
        }));
    }
    /**
     * Load the required charts
     * @param {?} observer
     * @param {?} chartName
     * @return {?}
     */
    loadRequiredChart(observer, chartName) {
        if (google.visualization.hasOwnProperty(chartName)) {
            observer.complete();
        }
        else {
            google.charts.load('current', { packages: [this.chartPackage[chartName]] });
            google.charts.setOnLoadCallback((/**
             * @return {?}
             */
            () => {
                observer.complete();
            }));
        }
    }
}
DashboardLoaderService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
DashboardLoaderService.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by Sagar.
*/
/*
 Component Name : Amexio gaugechart
 Component Selector : <amexio-dashboard-gauge>
 Component Description : A gauge with a dial,rendered within the browser using SVG.
 Gauges are available under AmexioDashboardModule from amexio-ng-extensions/dashboard
*/
class GaugeChartComponent {
    /**
     * @param {?} loader
     */
    constructor(loader) {
        this.loader = loader;
        this.width = '100%';
    }
    /**
     * @return {?}
     */
    get data() {
        return this._data;
    }
    /*
    Properties
    name : data
    datatype : any
    version : 4.0 onwards
    default : none
    description : Local data for gauge chart
    */
    /**
     * @param {?} data
     * @return {?}
     */
    set data(data) {
        if (data) {
            this._data = data;
            this.showChart = true;
        }
        else {
            this.showChart = false;
        }
    }
    /**
     * @return {?}
     */
    drawChart() {
        if (this.showChart) {
            this.gaugeData = google.visualization.arrayToDataTable(this._data);
            this.options = {
                width: this.width,
                height: this.height,
                redFrom: this.redcolorfrom,
                redTo: this.redcolorto,
                yellowFrom: this.yellowcolorfrom,
                yellowTo: this.yellowcolorto,
                scalevalue: this.scalevalue,
            };
            if (this.gaugeData) {
                this.chart = new google.visualization.Gauge(this.gaugedashboard.nativeElement);
                this.hasLoaded = true;
                this.chart.draw(this.gaugeData, this.options);
            }
        }
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.chartTitleArray = this.chartTitleComp.toArray();
        // take first component
        if (this.chartTitleArray.length === 1) {
            this.chartTitleComponent = this.chartTitleArray.pop();
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.hasLoaded = false;
        this.loader.loadCharts('Gauge').subscribe((/**
         * @param {?} value
         * @return {?}
         */
        (value) => console.log()), (/**
         * @param {?} errror
         * @return {?}
         */
        (errror) => console.error(errror)), (/**
         * @return {?}
         */
        () => {
            this.drawChart();
        }));
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onResize(event) {
        this.drawChart();
    }
}
GaugeChartComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-dashboard-gauge', template: `
    <div *ngIf="showChart" #gaugedashboard
         [style.width]="width"
         [style.height]="height" (window:resize)="onResize($event)">
      <div *ngIf="!hasLoaded" class="lmask">
      </div>
    </div>
  `, styles: [`.lmask {
    position: absolute;
    height: 100%;
    width: 100%;
    background-color: #000;
    bottom: 0;
    left: 0;
    right: 0;
    top: 0;
    z-index: 9999;
    opacity: 0.4;
  }

  .lmask.fixed {
    position: fixed;
  }

  .lmask:before {
    content: '';
    background-color: transparent;
    border: 5px solid rgba(0, 183, 229, 0.9);
    opacity: .9;
    border-right: 5px solid transparent;
    border-left: 5px solid transparent;
    border-radius: 50px;
    box-shadow: 0 0 35px #2187e7;
    width: 50px;
    height: 50px;
    -moz-animation: spinPulse 1s infinite ease-in-out;
    -webkit-animation: spinPulse 1s infinite linear;
    margin: -25px 0 0 -25px;
    position: absolute;
    top: 50%;
    left: 50%;
  }

  .lmask:after {
    content: '';
    background-color: transparent;
    border: 5px solid rgba(0, 183, 229, 0.9);
    opacity: .9;
    border-left: 5px solid transparent;
    border-right: 5px solid transparent;
    border-radius: 50px;
    box-shadow: 0 0 15px #2187e7;
    width: 30px;
    height: 30px;
    -moz-animation: spinoffPulse 1s infinite linear;
    -webkit-animation: spinoffPulse 1s infinite linear;
    margin: -15px 0 0 -15px;
    position: absolute;
    top: 50%;
    left: 50%;
  }

  @-moz-keyframes spinPulse {
    0% {
      -moz-transform: rotate(160deg);
      opacity: 0;
      box-shadow: 0 0 1px #2187e7;
    }
    50% {
      -moz-transform: rotate(145deg);
      opacity: 1;
    }
    100% {
      -moz-transform: rotate(-320deg);
      opacity: 0;
    }
  }

  @-moz-keyframes spinoffPulse {
    0% {
      -moz-transform: rotate(0deg);
    }
    100% {
      -moz-transform: rotate(360deg);
    }
  }

  @-webkit-keyframes spinPulse {
    0% {
      -webkit-transform: rotate(160deg);
      opacity: 0;
      box-shadow: 0 0 1px #2187e7;
    }
    50% {
      -webkit-transform: rotate(145deg);
      opacity: 1;
    }
    100% {
      -webkit-transform: rotate(-320deg);
      opacity: 0;
    }
  }

  @-webkit-keyframes spinoffPulse {
    0% {
      -webkit-transform: rotate(0deg);
    }
    100% {
      -webkit-transform: rotate(360deg);
    }
  }

  `],
            },] },
];
/** @nocollapse */
GaugeChartComponent.ctorParameters = () => [
    { type: DashboardLoaderService }
];
GaugeChartComponent.propDecorators = {
    width: [{ type: Input }],
    height: [{ type: Input }],
    data: [{ type: Input, args: ['data',] }],
    redcolorfrom: [{ type: Input, args: ['red-color-from',] }],
    redcolorto: [{ type: Input, args: ['red-color-to',] }],
    yellowcolorfrom: [{ type: Input, args: ['yellow-color-from',] }],
    yellowcolorto: [{ type: Input, args: ['yellow-color-to',] }],
    scalevalue: [{ type: Input, args: ['scale-value',] }],
    chartTitleComp: [{ type: ContentChildren, args: [DashBoardTitleComponent,] }],
    gaugedashboard: [{ type: ViewChild, args: ['gaugedashboard',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const DASHBOARD = [
    DashBoardTitleComponent,
    DataPointCenterComponent,
    DataPointsComponent,
    DataPointEastComponent,
    DataPointNorthComponent,
    DataPointSouthComponent,
    DataPointWestComponent,
    GaugeChartComponent,
];
class AmexioDashBoardModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: AmexioDashBoardModule,
            providers: [CommonDataService, DashboardLoaderService],
        };
    }
}
AmexioDashBoardModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    FormsModule,
                    HttpClientModule,
                    AmexioCommonModule,
                ],
                exports: DASHBOARD,
                declarations: DASHBOARD,
                providers: [CommonDataService, DashboardLoaderService],
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 * Copyright 2016-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Author - Sagar Jadhav
 *
 */
/*
Component Name : Amexio area chart properties
Component Selector : <amexio-chart-area-properties>
Component Description : An area chart that is rendered within the browser using SVG .Displays tips when hovering over points.
*/
class ChartAreaComponent {
    constructor() {
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
}
ChartAreaComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-chart-area-properties', template: ``,
            },] },
];
/** @nocollapse */
ChartAreaComponent.ctorParameters = () => [];
ChartAreaComponent.propDecorators = {
    chartbackgroundcolor: [{ type: Input, args: ['chart-background-color',] }],
    leftposition: [{ type: Input, args: ['left-position',] }],
    topposition: [{ type: Input, args: ['top-position',] }],
    chartwidth: [{ type: Input, args: ['chart-width',] }],
    chartheight: [{ type: Input, args: ['chart-height',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 * Copyright 2016-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Author - Sagar Jadhav
 *
 */
/*
Component Name : Amexio chart legend
Component Selector : <amexio-chart-legend>
Component Description : describes chart legend properties
*/
class ChartLegendComponent {
    constructor() {
        /*
        Properties
        name : bold
        datatype : boolean
        version : 4.0 onwards
        default : false
        description : Set true for Legend text in bold
        */
        this.bold = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
}
ChartLegendComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-chart-legend', template: ` `,
            },] },
];
/** @nocollapse */
ChartLegendComponent.ctorParameters = () => [];
ChartLegendComponent.propDecorators = {
    position: [{ type: Input }],
    alignment: [{ type: Input }],
    color: [{ type: Input }],
    fontname: [{ type: Input, args: ['font-name',] }],
    fontsize: [{ type: Input, args: ['font-size',] }],
    bold: [{ type: Input }],
    maxlines: [{ type: Input, args: ['max-lines',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 * Copyright 2016-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Author - Sagar Jadhav
 *
 */
/*
Component Name : Amexio chart title
Component Selector : <amexio-chart-title>
Component Description : describes chart title properties
*/
class ChartTitleComponent {
    constructor() {
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
}
ChartTitleComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-chart-title', template: ` `,
            },] },
];
/** @nocollapse */
ChartTitleComponent.ctorParameters = () => [];
ChartTitleComponent.propDecorators = {
    title: [{ type: Input }],
    position: [{ type: Input }],
    color: [{ type: Input }],
    fontname: [{ type: Input, args: ['font-name',] }],
    fontsize: [{ type: Input, args: ['font-size',] }],
    bold: [{ type: Input }],
    italic: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Created by pratik on 17/8/17.
 */
class ChartLoaderService {
    constructor() {
        this.chartPackage = {
            AreaChart: 'corechart',
            Bar: 'bar',
            BarChart: 'corechart',
            ColumnChart: 'corechart',
            PieChart: 'corechart',
            Gantt: 'gantt',
            Gauge: 'gauge',
            GeoChart: 'geochart',
            Histogram: 'corechart',
            Line: 'line',
            LineChart: 'corechart',
            Map: 'map',
            Timeline: 'timeline',
            BubbleChart: 'corechart',
            CandlestickChart: 'corechart',
            ComboChart: 'corechart',
            TreeMap: 'treemap',
        };
        this.googleScriptLoadingNotifier = new EventEmitter();
        this.isScriptLoading = false;
    }
    /**
     * @param {?} chartName
     * @return {?}
     */
    loadCharts(chartName) {
        return new rxjs_1((/**
         * @param {?} observer
         * @return {?}
         */
        (observer) => {
            this.loadScript().subscribe((/**
             * @param {?} val
             * @return {?}
             */
            (val) => console.log()), (/**
             * @param {?} error
             * @return {?}
             */
            (error) => console.error(error)), (/**
             * @return {?}
             */
            () => {
                this.loadRequiredChart(observer, chartName);
            }));
        }));
    }
    /**
     * @return {?}
     */
    loadScript() {
        return new rxjs_1((/**
         * @param {?} observer
         * @return {?}
         */
        (observer) => {
            if (!this.isScriptLoading) {
                // check if previously its loaded
                if (typeof google !== 'undefined' && google.charts) {
                    // check if chart package has been loaded using chartPackagename ?
                    this.loadBaseChart(observer);
                }
                else {
                    this.isScriptLoading = true;
                    /** @type {?} */
                    const script = document.createElement('script');
                    script.type = 'text/javascript';
                    script.src = 'https://www.gstatic.com/charts/loader.js';
                    script.async = true;
                    script.defer = true;
                    script.onload = (/**
                     * @return {?}
                     */
                    () => {
                        this.isScriptLoading = false;
                        this.googleScriptLoadingNotifier.emit(true);
                        this.loadBaseChart(observer);
                    });
                    script.onerror = (/**
                     * @return {?}
                     */
                    () => {
                        observer.error('Could Not Load google Script');
                    });
                    document.getElementsByTagName('head')[0].appendChild(script);
                }
            }
            else {
                this.googleScriptLoadingNotifier.subscribe((/**
                 * @param {?} loaded
                 * @return {?}
                 */
                (loaded) => {
                    if (loaded) {
                        this.loadBaseChart(observer);
                    }
                }));
            }
        }));
    }
    /**
     * Load Base Chart
     * @param {?} observer
     * @return {?}
     */
    loadBaseChart(observer) {
        google.charts.load('current', { packages: ['corechart'] });
        google.charts.setOnLoadCallback((/**
         * @return {?}
         */
        () => {
            observer.complete();
        }));
    }
    /**
     * Load the required charts
     * @param {?} observer
     * @param {?} chartName
     * @return {?}
     */
    loadRequiredChart(observer, chartName) {
        if (google.visualization.hasOwnProperty(chartName)) {
            observer.complete();
        }
        else {
            google.charts.load('current', { packages: [this.chartPackage[chartName]] });
            google.charts.setOnLoadCallback((/**
             * @return {?}
             */
            () => {
                observer.complete();
            }));
        }
    }
}
ChartLoaderService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
ChartLoaderService.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Author: Sagar
*/
/*
 Component Name : Amexio area chart
 Component Selector : <amexio-chart-area>
 Component Description : An area chart that is rendered within the browser using SVG.
 Displays tips when hovering over points.
*/
class AreaChartComponent {
    /**
     * @param {?} loader
     */
    constructor(loader) {
        this.loader = loader;
        this.width = '100%';
    }
    /**
     * @return {?}
     */
    get data() {
        return this._data;
    }
    /*
    Properties
    name : data
    datatype : any
    version : 4.0 onwards
    default :
    description : Local data for AreaChart
    */
    /**
     * @param {?} data
     * @return {?}
     */
    set data(data) {
        if (data) {
            this._data = data;
            this.showChart = true;
        }
        else {
            this.showChart = false;
        }
    }
    /**
     * @return {?}
     */
    drawChart() {
        if (this.showChart) {
            this.areaData = google.visualization.arrayToDataTable(this._data);
            this.options = {
                title: this.chartTitleComponent ? this.chartTitleComponent.title : null,
                titleTextStyle: this.chartTitleComponent ? this.createTitleTextStyle() : null,
                backgroundcolor: this.backgroundcolor,
                legend: this.chartLengendComponent ? this.createChartLegend() : 'none',
                chartArea: this.chartAreaComponent ? this.createChartArea() : null,
            };
            if (this.areaData) {
                this.chart = new google.visualization.AreaChart(this.areachart.nativeElement);
                this.hasLoaded = true;
                this.chart.draw(this.areaData, this.options);
                google.visualization.events.addListener(this.chart, 'click', this.click);
            }
        }
    }
    /**
     * @return {?}
     */
    createTitleTextStyle() {
        return {
            color: this.chartTitleComponent.color ? this.chartTitleComponent.color : null,
            fontName: this.chartTitleComponent.fontname ? this.chartTitleComponent.fontname : null,
            fontsize: this.chartTitleComponent.fontsize ? this.chartTitleComponent.fontsize : null,
            bold: this.chartTitleComponent.bold ? this.chartTitleComponent.bold : null,
            italic: this.chartTitleComponent.italic ? this.chartTitleComponent.italic : null,
        };
    }
    /**
     * @return {?}
     */
    createChartLegend() {
        return {
            position: this.chartLengendComponent.position ? this.chartLengendComponent.position : null,
            // this work only in chart position is top
            maxLines: this.chartLengendComponent.maxlines ? this.chartLengendComponent.maxlines : null, textStyle: {
                color: this.chartLengendComponent.color ? this.chartLengendComponent.color : null,
                fontsize: this.chartLengendComponent.fontsize ? this.chartLengendComponent.fontsize : null,
                fontName: this.chartLengendComponent.fontname ? this.chartLengendComponent.fontname : null,
                bold: this.chartLengendComponent.bold ? this.chartLengendComponent.bold : null,
                alignment: this.chartLengendComponent.alignment ? this.chartLengendComponent.alignment : null,
            },
        };
    }
    /**
     * @return {?}
     */
    createChartArea() {
        return {
            backgroundcolor: this.chartAreaComponent.chartbackgroundcolor ? this.chartAreaComponent.chartbackgroundcolor : null,
            left: this.chartAreaComponent.leftposition ? this.chartAreaComponent.leftposition : null,
            top: this.chartAreaComponent.topposition ? this.chartAreaComponent.topposition : null,
            height: this.chartAreaComponent.chartheight ? this.chartAreaComponent.chartheight : null,
            width: this.chartAreaComponent.chartwidth ? this.chartAreaComponent.chartwidth : null,
        };
    }
    /**
     * @param {?} e
     * @return {?}
     */
    click(e) {
    }
    // after content init for inner directive is run
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.chartLegendArray = this.chartLegendComp.toArray();
        this.chartTitleArray = this.chartTitleComp.toArray();
        this.chartAreaArray = this.chartAreaComp.toArray();
        // take first component
        if (this.chartLegendArray.length === 1) {
            this.chartLengendComponent = this.chartLegendArray.pop();
        }
        if (this.chartTitleArray.length === 1) {
            this.chartTitleComponent = this.chartTitleArray.pop();
        }
        if (this.chartAreaArray.length === 1) {
            this.chartAreaComponent = this.chartAreaArray.pop();
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.hasLoaded = false;
        this.loader.loadCharts('AreaChart').subscribe((/**
         * @param {?} value
         * @return {?}
         */
        (value) => console.log()), (/**
         * @param {?} errror
         * @return {?}
         */
        (errror) => console.error(errror)), (/**
         * @return {?}
         */
        () => {
            this.drawChart();
        }));
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onResize(event) {
        this.drawChart();
    }
}
AreaChartComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-chart-area', template: `
    <div *ngIf="showChart" #areachart
         [style.width]="width"
         [style.height]="height" (window:resize)="onResize($event)">
      <div *ngIf="!hasLoaded" class="lmask">
      </div>
    </div>
  `, styles: [`.lmask {
    position: absolute;
    height: 100%;
    width: 100%;
    background-color: #000;
    bottom: 0;
    left: 0;
    right: 0;
    top: 0;
    z-index: 9999;
    opacity: 0.4;
  }

  .lmask.fixed {
    position: fixed;
  }

  .lmask:before {
    content: '';
    background-color: transparent;
    border: 5px solid rgba(0, 183, 229, 0.9);
    opacity: .9;
    border-right: 5px solid transparent;
    border-left: 5px solid transparent;
    border-radius: 50px;
    box-shadow: 0 0 35px #2187e7;
    width: 50px;
    height: 50px;
    -moz-animation: spinPulse 1s infinite ease-in-out;
    -webkit-animation: spinPulse 1s infinite linear;
    margin: -25px 0 0 -25px;
    position: absolute;
    top: 50%;
    left: 50%;
  }

  .lmask:after {
    content: '';
    background-color: transparent;
    border: 5px solid rgba(0, 183, 229, 0.9);
    opacity: .9;
    border-left: 5px solid transparent;
    border-right: 5px solid transparent;
    border-radius: 50px;
    box-shadow: 0 0 15px #2187e7;
    width: 30px;
    height: 30px;
    -moz-animation: spinoffPulse 1s infinite linear;
    -webkit-animation: spinoffPulse 1s infinite linear;
    margin: -15px 0 0 -15px;
    position: absolute;
    top: 50%;
    left: 50%;
  }

  @-moz-keyframes spinPulse {
    0% {
      -moz-transform: rotate(160deg);
      opacity: 0;
      box-shadow: 0 0 1px #2187e7;
    }
    50% {
      -moz-transform: rotate(145deg);
      opacity: 1;
    }
    100% {
      -moz-transform: rotate(-320deg);
      opacity: 0;
    }
  }

  @-moz-keyframes spinoffPulse {
    0% {
      -moz-transform: rotate(0deg);
    }
    100% {
      -moz-transform: rotate(360deg);
    }
  }

  @-webkit-keyframes spinPulse {
    0% {
      -webkit-transform: rotate(160deg);
      opacity: 0;
      box-shadow: 0 0 1px #2187e7;
    }
    50% {
      -webkit-transform: rotate(145deg);
      opacity: 1;
    }
    100% {
      -webkit-transform: rotate(-320deg);
      opacity: 0;
    }
  }

  @-webkit-keyframes spinoffPulse {
    0% {
      -webkit-transform: rotate(0deg);
    }
    100% {
      -webkit-transform: rotate(360deg);
    }
  }

  `],
            },] },
];
/** @nocollapse */
AreaChartComponent.ctorParameters = () => [
    { type: ChartLoaderService }
];
AreaChartComponent.propDecorators = {
    width: [{ type: Input }],
    height: [{ type: Input }],
    data: [{ type: Input, args: ['data',] }],
    backgroundcolor: [{ type: Input, args: ['background-color',] }],
    chartLegendComp: [{ type: ContentChildren, args: [ChartLegendComponent,] }],
    chartTitleComp: [{ type: ContentChildren, args: [ChartTitleComponent,] }],
    chartAreaComp: [{ type: ContentChildren, args: [ChartAreaComponent,] }],
    areachart: [{ type: ViewChild, args: ['areachart',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 * Copyright 2016-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Author - Sagar Jadhav
 *
 */
/*
Component Name : Amexio bar chart
Component Selector : <amexio-chart-bar>
Component Description : An bar chart that is rendered within the browser using SVG.
A bar chart is a chart that presents grouped data with rectangular bars with lengths proportional to the values that they represent.
*/
class BarChartComponent {
    /**
     * @param {?} loader
     */
    constructor(loader) {
        this.loader = loader;
        // showing stack chart
        /*
        Properties
        name : stacked
        datatype : boolean
        version : 4.0 onwards
        default : false
        description : If set to true, stacks the elements for all series at each domain value.default value is false
        */
        this.stacked = false;
        this.width = '100%';
    }
    /**
     * @return {?}
     */
    get data() {
        return this._data;
    }
    /*
    Properties
    name : data
    datatype : any
    version : 4.0 onwards
    default :
    description : Local data for AreaChart
    */
    /**
     * @param {?} data
     * @return {?}
     */
    set data(data) {
        if (data) {
            this.showChart = true;
            this._data = data;
        }
        else {
            this.showChart = false;
        }
    }
    /**
     * @return {?}
     */
    drawChart() {
        if (this.showChart) {
            // bind the data
            this.barData = google.visualization.arrayToDataTable(this._data);
            this.options = {
                title: this.chartTitleComponent ? this.chartTitleComponent.title : null,
                titleTextStyle: this.chartTitleComponent ? this.chartTitleTextStyle() : null,
                isStacked: this.stacked,
                backgroundcolor: this.backgroundcolor,
                legend: this.chartLengendComponent ? this.createChartLegend() : 'none',
                chartArea: this.chartAreaComponent ? this.createChartBar() : null,
                hAxis: {
                    title: this.xaxistitle, minvalue: 0,
                },
                vAxis: {
                    title: this.yaxistitle,
                },
            };
            if (this.barData) {
                this.chart = new google.visualization.BarChart(this.barchart.nativeElement);
                this.hasLoaded = true;
                this.chart.draw(this.barData, this.options);
            }
        }
    }
    /**
     * @return {?}
     */
    chartTitleTextStyle() {
        return {
            color: this.chartTitleComponent.color ? this.chartTitleComponent.color : null,
            fontName: this.chartTitleComponent.fontname ? this.chartTitleComponent.fontname : null,
            fontsize: this.chartTitleComponent.fontsize ? this.chartTitleComponent.fontsize : null,
            bold: this.chartTitleComponent.bold ? this.chartTitleComponent.bold : null,
            italic: this.chartTitleComponent.italic ? this.chartTitleComponent.italic : null,
        };
    }
    /**
     * @return {?}
     */
    createChartLegend() {
        return {
            position: this.chartLengendComponent.position ? this.chartLengendComponent.position : null,
            maxLines: this.chartLengendComponent.maxlines ? this.chartLengendComponent.maxlines : null,
            textStyle: {
                color: this.chartLengendComponent.color ? this.chartLengendComponent.color : null,
                fontsize: this.chartLengendComponent.fontsize ? this.chartLengendComponent.fontsize : null,
                fontName: this.chartLengendComponent.fontname ? this.chartLengendComponent.fontname : null,
                bold: this.chartLengendComponent.bold ? this.chartLengendComponent.bold : null,
                alignment: this.chartLengendComponent.alignment ? this.chartLengendComponent.alignment : null,
            },
        };
    }
    /**
     * @return {?}
     */
    createChartBar() {
        return {
            backgroundcolor: this.chartAreaComponent.chartbackgroundcolor ? this.chartAreaComponent.chartbackgroundcolor : null,
            left: this.chartAreaComponent.leftposition ? this.chartAreaComponent.leftposition : null,
            top: this.chartAreaComponent.topposition ? this.chartAreaComponent.topposition : null,
            height: this.chartAreaComponent.chartheight ? this.chartAreaComponent.chartheight : null,
            width: this.chartAreaComponent.chartwidth ? this.chartAreaComponent.chartwidth : null,
        };
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.chartLegendArray = this.chartLegendComp.toArray();
        this.chartTitleArray = this.chartTitleComp.toArray();
        this.chartAreaArray = this.chartAreaComp.toArray();
        // take first component
        if (this.chartLegendArray.length === 1) {
            this.chartLengendComponent = this.chartLegendArray.pop();
        }
        if (this.chartTitleArray.length === 1) {
            this.chartTitleComponent = this.chartTitleArray.pop();
        }
        if (this.chartAreaArray.length === 1) {
            this.chartAreaComponent = this.chartAreaArray.pop();
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.hasLoaded = false;
        this.loader.loadCharts('BarChart').subscribe((/**
         * @param {?} value
         * @return {?}
         */
        (value) => console.log()), (/**
         * @param {?} errror
         * @return {?}
         */
        (errror) => console.error(errror)), (/**
         * @return {?}
         */
        () => {
            this.drawChart();
        }));
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onResize(event) {
        this.drawChart();
    }
}
BarChartComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-chart-bar', template: `
    <div *ngIf="showChart" #barchart
         [style.width]="width"
         [style.height]="height" (window:resize)="onResize($event)">
      <div *ngIf="!hasLoaded" class="lmask">
      </div>
    </div>
  `, styles: [`.lmask {
    position: absolute;
    height: 100%;
    width: 100%;
    background-color: #000;
    bottom: 0;
    left: 0;
    right: 0;
    top: 0;
    z-index: 9999;
    opacity: 0.4;
  }

  .lmask.fixed {
    position: fixed;
  }

  .lmask:before {
    content: '';
    background-color: transparent;
    border: 5px solid rgba(0, 183, 229, 0.9);
    opacity: .9;
    border-right: 5px solid transparent;
    border-left: 5px solid transparent;
    border-radius: 50px;
    box-shadow: 0 0 35px #2187e7;
    width: 50px;
    height: 50px;
    -moz-animation: spinPulse 1s infinite ease-in-out;
    -webkit-animation: spinPulse 1s infinite linear;
    margin: -25px 0 0 -25px;
    position: absolute;
    top: 50%;
    left: 50%;
  }

  .lmask:after {
    content: '';
    background-color: transparent;
    border: 5px solid rgba(0, 183, 229, 0.9);
    opacity: .9;
    border-left: 5px solid transparent;
    border-right: 5px solid transparent;
    border-radius: 50px;
    box-shadow: 0 0 15px #2187e7;
    width: 30px;
    height: 30px;
    -moz-animation: spinoffPulse 1s infinite linear;
    -webkit-animation: spinoffPulse 1s infinite linear;
    margin: -15px 0 0 -15px;
    position: absolute;
    top: 50%;
    left: 50%;
  }

  @-moz-keyframes spinPulse {
    0% {
      -moz-transform: rotate(160deg);
      opacity: 0;
      box-shadow: 0 0 1px #2187e7;
    }
    50% {
      -moz-transform: rotate(145deg);
      opacity: 1;
    }
    100% {
      -moz-transform: rotate(-320deg);
      opacity: 0;
    }
  }

  @-moz-keyframes spinoffPulse {
    0% {
      -moz-transform: rotate(0deg);
    }
    100% {
      -moz-transform: rotate(360deg);
    }
  }

  @-webkit-keyframes spinPulse {
    0% {
      -webkit-transform: rotate(160deg);
      opacity: 0;
      box-shadow: 0 0 1px #2187e7;
    }
    50% {
      -webkit-transform: rotate(145deg);
      opacity: 1;
    }
    100% {
      -webkit-transform: rotate(-320deg);
      opacity: 0;
    }
  }

  @-webkit-keyframes spinoffPulse {
    0% {
      -webkit-transform: rotate(0deg);
    }
    100% {
      -webkit-transform: rotate(360deg);
    }
  }

  `],
            },] },
];
/** @nocollapse */
BarChartComponent.ctorParameters = () => [
    { type: ChartLoaderService }
];
BarChartComponent.propDecorators = {
    data: [{ type: Input, args: ['data',] }],
    width: [{ type: Input }],
    height: [{ type: Input }],
    stacked: [{ type: Input }],
    xaxistitle: [{ type: Input, args: ['x-axis-title',] }],
    yaxistitle: [{ type: Input, args: ['y-axis-title',] }],
    backgroundcolor: [{ type: Input, args: ['background-color',] }],
    chartLegendComp: [{ type: ContentChildren, args: [ChartLegendComponent,] }],
    chartTitleComp: [{ type: ContentChildren, args: [ChartTitleComponent,] }],
    chartAreaComp: [{ type: ContentChildren, args: [ChartAreaComponent,] }],
    barchart: [{ type: ViewChild, args: ['barchart',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 * Copyright 2016-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Author - Sagar Jadhav
 *
 */
/*
Component Name : Amexio chart horizontal axis
Component Selector : <amexio-chart-horizontal-axis>
Component Description : it describes horizontal axis properties of chart.
*/
class HorizontalAxisComponent {
    constructor() {
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
}
HorizontalAxisComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-chart-horizontal-axis', template: ` `,
            },] },
];
/** @nocollapse */
HorizontalAxisComponent.ctorParameters = () => [];
HorizontalAxisComponent.propDecorators = {
    title: [{ type: Input }],
    titlecolor: [{ type: Input, args: ['title-color',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 * Copyright 2016-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Author - Sagar Jadhav
 *
 */
/*
Component Name : Amexio chart vertical axis
Component Selector : <amexio-chart-vertical-axis>
Component Description : it describes vertical axis properties of chart.
*/
class VerticalAxisComponent {
    constructor() {
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
}
VerticalAxisComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-chart-vertical-axis', template: ` `,
            },] },
];
/** @nocollapse */
VerticalAxisComponent.ctorParameters = () => [];
VerticalAxisComponent.propDecorators = {
    title: [{ type: Input }],
    titlecolor: [{ type: Input, args: ['title-color',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 * Copyright 2016-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Author - Sagar Jadhav
 *
 */
/*
Component Name : Amexio bubble chart
Component Selector : <amexio-chart-bubble>
Component Description : A bubble chart is used to visualize a data set with two to four dimensions.
The first two dimensions are visualized as coordinates, the third as color and the fourth as size.
*/
class BubbleChartComponent {
    /**
     * @param {?} loader
     */
    constructor(loader) {
        this.loader = loader;
        /*
        Properties
        name : axis-color
        datatype : any
        version : 4.0 onwards
        default : none
        description : An object that specifies a mapping between color column values and
        colors or a gradient scale.example:['#FF0000', '#00FF00'] or ['yellow', 'red']
        */
        this.axiscolor = [];
        this.width = '100%';
    }
    /**
     * @return {?}
     */
    get data() {
        return this._data;
    }
    /*
    Properties
    name : data
    datatype : any
    version : 4.0 onwards
    default : none
    description : Local data for AreaChart
    */
    /**
     * @param {?} data
     * @return {?}
     */
    set data(data) {
        if (data) {
            this._data = data;
            this.showChart = true;
        }
        else {
            this.showChart = false;
        }
    }
    /**
     * @return {?}
     */
    drawChart() {
        if (this.showChart) {
            this.bubbleData = google.visualization.arrayToDataTable(this._data);
            this.options = {
                title: this.chartTitleComponent ? this.chartTitleComponent.title : null,
                titleTextStyle: this.chartTitleComponent ? this.createTitleTextStyle() : null,
                backgroundcolor: this.backgroundcolor,
                legend: this.chartLengendComponent ? this.createChartLegend() : 'none',
                chartArea: this.chartAreaComponent ? this.createChartBackground() : null,
                vAxis: this.verticalComponent ? this.createChartVertical() : null,
                hAxis: this.horizontalComponent ? this.createchartHorizontal() : null,
                bubble: { textStyle: { fontsize: 11 } },
                axiscolor: { colors: this.axiscolor },
            };
            if (this.bubbleData) {
                this.chart = new google.visualization.BubbleChart(this.bubblechart.nativeElement);
                this.hasLoaded = true;
                this.chart.draw(this.bubbleData, this.options);
                google.visualization.events.addListener(this.chart, 'click', this.click);
            }
        }
    }
    /**
     * @return {?}
     */
    createTitleTextStyle() {
        return {
            color: this.chartTitleComponent.color ? this.chartTitleComponent.color : null,
            fontName: this.chartTitleComponent.fontname ? this.chartTitleComponent.fontname : null,
            fontsize: this.chartTitleComponent.fontsize ? this.chartTitleComponent.fontsize : null,
            bold: this.chartTitleComponent.bold ? this.chartTitleComponent.bold : null,
            italic: this.chartTitleComponent.italic ? this.chartTitleComponent.italic : null,
        };
    }
    /**
     * @return {?}
     */
    createChartLegend() {
        return {
            position: this.chartLengendComponent.position ? this.chartLengendComponent.position : null,
            // this work only in chart position is top
            maxLines: this.chartLengendComponent.maxlines ? this.chartLengendComponent.maxlines : null,
            textStyle: {
                color: this.chartLengendComponent.color ? this.chartLengendComponent.color : null,
                fontsize: this.chartLengendComponent.fontsize ? this.chartLengendComponent.fontsize : null,
                fontName: this.chartLengendComponent.fontname ? this.chartLengendComponent.fontname : null,
                bold: this.chartLengendComponent.bold ? this.chartLengendComponent.bold : null,
                alignment: this.chartLengendComponent.alignment ? this.chartLengendComponent.alignment : null,
            },
        };
    }
    /**
     * @return {?}
     */
    createChartBackground() {
        return {
            backgroundcolor: this.chartAreaComponent.chartbackgroundcolor ? this.chartAreaComponent.chartbackgroundcolor : null,
            left: this.chartAreaComponent.leftposition ? this.chartAreaComponent.leftposition : null,
            top: this.chartAreaComponent.topposition ? this.chartAreaComponent.topposition : null,
            height: this.chartAreaComponent.chartheight ? this.chartAreaComponent.chartheight : null,
            width: this.chartAreaComponent.chartwidth ? this.chartAreaComponent.chartwidth : null,
        };
    }
    /**
     * @return {?}
     */
    createChartVertical() {
        return {
            title: this.verticalComponent.title ? this.verticalComponent.title : null,
            titleTextStyle: { color: this.verticalComponent.titlecolor ? this.verticalComponent.titlecolor : null },
        };
    }
    /**
     * @return {?}
     */
    createchartHorizontal() {
        return {
            title: this.horizontalComponent.title ? this.horizontalComponent.title : null,
            titleTextStyle: { color: this.horizontalComponent.titlecolor ? this.horizontalComponent.titlecolor : null },
        };
    }
    /**
     * @param {?} e
     * @return {?}
     */
    click(e) {
    }
    // after content init for inner directive is run
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.chartLegendArray = this.chartLegendComp.toArray();
        this.chartTitleArray = this.chartTitleComp.toArray();
        this.chartAreaArray = this.chartAreaComp.toArray();
        this.horizontalArray = this.horizontalComp.toArray();
        this.verticalArray = this.verticalComp.toArray();
        // take first component
        if (this.chartLegendArray.length === 1) {
            this.chartLengendComponent = this.chartLegendArray.pop();
        }
        if (this.chartTitleArray.length === 1) {
            this.chartTitleComponent = this.chartTitleArray.pop();
        }
        if (this.chartAreaArray.length === 1) {
            this.chartAreaComponent = this.chartAreaArray.pop();
        }
        if (this.horizontalArray.length === 1) {
            this.horizontalComponent = this.horizontalArray.pop();
        }
        if (this.verticalArray.length === 1) {
            this.verticalComponent = this.verticalArray.pop();
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.hasLoaded = false;
        this.loader.loadCharts('BubbleChart').subscribe((/**
         * @param {?} value
         * @return {?}
         */
        (value) => console.log()), (/**
         * @param {?} errror
         * @return {?}
         */
        (errror) => console.error(errror)), (/**
         * @return {?}
         */
        () => {
            this.drawChart();
        }));
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onResize(event) {
        this.drawChart();
    }
}
BubbleChartComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-chart-bubble',
                template: `
      <div *ngIf="showChart" #bubblechart
           [style.width]="width"
           [style.height]="height" (window:resize)="onResize($event)">
        <div *ngIf="!hasLoaded" class="lmask">
        </div>
      </div>
  `,
                styles: [`.lmask {
    position: absolute;
    height: 100%;
    width: 100%;
    background-color: #000;
    bottom: 0;
    left: 0;
    right: 0;
    top: 0;
    z-index: 9999;
    opacity: 0.4;
  }
  .lmask.fixed {
    position: fixed;
  }
  .lmask:before {
    content: '';
    background-color: transparent;
    border: 5px solid rgba(0, 183, 229, 0.9);
    opacity: .9;
    border-right: 5px solid transparent;
    border-left: 5px solid transparent;
    border-radius: 50px;
    box-shadow: 0 0 35px #2187e7;
    width: 50px;
    height: 50px;
    -moz-animation: spinPulse 1s infinite ease-in-out;
    -webkit-animation: spinPulse 1s infinite linear;
    margin: -25px 0 0 -25px;
    position: absolute;
    top: 50%;
    left: 50%;
  }
  .lmask:after {
    content: '';
    background-color: transparent;
    border: 5px solid rgba(0, 183, 229, 0.9);
    opacity: .9;
    border-left: 5px solid transparent;
    border-right: 5px solid transparent;
    border-radius: 50px;
    box-shadow: 0 0 15px #2187e7;
    width: 30px;
    height: 30px;
    -moz-animation: spinoffPulse 1s infinite linear;
    -webkit-animation: spinoffPulse 1s infinite linear;
    margin: -15px 0 0 -15px;
    position: absolute;
    top: 50%;
    left: 50%;
  }

  @-moz-keyframes spinPulse {
    0% {
      -moz-transform: rotate(160deg);
      opacity: 0;
      box-shadow: 0 0 1px #2187e7;
    }
    50% {
      -moz-transform: rotate(145deg);
      opacity: 1;
    }
    100% {
      -moz-transform: rotate(-320deg);
      opacity: 0;
    }
  }
  @-moz-keyframes spinoffPulse {
    0% {
      -moz-transform: rotate(0deg);
    }
    100% {
      -moz-transform: rotate(360deg);
    }
  }
  @-webkit-keyframes spinPulse {
    0% {
      -webkit-transform: rotate(160deg);
      opacity: 0;
      box-shadow: 0 0 1px #2187e7;
    }
    50% {
      -webkit-transform: rotate(145deg);
      opacity: 1;
    }
    100% {
      -webkit-transform: rotate(-320deg);
      opacity: 0;
    }
  }
  @-webkit-keyframes spinoffPulse {
    0% {
      -webkit-transform: rotate(0deg);
    }
    100% {
      -webkit-transform: rotate(360deg);
    }
  }

  `],
            },] },
];
/** @nocollapse */
BubbleChartComponent.ctorParameters = () => [
    { type: ChartLoaderService }
];
BubbleChartComponent.propDecorators = {
    width: [{ type: Input }],
    height: [{ type: Input }],
    data: [{ type: Input, args: ['data',] }],
    axiscolor: [{ type: Input, args: ['axis-color',] }],
    backgroundcolor: [{ type: Input, args: ['background-color',] }],
    chartLegendComp: [{ type: ContentChildren, args: [ChartLegendComponent,] }],
    chartTitleComp: [{ type: ContentChildren, args: [ChartTitleComponent,] }],
    chartAreaComp: [{ type: ContentChildren, args: [ChartAreaComponent,] }],
    horizontalComp: [{ type: ContentChildren, args: [HorizontalAxisComponent,] }],
    verticalComp: [{ type: ContentChildren, args: [VerticalAxisComponent,] }],
    bubblechart: [{ type: ViewChild, args: ['bubblechart',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 * Copyright 2016-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Author - Sagar Jadhav
 *
 */
/*
 Component Name : Amexio candlestick chart
 Component Selector : <amexio-chart-candlestick>
 Component Description : A candlestick chart is used to show an opening and closing value overlaid on top of a total variance.
 Candlestick charts are often used to show stock value behavior.
*/
class CandlestickChartComponent {
    /**
     * @param {?} loader
     */
    constructor(loader) {
        this.loader = loader;
        this.width = '100%';
    }
    /**
     * @return {?}
     */
    get data() {
        return this._data;
    }
    /*
    Properties
    name : data
    datatype : any
    version : 4.0 onwards
    default : none
    description : Local data for AreaChart
    */
    /**
     * @param {?} data
     * @return {?}
     */
    set data(data) {
        if (data) {
            this._data = data;
            this.showChart = true;
        }
        else {
            this.showChart = false;
        }
    }
    /**
     * @return {?}
     */
    drawChart() {
        if (this.showChart) {
            this.candlestickData = google.visualization.arrayToDataTable(this._data, true);
            this.options = {
                title: this.chartTitleComponent ? this.chartTitleComponent.title : null,
                titleTextStyle: this.chartTitleComponent ? this.chartTileTextStyle() : null,
                backgroundcolor: this.backgroundcolor,
                legend: 'none',
                chartArea: this.chartAreaComponent ? this.chartLegendStyle() : null,
                vAxis: this.verticalComponent ? this.chartVerticalStyle() : null,
                hAxis: this.horizontalComponent ? this.chartHorizontalStyle() : null,
            };
            if (this.candlestickData) {
                this.chart = new google.visualization.CandlestickChart(this.candlestick.nativeElement);
                this.hasLoaded = true;
                this.chart.draw(this.candlestickData, this.options);
                google.visualization.events.addListener(this.chart, 'click', this.click);
            }
        }
    }
    /**
     * @return {?}
     */
    chartTileTextStyle() {
        return {
            color: this.chartTitleComponent.color ? this.chartTitleComponent.color : null,
            fontName: this.chartTitleComponent.fontname ? this.chartTitleComponent.fontname : null,
            fontsize: this.chartTitleComponent.fontsize ? this.chartTitleComponent.fontsize : null,
            bold: this.chartTitleComponent.bold ? this.chartTitleComponent.bold : null,
            italic: this.chartTitleComponent.italic ? this.chartTitleComponent.italic : null,
        };
    }
    /**
     * @return {?}
     */
    chartLegendStyle() {
        return {
            backgroundcolor: this.chartAreaComponent.chartbackgroundcolor ? this.chartAreaComponent.chartbackgroundcolor : null,
            left: this.chartAreaComponent.leftposition ? this.chartAreaComponent.leftposition : null,
            top: this.chartAreaComponent.topposition ? this.chartAreaComponent.topposition : null,
            height: this.chartAreaComponent.chartheight ? this.chartAreaComponent.chartheight : null,
            width: this.chartAreaComponent.chartwidth ? this.chartAreaComponent.chartwidth : null,
        };
    }
    /**
     * @return {?}
     */
    chartVerticalStyle() {
        return {
            title: this.verticalComponent.title ? this.verticalComponent.title : null,
            titleTextStyle: { color: this.verticalComponent.titlecolor ? this.verticalComponent.titlecolor : null },
        };
    }
    /**
     * @return {?}
     */
    chartHorizontalStyle() {
        return {
            title: this.horizontalComponent.title ? this.horizontalComponent.title : null,
            titleTextStyle: { color: this.horizontalComponent.titlecolor ? this.horizontalComponent.titlecolor : null },
        };
    }
    /**
     * @param {?} e
     * @return {?}
     */
    click(e) {
    }
    // after content init for inner directive is run
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.chartAreaArray = this.chartAreaComp.toArray();
        this.horizontalArray = this.horizontalComp.toArray();
        this.verticalArray = this.verticalComp.toArray();
        this.chartTitleArray = this.chartTitleComp.toArray();
        // take first component
        if (this.chartTitleArray.length === 1) {
            this.chartTitleComponent = this.chartTitleArray.pop();
        }
        if (this.chartAreaArray.length === 1) {
            this.chartAreaComponent = this.chartAreaArray.pop();
        }
        if (this.horizontalArray.length === 1) {
            this.horizontalComponent = this.horizontalArray.pop();
        }
        if (this.verticalArray.length === 1) {
            this.verticalComponent = this.verticalArray.pop();
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.hasLoaded = false;
        this.loader.loadCharts('CandlestickChart').subscribe((/**
         * @param {?} value
         * @return {?}
         */
        (value) => console.log()), (/**
         * @param {?} errror
         * @return {?}
         */
        (errror) => console.error(errror)), (/**
         * @return {?}
         */
        () => {
            this.drawChart();
        }));
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onResize(event) {
        this.drawChart();
    }
}
CandlestickChartComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-chart-candlestick', template: `
    <div *ngIf="showChart" #candlestick
         [style.width]="width"
         [style.height]="height" (window:resize)="onResize($event)">
      <div *ngIf="!hasLoaded" class="lmask">
      </div>
    </div>
  `, styles: [`.lmask {
    position: absolute;
    height: 100%;
    width: 100%;
    background-color: #000;
    bottom: 0;
    left: 0;
    right: 0;
    top: 0;
    z-index: 9999;
    opacity: 0.4;
  }

  .lmask.fixed {
    position: fixed;
  }

  .lmask:before {
    content: '';
    background-color: transparent;
    border: 5px solid rgba(0, 183, 229, 0.9);
    opacity: .9;
    border-right: 5px solid transparent;
    border-left: 5px solid transparent;
    border-radius: 50px;
    box-shadow: 0 0 35px #2187e7;
    width: 50px;
    height: 50px;
    -moz-animation: spinPulse 1s infinite ease-in-out;
    -webkit-animation: spinPulse 1s infinite linear;
    margin: -25px 0 0 -25px;
    position: absolute;
    top: 50%;
    left: 50%;
  }

  .lmask:after {
    content: '';
    background-color: transparent;
    border: 5px solid rgba(0, 183, 229, 0.9);
    opacity: .9;
    border-left: 5px solid transparent;
    border-right: 5px solid transparent;
    border-radius: 50px;
    box-shadow: 0 0 15px #2187e7;
    width: 30px;
    height: 30px;
    -moz-animation: spinoffPulse 1s infinite linear;
    -webkit-animation: spinoffPulse 1s infinite linear;
    margin: -15px 0 0 -15px;
    position: absolute;
    top: 50%;
    left: 50%;
  }

  @-moz-keyframes spinPulse {
    0% {
      -moz-transform: rotate(160deg);
      opacity: 0;
      box-shadow: 0 0 1px #2187e7;
    }
    50% {
      -moz-transform: rotate(145deg);
      opacity: 1;
    }
    100% {
      -moz-transform: rotate(-320deg);
      opacity: 0;
    }
  }

  @-moz-keyframes spinoffPulse {
    0% {
      -moz-transform: rotate(0deg);
    }
    100% {
      -moz-transform: rotate(360deg);
    }
  }

  @-webkit-keyframes spinPulse {
    0% {
      -webkit-transform: rotate(160deg);
      opacity: 0;
      box-shadow: 0 0 1px #2187e7;
    }
    50% {
      -webkit-transform: rotate(145deg);
      opacity: 1;
    }
    100% {
      -webkit-transform: rotate(-320deg);
      opacity: 0;
    }
  }

  @-webkit-keyframes spinoffPulse {
    0% {
      -webkit-transform: rotate(0deg);
    }
    100% {
      -webkit-transform: rotate(360deg);
    }
  }

  `],
            },] },
];
/** @nocollapse */
CandlestickChartComponent.ctorParameters = () => [
    { type: ChartLoaderService }
];
CandlestickChartComponent.propDecorators = {
    width: [{ type: Input }],
    height: [{ type: Input }],
    data: [{ type: Input, args: ['data',] }],
    backgroundcolor: [{ type: Input, args: ['background-color',] }],
    chartAreaComp: [{ type: ContentChildren, args: [ChartAreaComponent,] }],
    chartTitleComp: [{ type: ContentChildren, args: [ChartTitleComponent,] }],
    horizontalComp: [{ type: ContentChildren, args: [HorizontalAxisComponent,] }],
    verticalComp: [{ type: ContentChildren, args: [VerticalAxisComponent,] }],
    candlestick: [{ type: ViewChild, args: ['candlestick',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 * Copyright 2016-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Author - Sagar Jadhav
 *
 */
/*
 Component Name : Amexio candlestick waterfall chart
 Component Selector : <amexio-chart-candlestick-waterfall>
 Component Description : A candlestick waterfall chart is used to show an opening and closing
 value overlaid on top of a total variance. Candlestick charts are often used to show stock value behavior.
*/
class CandlestickWaterfallChartComponent {
    /**
     * @param {?} loader
     */
    constructor(loader) {
        this.loader = loader;
        this.width = '100%';
    }
    /**
     * @return {?}
     */
    get data() {
        return this._data;
    }
    /*
    Properties
    name : data
    datatype : any
    version : 4.0 onwards
    default : none
    description : Local data for AreaChart
    */
    /**
     * @param {?} data
     * @return {?}
     */
    set data(data) {
        if (data) {
            this._data = data;
            this.showChart = true;
        }
        else {
            this.showChart = false;
        }
    }
    /**
     * @return {?}
     */
    drawChart() {
        if (this.showChart) {
            this.candlestickData = google.visualization.arrayToDataTable(this._data, true);
            this.options = {
                title: this.chartTitleComponent ? this.chartTitleComponent.title : null,
                titleTextStyle: this.chartTitleComponent ? this.chartTitleTextStyle() : null,
                backgroundcolor: this.backgroundcolor,
                legend: 'none',
                chartArea: this.chartAreaComponent ? this.chartLegendStyle() : null,
                vAxis: this.verticalComponent ? this.chartVerticalComponent() : null,
                hAxis: this.horizontalComponent ? this.chartHorizontalComponent() : null,
                bar: { groupWidth: this.barwidth ? this.barwidth : null },
                // Remove space between bars.
                candlestick: this.chartColorStyle(),
            };
            if (this.candlestickData) {
                this.chart = new google.visualization.CandlestickChart(this.candlestickwaterfall.nativeElement);
                this.hasLoaded = true;
                this.chart.draw(this.candlestickData, this.options);
                google.visualization.events.addListener(this.chart, 'click', this.click);
            }
        }
    }
    /**
     * @return {?}
     */
    chartTitleTextStyle() {
        return {
            color: this.chartTitleComponent.color ? this.chartTitleComponent.color : null,
            fontName: this.chartTitleComponent.fontname ? this.chartTitleComponent.fontname : null,
            fontsize: this.chartTitleComponent.fontsize ? this.chartTitleComponent.fontsize : null,
            bold: this.chartTitleComponent.bold ? this.chartTitleComponent.bold : null,
            italic: this.chartTitleComponent.italic ? this.chartTitleComponent.italic : null,
        };
    }
    /**
     * @return {?}
     */
    chartLegendStyle() {
        return {
            backgroundcolor: this.chartAreaComponent.chartbackgroundcolor ? this.chartAreaComponent.chartbackgroundcolor : null,
            left: this.chartAreaComponent.leftposition ? this.chartAreaComponent.leftposition : null,
            top: this.chartAreaComponent.topposition ? this.chartAreaComponent.topposition : null,
            height: this.chartAreaComponent.chartheight ? this.chartAreaComponent.chartheight : null,
            width: this.chartAreaComponent.chartwidth ? this.chartAreaComponent.chartwidth : null,
        };
    }
    /**
     * @return {?}
     */
    chartVerticalComponent() {
        return {
            title: this.verticalComponent.title ? this.verticalComponent.title : null,
            titleTextStyle: { color: this.verticalComponent.titlecolor ? this.verticalComponent.titlecolor : null },
        };
    }
    /**
     * @return {?}
     */
    chartHorizontalComponent() {
        return {
            title: this.horizontalComponent.title ? this.horizontalComponent.title : null,
            titleTextStyle: { color: this.horizontalComponent.titlecolor ? this.horizontalComponent.titlecolor : null },
        };
    }
    /**
     * @return {?}
     */
    chartColorStyle() {
        return {
            fallingColor: this.fallingcolor ? { strokeWidth: 0, fill: this.fallingcolor ? this.fallingcolor : null } : null,
            // red
            risingColor: this.risingcolor ? { strokeWidth: 0, fill: this.risingcolor ? this.risingcolor : null } : null,
        };
    }
    /**
     * @param {?} e
     * @return {?}
     */
    click(e) {
    }
    // after content init for inner directive is run
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.chartAreaArray = this.chartAreaComp.toArray();
        this.horizontalArray = this.horizontalComp.toArray();
        this.verticalArray = this.verticalComp.toArray();
        this.chartTitleArray = this.chartTitleComp.toArray();
        // take first component
        if (this.chartTitleArray.length === 1) {
            this.chartTitleComponent = this.chartTitleArray.pop();
        }
        if (this.chartAreaArray.length === 1) {
            this.chartAreaComponent = this.chartAreaArray.pop();
        }
        if (this.horizontalArray.length === 1) {
            this.horizontalComponent = this.horizontalArray.pop();
        }
        if (this.verticalArray.length === 1) {
            this.verticalComponent = this.verticalArray.pop();
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.hasLoaded = false;
        this.loader.loadCharts('CandlestickChart').subscribe((/**
         * @param {?} value
         * @return {?}
         */
        (value) => console.log()), (/**
         * @param {?} errror
         * @return {?}
         */
        (errror) => console.error(errror)), (/**
         * @return {?}
         */
        () => {
            this.drawChart();
        }));
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onResize(event) {
        this.drawChart();
    }
}
CandlestickWaterfallChartComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-chart-candlestick-waterfall', template: `
    <div *ngIf="showChart" #candlestickwaterfall
         [style.width]="width"
         [style.height]="height" (window:resize)="onResize($event)">
      <div *ngIf="!hasLoaded" class="lmask">
      </div>
    </div>
  `, styles: [`.lmask {
    position: absolute;
    height: 100%;
    width: 100%;
    background-color: #000;
    bottom: 0;
    left: 0;
    right: 0;
    top: 0;
    z-index: 9999;
    opacity: 0.4;
  }

  .lmask.fixed {
    position: fixed;
  }

  .lmask:before {
    content: '';
    background-color: transparent;
    border: 5px solid rgba(0, 183, 229, 0.9);
    opacity: .9;
    border-right: 5px solid transparent;
    border-left: 5px solid transparent;
    border-radius: 50px;
    box-shadow: 0 0 35px #2187e7;
    width: 50px;
    height: 50px;
    -moz-animation: spinPulse 1s infinite ease-in-out;
    -webkit-animation: spinPulse 1s infinite linear;
    margin: -25px 0 0 -25px;
    position: absolute;
    top: 50%;
    left: 50%;
  }

  .lmask:after {
    content: '';
    background-color: transparent;
    border: 5px solid rgba(0, 183, 229, 0.9);
    opacity: .9;
    border-left: 5px solid transparent;
    border-right: 5px solid transparent;
    border-radius: 50px;
    box-shadow: 0 0 15px #2187e7;
    width: 30px;
    height: 30px;
    -moz-animation: spinoffPulse 1s infinite linear;
    -webkit-animation: spinoffPulse 1s infinite linear;
    margin: -15px 0 0 -15px;
    position: absolute;
    top: 50%;
    left: 50%;
  }

  @-moz-keyframes spinPulse {
    0% {
      -moz-transform: rotate(160deg);
      opacity: 0;
      box-shadow: 0 0 1px #2187e7;
    }
    50% {
      -moz-transform: rotate(145deg);
      opacity: 1;
    }
    100% {
      -moz-transform: rotate(-320deg);
      opacity: 0;
    }
  }

  @-moz-keyframes spinoffPulse {
    0% {
      -moz-transform: rotate(0deg);
    }
    100% {
      -moz-transform: rotate(360deg);
    }
  }

  @-webkit-keyframes spinPulse {
    0% {
      -webkit-transform: rotate(160deg);
      opacity: 0;
      box-shadow: 0 0 1px #2187e7;
    }
    50% {
      -webkit-transform: rotate(145deg);
      opacity: 1;
    }
    100% {
      -webkit-transform: rotate(-320deg);
      opacity: 0;
    }
  }

  @-webkit-keyframes spinoffPulse {
    0% {
      -webkit-transform: rotate(0deg);
    }
    100% {
      -webkit-transform: rotate(360deg);
    }
  }

  `],
            },] },
];
/** @nocollapse */
CandlestickWaterfallChartComponent.ctorParameters = () => [
    { type: ChartLoaderService }
];
CandlestickWaterfallChartComponent.propDecorators = {
    width: [{ type: Input }],
    height: [{ type: Input }],
    data: [{ type: Input, args: ['data',] }],
    backgroundcolor: [{ type: Input, args: ['background-color',] }],
    barwidth: [{ type: Input, args: ['bar-width',] }],
    fallingcolor: [{ type: Input, args: ['falling-color',] }],
    risingcolor: [{ type: Input, args: ['rising-color',] }],
    chartAreaComp: [{ type: ContentChildren, args: [ChartAreaComponent,] }],
    chartTitleComp: [{ type: ContentChildren, args: [ChartTitleComponent,] }],
    horizontalComp: [{ type: ContentChildren, args: [HorizontalAxisComponent,] }],
    verticalComp: [{ type: ContentChildren, args: [VerticalAxisComponent,] }],
    candlestickwaterfall: [{ type: ViewChild, args: ['candlestickwaterfall',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 * Copyright 2016-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Author - Sagar Jadhav
 *
 */
/*
Component Name : Amexio column chart
Component Selector : <amexio-chart-column>
Component Description : A column chart is a vertical bar chart rendered in the browser using SVG.
*/
class ColumnChartComponent {
    /**
     * @param {?} loader
     */
    constructor(loader) {
        this.loader = loader;
        // showing stack chart
        /*
        Properties
        name : stacked
        datatype : boolean
        version : 4.0 onwards
        default : false
        description : If set to true, stacks the elements for all series at each domain value.default value is false
        */
        this.stacked = false;
        this.width = '100%';
    }
    /**
     * @return {?}
     */
    get data() {
        return this._data;
    }
    /*
    Properties
    name : data
    datatype : any
    version : 4.0 onwards
    default : none
    description : For the use of local data
    */
    /**
     * @param {?} data
     * @return {?}
     */
    set data(data) {
        if (data) {
            this._data = data;
            this.showChart = true;
        }
        else {
            this.showChart = false;
        }
    }
    /**
     * @return {?}
     */
    drawChart() {
        if (this.showChart) {
            this.columnData = this.createTable(this._data);
            this.options = {
                title: this.chartTitleComponent ? this.chartTitleComponent.title : null,
                titleTextStyle: this.chartTitleComponent ? this.chartTitleTextStyle() : null,
                isStacked: this.stacked,
                backgroundcolor: this.backgroundcolor,
                legend: this.chartLengendComponent ? this.chartLegendStyle() : 'none',
                chartArea: this.chartAreaComponent ? this.chartBackGroundColor() : null,
            };
            if (this.columnData) {
                this.chart = new google.visualization.ColumnChart(this.columnchart.nativeElement);
                this.hasLoaded = true;
                this.chart.draw(this.columnData, this.options);
                google.visualization.events.addListener(this.chart, 'click', this.onClick);
            }
        }
    }
    /**
     * @return {?}
     */
    chartTitleTextStyle() {
        return {
            color: this.chartTitleComponent.color ? this.chartTitleComponent.color : null,
            fontName: this.chartTitleComponent.fontname ? this.chartTitleComponent.fontname : null,
            fontsize: this.chartTitleComponent.fontsize ? this.chartTitleComponent.fontsize : null,
            bold: this.chartTitleComponent.bold ? this.chartTitleComponent.bold : null,
            italic: this.chartTitleComponent.italic ? this.chartTitleComponent.italic : null,
        };
    }
    /**
     * @return {?}
     */
    chartLegendStyle() {
        return {
            position: this.chartLengendComponent.position ? this.chartLengendComponent.position : null,
            // this work only in chart position is top
            maxLines: this.chartLengendComponent.maxlines ? this.chartLengendComponent.maxlines : null,
            textStyle: {
                color: this.chartLengendComponent.color ? this.chartLengendComponent.color : null,
                fontsize: this.chartLengendComponent.fontsize ? this.chartLengendComponent.fontsize : null,
                fontName: this.chartLengendComponent.fontname ? this.chartLengendComponent.fontname : null,
                bold: this.chartLengendComponent.bold ? this.chartLengendComponent.bold : null,
                alignment: this.chartLengendComponent.alignment ? this.chartLengendComponent.alignment : null,
            },
        };
    }
    /**
     * @return {?}
     */
    chartBackGroundColor() {
        return {
            backgroundcolor: this.chartAreaComponent.chartbackgroundcolor ? this.chartAreaComponent.chartbackgroundcolor : null,
            left: this.chartAreaComponent.leftposition ? this.chartAreaComponent.leftposition : null,
            top: this.chartAreaComponent.topposition ? this.chartAreaComponent.topposition : null,
            height: this.chartAreaComponent.chartheight ? this.chartAreaComponent.chartheight : null,
            width: this.chartAreaComponent.chartwidth ? this.chartAreaComponent.chartwidth : null,
        };
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onClick(e) {
    }
    // after content init for inner directive is run
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.chartLegendArray = this.chartLegendComp.toArray();
        this.chartTitleArray = this.chartTitleComp.toArray();
        this.chartAreaArray = this.chartAreaComp.toArray();
        // take first component
        if (this.chartLegendArray.length === 1) {
            this.chartLengendComponent = this.chartLegendArray.pop();
        }
        if (this.chartTitleArray.length === 1) {
            this.chartTitleComponent = this.chartTitleArray.pop();
        }
        if (this.chartAreaArray.length === 1) {
            this.chartAreaComponent = this.chartAreaArray.pop();
        }
    }
    // This method create data table structure of array and return in required chart data
    /**
     * @param {?} array
     * @return {?}
     */
    createTable(array) {
        // create Duplicate Array for data arrangement
        /** @type {?} */
        const dupArray = array.slice();
        /** @type {?} */
        const data = new google.visualization.DataTable();
        /** @type {?} */
        const labelObject = dupArray[0];
        // remove first object of array
        dupArray.shift();
        labelObject.forEach((/**
         * @param {?} datatypeObject
         * @return {?}
         */
        (datatypeObject) => {
            data.addColumn(datatypeObject.datatype, datatypeObject.label);
        }));
        /** @type {?} */
        const finalArray = [];
        dupArray.forEach((/**
         * @param {?} rowObject
         * @return {?}
         */
        (rowObject) => {
            finalArray.push(rowObject);
        }));
        data.addRows(finalArray);
        return data;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.hasLoaded = false;
        this.loader.loadCharts('ColumnChart').subscribe((/**
         * @param {?} value
         * @return {?}
         */
        (value) => console.log()), (/**
         * @param {?} errror
         * @return {?}
         */
        (errror) => console.error(errror)), (/**
         * @return {?}
         */
        () => {
            this.drawChart();
        }));
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onResize(event) {
        this.drawChart();
    }
}
ColumnChartComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-chart-column', template: `
    <div  *ngIf="showChart" #columnchart
         [style.width]="width"
         [style.height]="height"
         (window:resize)="onResize($event)">
      <div *ngIf="!hasLoaded" class="lmask">
      </div>
    </div>
  `, styles: [`.lmask {
    position: absolute;
    height: 100%;
    width: 100%;
    background-color: #000;
    bottom: 0;
    left: 0;
    right: 0;
    top: 0;
    z-index: 9999;
    opacity: 0.4;
  }

  .lmask.fixed {
    position: fixed;
  }

  .lmask:before {
    content: '';
    background-color: transparent;
    border: 5px solid rgba(0, 183, 229, 0.9);
    opacity: .9;
    border-right: 5px solid transparent;
    border-left: 5px solid transparent;
    border-radius: 50px;
    box-shadow: 0 0 35px #2187e7;
    width: 50px;
    height: 50px;
    -moz-animation: spinPulse 1s infinite ease-in-out;
    -webkit-animation: spinPulse 1s infinite linear;
    margin: -25px 0 0 -25px;
    position: absolute;
    top: 50%;
    left: 50%;
  }

  .lmask:after {
    content: '';
    background-color: transparent;
    border: 5px solid rgba(0, 183, 229, 0.9);
    opacity: .9;
    border-left: 5px solid transparent;
    border-right: 5px solid transparent;
    border-radius: 50px;
    box-shadow: 0 0 15px #2187e7;
    width: 30px;
    height: 30px;
    -moz-animation: spinoffPulse 1s infinite linear;
    -webkit-animation: spinoffPulse 1s infinite linear;
    margin: -15px 0 0 -15px;
    position: absolute;
    top: 50%;
    left: 50%;
  }

  @-moz-keyframes spinPulse {
    0% {
      -moz-transform: rotate(160deg);
      opacity: 0;
      box-shadow: 0 0 1px #2187e7;
    }
    50% {
      -moz-transform: rotate(145deg);
      opacity: 1;
    }
    100% {
      -moz-transform: rotate(-320deg);
      opacity: 0;
    }
  }

  @-moz-keyframes spinoffPulse {
    0% {
      -moz-transform: rotate(0deg);
    }
    100% {
      -moz-transform: rotate(360deg);
    }
  }

  @-webkit-keyframes spinPulse {
    0% {
      -webkit-transform: rotate(160deg);
      opacity: 0;
      box-shadow: 0 0 1px #2187e7;
    }
    50% {
      -webkit-transform: rotate(145deg);
      opacity: 1;
    }
    100% {
      -webkit-transform: rotate(-320deg);
      opacity: 0;
    }
  }

  @-webkit-keyframes spinoffPulse {
    0% {
      -webkit-transform: rotate(0deg);
    }
    100% {
      -webkit-transform: rotate(360deg);
    }
  }

  `],
            },] },
];
/** @nocollapse */
ColumnChartComponent.ctorParameters = () => [
    { type: ChartLoaderService }
];
ColumnChartComponent.propDecorators = {
    width: [{ type: Input }],
    height: [{ type: Input }],
    data: [{ type: Input, args: ['data',] }],
    stacked: [{ type: Input }],
    backgroundcolor: [{ type: Input, args: ['background-color',] }],
    chartLegendComp: [{ type: ContentChildren, args: [ChartLegendComponent,] }],
    chartTitleComp: [{ type: ContentChildren, args: [ChartTitleComponent,] }],
    chartAreaComp: [{ type: ContentChildren, args: [ChartAreaComponent,] }],
    columnchart: [{ type: ViewChild, args: ['columnchart',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 * Copyright 2016-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Author - Sagar Jadhav
 *
 */
/*
Component Name : Amexio combo chart
Component Selector : <amexio-chart-combo>
Component Description : A chart that lets you render each series as a different marker type from the following list: line,bars
*/
class ComboChartComponent {
    /**
     * @param {?} loader
     */
    constructor(loader) {
        this.loader = loader;
        this.width = '100%';
    }
    /**
     * @return {?}
     */
    get data() {
        return this._data;
    }
    /*
    Properties
    name : data
    datatype : any
    version : 4.0 onwards
    default : none
    description : For the use of local data
    */
    /**
     * @param {?} data
     * @return {?}
     */
    set data(data) {
        if (data) {
            this._data = data;
            this.showChart = true;
        }
        else {
            this.showChart = false;
        }
    }
    /**
     * @return {?}
     */
    drawChart() {
        if (this.showChart) {
            this.comboData = google.visualization.arrayToDataTable(this._data);
            this.options = {
                title: this.chartTitleComponent ? this.chartTitleComponent.title : null,
                titleTextStyle: this.chartTitleComponent ? this.chartTitleStyle() : null,
                backgroundcolor: this.backgroundcolor,
                legend: this.chartLengendComponent ? this.chartLegendStyle() : 'none',
                chartArea: this.chartAreaComponent ? this.chartBackground() : null,
                vAxis: this.verticalComponent ? this.chartVerticalStyle() : null,
                hAxis: this.horizontalComponent ? this.chartHorizontalStyle() : null,
                seriesType: 'bars',
                series: { 4: { type: 'line' } },
            };
            if (this.comboData) {
                this.chart = new google.visualization.ComboChart(this.combochart.nativeElement);
                this.hasLoaded = true;
                this.chart.draw(this.comboData, this.options);
                google.visualization.events.addListener(this.chart, 'click', this.click);
            }
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    click(e) {
    }
    /**
     * @return {?}
     */
    chartTitleStyle() {
        return {
            color: this.chartTitleComponent.color ? this.chartTitleComponent.color : null,
            fontName: this.chartTitleComponent.fontname ? this.chartTitleComponent.fontname : null,
            fontsize: this.chartTitleComponent.fontsize ? this.chartTitleComponent.fontsize : null,
            bold: this.chartTitleComponent.bold ? this.chartTitleComponent.bold : null,
            italic: this.chartTitleComponent.italic ? this.chartTitleComponent.italic : null,
        };
    }
    /**
     * @return {?}
     */
    chartLegendStyle() {
        return {
            position: this.chartLengendComponent.position ? this.chartLengendComponent.position : null,
            // this work only in chart position is top
            maxLines: this.chartLengendComponent.maxlines ? this.chartLengendComponent.maxlines : null, textStyle: {
                color: this.chartLengendComponent.color ? this.chartLengendComponent.color : null,
                fontsize: this.chartLengendComponent.fontsize ? this.chartLengendComponent.fontsize : null,
                fontName: this.chartLengendComponent.fontname ? this.chartLengendComponent.fontname : null,
                bold: this.chartLengendComponent.bold ? this.chartLengendComponent.bold : null,
                alignment: this.chartLengendComponent.alignment ? this.chartLengendComponent.alignment : null,
            },
        };
    }
    /**
     * @return {?}
     */
    chartBackground() {
        return {
            backgroundcolor: this.chartAreaComponent.chartbackgroundcolor ? this.chartAreaComponent.chartbackgroundcolor : null,
            left: this.chartAreaComponent.leftposition ? this.chartAreaComponent.leftposition : null,
            top: this.chartAreaComponent.topposition ? this.chartAreaComponent.topposition : null,
            height: this.chartAreaComponent.chartheight ? this.chartAreaComponent.chartheight : null,
            width: this.chartAreaComponent.chartwidth ? this.chartAreaComponent.chartwidth : null,
        };
    }
    /**
     * @return {?}
     */
    chartVerticalStyle() {
        return {
            title: this.verticalComponent.title ? this.verticalComponent.title : null,
            titleTextStyle: { color: this.verticalComponent.titlecolor ? this.verticalComponent.titlecolor : null },
        };
    }
    /**
     * @return {?}
     */
    chartHorizontalStyle() {
        return {
            title: this.horizontalComponent.title ? this.horizontalComponent.title : null,
            titleTextStyle: { color: this.horizontalComponent.titlecolor ? this.horizontalComponent.titlecolor : null },
        };
    }
    // after content init for inner directive is run
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.chartLegendArray = this.chartLegendComp.toArray();
        this.chartTitleArray = this.chartTitleComp.toArray();
        this.chartAreaArray = this.chartAreaComp.toArray();
        this.horizontalArray = this.horizontalComp.toArray();
        this.verticalArray = this.verticalComp.toArray();
        // take first component
        if (this.chartLegendArray.length === 1) {
            this.chartLengendComponent = this.chartLegendArray.pop();
        }
        if (this.chartTitleArray.length === 1) {
            this.chartTitleComponent = this.chartTitleArray.pop();
        }
        if (this.chartAreaArray.length === 1) {
            this.chartAreaComponent = this.chartAreaArray.pop();
        }
        if (this.horizontalArray.length === 1) {
            this.horizontalComponent = this.horizontalArray.pop();
        }
        if (this.verticalArray.length === 1) {
            this.verticalComponent = this.verticalArray.pop();
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.hasLoaded = false;
        this.loader.loadCharts('ComboChart').subscribe((/**
         * @param {?} value
         * @return {?}
         */
        (value) => console.log()), (/**
         * @param {?} errror
         * @return {?}
         */
        (errror) => console.error(errror)), (/**
         * @return {?}
         */
        () => {
            this.drawChart();
        }));
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onResize(event) {
        this.drawChart();
    }
}
ComboChartComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-chart-combo', template: `
    <div *ngIf="showChart" #combochart
         [style.width]="width"
         [style.height]="height" (window:resize)="onResize($event)">
      <div *ngIf="!hasLoaded" class="lmask">
      </div>
    </div>
  `, styles: [`.lmask {
    position: absolute;
    height: 100%;
    width: 100%;
    background-color: #000;
    bottom: 0;
    left: 0;
    right: 0;
    top: 0;
    z-index: 9999;
    opacity: 0.4;
  }

  .lmask.fixed {
    position: fixed;
  }

  .lmask:before {
    content: '';
    background-color: transparent;
    border: 5px solid rgba(0, 183, 229, 0.9);
    opacity: .9;
    border-right: 5px solid transparent;
    border-left: 5px solid transparent;
    border-radius: 50px;
    box-shadow: 0 0 35px #2187e7;
    width: 50px;
    height: 50px;
    -moz-animation: spinPulse 1s infinite ease-in-out;
    -webkit-animation: spinPulse 1s infinite linear;
    margin: -25px 0 0 -25px;
    position: absolute;
    top: 50%;
    left: 50%;
  }

  .lmask:after {
    content: '';
    background-color: transparent;
    border: 5px solid rgba(0, 183, 229, 0.9);
    opacity: .9;
    border-left: 5px solid transparent;
    border-right: 5px solid transparent;
    border-radius: 50px;
    box-shadow: 0 0 15px #2187e7;
    width: 30px;
    height: 30px;
    -moz-animation: spinoffPulse 1s infinite linear;
    -webkit-animation: spinoffPulse 1s infinite linear;
    margin: -15px 0 0 -15px;
    position: absolute;
    top: 50%;
    left: 50%;
  }

  @-moz-keyframes spinPulse {
    0% {
      -moz-transform: rotate(160deg);
      opacity: 0;
      box-shadow: 0 0 1px #2187e7;
    }
    50% {
      -moz-transform: rotate(145deg);
      opacity: 1;
    }
    100% {
      -moz-transform: rotate(-320deg);
      opacity: 0;
    }
  }

  @-moz-keyframes spinoffPulse {
    0% {
      -moz-transform: rotate(0deg);
    }
    100% {
      -moz-transform: rotate(360deg);
    }
  }

  @-webkit-keyframes spinPulse {
    0% {
      -webkit-transform: rotate(160deg);
      opacity: 0;
      box-shadow: 0 0 1px #2187e7;
    }
    50% {
      -webkit-transform: rotate(145deg);
      opacity: 1;
    }
    100% {
      -webkit-transform: rotate(-320deg);
      opacity: 0;
    }
  }

  @-webkit-keyframes spinoffPulse {
    0% {
      -webkit-transform: rotate(0deg);
    }
    100% {
      -webkit-transform: rotate(360deg);
    }
  }

  `],
            },] },
];
/** @nocollapse */
ComboChartComponent.ctorParameters = () => [
    { type: ChartLoaderService }
];
ComboChartComponent.propDecorators = {
    width: [{ type: Input }],
    height: [{ type: Input }],
    data: [{ type: Input, args: ['data',] }],
    backgroundcolor: [{ type: Input, args: ['background-color',] }],
    chartLegendComp: [{ type: ContentChildren, args: [ChartLegendComponent,] }],
    chartTitleComp: [{ type: ContentChildren, args: [ChartTitleComponent,] }],
    chartAreaComp: [{ type: ContentChildren, args: [ChartAreaComponent,] }],
    horizontalComp: [{ type: ContentChildren, args: [HorizontalAxisComponent,] }],
    verticalComp: [{ type: ContentChildren, args: [VerticalAxisComponent,] }],
    combochart: [{ type: ViewChild, args: ['combochart',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 * Copyright 2016-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Author - Sagar Jadhav
 *
 */
/*
Component Name : Amexio donut chart
Component Selector : <amexio-chart-donut>
Component Description : An donut chart that is rendered within the browser using SVG.
A donut chart is a pie chart with a hole in the center.
*/
class DonutChartComponent {
    /**
     * @param {?} loader
     */
    constructor(loader) {
        this.loader = loader;
        this.width = '100%';
    }
    /**
     * @return {?}
     */
    get data() {
        return this._data;
    }
    /*
      Properties
      name : data
      datatype : any
      version : 4.0 onwards
      default : none
      description : For the use of local data
      */
    /**
     * @param {?} data
     * @return {?}
     */
    set data(data) {
        if (data) {
            this._data = data;
            this.showChart = true;
        }
        else {
            this.showChart = false;
        }
    }
    /**
     * @return {?}
     */
    drawChart() {
        if (this.showChart) {
            this.donutData = google.visualization.arrayToDataTable(this._data);
            this.options = {
                title: this.chartTitleComponent ? this.chartTitleComponent.title : null,
                titleTextStyle: this.chartTitleComponent ? this.chariTitleTextStyle() : null,
                pieHole: 0.4,
                backgroundcolor: this.backgroundcolor,
                legend: this.chartLengendComponent ? this.chartLegendStyle() : 'none',
                chartArea: this.chartAreaComponent ? this.chartBackgroundColor() : null,
            };
            if (this.donutData) {
                this.chart = new google.visualization.PieChart(this.donutchart.nativeElement);
                this.hasLoaded = true;
                this.chart.draw(this.donutData, this.options);
                google.visualization.events.addListener(this.chart, 'click', this.onClick);
            }
        }
    }
    /**
     * @return {?}
     */
    chariTitleTextStyle() {
        return {
            color: this.chartTitleComponent.color ? this.chartTitleComponent.color : null,
            fontName: this.chartTitleComponent.fontname ? this.chartTitleComponent.fontname : null,
            fontsize: this.chartTitleComponent.fontsize ? this.chartTitleComponent.fontsize : null,
            bold: this.chartTitleComponent.bold ? this.chartTitleComponent.bold : null,
            italic: this.chartTitleComponent.italic ? this.chartTitleComponent.italic : null,
        };
    }
    /**
     * @return {?}
     */
    chartLegendStyle() {
        return {
            position: this.chartLengendComponent.position ? this.chartLengendComponent.position : null,
            // this work only in chart position is top
            maxLines: this.chartLengendComponent.maxlines ? this.chartLengendComponent.maxlines : null, textStyle: {
                color: this.chartLengendComponent.color ? this.chartLengendComponent.color : null,
                fontsize: this.chartLengendComponent.fontsize ? this.chartLengendComponent.fontsize : null,
                fontName: this.chartLengendComponent.fontname ? this.chartLengendComponent.fontname : null,
                bold: this.chartLengendComponent.bold ? this.chartLengendComponent.bold : null,
                alignment: this.chartLengendComponent.alignment ? this.chartLengendComponent.alignment : null,
            },
        };
    }
    /**
     * @return {?}
     */
    chartBackgroundColor() {
        return { backgroundcolor: this.chartAreaComponent.chartbackgroundcolor ? this.chartAreaComponent.chartbackgroundcolor : null,
            left: this.chartAreaComponent.leftposition ? this.chartAreaComponent.leftposition : null,
            top: this.chartAreaComponent.topposition ? this.chartAreaComponent.topposition : null,
            height: this.chartAreaComponent.chartheight ? this.chartAreaComponent.chartheight : null,
            width: this.chartAreaComponent.chartwidth ? this.chartAreaComponent.chartwidth : null,
        };
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onClick(e) {
    }
    // after content init for inner directive is run
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.chartLegendArray = this.chartLegendComp.toArray();
        this.chartTitleArray = this.chartTitleComp.toArray();
        this.chartAreaArray = this.chartAreaComp.toArray();
        // take first component
        if (this.chartLegendArray.length === 1) {
            this.chartLengendComponent = this.chartLegendArray.pop();
        }
        if (this.chartTitleArray.length === 1) {
            this.chartTitleComponent = this.chartTitleArray.pop();
        }
        if (this.chartAreaArray.length === 1) {
            this.chartAreaComponent = this.chartAreaArray.pop();
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.hasLoaded = false;
        this.loader.loadCharts('PieChart').subscribe((/**
         * @param {?} value
         * @return {?}
         */
        (value) => console.log()), (/**
         * @param {?} errror
         * @return {?}
         */
        (errror) => console.error(errror)), (/**
         * @return {?}
         */
        () => {
            this.drawChart();
        }));
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onResize(event) {
        this.drawChart();
    }
}
DonutChartComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-chart-donut', template: `
    <div *ngIf="showChart" #donutchart
         [style.width]="width"
         [style.height]="height"
         (window:resize)="onResize($event)">
      <div *ngIf="!hasLoaded" class="lmask">
      </div>
    </div>
  `, styles: [`.lmask {
    position: absolute;
    height: 100%;
    width: 100%;
    background-color: #000;
    bottom: 0;
    left: 0;
    right: 0;
    top: 0;
    z-index: 9999;
    opacity: 0.4;
  }

  .lmask.fixed {
    position: fixed;
  }

  .lmask:before {
    content: '';
    background-color: transparent;
    border: 5px solid rgba(0, 183, 229, 0.9);
    opacity: .9;
    border-right: 5px solid transparent;
    border-left: 5px solid transparent;
    border-radius: 50px;
    box-shadow: 0 0 35px #2187e7;
    width: 50px;
    height: 50px;
    -moz-animation: spinPulse 1s infinite ease-in-out;
    -webkit-animation: spinPulse 1s infinite linear;
    margin: -25px 0 0 -25px;
    position: absolute;
    top: 50%;
    left: 50%;
  }

  .lmask:after {
    content: '';
    background-color: transparent;
    border: 5px solid rgba(0, 183, 229, 0.9);
    opacity: .9;
    border-left: 5px solid transparent;
    border-right: 5px solid transparent;
    border-radius: 50px;
    box-shadow: 0 0 15px #2187e7;
    width: 30px;
    height: 30px;
    -moz-animation: spinoffPulse 1s infinite linear;
    -webkit-animation: spinoffPulse 1s infinite linear;
    margin: -15px 0 0 -15px;
    position: absolute;
    top: 50%;
    left: 50%;
  }

  @-moz-keyframes spinPulse {
    0% {
      -moz-transform: rotate(160deg);
      opacity: 0;
      box-shadow: 0 0 1px #2187e7;
    }
    50% {
      -moz-transform: rotate(145deg);
      opacity: 1;
    }
    100% {
      -moz-transform: rotate(-320deg);
      opacity: 0;
    }
  }

  @-moz-keyframes spinoffPulse {
    0% {
      -moz-transform: rotate(0deg);
    }
    100% {
      -moz-transform: rotate(360deg);
    }
  }

  @-webkit-keyframes spinPulse {
    0% {
      -webkit-transform: rotate(160deg);
      opacity: 0;
      box-shadow: 0 0 1px #2187e7;
    }
    50% {
      -webkit-transform: rotate(145deg);
      opacity: 1;
    }
    100% {
      -webkit-transform: rotate(-320deg);
      opacity: 0;
    }
  }

  @-webkit-keyframes spinoffPulse {
    0% {
      -webkit-transform: rotate(0deg);
    }
    100% {
      -webkit-transform: rotate(360deg);
    }
  }

  `],
            },] },
];
/** @nocollapse */
DonutChartComponent.ctorParameters = () => [
    { type: ChartLoaderService }
];
DonutChartComponent.propDecorators = {
    width: [{ type: Input }],
    height: [{ type: Input }],
    data: [{ type: Input, args: ['data',] }],
    backgroundcolor: [{ type: Input, args: ['background-color',] }],
    chartLegendComp: [{ type: ContentChildren, args: [ChartLegendComponent,] }],
    chartTitleComp: [{ type: ContentChildren, args: [ChartTitleComponent,] }],
    chartAreaComp: [{ type: ContentChildren, args: [ChartAreaComponent,] }],
    donutchart: [{ type: ViewChild, args: ['donutchart',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 * Copyright 2017-2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Author - Sagar Jadhav
 *
 */
/*
Component Name : Amexio Gantt chart
Component Selector : <amexio-chart-gantt>
Component Description : A timeline is a chart that depicts how a set of resources are used over time.
*/
class GanttChartComponent {
    /**
     * @param {?} loader
     */
    constructor(loader) {
        this.loader = loader;
        /*
        Properties
        name : critical-path-enabled
        datatype : boolean
        version : 4.3 onwards
        default : false
        description : If you set the criticalPathEnabled option to true, it show critical path line
        */
        this.criticalPathEnabled = false;
        this.width = '100%';
    }
    /**
     * @return {?}
     */
    get data() {
        return this._data;
    }
    /*
    Properties
    name : data
    datatype : any
    version : 4.3 onwards
    default : none
    description : For the use of local data
    */
    /**
     * @param {?} data
     * @return {?}
     */
    set data(data) {
        if (data) {
            this._data = data;
            this.showChart = true;
        }
        else {
            this.showChart = false;
        }
    }
    /**
     * @return {?}
     */
    drawChart() {
        if (this.data && this.showChart) {
            this.hasLoaded = true;
            this.options = { gantt: { criticalPathEnabled: this.criticalPathEnabled,
                    criticalPathStyle: { stroke: '#e64a19',
                        strokeWidth: 5 } },
                innerGridTrack: { fill: this.innerGridTrackColor ? this.innerGridTrackColor : '' },
                innerGridDarkTrack: { fill: this.innerGridDarkTrack ? this.innerGridDarkTrack : '' },
            };
            if (google && google.visualization) {
                this.chart = new google.visualization.Gantt(this.ganttchart.nativeElement);
                this.chart.draw(this.createTable(this._data), this.options);
                google.visualization.events.addListener(this.chart, 'click', this.onClick);
            }
            else {
                this.hasLoaded = false;
            }
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onClick(e) {
    }
    /**
     * @param {?} array
     * @return {?}
     */
    createTable(array) {
        /** @type {?} */
        const copyOfArray = array.slice();
        /** @type {?} */
        const data = new google.visualization.DataTable();
        /** @type {?} */
        const labelObject = copyOfArray[0];
        copyOfArray.shift();
        labelObject.forEach((/**
         * @param {?} datatypeObject
         * @return {?}
         */
        (datatypeObject) => {
            data.addColumn(datatypeObject.datatype, datatypeObject.label);
        }));
        /** @type {?} */
        const newArray = [];
        copyOfArray.forEach((/**
         * @param {?} rowObject
         * @return {?}
         */
        (rowObject) => {
            newArray.push(rowObject);
        }));
        data.addRows(newArray);
        return data;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.hasLoaded = false;
        this.loader.loadCharts('Gantt').subscribe((/**
         * @param {?} value
         * @return {?}
         */
        (value) => console.log()), (/**
         * @param {?} errror
         * @return {?}
         */
        (errror) => console.error(errror)), (/**
         * @return {?}
         */
        () => {
            this.drawChart();
        }));
    }
}
GanttChartComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-chart-gantt', template: `
    <div *ngIf='showChart' #gantt
         [style.width]='width'
    >
      <div *ngIf='!hasLoaded' class='lmask'>
      </div>
    </div>
  `, styles: [`.lmask {
    position: absolute;
    height: 100%;
    width: 100%;
    background-color: #000;
    bottom: 0;
    left: 0;
    right: 0;
    top: 0;
    z-index: 9999;
    opacity: 0.4;
  }

  .lmask.fixed {
    position: fixed;
  }

  .lmask:before {
    content: '';
    background-color: transparent;
    border: 5px solid rgba(0, 183, 229, 0.9);
    opacity: .9;
    border-right: 5px solid transparent;
    border-left: 5px solid transparent;
    border-radius: 50px;
    box-shadow: 0 0 35px #2187e7;
    width: 50px;
    height: 50px;
    -moz-animation: spinPulse 1s infinite ease-in-out;
    -webkit-animation: spinPulse 1s infinite linear;
    margin: -25px 0 0 -25px;
    position: absolute;
    top: 50%;
    left: 50%;
  }

  .lmask:after {
    content: '';
    background-color: transparent;
    border: 5px solid rgba(0, 183, 229, 0.9);
    opacity: .9;
    border-left: 5px solid transparent;
    border-right: 5px solid transparent;
    border-radius: 50px;
    box-shadow: 0 0 15px #2187e7;
    width: 30px;
    height: 30px;
    -moz-animation: spinoffPulse 1s infinite linear;
    -webkit-animation: spinoffPulse 1s infinite linear;
    margin: -15px 0 0 -15px;
    position: absolute;
    top: 50%;
    left: 50%;
  }

  @-moz-keyframes spinPulse {
    0% {
      -moz-transform: rotate(160deg);
      opacity: 0;
      box-shadow: 0 0 1px #2187e7;
    }
    50% {
      -moz-transform: rotate(145deg);
      opacity: 1;
    }
    100% {
      -moz-transform: rotate(-320deg);
      opacity: 0;
    }
  }

  @-moz-keyframes spinoffPulse {
    0% {
      -moz-transform: rotate(0deg);
    }
    100% {
      -moz-transform: rotate(360deg);
    }
  }

  @-webkit-keyframes spinPulse {
    0% {
      -webkit-transform: rotate(160deg);
      opacity: 0;
      box-shadow: 0 0 1px #2187e7;
    }
    50% {
      -webkit-transform: rotate(145deg);
      opacity: 1;
    }
    100% {
      -webkit-transform: rotate(-320deg);
      opacity: 0;
    }
  }

  @-webkit-keyframes spinoffPulse {
    0% {
      -webkit-transform: rotate(0deg);
    }
    100% {
      -webkit-transform: rotate(360deg);
    }
  }

  `],
            },] },
];
/** @nocollapse */
GanttChartComponent.ctorParameters = () => [
    { type: ChartLoaderService }
];
GanttChartComponent.propDecorators = {
    width: [{ type: Input }],
    data: [{ type: Input, args: ['data',] }],
    criticalPathEnabled: [{ type: Input, args: ['critical-path-enabled',] }],
    innerGridTrackColor: [{ type: Input, args: ['inner-grid-track-color',] }],
    innerGridDarkTrack: [{ type: Input, args: ['inner-grid-dark-track-color',] }],
    ganttchart: [{ type: ViewChild, args: ['gantt',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 * Copyright 2016-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Author - Sagar Jadhav
 *
 */
/*
Component Name : Amexio histogram chart
Component Selector : <amexio-chart-histogram>
Component Description : A histogram is a chart that groups numeric data into bins, displaying the bins as segmented columns.
*/
class HistogramChartComponent {
    /**
     * @param {?} loader
     */
    constructor(loader) {
        this.loader = loader;
        this.width = '100%';
    }
    /**
     * @return {?}
     */
    get data() {
        return this._data;
    }
    /*
    Properties
    name : data
    datatype : any
    version : 4.0 onwards
    default : none
    description : For the use of local data
    */
    /**
     * @param {?} data
     * @return {?}
     */
    set data(data) {
        if (data) {
            this._data = data;
            this.showChart = true;
        }
        else {
            this.showChart = false;
        }
    }
    /**
     * @return {?}
     */
    drawChart() {
        if (this.showChart) {
            this.histogramData = google.visualization.arrayToDataTable(this._data);
            this.options = {
                title: this.chartTitleComponent ? this.chartTitleComponent.title : null,
                titleTextStyle: this.chartTitleComponent ? this.charttitleTextStyle() : null,
                backgroundcolor: this.backgroundcolor,
                legend: this.chartLengendComponent ? this.chartegendStyle() : 'none',
                chartArea: this.chartAreaComponent ? this.chartBackground() : null,
            };
            if (this.histogramData) {
                this.chart = new google.visualization.Histogram(this.histogramchart.nativeElement);
                this.hasLoaded = true;
                this.chart.draw(this.histogramData, this.options);
                google.visualization.events.addListener(this.chart, 'click', this.onClick);
            }
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onClick(e) {
    }
    /**
     * @return {?}
     */
    charttitleTextStyle() {
        return {
            color: this.chartTitleComponent.color ? this.chartTitleComponent.color : null,
            fontName: this.chartTitleComponent.fontname ? this.chartTitleComponent.fontname : null,
            fontsize: this.chartTitleComponent.fontsize ? this.chartTitleComponent.fontsize : null,
            bold: this.chartTitleComponent.bold ? this.chartTitleComponent.bold : null,
            italic: this.chartTitleComponent.italic ? this.chartTitleComponent.italic : null,
        };
    }
    /**
     * @return {?}
     */
    chartegendStyle() {
        return {
            position: this.chartLengendComponent.position ? this.chartLengendComponent.position : null,
            // this work only in chart position is top
            maxLines: this.chartLengendComponent.maxlines ? this.chartLengendComponent.maxlines : null,
            textStyle: {
                color: this.chartLengendComponent.color ? this.chartLengendComponent.color : null,
                fontsize: this.chartLengendComponent.fontsize ? this.chartLengendComponent.fontsize : null,
                fontName: this.chartLengendComponent.fontname ? this.chartLengendComponent.fontname : null,
                bold: this.chartLengendComponent.bold ? this.chartLengendComponent.bold : null,
                alignment: this.chartLengendComponent.alignment ? this.chartLengendComponent.alignment : null,
            },
        };
    }
    /**
     * @return {?}
     */
    chartBackground() {
        return {
            backgroundcolor: this.chartAreaComponent.chartbackgroundcolor ? this.chartAreaComponent.chartbackgroundcolor : null,
            left: this.chartAreaComponent.leftposition ? this.chartAreaComponent.leftposition : null,
            top: this.chartAreaComponent.topposition ? this.chartAreaComponent.topposition : null,
            height: this.chartAreaComponent.chartheight ? this.chartAreaComponent.chartheight : null,
            width: this.chartAreaComponent.chartwidth ? this.chartAreaComponent.chartwidth : null,
        };
    }
    // after content init for inner directive is run
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.chartLegendArray = this.chartLegendComp.toArray();
        this.chartTitleArray = this.chartTitleComp.toArray();
        this.chartAreaArray = this.chartAreaComp.toArray();
        // take first component
        if (this.chartLegendArray.length === 1) {
            this.chartLengendComponent = this.chartLegendArray.pop();
        }
        if (this.chartTitleArray.length === 1) {
            this.chartTitleComponent = this.chartTitleArray.pop();
        }
        if (this.chartAreaArray.length === 1) {
            this.chartAreaComponent = this.chartAreaArray.pop();
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.hasLoaded = false;
        this.loader.loadCharts('Histogram').subscribe((/**
         * @param {?} value
         * @return {?}
         */
        (value) => console.log()), (/**
         * @param {?} errror
         * @return {?}
         */
        (errror) => console.error(errror)), (/**
         * @return {?}
         */
        () => {
            this.drawChart();
        }));
    }
}
HistogramChartComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-chart-histogram',
                template: `
      <div *ngIf="showChart" #histogramchart
           [style.width]="width"
           [style.height]="height"
      >
        <div *ngIf="!hasLoaded" class="lmask">
        </div>
      </div>
  `,
                styles: [`.lmask {
    position: absolute;
    height: 100%;
    width: 100%;
    background-color: #000;
    bottom: 0;
    left: 0;
    right: 0;
    top: 0;
    z-index: 9999;
    opacity: 0.4;
  }
  .lmask.fixed {
    position: fixed;
  }
  .lmask:before {
    content: '';
    background-color: transparent;
    border: 5px solid rgba(0, 183, 229, 0.9);
    opacity: .9;
    border-right: 5px solid transparent;
    border-left: 5px solid transparent;
    border-radius: 50px;
    box-shadow: 0 0 35px #2187e7;
    width: 50px;
    height: 50px;
    -moz-animation: spinPulse 1s infinite ease-in-out;
    -webkit-animation: spinPulse 1s infinite linear;
    margin: -25px 0 0 -25px;
    position: absolute;
    top: 50%;
    left: 50%;
  }
  .lmask:after {
    content: '';
    background-color: transparent;
    border: 5px solid rgba(0, 183, 229, 0.9);
    opacity: .9;
    border-left: 5px solid transparent;
    border-right: 5px solid transparent;
    border-radius: 50px;
    box-shadow: 0 0 15px #2187e7;
    width: 30px;
    height: 30px;
    -moz-animation: spinoffPulse 1s infinite linear;
    -webkit-animation: spinoffPulse 1s infinite linear;
    margin: -15px 0 0 -15px;
    position: absolute;
    top: 50%;
    left: 50%;
  }

  @-moz-keyframes spinPulse {
    0% {
      -moz-transform: rotate(160deg);
      opacity: 0;
      box-shadow: 0 0 1px #2187e7;
    }
    50% {
      -moz-transform: rotate(145deg);
      opacity: 1;
    }
    100% {
      -moz-transform: rotate(-320deg);
      opacity: 0;
    }
  }
  @-moz-keyframes spinoffPulse {
    0% {
      -moz-transform: rotate(0deg);
    }
    100% {
      -moz-transform: rotate(360deg);
    }
  }
  @-webkit-keyframes spinPulse {
    0% {
      -webkit-transform: rotate(160deg);
      opacity: 0;
      box-shadow: 0 0 1px #2187e7;
    }
    50% {
      -webkit-transform: rotate(145deg);
      opacity: 1;
    }
    100% {
      -webkit-transform: rotate(-320deg);
      opacity: 0;
    }
  }
  @-webkit-keyframes spinoffPulse {
    0% {
      -webkit-transform: rotate(0deg);
    }
    100% {
      -webkit-transform: rotate(360deg);
    }
  }

  `],
            },] },
];
/** @nocollapse */
HistogramChartComponent.ctorParameters = () => [
    { type: ChartLoaderService }
];
HistogramChartComponent.propDecorators = {
    width: [{ type: Input }],
    height: [{ type: Input }],
    data: [{ type: Input, args: ['data',] }],
    backgroundcolor: [{ type: Input, args: ['background-color',] }],
    chartLegendComp: [{ type: ContentChildren, args: [ChartLegendComponent,] }],
    chartTitleComp: [{ type: ContentChildren, args: [ChartTitleComponent,] }],
    chartAreaComp: [{ type: ContentChildren, args: [ChartAreaComponent,] }],
    histogramchart: [{ type: ViewChild, args: ['histogramchart',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 * Copyright 2016-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Author - Sagar Jadhav
 *
 */
/*
Component Name : Amexio line chart
Component Selector : <amexio-chart-line>
Component Description : A line chart that is rendered within the browser using SVG.
*/
class LineChartComponent {
    /**
     * @param {?} loader
     */
    constructor(loader) {
        this.loader = loader;
        this.width = '100%';
    }
    /**
     * @return {?}
     */
    get data() {
        return this._data;
    }
    /*
    Properties
    name : data
    datatype : any
    version : 4.0 onwards
    default : none
    description : For the use of local data
    */
    /**
     * @param {?} data
     * @return {?}
     */
    set data(data) {
        if (data) {
            this._data = data;
            this.showChart = true;
        }
        else {
            this.showChart = false;
        }
    }
    /**
     * @return {?}
     */
    drawChart() {
        if (this.showChart) {
            this.lineData = this.createTable(this._data);
            this.options = {
                title: this.chartTitleComponent ? this.chartTitleComponent.title : null,
                titleTextStyle: this.chartTitleComponent ? this.chartTitleTextStyle() : null,
                backgroundcolor: this.backgroundcolor,
                legend: this.chartLengendComponent ? this.chartLegendStyle() : 'none',
                chartArea: this.chartAreaComponent ? this.chartBackgroundStyle() : null,
            };
            if (this.lineData) {
                this.chart = new google.visualization.LineChart(this.linechart.nativeElement);
                this.hasLoaded = true;
                this.chart.draw(this.lineData, this.options);
                google.visualization.events.addListener(this.chart, 'click', this.onClick);
            }
        }
    }
    /**
     * @return {?}
     */
    chartTitleTextStyle() {
        return {
            color: this.chartTitleComponent.color ? this.chartTitleComponent.color : null,
            fontName: this.chartTitleComponent.fontname ? this.chartTitleComponent.fontname : null,
            fontsize: this.chartTitleComponent.fontsize ? this.chartTitleComponent.fontsize : null,
            bold: this.chartTitleComponent.bold ? this.chartTitleComponent.bold : null,
            italic: this.chartTitleComponent.italic ? this.chartTitleComponent.italic : null,
        };
    }
    /**
     * @return {?}
     */
    chartLegendStyle() {
        return {
            position: this.chartLengendComponent.position ? this.chartLengendComponent.position : null,
            // this work only in chart position is top
            maxLines: this.chartLengendComponent.maxlines ? this.chartLengendComponent.maxlines : null, textStyle: {
                color: this.chartLengendComponent.color ? this.chartLengendComponent.color : null,
                fontsize: this.chartLengendComponent.fontsize ? this.chartLengendComponent.fontsize : null,
                fontName: this.chartLengendComponent.fontname ? this.chartLengendComponent.fontname : null,
                bold: this.chartLengendComponent.bold ? this.chartLengendComponent.bold : null,
                alignment: this.chartLengendComponent.alignment ? this.chartLengendComponent.alignment : null,
            },
        };
    }
    /**
     * @return {?}
     */
    chartBackgroundStyle() {
        return {
            backgroundcolor: this.chartAreaComponent.chartbackgroundcolor ? this.chartAreaComponent.chartbackgroundcolor : null,
            left: this.chartAreaComponent.leftposition ? this.chartAreaComponent.leftposition : null,
            top: this.chartAreaComponent.topposition ? this.chartAreaComponent.topposition : null,
            height: this.chartAreaComponent.chartheight ? this.chartAreaComponent.chartheight : null,
            width: this.chartAreaComponent.chartwidth ? this.chartAreaComponent.chartwidth : null,
        };
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onClick(e) {
    }
    // after content init for inner directive is run
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.chartLegendArray = this.chartLegendComp.toArray();
        this.chartTitleArray = this.chartTitleComp.toArray();
        this.chartAreaArray = this.chartAreaComp.toArray();
        // take first component
        if (this.chartLegendArray.length === 1) {
            this.chartLengendComponent = this.chartLegendArray.pop();
        }
        if (this.chartTitleArray.length === 1) {
            this.chartTitleComponent = this.chartTitleArray.pop();
        }
        if (this.chartAreaArray.length === 1) {
            this.chartAreaComponent = this.chartAreaArray.pop();
        }
    }
    // This method create data table structure of array and return in required chart data
    /**
     * @param {?} array
     * @return {?}
     */
    createTable(array) {
        // create Duplicate Array for data arrangement
        /** @type {?} */
        const dupArray = array.slice();
        /** @type {?} */
        const data = new google.visualization.DataTable();
        /** @type {?} */
        const labelObject = dupArray[0];
        // remove first object of array
        dupArray.shift();
        labelObject.forEach((/**
         * @param {?} datatypeObject
         * @return {?}
         */
        (datatypeObject) => {
            data.addColumn(datatypeObject.datatype, datatypeObject.label);
        }));
        /** @type {?} */
        const finalArray = [];
        dupArray.forEach((/**
         * @param {?} rowObject
         * @return {?}
         */
        (rowObject) => {
            finalArray.push(rowObject);
        }));
        data.addRows(finalArray);
        return data;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.hasLoaded = false;
        this.loader.loadCharts('LineChart').subscribe((/**
         * @param {?} value
         * @return {?}
         */
        (value) => console.log()), (/**
         * @param {?} error
         * @return {?}
         */
        (error) => console.error(error)), (/**
         * @return {?}
         */
        () => {
            this.drawChart();
        }));
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onResize(event) {
        this.drawChart();
    }
}
LineChartComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-chart-line', template: `
    <div *ngIf="showChart" #linechart
         [style.width]="width"
         [style.height]="height"
         (window:resize)="onResize($event)">
      <div *ngIf="!hasLoaded" class="lmask">
      </div>
    </div>

  `, styles: [`.lmask {
    position: absolute;
    height: 100%;
    width: 100%;
    background-color: #000;
    bottom: 0;
    left: 0;
    right: 0;
    top: 0;
    z-index: 9999;
    opacity: 0.4;
  }

  .lmask.fixed {
    position: fixed;
  }

  .lmask:before {
    content: '';
    background-color: transparent;
    border: 5px solid rgba(0, 183, 229, 0.9);
    opacity: .9;
    border-right: 5px solid transparent;
    border-left: 5px solid transparent;
    border-radius: 50px;
    box-shadow: 0 0 35px #2187e7;
    width: 50px;
    height: 50px;
    -moz-animation: spinPulse 1s infinite ease-in-out;
    -webkit-animation: spinPulse 1s infinite linear;
    margin: -25px 0 0 -25px;
    position: absolute;
    top: 50%;
    left: 50%;
  }

  .lmask:after {
    content: '';
    background-color: transparent;
    border: 5px solid rgba(0, 183, 229, 0.9);
    opacity: .9;
    border-left: 5px solid transparent;
    border-right: 5px solid transparent;
    border-radius: 50px;
    box-shadow: 0 0 15px #2187e7;
    width: 30px;
    height: 30px;
    -moz-animation: spinoffPulse 1s infinite linear;
    -webkit-animation: spinoffPulse 1s infinite linear;
    margin: -15px 0 0 -15px;
    position: absolute;
    top: 50%;
    left: 50%;
  }

  @-moz-keyframes spinPulse {
    0% {
      -moz-transform: rotate(160deg);
      opacity: 0;
      box-shadow: 0 0 1px #2187e7;
    }
    50% {
      -moz-transform: rotate(145deg);
      opacity: 1;
    }
    100% {
      -moz-transform: rotate(-320deg);
      opacity: 0;
    }
  }

  @-moz-keyframes spinoffPulse {
    0% {
      -moz-transform: rotate(0deg);
    }
    100% {
      -moz-transform: rotate(360deg);
    }
  }

  @-webkit-keyframes spinPulse {
    0% {
      -webkit-transform: rotate(160deg);
      opacity: 0;
      box-shadow: 0 0 1px #2187e7;
    }
    50% {
      -webkit-transform: rotate(145deg);
      opacity: 1;
    }
    100% {
      -webkit-transform: rotate(-320deg);
      opacity: 0;
    }
  }

  @-webkit-keyframes spinoffPulse {
    0% {
      -webkit-transform: rotate(0deg);
    }
    100% {
      -webkit-transform: rotate(360deg);
    }
  }

  `],
            },] },
];
/** @nocollapse */
LineChartComponent.ctorParameters = () => [
    { type: ChartLoaderService }
];
LineChartComponent.propDecorators = {
    width: [{ type: Input }],
    height: [{ type: Input }],
    data: [{ type: Input, args: ['data',] }],
    backgroundcolor: [{ type: Input, args: ['background-color',] }],
    chartLegendComp: [{ type: ContentChildren, args: [ChartLegendComponent,] }],
    chartTitleComp: [{ type: ContentChildren, args: [ChartTitleComponent,] }],
    chartAreaComp: [{ type: ContentChildren, args: [ChartAreaComponent,] }],
    linechart: [{ type: ViewChild, args: ['linechart',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 * Copyright 2016-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Author - Sagar Jadhav
 *
 */
/*
Component Name : Amexio pie chart
Component Selector : <amexio-chart-pie>
Component Description : A pie chart that is rendered within the browser using SVG.
*/
class PieChartComponent {
    /**
     * @param {?} loader
     */
    constructor(loader) {
        this.loader = loader;
        this.width = '100%';
    }
    /**
     * @return {?}
     */
    get data() {
        return this._data;
    }
    /*
    Properties
    name : data
    datatype : any
    version : 4.0 onwards
    default : none
    description : sets the pie hole size
    */
    /**
     * @param {?} data
     * @return {?}
     */
    set data(data) {
        if (data) {
            this._data = data;
            this.showChart = true;
        }
        else {
            this.showChart = false;
        }
    }
    /**
     * @return {?}
     */
    drawChart() {
        if (this.showChart) {
            this.pieData = google.visualization.arrayToDataTable(this._data);
            this.options = {
                title: this.chartTitleComponent ? this.chartTitleComponent.title : null,
                titleTextStyle: this.chartTitleComponent ? this.charttitleTextStyle() : null,
                is3D: this.is3d,
                pieHole: this.piehole,
                startangle: this.startangle,
                backgroundcolor: this.backgroundcolor,
                legend: this.chartLengendComponent ? this.chartLengendStyle() : 'none',
                chartArea: this.chartAreaComponent ? this.chartBackgroundStyle() : null,
            };
            if (this.pieData) {
                this.chart = new google.visualization.PieChart(this.piechart.nativeElement);
                this.hasLoaded = true;
                this.chart.draw(this.pieData, this.options);
                google.visualization.events.addListener(this.chart, 'click', this.onClick);
            }
        }
    }
    /**
     * @return {?}
     */
    charttitleTextStyle() {
        return {
            color: this.chartTitleComponent.color ? this.chartTitleComponent.color : null,
            fontName: this.chartTitleComponent.fontname ? this.chartTitleComponent.fontname : null,
            fontsize: this.chartTitleComponent.fontsize ? this.chartTitleComponent.fontsize : null,
            bold: this.chartTitleComponent.bold ? this.chartTitleComponent.bold : null,
            italic: this.chartTitleComponent.italic ? this.chartTitleComponent.italic : null,
        };
    }
    /**
     * @return {?}
     */
    chartLengendStyle() {
        return {
            position: this.chartLengendComponent.position ? this.chartLengendComponent.position : null,
            // this work only in chart position is top
            maxLines: this.chartLengendComponent.maxlines ? this.chartLengendComponent.maxlines : null,
            textStyle: {
                color: this.chartLengendComponent.color ? this.chartLengendComponent.color : null,
                fontsize: this.chartLengendComponent.fontsize ? this.chartLengendComponent.fontsize : null,
                fontName: this.chartLengendComponent.fontname ? this.chartLengendComponent.fontname : null,
                bold: this.chartLengendComponent.bold ? this.chartLengendComponent.bold : null,
                alignment: this.chartLengendComponent.alignment ? this.chartLengendComponent.alignment : null,
            },
        };
    }
    /**
     * @return {?}
     */
    chartBackgroundStyle() {
        return {
            backgroundcolor: this.chartAreaComponent.chartbackgroundcolor ? this.chartAreaComponent.chartbackgroundcolor : null,
            left: this.chartAreaComponent.leftposition ? this.chartAreaComponent.leftposition : null,
            top: this.chartAreaComponent.topposition ? this.chartAreaComponent.topposition : null,
            height: this.chartAreaComponent.chartheight ? this.chartAreaComponent.chartheight : null,
            width: this.chartAreaComponent.chartwidth ? this.chartAreaComponent.chartwidth : null,
        };
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onClick(e) {
    }
    // after content init for inner directive is run
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.chartLegendArray = this.chartLegendComp.toArray();
        this.chartTitleArray = this.chartTitleComp.toArray();
        this.chartAreaArray = this.chartAreaComp.toArray();
        // take first component
        if (this.chartLegendArray.length === 1) {
            this.chartLengendComponent = this.chartLegendArray.pop();
        }
        if (this.chartTitleArray.length === 1) {
            this.chartTitleComponent = this.chartTitleArray.pop();
        }
        if (this.chartAreaArray.length === 1) {
            this.chartAreaComponent = this.chartAreaArray.pop();
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.hasLoaded = false;
        this.loader.loadCharts('PieChart').subscribe((/**
         * @param {?} value
         * @return {?}
         */
        (value) => console.log()), (/**
         * @param {?} error
         * @return {?}
         */
        (error) => console.error(error)), (/**
         * @return {?}
         */
        () => {
            this.drawChart();
        }));
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onResize(event) {
        this.drawChart();
    }
}
PieChartComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-chart-pie', template: `

        <div *ngIf="showChart" #piechart
             [style.width]="width"
             [style.height]="height"
             (window:resize)="onResize($event)">
          <div *ngIf="!hasLoaded" class="lmask">
          </div>
        </div>
  `,
                styles: [`.lmask {
    position: absolute;
    height: 100%;
    width: 100%;
    background-color: #000;
    bottom: 0;
    left: 0;
    right: 0;
    top: 0;
    z-index: 9999;
    opacity: 0.4;
  }
  .lmask.fixed {
    position: fixed;
  }
  .lmask:before {
    content: '';
    background-color: transparent;
    border: 5px solid rgba(0, 183, 229, 0.9);
    opacity: .9;
    border-right: 5px solid transparent;
    border-left: 5px solid transparent;
    border-radius: 50px;
    box-shadow: 0 0 35px #2187e7;
    width: 50px;
    height: 50px;
    -moz-animation: spinPulse 1s infinite ease-in-out;
    -webkit-animation: spinPulse 1s infinite linear;
    margin: -25px 0 0 -25px;
    position: absolute;
    top: 50%;
    left: 50%;
  }
  .lmask:after {
    content: '';
    background-color: transparent;
    border: 5px solid rgba(0, 183, 229, 0.9);
    opacity: .9;
    border-left: 5px solid transparent;
    border-right: 5px solid transparent;
    border-radius: 50px;
    box-shadow: 0 0 15px #2187e7;
    width: 30px;
    height: 30px;
    -moz-animation: spinoffPulse 1s infinite linear;
    -webkit-animation: spinoffPulse 1s infinite linear;
    margin: -15px 0 0 -15px;
    position: absolute;
    top: 50%;
    left: 50%;
  }

  @-moz-keyframes spinPulse {
    0% {
      -moz-transform: rotate(160deg);
      opacity: 0;
      box-shadow: 0 0 1px #2187e7;
    }
    50% {
      -moz-transform: rotate(145deg);
      opacity: 1;
    }
    100% {
      -moz-transform: rotate(-320deg);
      opacity: 0;
    }
  }
  @-moz-keyframes spinoffPulse {
    0% {
      -moz-transform: rotate(0deg);
    }
    100% {
      -moz-transform: rotate(360deg);
    }
  }
  @-webkit-keyframes spinPulse {
    0% {
      -webkit-transform: rotate(160deg);
      opacity: 0;
      box-shadow: 0 0 1px #2187e7;
    }
    50% {
      -webkit-transform: rotate(145deg);
      opacity: 1;
    }
    100% {
      -webkit-transform: rotate(-320deg);
      opacity: 0;
    }
  }
  @-webkit-keyframes spinoffPulse {
    0% {
      -webkit-transform: rotate(0deg);
    }
    100% {
      -webkit-transform: rotate(360deg);
    }
  }

  `],
            },] },
];
/** @nocollapse */
PieChartComponent.ctorParameters = () => [
    { type: ChartLoaderService }
];
PieChartComponent.propDecorators = {
    width: [{ type: Input }],
    height: [{ type: Input }],
    is3d: [{ type: Input }],
    piehole: [{ type: Input }],
    data: [{ type: Input, args: ['data',] }],
    startangle: [{ type: Input, args: ['start-angle',] }],
    backgroundcolor: [{ type: Input, args: ['background-color',] }],
    chartLegendComp: [{ type: ContentChildren, args: [ChartLegendComponent,] }],
    chartTitleComp: [{ type: ContentChildren, args: [ChartTitleComponent,] }],
    chartAreaComp: [{ type: ContentChildren, args: [ChartAreaComponent,] }],
    piechart: [{ type: ViewChild, args: ['piechart',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 * Copyright 2016-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Author - Sagar Jadhav
 *
 */
/*
Component Name : Amexio scatter chart
Component Selector : <amexio-chart-scatter>
Component Description : Scatter charts plot points on a graph.
When the user hovers over the points, tooltips are displayed with more information.
*/
class ScatterChartComponent {
    /**
     * @param {?} loader
     */
    constructor(loader) {
        this.loader = loader;
        this.width = '100%';
    }
    /**
     * @return {?}
     */
    get data() {
        return this._data;
    }
    /*
    Properties
    name : data
    datatype : any
    version : 4.0 onwards
    default : none
    description : For the use of local data
    */
    /**
     * @param {?} data
     * @return {?}
     */
    set data(data) {
        if (data) {
            this._data = data;
            this.showChart = true;
        }
        else {
            this.showChart = false;
        }
    }
    /**
     * @return {?}
     */
    drawChart() {
        if (this.showChart) {
            this.scatterData = google.visualization.arrayToDataTable(this._data);
            this.options = {
                title: this.chartTitleComponent ? this.chartTitleComponent.title : null,
                titleTextStyle: this.chartTitleComponent ? this.chartTitleTextStyle() : null,
                backgroundcolor: this.backgroundcolor,
                legend: this.chartLengendComponent ? this.chartLegendStyle() : 'none',
                chartArea: this.chartAreaComponent ? this.chartBackgroundColor() : null,
                vAxis: this.verticalComponent ? this.chartVerticalStyle() : null,
                hAxis: this.horizontalComponent ? this.chartHorizontalStyle() : null,
            };
            if (this.scatterData) {
                this.chart = new google.visualization.ScatterChart(this.scatterchart.nativeElement);
                this.hasLoaded = true;
                this.chart.draw(this.scatterData, this.options);
                google.visualization.events.addListener(this.chart, 'click', this.click);
            }
        }
    }
    /**
     * @return {?}
     */
    chartTitleTextStyle() {
        return {
            color: this.chartTitleComponent.color ? this.chartTitleComponent.color : null,
            fontName: this.chartTitleComponent.fontname ? this.chartTitleComponent.fontname : null,
            fontsize: this.chartTitleComponent.fontsize ? this.chartTitleComponent.fontsize : null,
            bold: this.chartTitleComponent.bold ? this.chartTitleComponent.bold : null,
            italic: this.chartTitleComponent.italic ? this.chartTitleComponent.italic : null,
        };
    }
    /**
     * @return {?}
     */
    chartLegendStyle() {
        return {
            position: this.chartLengendComponent.position ? this.chartLengendComponent.position : null,
            // this work only in chart position is top
            maxLines: this.chartLengendComponent.maxlines ? this.chartLengendComponent.maxlines : null, textStyle: {
                color: this.chartLengendComponent.color ? this.chartLengendComponent.color : null,
                fontsize: this.chartLengendComponent.fontsize ? this.chartLengendComponent.fontsize : null,
                fontName: this.chartLengendComponent.fontname ? this.chartLengendComponent.fontname : null,
                bold: this.chartLengendComponent.bold ? this.chartLengendComponent.bold : null,
                alignment: this.chartLengendComponent.alignment ? this.chartLengendComponent.alignment : null,
            },
        };
    }
    /**
     * @return {?}
     */
    chartBackgroundColor() {
        return {
            backgroundcolor: this.chartAreaComponent.chartbackgroundcolor ? this.chartAreaComponent.chartbackgroundcolor : null,
            left: this.chartAreaComponent.leftposition ? this.chartAreaComponent.leftposition : null,
            top: this.chartAreaComponent.topposition ? this.chartAreaComponent.topposition : null,
            height: this.chartAreaComponent.chartheight ? this.chartAreaComponent.chartheight : null,
            width: this.chartAreaComponent.chartwidth ? this.chartAreaComponent.chartwidth : null,
        };
    }
    /**
     * @return {?}
     */
    chartVerticalStyle() {
        return {
            title: this.verticalComponent.title ? this.verticalComponent.title : null,
            titleTextStyle: { color: this.verticalComponent.titlecolor ? this.verticalComponent.titlecolor : null },
        };
    }
    /**
     * @return {?}
     */
    chartHorizontalStyle() {
        return {
            title: this.horizontalComponent.title ? this.horizontalComponent.title : null,
            titleTextStyle: { color: this.horizontalComponent.titlecolor ? this.horizontalComponent.titlecolor : null },
        };
    }
    /**
     * @param {?} e
     * @return {?}
     */
    click(e) {
    }
    // after content init for inner directive is run
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.chartLegendArray = this.chartLegendComp.toArray();
        this.chartTitleArray = this.chartTitleComp.toArray();
        this.chartAreaArray = this.chartAreaComp.toArray();
        this.horizontalArray = this.horizontalComp.toArray();
        this.verticalArray = this.verticalComp.toArray();
        // take first component
        if (this.chartLegendArray.length === 1) {
            this.chartLengendComponent = this.chartLegendArray.pop();
        }
        if (this.chartTitleArray.length === 1) {
            this.chartTitleComponent = this.chartTitleArray.pop();
        }
        if (this.chartAreaArray.length === 1) {
            this.chartAreaComponent = this.chartAreaArray.pop();
        }
        if (this.horizontalArray.length === 1) {
            this.horizontalComponent = this.horizontalArray.pop();
        }
        if (this.verticalArray.length === 1) {
            this.verticalComponent = this.verticalArray.pop();
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.hasLoaded = false;
        this.loader.loadCharts('ScatterChart').subscribe((/**
         * @param {?} value
         * @return {?}
         */
        (value) => console.log()), (/**
         * @param {?} error
         * @return {?}
         */
        (error) => console.error(error)), (/**
         * @return {?}
         */
        () => {
            this.drawChart();
        }));
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onResize(event) {
        this.drawChart();
    }
}
ScatterChartComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-chart-scatter', template: `
    <div *ngIf="showChart" #scatterchart
         [style.width]="width"
         [style.height]="height" (window:resize)="onResize($event)">
      <div *ngIf="!hasLoaded" class="lmask">
      </div>
    </div>
  `, styles: [`.lmask {
    position: absolute;
    height: 100%;
    width: 100%;
    background-color: #000;
    bottom: 0;
    left: 0;
    right: 0;
    top: 0;
    z-index: 9999;
    opacity: 0.4;
  }

  .lmask.fixed {
    position: fixed;
  }

  .lmask:before {
    content: '';
    background-color: transparent;
    border: 5px solid rgba(0, 183, 229, 0.9);
    opacity: .9;
    border-right: 5px solid transparent;
    border-left: 5px solid transparent;
    border-radius: 50px;
    box-shadow: 0 0 35px #2187e7;
    width: 50px;
    height: 50px;
    -moz-animation: spinPulse 1s infinite ease-in-out;
    -webkit-animation: spinPulse 1s infinite linear;
    margin: -25px 0 0 -25px;
    position: absolute;
    top: 50%;
    left: 50%;
  }

  .lmask:after {
    content: '';
    background-color: transparent;
    border: 5px solid rgba(0, 183, 229, 0.9);
    opacity: .9;
    border-left: 5px solid transparent;
    border-right: 5px solid transparent;
    border-radius: 50px;
    box-shadow: 0 0 15px #2187e7;
    width: 30px;
    height: 30px;
    -moz-animation: spinoffPulse 1s infinite linear;
    -webkit-animation: spinoffPulse 1s infinite linear;
    margin: -15px 0 0 -15px;
    position: absolute;
    top: 50%;
    left: 50%;
  }

  @-moz-keyframes spinPulse {
    0% {
      -moz-transform: rotate(160deg);
      opacity: 0;
      box-shadow: 0 0 1px #2187e7;
    }
    50% {
      -moz-transform: rotate(145deg);
      opacity: 1;
    }
    100% {
      -moz-transform: rotate(-320deg);
      opacity: 0;
    }
  }

  @-moz-keyframes spinoffPulse {
    0% {
      -moz-transform: rotate(0deg);
    }
    100% {
      -moz-transform: rotate(360deg);
    }
  }

  @-webkit-keyframes spinPulse {
    0% {
      -webkit-transform: rotate(160deg);
      opacity: 0;
      box-shadow: 0 0 1px #2187e7;
    }
    50% {
      -webkit-transform: rotate(145deg);
      opacity: 1;
    }
    100% {
      -webkit-transform: rotate(-320deg);
      opacity: 0;
    }
  }

  @-webkit-keyframes spinoffPulse {
    0% {
      -webkit-transform: rotate(0deg);
    }
    100% {
      -webkit-transform: rotate(360deg);
    }
  }

  `],
            },] },
];
/** @nocollapse */
ScatterChartComponent.ctorParameters = () => [
    { type: ChartLoaderService }
];
ScatterChartComponent.propDecorators = {
    width: [{ type: Input }],
    height: [{ type: Input }],
    data: [{ type: Input, args: ['data',] }],
    backgroundcolor: [{ type: Input, args: ['background-color',] }],
    chartLegendComp: [{ type: ContentChildren, args: [ChartLegendComponent,] }],
    chartTitleComp: [{ type: ContentChildren, args: [ChartTitleComponent,] }],
    chartAreaComp: [{ type: ContentChildren, args: [ChartAreaComponent,] }],
    horizontalComp: [{ type: ContentChildren, args: [HorizontalAxisComponent,] }],
    verticalComp: [{ type: ContentChildren, args: [VerticalAxisComponent,] }],
    scatterchart: [{ type: ViewChild, args: ['scatterchart',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
 * Copyright 2016-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Author - Sagar Jadhav
 *
 */
/*
Component Name : Amexio timeline chart
Component Selector : <amexio-chart-timeline>
Component Description : A timeline is a chart that depicts how a set of resources are used over time.
*/
class TimeLineChartComponent {
    /**
     * @param {?} loader
     */
    constructor(loader) {
        this.loader = loader;
        this.width = '100%';
    }
    /**
     * @return {?}
     */
    get data() {
        return this._data;
    }
    /*
      Properties
      name : data
      datatype : any
      version : 4.0 onwards
      default : none
      description : For the use of local data
      */
    /**
     * @param {?} data
     * @return {?}
     */
    set data(data) {
        if (data) {
            this._data = data;
            this.showChart = true;
        }
        else {
            this.showChart = false;
        }
    }
    /**
     * @return {?}
     */
    drawChart() {
        if (this.data && this.showChart) {
            this.chart = new google.visualization.Timeline(this.timelinechart.nativeElement);
            this.hasLoaded = true;
            this.chart.draw(this.createTable(this._data));
            google.visualization.events.addListener(this.chart, 'click', this.onClick);
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    onClick(e) {
    }
    // after content init for inner directive is run
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.chartLegendArray = this.chartLegendComp.toArray();
        this.chartTitleArray = this.chartTitleComp.toArray();
        this.chartAreaArray = this.chartAreaComp.toArray();
        // take first component
        if (this.chartLegendArray.length === 1) {
            this.chartLengendComponent = this.chartLegendArray.pop();
        }
        if (this.chartTitleArray.length === 1) {
            this.chartTitleComponent = this.chartTitleArray.pop();
        }
        if (this.chartAreaArray.length === 1) {
            this.chartAreaComponent = this.chartAreaArray.pop();
        }
    }
    // This method create data table structure of array and return in required chart data
    /**
     * @param {?} array
     * @return {?}
     */
    createTable(array) {
        // create Duplicate Array for data arrangement
        /** @type {?} */
        const dupArray = array.slice();
        /** @type {?} */
        const data = new google.visualization.DataTable();
        /** @type {?} */
        const labelObject = dupArray[0];
        // remove first object of array
        dupArray.shift();
        labelObject.forEach((/**
         * @param {?} datatypeObject
         * @return {?}
         */
        (datatypeObject) => {
            data.addColumn(datatypeObject.datatype, datatypeObject.label);
        }));
        /** @type {?} */
        const finalArray = [];
        dupArray.forEach((/**
         * @param {?} rowObject
         * @return {?}
         */
        (rowObject) => {
            finalArray.push(rowObject);
        }));
        data.addRows(finalArray);
        return data;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.hasLoaded = false;
        this.loader.loadCharts('Timeline').subscribe((/**
         * @param {?} value
         * @return {?}
         */
        (value) => console.log()), (/**
         * @param {?} error
         * @return {?}
         */
        (error) => console.error(error)), (/**
         * @return {?}
         */
        () => {
            this.drawChart();
        }));
    }
}
TimeLineChartComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-chart-timeline', template: `
    <div *ngIf="showChart" #timelinechart
         [style.width]="width"
    >
      <div *ngIf="!hasLoaded" class="lmask">
      </div>
    </div>
  `, styles: [`.lmask {
    position: absolute;
    height: 100%;
    width: 100%;
    background-color: #000;
    bottom: 0;
    left: 0;
    right: 0;
    top: 0;
    z-index: 9999;
    opacity: 0.4;
  }

  .lmask.fixed {
    position: fixed;
  }

  .lmask:before {
    content: '';
    background-color: transparent;
    border: 5px solid rgba(0, 183, 229, 0.9);
    opacity: .9;
    border-right: 5px solid transparent;
    border-left: 5px solid transparent;
    border-radius: 50px;
    box-shadow: 0 0 35px #2187e7;
    width: 50px;
    height: 50px;
    -moz-animation: spinPulse 1s infinite ease-in-out;
    -webkit-animation: spinPulse 1s infinite linear;
    margin: -25px 0 0 -25px;
    position: absolute;
    top: 50%;
    left: 50%;
  }

  .lmask:after {
    content: '';
    background-color: transparent;
    border: 5px solid rgba(0, 183, 229, 0.9);
    opacity: .9;
    border-left: 5px solid transparent;
    border-right: 5px solid transparent;
    border-radius: 50px;
    box-shadow: 0 0 15px #2187e7;
    width: 30px;
    height: 30px;
    -moz-animation: spinoffPulse 1s infinite linear;
    -webkit-animation: spinoffPulse 1s infinite linear;
    margin: -15px 0 0 -15px;
    position: absolute;
    top: 50%;
    left: 50%;
  }

  @-moz-keyframes spinPulse {
    0% {
      -moz-transform: rotate(160deg);
      opacity: 0;
      box-shadow: 0 0 1px #2187e7;
    }
    50% {
      -moz-transform: rotate(145deg);
      opacity: 1;
    }
    100% {
      -moz-transform: rotate(-320deg);
      opacity: 0;
    }
  }

  @-moz-keyframes spinoffPulse {
    0% {
      -moz-transform: rotate(0deg);
    }
    100% {
      -moz-transform: rotate(360deg);
    }
  }

  @-webkit-keyframes spinPulse {
    0% {
      -webkit-transform: rotate(160deg);
      opacity: 0;
      box-shadow: 0 0 1px #2187e7;
    }
    50% {
      -webkit-transform: rotate(145deg);
      opacity: 1;
    }
    100% {
      -webkit-transform: rotate(-320deg);
      opacity: 0;
    }
  }

  @-webkit-keyframes spinoffPulse {
    0% {
      -webkit-transform: rotate(0deg);
    }
    100% {
      -webkit-transform: rotate(360deg);
    }
  }

  `],
            },] },
];
/** @nocollapse */
TimeLineChartComponent.ctorParameters = () => [
    { type: ChartLoaderService }
];
TimeLineChartComponent.propDecorators = {
    width: [{ type: Input }],
    data: [{ type: Input, args: ['data',] }],
    chartLegendComp: [{ type: ContentChildren, args: [ChartLegendComponent,] }],
    chartTitleComp: [{ type: ContentChildren, args: [ChartTitleComponent,] }],
    chartAreaComp: [{ type: ContentChildren, args: [ChartAreaComponent,] }],
    timelinechart: [{ type: ViewChild, args: ['timelinechart',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const CHART_COMPONENTS = [
    AreaChartComponent, BarChartComponent, ChartAreaComponent,
    ChartLegendComponent, ChartTitleComponent, ColumnChartComponent,
    DonutChartComponent, GanttChartComponent, HistogramChartComponent, LineChartComponent,
    PieChartComponent, TimeLineChartComponent, ComboChartComponent,
    VerticalAxisComponent,
    HorizontalAxisComponent,
    BubbleChartComponent,
    ScatterChartComponent, CandlestickChartComponent, CandlestickWaterfallChartComponent,
];
class AmexioChartsModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: AmexioChartsModule,
            providers: [CommonDataService, ChartLoaderService],
        };
    }
}
AmexioChartsModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    FormsModule,
                    HttpClientModule,
                    AmexioCommonModule,
                ],
                exports: CHART_COMPONENTS,
                declarations: CHART_COMPONENTS,
                providers: [CommonDataService, ChartLoaderService],
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*  Created by pratik on 17/8/17.
*/
class MapLoaderService {
    constructor() {
        this.chartPackage = {
            AreaChart: 'corechart',
            Bar: 'bar',
            BarChart: 'corechart',
            ColumnChart: 'corechart',
            PieChart: 'corechart',
            Gantt: 'gantt',
            Gauge: 'gauge',
            GeoChart: 'geochart',
            Histogram: 'corechart',
            Line: 'line',
            LineChart: 'corechart',
            Map: 'map',
            Timeline: 'timeline',
            BubbleChart: 'corechart',
            CandlestickChart: 'corechart',
            ComboChart: 'corechart',
            TreeMap: 'treemap',
        };
        this.googleScriptLoadingNotifier = new EventEmitter();
        this.isScriptLoading = false;
    }
    /**
     * @param {?} chartName
     * @return {?}
     */
    loadCharts(chartName) {
        return new rxjs_1((/**
         * @param {?} observer
         * @return {?}
         */
        (observer) => {
            this.loadScript().subscribe((/**
             * @param {?} val
             * @return {?}
             */
            (val) => console.log()), (/**
             * @param {?} error
             * @return {?}
             */
            (error) => console.error(error)), (/**
             * @return {?}
             */
            () => {
                this.loadRequiredChart(observer, chartName);
            }));
        }));
    }
    /**
     * @return {?}
     */
    loadScript() {
        return new rxjs_1((/**
         * @param {?} observer
         * @return {?}
         */
        (observer) => {
            if (!this.isScriptLoading) {
                // check if previously its loaded
                if (typeof google !== 'undefined' && google.charts) {
                    // check if chart package has been loaded using chartPackagename ?
                    this.loadBaseChart(observer);
                }
                else {
                    this.isScriptLoading = true;
                    /** @type {?} */
                    const script = document.createElement('script');
                    script.type = 'text/javascript';
                    script.src = 'https://www.gstatic.com/charts/loader.js';
                    script.async = true;
                    script.defer = true;
                    script.onload = (/**
                     * @return {?}
                     */
                    () => {
                        this.isScriptLoading = false;
                        this.googleScriptLoadingNotifier.emit(true);
                        this.loadBaseChart(observer);
                    });
                    script.onerror = (/**
                     * @return {?}
                     */
                    () => {
                        observer.error('Could Not Load google Script');
                    });
                    document.getElementsByTagName('head')[0].appendChild(script);
                }
            }
            else {
                this.googleScriptLoadingNotifier.subscribe((/**
                 * @param {?} loaded
                 * @return {?}
                 */
                (loaded) => {
                    if (loaded) {
                        this.loadBaseChart(observer);
                    }
                }));
            }
        }));
    }
    /**
     *  Load Base Chart
     * @param {?} observer
     * @return {?}
     */
    loadBaseChart(observer) {
        google.charts.load('current', { packages: ['corechart'] });
        google.charts.setOnLoadCallback((/**
         * @return {?}
         */
        () => {
            observer.complete();
        }));
    }
    /**
     *  Load the required charts
     * @param {?} observer
     * @param {?} chartName
     * @return {?}
     */
    loadRequiredChart(observer, chartName) {
        if (google.visualization.hasOwnProperty(chartName)) {
            observer.complete();
        }
        else {
            google.charts.load('current', { packages: [this.chartPackage[chartName]] });
            google.charts.setOnLoadCallback((/**
             * @return {?}
             */
            () => {
                observer.complete();
            }));
        }
    }
}
MapLoaderService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
MapLoaderService.ctorParameters = () => [];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*  Created by Sagar.
*/
class MapPropertiesComponent {
    constructor() {
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
}
MapPropertiesComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-map-properties', template: ``,
            },] },
];
/** @nocollapse */
MapPropertiesComponent.ctorParameters = () => [];
MapPropertiesComponent.propDecorators = {
    chartbackgroundcolor: [{ type: Input, args: ['chart-background-color',] }],
    leftposition: [{ type: Input, args: ['left-position',] }],
    topposition: [{ type: Input, args: ['top-position',] }],
    chartwidth: [{ type: Input, args: ['chart-width',] }],
    chartheight: [{ type: Input, args: ['chart-height',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*  Created by Sagar on 10/8/17..
*/
class GeoChartComponent {
    /**
     * @param {?} loader
     */
    constructor(loader) {
        this.loader = loader;
        /*
          not in use
        */
        this.countryname = false;
        this.width = '100%';
    }
    /**
     * @return {?}
     */
    get data() {
        return this._data;
    }
    /**
     * @param {?} data
     * @return {?}
     */
    set data(data) {
        if (data) {
            this._data = data;
            this.showChart = true;
        }
        else {
            this.showChart = false;
        }
    }
    /**
     * @return {?}
     */
    drawChart() {
        if (this.showChart) {
            this.geomapData = google.visualization.arrayToDataTable(this._data);
            this.showChartExist();
            if (this.geomapData) {
                this.chart = new google.visualization.GeoChart(this.geochart.nativeElement);
                this.hasLoaded = true;
                this.chart.draw(this.geomapData, this.options);
                google.visualization.events.addListener(this.chart, 'click', this.click);
            }
        }
    }
    /**
     * @return {?}
     */
    showChartExist() {
        this.options = {
            displayMode: this.countryname ? 'text' : null,
            region: this.regioncode ? this.regioncode : null,
            backgroundcolor: this.backgroundcolor ? this.backgroundcolor : null,
            unusedregioncolor: this.unusedregioncolor ? this.unusedregioncolor : null,
            chartArea: this.chartAreaComponent ? {
                backgroundcolor: this.chartAreaComponent.chartbackgroundcolor ? this.chartAreaComponent.chartbackgroundcolor : null,
                left: this.chartAreaComponent.leftposition ? this.chartAreaComponent.leftposition : null,
                top: this.chartAreaComponent.topposition ? this.chartAreaComponent.topposition : null,
                height: this.chartAreaComponent.chartheight ? this.chartAreaComponent.chartheight : null,
                width: this.chartAreaComponent.chartwidth ? this.chartAreaComponent.chartwidth : null,
            } : null,
        };
    }
    /**
     * @param {?} e
     * @return {?}
     */
    click(e) {
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.chartAreaArray = this.chartAreaComp.toArray();
        if (this.chartAreaArray.length === 1) {
            this.chartAreaComponent = this.chartAreaArray.pop();
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.hasLoaded = false;
        this.loader.loadCharts('GeoChart').subscribe((/**
         * @param {?} value
         * @return {?}
         */
        (value) => console.log()), (/**
         * @param {?} errror
         * @return {?}
         */
        (errror) => console.error(errror)), (/**
         * @return {?}
         */
        () => {
            this.drawChart();
        }));
    }
}
GeoChartComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-map-geo-chart', template: `
    <div *ngIf="showChart" #geochart
         [style.width]="width"
         [style.height]="height"
    >
      <div *ngIf="!hasLoaded" class="lmask">
      </div>
    </div>
  `, styles: [`.lmask {
    position: absolute;
    height: 100%;
    width: 100%;
    background-color: #000;
    bottom: 0;
    left: 0;
    right: 0;
    top: 0;
    z-index: 9999;
    opacity: 0.4;
  }

  .lmask.fixed {
    position: fixed;
  }

  .lmask:before {
    content: '';
    background-color: transparent;
    border: 5px solid rgba(0, 183, 229, 0.9);
    opacity: .9;
    border-right: 5px solid transparent;
    border-left: 5px solid transparent;
    border-radius: 50px;
    box-shadow: 0 0 35px #2187e7;
    width: 50px;
    height: 50px;
    -moz-animation: spinPulse 1s infinite ease-in-out;
    -webkit-animation: spinPulse 1s infinite linear;
    margin: -25px 0 0 -25px;
    position: absolute;
    top: 50%;
    left: 50%;
  }

  .lmask:after {
    content: '';
    background-color: transparent;
    border: 5px solid rgba(0, 183, 229, 0.9);
    opacity: .9;
    border-left: 5px solid transparent;
    border-right: 5px solid transparent;
    border-radius: 50px;
    box-shadow: 0 0 15px #2187e7;
    width: 30px;
    height: 30px;
    -moz-animation: spinoffPulse 1s infinite linear;
    -webkit-animation: spinoffPulse 1s infinite linear;
    margin: -15px 0 0 -15px;
    position: absolute;
    top: 50%;
    left: 50%;
  }

  @-moz-keyframes spinPulse {
    0% {
      -moz-transform: rotate(160deg);
      opacity: 0;
      box-shadow: 0 0 1px #2187e7;
    }
    50% {
      -moz-transform: rotate(145deg);
      opacity: 1;
    }
    100% {
      -moz-transform: rotate(-320deg);
      opacity: 0;
    }
  }

  @-moz-keyframes spinoffPulse {
    0% {
      -moz-transform: rotate(0deg);
    }
    100% {
      -moz-transform: rotate(360deg);
    }
  }

  @-webkit-keyframes spinPulse {
    0% {
      -webkit-transform: rotate(160deg);
      opacity: 0;
      box-shadow: 0 0 1px #2187e7;
    }
    50% {
      -webkit-transform: rotate(145deg);
      opacity: 1;
    }
    100% {
      -webkit-transform: rotate(-320deg);
      opacity: 0;
    }
  }

  @-webkit-keyframes spinoffPulse {
    0% {
      -webkit-transform: rotate(0deg);
    }
    100% {
      -webkit-transform: rotate(360deg);
    }
  }
`],
            },] },
];
/** @nocollapse */
GeoChartComponent.ctorParameters = () => [
    { type: MapLoaderService }
];
GeoChartComponent.propDecorators = {
    width: [{ type: Input }],
    height: [{ type: Input }],
    data: [{ type: Input, args: ['data',] }],
    countryname: [{ type: Input, args: ['country-name',] }],
    regioncode: [{ type: Input, args: ['region-code',] }],
    backgroundcolor: [{ type: Input, args: ['background-color',] }],
    unusedregioncolor: [{ type: Input, args: ['unused-region-color',] }],
    chartAreaComp: [{ type: ContentChildren, args: [MapPropertiesComponent,] }],
    geochart: [{ type: ViewChild, args: ['geochart',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*  Created by Sagar.
*/
class MapTitleComponent {
    constructor() {
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
}
MapTitleComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-map-title', template: ` `,
            },] },
];
/** @nocollapse */
MapTitleComponent.ctorParameters = () => [];
MapTitleComponent.propDecorators = {
    title: [{ type: Input }],
    position: [{ type: Input }],
    color: [{ type: Input }],
    fontname: [{ type: Input, args: ['font-name',] }],
    bold: [{ type: Input }],
    italic: [{ type: Input }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*  Created by sagar on 18/8/17.
*/
class TreeMapComponent {
    /**
     * @param {?} loader
     */
    constructor(loader) {
        this.loader = loader;
        this.onClick = new EventEmitter();
        this.width = '100%';
    }
    /**
     * @return {?}
     */
    get data() {
        return this._data;
    }
    /*
      Properties
      name : data
      datatype : any
      version : 4.0 onwards
      default : none
      description : Local data for TreeMap.
      */
    /**
     * @param {?} data
     * @return {?}
     */
    set data(data) {
        if (data) {
            this._data = data;
            this.showChart = true;
        }
        else {
            this.showChart = false;
        }
    }
    /**
     * @return {?}
     */
    drawChart() {
        /** @type {?} */
        let chart;
        /** @type {?} */
        const localData = this._data;
        if (this.showChart) {
            this.treemapData = google.visualization.arrayToDataTable(this._data);
            this.initializeOptions();
            if (this.treemapData) {
                chart = new google.visualization.TreeMap(this.treemapmap.nativeElement);
                this.hasLoaded = true;
                chart.draw(this.treemapData, this.options);
                google.visualization.events.addListener(chart, 'select', (/**
                 * @param {?} eve
                 * @param {?} event
                 * @return {?}
                 */
                (eve, event) => {
                    localData.forEach((/**
                     * @param {?} element
                     * @param {?} index
                     * @return {?}
                     */
                    (element, index) => {
                        if ((chart.getSelection())[0].row + 1 === index) {
                            this.onClick.emit(element);
                        }
                    }));
                }));
            }
        }
    }
    /**
     * @return {?}
     */
    initializeOptions() {
        this.options = {
            title: this.mapTitleComponent ? this.mapTitleComponent.title : null,
            titleTextStyle: this.mapTitleComponent ? this.mapTitleTextStyle() : null,
            mincolor: this.mincolor ? this.mincolor : null, midcolor: this.midcolor ? this.midcolor : null,
            maxcolor: this.maxcolor ? this.maxcolor : null, headerHeight: 15, fontcolor: 'black',
            showscale: this.showscale ? this.showscale : false,
            maxpostdepth: this.maxpostdepth ? this.maxpostdepth : 1,
        };
    }
    /**
     * @return {?}
     */
    mapTitleTextStyle() {
        return {
            color: this.mapTitleComponent.color ? this.mapTitleComponent.color : null,
            fontName: this.mapTitleComponent.fontname ? this.mapTitleComponent.fontname : null,
            bold: this.mapTitleComponent.bold ? this.mapTitleComponent.bold : null,
            italic: this.mapTitleComponent.italic ? this.mapTitleComponent.italic : null,
        };
    }
    /**
     * @param {?} e
     * @return {?}
     */
    click(e) {
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        this.mapTitleArray = this.maptleComp.toArray();
        if (this.mapTitleArray.length === 1) {
            this.mapTitleComponent = this.mapTitleArray.pop();
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.hasLoaded = false;
        this.loader.loadCharts('TreeMap').subscribe((/**
         * @param {?} value
         * @return {?}
         */
        (value) => console.log()), (/**
         * @param {?} errror
         * @return {?}
         */
        (errror) => console.error(errror)), (/**
         * @return {?}
         */
        () => {
            this.drawChart();
        }));
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onResize(event) {
        this.drawChart();
    }
}
TreeMapComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-map-treemap', template: `
    <div *ngIf="showChart" #treemapmap
         [style.width]="width"
         [style.height]="height" (window:resize)="onResize($event)"
    >
      <div *ngIf="!hasLoaded" class="lmask">
      </div>
    </div>
  `, styles: [`.lmask {
    position: absolute;
    height: 100%;
    width: 100%;
    background-color: #000;
    bottom: 0;
    left: 0;
    right: 0;
    top: 0;
    z-index: 9999;
    opacity: 0.4;
  }

  .lmask.fixed {
    position: fixed;
  }

  .lmask:before {
    content: '';
    background-color: transparent;
    border: 5px solid rgba(0, 183, 229, 0.9);
    opacity: .9;
    border-right: 5px solid transparent;
    border-left: 5px solid transparent;
    border-radius: 50px;
    box-shadow: 0 0 35px #2187e7;
    width: 50px;
    height: 50px;
    -moz-animation: spinPulse 1s infinite ease-in-out;
    -webkit-animation: spinPulse 1s infinite linear;
    margin: -25px 0 0 -25px;
    position: absolute;
    top: 50%;
    left: 50%;
  }

  .lmask:after {
    content: '';
    background-color: transparent;
    border: 5px solid rgba(0, 183, 229, 0.9);
    opacity: .9;
    border-left: 5px solid transparent;
    border-right: 5px solid transparent;
    border-radius: 50px;
    box-shadow: 0 0 15px #2187e7;
    width: 30px;
    height: 30px;
    -moz-animation: spinoffPulse 1s infinite linear;
    -webkit-animation: spinoffPulse 1s infinite linear;
    margin: -15px 0 0 -15px;
    position: absolute;
    top: 50%;
    left: 50%;
  }

  @-moz-keyframes spinPulse {
    0% {
      -moz-transform: rotate(160deg);
      opacity: 0;
      box-shadow: 0 0 1px #2187e7;
    }
    50% {
      -moz-transform: rotate(145deg);
      opacity: 1;
    }
    100% {
      -moz-transform: rotate(-320deg);
      opacity: 0;
    }
  }

  @-moz-keyframes spinoffPulse {
    0% {
      -moz-transform: rotate(0deg);
    }
    100% {
      -moz-transform: rotate(360deg);
    }
  }

  @-webkit-keyframes spinPulse {
    0% {
      -webkit-transform: rotate(160deg);
      opacity: 0;
      box-shadow: 0 0 1px #2187e7;
    }
    50% {
      -webkit-transform: rotate(145deg);
      opacity: 1;
    }
    100% {
      -webkit-transform: rotate(-320deg);
      opacity: 0;
    }
  }

  @-webkit-keyframes spinoffPulse {
    0% {
      -webkit-transform: rotate(0deg);
    }
    100% {
      -webkit-transform: rotate(360deg);
    }
  }

  `],
            },] },
];
/** @nocollapse */
TreeMapComponent.ctorParameters = () => [
    { type: MapLoaderService }
];
TreeMapComponent.propDecorators = {
    width: [{ type: Input }],
    height: [{ type: Input }],
    data: [{ type: Input, args: ['data',] }],
    mincolor: [{ type: Input, args: ['min-color',] }],
    midcolor: [{ type: Input, args: ['mid-color',] }],
    maxcolor: [{ type: Input, args: ['max-color',] }],
    showscale: [{ type: Input, args: ['show-scale',] }],
    maxpostdepth: [{ type: Input, args: ['max-post-depth',] }],
    onClick: [{ type: Output }],
    maptleComp: [{ type: ContentChildren, args: [MapTitleComponent,] }],
    treemapmap: [{ type: ViewChild, args: ['treemapmap',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const MAP_COMPONENTS = [
    MapPropertiesComponent,
    GeoChartComponent,
    TreeMapComponent,
    MapTitleComponent,
];
class AmexioMapModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: AmexioMapModule,
            providers: [CommonDataService, MapLoaderService],
        };
    }
}
AmexioMapModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    FormsModule,
                    HttpClientModule,
                    AmexioCommonModule,
                ],
                exports: MAP_COMPONENTS,
                declarations: MAP_COMPONENTS,
                providers: [CommonDataService, MapLoaderService],
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Created by pratik on 18/1/18.
 */
/*
 * Copyright 2016-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Author - Pratik Kelwalkar
 *
 */
/*
 Component Name: Amexio  Multi item carousel
 Component Selector: <amexio-media-ee-carousel>
 Component Description: Amexio Awesome Multi Item Media Carousel,
 which comes preloaded with video playing and a full blown detailing page embedded in the component itself
*/
class MultiMediaCarouselComponent {
    constructor() {
        /*
        Properties
        name : has-details
        datatype :  boolean
        version : 4.0 onwards
        default : none
        description : Provide a embedded view for more information on the media
        
        */
        this.hasDetail = true;
        /*
        Events
        name : onVideoLoad
        datatype : none
        version : none
        default : none
        description :
        */
        this.onVideoLoad = new EventEmitter();
        this.right = false;
        this.left = false;
        this.elementId = 'multi-media-ee-carousel-' + window.crypto.getRandomValues(new Uint32Array(1))[0];
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.carouselStyle == null) {
            this.carouselStyle = 'horizontal';
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes['data'] != null) {
            this.data = changes['data'].currentValue;
        }
    }
    /**
     * @return {?}
     */
    leftClick() {
        /** @type {?} */
        const ts = document.getElementById(this.elementId);
        ts.scrollLeft -= 350;
        if (ts.scrollLeft === 0) {
            document.getElementById(this.elementId + 'leftarrow').style.visibility = 'hidden';
        }
        document.getElementById(this.elementId + 'rightarrow').style.visibility = 'visible';
    }
    /**
     * @return {?}
     */
    rightClick() {
        /** @type {?} */
        const ts = document.getElementById(this.elementId);
        ts.scrollLeft += 350;
        if ((ts.scrollWidth - ts.offsetWidth - ts.scrollLeft) <= 0) {
            document.getElementById(this.elementId + 'rightarrow').style.visibility = 'hidden';
        }
        document.getElementById(this.elementId + 'leftarrow').style.visibility = 'visible';
    }
    /**
     * @return {?}
     */
    closeDetailPage() {
        this.data.forEach((/**
         * @param {?} item
         * @return {?}
         */
        (item) => {
            item.selected = null;
        }));
        this.displayDetail = false;
    }
    /**
     * @param {?} item
     * @return {?}
     */
    openDetailsSection(item) {
        this.videoUrl = item.video;
        this.currentDetailsImagePath = item.details_img;
        this.currentDetailsTitle = item.title;
        this.currentDetailsDesc = item.desc;
        this.currentContent = item.content;
        this.seasonNo = item.seasonNo;
        this.matchPercentage = item.matchPercentage;
        this.ageLimit = item.ageLimit;
        this.releaseYear = item.releaseYear;
        this.data.forEach((/**
         * @param {?} item1
         * @return {?}
         */
        (item1) => {
            item1.selected = null;
        }));
        item.selected = 'selected';
        this.displayDetail = true;
    }
    /**
     * @param {?} item
     * @return {?}
     */
    loadVideo(item) {
        this.onVideoLoad.emit(item.video);
    }
    /**
     * @param {?} video
     * @return {?}
     */
    playVideo(video) {
        this.onVideoLoad.emit(video);
    }
}
MultiMediaCarouselComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-media-ee-carousel',
                template: `
    <div class="section-header" style="z-index: 1;">{{title}}</div>
    <div class="contain row">

      <div class="left-arrow" [attr.id]="elementId+'leftarrow'" style="cursor: pointer"> <div [ngClass]="{'controls' : carouselStyle=='horizontal','controls-v' : carouselStyle=='vertical'}" (click)="leftClick();"><em class="fa fa-chevron-left fa-2x" aria-hidden="true"></em></div> </div>

      <div class="row1" [attr.id]="elementId">
        <div class="row__inner">
          <ng-container *ngIf="data">
            <div class="tile" *ngFor="let item of data;let i = index">
              <div class="tile__media" (click)="loadVideo(item)">
                <img alt="title" class="tile__img" [attr.src]="item.img" />
              </div>
              <div class="{{item.selected}}">
                <em [ngStyle]="{'visibility':item.selected ? 'visible':'hidden'}" class="fa fa-caret-down" aria-hidden="false"></em>
              </div>
              <div [ngClass]="{'tile__details' : carouselStyle=='horizontal','tile__details_v' : carouselStyle=='vertical'}">
                <div class="textonly">

                  <div class="playpanel">
                    <div style="cursor: pointer" (click)="loadVideo(item)" class="playbutton"><em class="fa fa-play" aria-hidden="true"></em></div>
                  </div>

                  <span class="carousel-title" *ngIf="item.title">{{item.title}}</span><br>
                  <span class="match">{{item.matchPercentage}} Match</span> {{item.releaseYear}} <span class="age mini">{{item.ageLimit}}</span> {{item.seasonNo}}<br>
                  <div class="subtitle">{{item.desc}}</div>

                </div>
                <div class="actionpanel"   *ngIf="item.content">
                  <div style="cursor: pointer;" (click)="openDetailsSection(item)"><em class="fa fa-chevron-down fa-2x" aria-hidden="true"></em></div>
                </div>


              </div>
            </div>
          </ng-container>
        </div>
      </div>

      <ng-container *ngIf="carouselStyle=='horizontal'">
        <div class="right-arrow" [attr.id]="elementId+'rightarrow'" style="cursor: pointer"> <div [ngClass]="{'controls' : carouselStyle=='horizontal','controls-v' : carouselStyle=='vertical'}" (click)="rightClick();"><em class="fa fa-chevron-right fa-2x" aria-hidden="true"></em></div></div>
      </ng-container>

      <ng-container *ngIf="carouselStyle=='vertical'">
        <div class="right-arrow-tall" [attr.id]="elementId+'rightarrow'" style="cursor: pointer"> <div [ngClass]="{'controls' : carouselStyle=='horizontal','controls-v' : carouselStyle=='vertical'}" (click)="rightClick();"><em class="fa fa-chevron-right fa-2x" aria-hidden="true"></em></div></div>
      </ng-container>

    </div>

    <div [attr.id]="elementId+'carousel-detail-content'" class="collapse" *ngIf="hasDetail && displayDetail">
      <amexio-ee-content [bg-image-url]="currentDetailsImagePath"
                         [title]="currentDetailsTitle" [description]="currentDetailsDesc"
                         [contents]="currentContent" [link]="videoUrl"
                         (onWatchClick)="playVideo(videoUrl)" (onCloseClick)="closeDetailPage()"
                         [rate]="rate" [watch]="true" [my-list]="true"
                         [close]="true" [season-no]="seasonNo" [release-year]="releaseYear" [age-limit]="ageLimit" [match-percentage]="matchPercentage"
      ></amexio-ee-content>
    </div>
  `,
            },] },
];
/** @nocollapse */
MultiMediaCarouselComponent.ctorParameters = () => [];
MultiMediaCarouselComponent.propDecorators = {
    data: [{ type: Input }],
    carouselStyle: [{ type: Input, args: ['carousel-type',] }],
    hasDetail: [{ type: Input, args: ['has-details',] }],
    title: [{ type: Input }],
    onVideoLoad: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Created by dattaram on 23/8/17.
 */
/*
Component Name : Amexio  Media content
Component Selector : <amexio-ee-content>
Component Description : A simple configurable star rating component with visual feedback.

*/
class ContentComponent extends LifeCycleBaseComponent {
    constructor() {
        super();
        /*
        Properties
        name : watch
        datatype :  any
        version : 4.0 onwards
        default : false
        description : Enable watch button.*/
        this.enableWatch = false;
        /*
        Properties
        name : my-list
        datatype : none
        version : 4.0 onwards
        default : false
        description : Enable MyList button.
        */
        this.enableMyList = false;
        /*
        Events
        name :  onWatchClick
        datatype :  none
        version : none
        default : none
        description : Get watch button click.
        */
        this.onWatchClick = new EventEmitter();
        /*
        Properties
        name : onAddListClick
        datatype :  none
        version : none
        default : none
        description : Get add list button click.
        
        */
        this.onAddListClick = new EventEmitter();
        /*
        Properties
        name : onLikeClick
        datatype :  none
        version : none
        default : none
        description : Get like click.
        
        */
        this.onLikeClick = new EventEmitter();
        /*
        Properties
        name : onUnlikeLikeClick
        datatype :  none
        version : none
        default : none
        description : Get unlike click.
        
        */
        this.onUnlikeLikeClick = new EventEmitter();
        /*
        Properties
        name : onCloseClick
        datatype :  any
        version :none
        default : none
        description : Get close content click.
        
        */
        this.onCloseClick = new EventEmitter();
        this.closeEnable = false;
        this.smallScreen = false;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (window.innerWidth < 768) {
            this.smallScreen = true;
            this.size = 'small';
        }
        else {
            this.smallScreen = false;
            this.size = 'default';
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.videoLink && !changes.videoLink.isFirstChange()) {
            this.videoLink = changes.videoLink.currentValue;
        }
    }
    /**
     * @return {?}
     */
    playVideo() {
        this.onWatchClick.emit(this.videoLink);
    }
    /**
     * @return {?}
     */
    addToList() {
        this.overviewData = {
            'title': this.title, 'description': this.description, 'Video Link': this.videoLink, 'rate': this.rate,
        };
        this.onAddListClick.emit(this.overviewData);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onResize(event) {
        if (event.target.innerWidth < 995) {
            this.size = 'small';
            this.smallScreen = true;
        }
        else {
            this.size = 'default';
            this.smallScreen = false;
        }
    }
    /**
     * @return {?}
     */
    getClassName() {
        if (this.smallScreen) {
            return 'button-small';
        }
        else {
            return 'button';
        }
    }
    /**
     * @return {?}
     */
    unlikeClick() {
        this.overviewData = {
            title: this.title, rate: this.rate,
        };
        this.onUnlikeLikeClick.emit(this.overviewData);
    }
    /**
     * @return {?}
     */
    likeClick() {
        this.overviewData = {
            title: this.title, rate: this.rate,
        };
        this.onLikeClick.emit(this.overviewData);
    }
    /**
     * @return {?}
     */
    closeDetailPage() {
        this.onCloseClick.emit(this.title);
    }
}
ContentComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-ee-content', template: `
    <div class="main-content {{roundedgeclass}}" [ngStyle]="{'background-image':'url('+bgImgUrl+')'}" (window:resize)="onResize($event)">
       <span *ngIf="closeEnable" class="close-button">
        <i class="fa fa-times fa-lg" (click)="closeDetailPage()" aria-hidden="true"></i>
      </span>
      <div class="content-area" >
        <span class="content-title">{{title}}</span><br>
        <span><span class="match" *ngIf="matchPercentage">{{matchPercentage}} Match</span> {{releaseYear}} <span
          class="age" *ngIf="ageLimit">{{ageLimit}}</span> {{seasonNo}}</span><br>
        <p style="word-wrap: break-word;">{{description}}<br>

        <ng-container *ngIf="contents">
              <span>
                <li *ngFor="let data of contents"><strong
                  style="color: #999;">{{data.key}}: </strong> <strong>  {{data.value}}</strong></li><br>
          </span>
        </ng-container>
        <ul class="inline-list">
          <li *ngIf="enableWatch">
            <span class="content-button" (click)="playVideo()">
            <i class="fa fa-play"></i> &nbsp;&nbsp; Play</span>
            <!-- <amexio-ee-btn [cClass]="'buttoncustom'"
            [label]="'Play'" [type]="'danger'" [icon]="'fa fa-play'"
            [tooltipMessage]="'play'" [size]="size" (onClick)="playVideo()">
            </amexio-ee-btn> -->
          </li>
          <li *ngIf="enableMyList">
            <span class="content-button" (click)="addToList()">
            <i class="fa fa-plus"></i>&nbsp;&nbsp; MY LIST</span>
            <!-- <amexio-ee-btn [cClass]="'secondarybutton'" [label]="'MY LIST'"
            [icon]="'fa fa-plus'" [type]="'secondary'" [tooltipMessage]="'My List'"
            [size]="size" (onClick)="addToList()"></amexio-ee-btn> -->
          </li>
          <li>
            <a style="color: white!important;" [ngClass]="getClassName()" (click)="likeClick()"><i class="fa fa-thumbs-o-up fa-lg"
                                                                   aria-hidden="true"></i>
            </a>
          </li>
          <li><a style="color: white!important;" [ngClass]="getClassName()" (click)="unlikeClick()"><i class="fa fa-thumbs-o-down fa-lg "
                                                                       aria-hidden="true"></i></a></li>

        </ul>
        <ng-container *ngIf="rate && max">
          <amexio-rating-input [(ngModel)]="rate"
                               [max]="max" name="rate"
                               [read-only]="isReadonly">
          </amexio-rating-input>
        </ng-container>
      </div>
    </div>`,
            },] },
];
/** @nocollapse */
ContentComponent.ctorParameters = () => [];
ContentComponent.propDecorators = {
    bgImgUrl: [{ type: Input, args: ['bg-image-url',] }],
    title: [{ type: Input }],
    description: [{ type: Input }],
    contents: [{ type: Input }],
    videoLink: [{ type: Input, args: ['link',] }],
    rate: [{ type: Input }],
    max: [{ type: Input }],
    isReadonly: [{ type: Input }],
    enableWatch: [{ type: Input, args: ['watch',] }],
    enableMyList: [{ type: Input, args: ['my-list',] }],
    ageLimit: [{ type: Input, args: ['age-limit',] }],
    releaseYear: [{ type: Input, args: ['release-year',] }],
    seasonNo: [{ type: Input, args: ['season-no',] }],
    matchPercentage: [{ type: Input, args: ['match-percentage',] }],
    closeEnable: [{ type: Input, args: ['close',] }],
    onWatchClick: [{ type: Output }],
    onAddListClick: [{ type: Output }],
    onLikeClick: [{ type: Output }],
    onUnlikeLikeClick: [{ type: Output }],
    onCloseClick: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AmexioWeekDayAvailiblityComponent extends LifeCycleBaseComponent {
    constructor() {
        super();
        this.ariadateavailable = [];
        this.noOfDaysArray = [];
        this.selectedDays = [];
        this.data1 = [];
        this.month = ['January', 'Feburary', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
        this.day = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
        this.height = 'auto';
        this.noOfDays = 7;
        this.multiSelect = false;
        this.availableSlotsBgColor = '';
        this.availableSlotsColor = '';
        this.selectedSlotColor = '';
        this.selectedSlotBgColor = '';
        this.onSingleSelect = new EventEmitter();
        this.onMultiSelect = new EventEmitter();
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set date(v) {
        if (v != null && v) {
            this.currentDate = new Date(v.getTime());
            this.initComponent();
        }
    }
    /**
     * @return {?}
     */
    get date() {
        return this.currentDate;
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set availableslots(v) {
        if (v != null && v) {
            this.datesavailable = v;
            this.initComponent();
        }
    }
    /**
     * @return {?}
     */
    get availableslots() {
        return this.datesavailable;
    }
    /**
     * @param {?} event1
     * @param {?} dayModel1
     * @param {?} time1
     * @return {?}
     */
    onTimeClick(event1, dayModel1, time1) {
        if (time1 && time1.available && this.multiSelect) {
            this.onMultiSelection(dayModel1, time1);
        }
        else if (time1 && time1.available && !this.multiSelect) {
            this.viewData.forEach((/**
             * @param {?} object
             * @return {?}
             */
            (object) => {
                object.timeslots.forEach((/**
                 * @param {?} element
                 * @return {?}
                 */
                (element) => {
                    if (element === time1) {
                        element.selected = true;
                    }
                    else {
                        element.selected = false;
                    }
                }));
            }));
            this.onSingleSelect.emit({ date: dayModel1.date, time: time1.time, timeId: time1.timeId });
        }
    }
    /**
     * @param {?} data1
     * @return {?}
     */
    onArrowDown(data1) {
        this.actualtime = '';
        /** @type {?} */
        const tempid = data1.ariaId;
        /** @type {?} */
        let slicedid = tempid.slice(6);
        slicedid++;
        /** @type {?} */
        const newid = this.randomid + '-' + slicedid;
        document.getElementById(newid).focus();
    }
    /**
     * @param {?} data1
     * @return {?}
     */
    readtime(data1) {
        /** @type {?} */
        const t = parseInt(data1.time, 10);
        /** @type {?} */
        const t1 = t % 12;
        if (t1 <= 12) {
            if (t1 === 0) {
                this.actualtime = 12 + ' ' + 'am';
            }
            else {
                this.actualtime = t1 + ' ' + 'am';
            }
        }
        else {
            this.actualtime = t1 + ' ' + 'pm';
        }
    }
    /**
     * @param {?} data1
     * @return {?}
     */
    onArrowUp(data1) {
        /** @type {?} */
        const tempid = data1.ariaId;
        /** @type {?} */
        let slicedid = tempid.slice(6);
        slicedid--;
        /** @type {?} */
        const newid = this.randomid + '-' + slicedid;
        document.getElementById(newid).focus();
    }
    /**
     * @param {?} data1
     * @return {?}
     */
    onArrowRight(data1) {
        this.onArrowDown(data1);
    }
    /**
     * @param {?} data1
     * @return {?}
     */
    onArrowLeft(data1) {
        this.onArrowUp(data1);
    }
    /**
     * @param {?} dayModel1
     * @return {?}
     */
    getFullMonthName(dayModel1) {
        /** @type {?} */
        const months = ['January', 'Febuary', 'March', 'April', 'May',
            'June', 'July', 'August', 'September', 'October', 'November', 'December'];
        /** @type {?} */
        const datemonth = dayModel1.date.getMonth();
        /** @type {?} */
        let monthString = '';
        months.forEach((/**
         * @param {?} element
         * @param {?} index
         * @return {?}
         */
        (element, index) => {
            if (datemonth === index) {
                monthString = element;
            }
        }));
        return monthString;
    }
    /**
     * @param {?} dayModel1
     * @return {?}
     */
    getFullDayName(dayModel1) {
        /** @type {?} */
        const weekdays = ['Sunday', 'Monday', 'Tuesday', 'Wednesday',
            'Thursday', 'Friday', 'Saturday'];
        /** @type {?} */
        const day = dayModel1.date.getDay();
        /** @type {?} */
        let dayname = '';
        weekdays.forEach((/**
         * @param {?} element
         * @param {?} index
         * @return {?}
         */
        (element, index) => {
            if (day === index) {
                dayname = element;
            }
        }));
        return dayname;
    }
    /**
     * @return {?}
     */
    gettime() {
    }
    /**
     * @return {?}
     */
    initComponent() {
        if (this.currentDate) {
            this.viewData = [];
            this.randomid = window.crypto.getRandomValues(new Uint32Array(1))[0];
            /** @type {?} */
            const clonedDate = new Date(this.currentDate.getTime());
            /** @type {?} */
            let startDate = clonedDate;
            /** @type {?} */
            const d1 = new DayModel(new Date(startDate.getTime()), true, this.availableslots);
            d1.setTimeSlots(this.setStyle(new TimeUtil().timeData(true)));
            d1['fulldate'] = this.getFullDayName(d1) + ' ' + d1.date.getDate() + ' ' + this.getFullMonthName(d1)
                + ' ' + d1.date.getFullYear() + ' ' + d1.date.getUTCHours();
            this.viewData.push(d1);
            this.noOfDaysArray = [];
            for (let i = 0; i < this.noOfDays; i++) {
                this.noOfDaysArray.push(i);
            }
            for (let i = 1; i < this.noOfDays; i++) {
                /** @type {?} */
                const wdate = this.createWeekDays(startDate, i);
                /** @type {?} */
                const d2 = new DayModel(new Date(wdate.getTime()), true, this.availableslots);
                d2.setTimeSlots(this.setStyle(new TimeUtil().timeData(true)));
                d2['fulldate'] = this.getFullDayName(d2) + ' ' + d2.date.getDate()
                    + ' ' + this.getFullMonthName(d2) + ' ' + d2.date.getFullYear() + ' ' + d2.date.getUTCHours();
                this.viewData.push(d2);
                startDate = wdate;
            }
            /** @type {?} */
            let inc = 0;
            this.viewData.forEach((/**
             * @param {?} element
             * @return {?}
             */
            (element) => {
                if (element.availableSlots) {
                    element.timeslots.forEach((/**
                     * @param {?} data
                     * @return {?}
                     */
                    (data) => {
                        if (data.available) {
                            data['ariaId'] = this.randomid + '-' + inc;
                            inc++;
                        }
                    }));
                }
            }));
        }
    }
    /**
     * @private
     * @param {?} date
     * @param {?} count
     * @return {?}
     */
    createWeekDays(date, count) {
        date.setHours(date.getHours() + 24);
        return date;
    }
    /**
     * @private
     * @param {?} date
     * @return {?}
     */
    getMonday(date) {
        if (date) {
            /** @type {?} */
            const day = date.getDay() || 7;
            if (day !== 1) {
                date.setHours(-24 * (day - 1));
            }
        }
        return date;
    }
    /**
     * @param {?} dayModel1
     * @param {?} time1
     * @return {?}
     */
    onMultiSelection(dayModel1, time1) {
        dayModel1.timeslots.forEach((/**
         * @param {?} obj
         * @return {?}
         */
        (obj) => {
            if (obj === time1) {
                /** @type {?} */
                const selectedAppointDate = {
                    date: dayModel1.date,
                    time: obj.time,
                    timeId: obj.timeId,
                };
                obj.selected = true;
                if (this.selectedDays.length > 0) {
                    this.selectedDays.forEach((/**
                     * @param {?} item
                     * @param {?} index
                     * @return {?}
                     */
                    (item, index) => {
                        if (item.date === selectedAppointDate.date) {
                            this.selectedDays.splice(index, 1);
                        }
                    }));
                    this.selectedDays.push(selectedAppointDate);
                }
                else {
                    this.selectedDays.push(selectedAppointDate);
                }
            }
            else {
                obj.selected = false;
            }
        }));
        this.onSingleSelect.emit({ date: dayModel1.date, time: time1.time, timeId: time1.timeId });
        this.onMultiSelect.emit(this.selectedDays);
    }
    /**
     * @return {?}
     */
    getAvailableStyle() {
        return {
            'background-color': this.availableSlotsBgColor,
            'color': this.availableSlotsColor,
        };
    }
    /**
     * @return {?}
     */
    getSelectedStyle() {
        return {
            'background-color': this.selectedSlotBgColor,
            'color': this.selectedSlotColor,
        };
    }
    /**
     * @param {?} timeModelData
     * @return {?}
     */
    setStyle(timeModelData) {
        timeModelData.forEach((/**
         * @param {?} time
         * @return {?}
         */
        (time) => {
            time.selectedStyleClass = this.getSelectedStyle();
            time.availableStyleClass = this.getAvailableStyle();
        }));
        return timeModelData;
    }
}
AmexioWeekDayAvailiblityComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-ee-appointment',
                template: `
      <div class="{{roundedgeclass}}">
      <div class="weekdaycomponent">
          <div class="datetimepicker1" style="width: 100%;">
              <ul *ngIf="viewData && (viewData.length == noOfDays)" class="weekdays" style="padding: 5px 0!important">
                  <li *ngFor="let day of noOfDaysArray" style="width: 14.28%;">
                      <label>{{viewData[day].date| date:'E'}} </label><br />
                      <label style="font-size: 10px;">{{viewData[day].date| date:'dd/MM/yy'}}</label>
                  </li>
              </ul>
              <ul *ngIf="viewData && (viewData.length == noOfDays)" class="weekdays" [style.height]="height" style="overflow: auto;padding: 5px 0!important">
                  <li *ngFor="let day of noOfDaysArray" style="width: 14.28%;">
                      <ng-container *ngIf="viewData[day] && viewData[day].timeslots &&  viewData[day].timeslots.length>0">
                          <ng-container *ngFor="let time of  viewData[day].timeslots">
                              <div (focus)="readtime(time)" id={{time.ariaId}} [tabindex]="time.available ? 0 : -1"
                                  attr.aria-label="{{viewData[day].date | date : 'EEEE, MMMM d, y'}} {{actualtime}}"
                                  *ngIf="(time.timeId >= startTime && time.timeId <= endTime)" style="padding:5px;" [ngStyle]="time.selected ? time.selectedStyleClass: (time.available ? time.availableStyleClass : '')"
                                  [ngClass]="{'availableweekday': time.available,'notavailableweekday': !time.available,'selectedDay':time.selected}"
                                  (click)="onTimeClick($event,viewData[day],time)" (keyup.arrowdown)="onArrowDown(time)"
                                  (keyup.arrowup)="onArrowUp(time)" (keyup.arrowright)="onArrowRight(time)" (keyup.arrowleft)="onArrowLeft(time)" (keyup.enter)="onTimeClick($event,viewData[day],time)">
                                  {{time.time}}
                              </div>
                          </ng-container>
                      </ng-container>
                  </li>
              </ul>
          </div>
      </div>
      </div>
    `,
            },] },
];
/** @nocollapse */
AmexioWeekDayAvailiblityComponent.ctorParameters = () => [];
AmexioWeekDayAvailiblityComponent.propDecorators = {
    height: [{ type: Input, args: ['height',] }],
    startTime: [{ type: Input, args: ['start-time',] }],
    endTime: [{ type: Input, args: ['end-time',] }],
    noOfDays: [{ type: Input, args: ['no-of-days',] }],
    multiSelect: [{ type: Input, args: ['multi-select',] }],
    availableSlotsBgColor: [{ type: Input, args: ['available-slots-bg-color',] }],
    availableSlotsColor: [{ type: Input, args: ['available-slots-color',] }],
    selectedSlotColor: [{ type: Input, args: ['selected-slot-color',] }],
    selectedSlotBgColor: [{ type: Input, args: ['selected-slot-bg-color',] }],
    date: [{ type: Input, args: ['date',] }],
    availableslots: [{ type: Input, args: ['available-slots',] }],
    onSingleSelect: [{ type: Output }],
    onMultiSelect: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Created by pratik on 18/1/18.
 */
/*
 Component Name : Amexio youtube player
 Component Selector : <amexio-ee-youtube-player>
 Component Description : A simple configurable of video player.
*/
class AmexioYoutubePlayerComponent {
    /**
     * @param {?} sanitizer
     */
    constructor(sanitizer) {
        this.sanitizer = sanitizer;
        /*
        Events
        name :onCloseVideoPlayer
        datatype : none
        version : none
        default : none
        description : it is fired on video player close event
        
        */
        this.onCloseVideoPlayer = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.height == null) {
            this.height = 450;
        }
        if (this.width == null) {
            this.width = 98;
            this.closePadding = 97;
        }
        else {
            this.closePadding = this.width - 1;
        }
        if (this.url != null) {
            this.sanitizedUrl = this.sanitizer.bypassSecurityTrustResourceUrl(this.url);
        }
    }
    /**
     * @return {?}
     */
    routeBackToApp() {
        this.onCloseVideoPlayer.emit(this.url);
    }
}
AmexioYoutubePlayerComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-ee-youtube-player', template: `
    <div>
      <span class="close-button" [ngStyle]="{'padding-left':closePadding+'%'}">
        <i class="fa fa-times fa-lg" (click)="routeBackToApp()" aria-hidden="true"></i>
      </span>
      <div class="text-center">
        <iframe [height]="height+'px'" [width]="width+'%'"
                [src]="sanitizedUrl" frameborder="0"
                allowfullscreen>
        </iframe>
      </div>
    </div>
  `,
            },] },
];
/** @nocollapse */
AmexioYoutubePlayerComponent.ctorParameters = () => [
    { type: DomSanitizer }
];
AmexioYoutubePlayerComponent.propDecorators = {
    url: [{ type: Input }],
    height: [{ type: Input }],
    width: [{ type: Input }],
    onCloseVideoPlayer: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AvailabilityComponent {
    constructor() {
        this.onClick = new EventEmitter();
        this.radioValue = '';
        this.datesArrlen = 0;
        this.sDate = new Date();
        this.eDate = new Date();
        this.dateSpanHt = 18;
        this.dateSpanWt = 46;
        this.legendObj = {};
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.generateData();
    }
    // generate data structure
    /**
     * @return {?}
     */
    generateData() {
        this.selectedIndexArr = [];
        this.completeNewArr = [];
        this.slotTimeArr = [];
        this.dateArr = [];
        this.dateArr1 = [];
        this.completeTimeArr = [];
        this.dateSpanlist = [];
        this.legendArr = [];
        this.newTimeArr = [];
        this.sDate = new Date(this.startDate);
        this.eDate = new Date(this.endDate);
        /** @type {?} */
        let i = 0;
        this.dateArr = [{ dates: [], timearr: [] }];
        this.dateArr1 = [];
        /** @type {?} */
        let d;
        if (this.sDate < this.eDate) {
            do {
                d = new Date(this.sDate.getFullYear(), this.sDate.getMonth(), this.sDate.getDate() + i);
                /** @type {?} */
                const dobj = { date: d };
                this.dateArr[0].dates.push(dobj);
                i++;
            } while (d < this.eDate);
        }
        else if (this.sDate === this.eDate) {
            d = new Date(this.sDate.getFullYear(), this.sDate.getMonth(), this.sDate.getDate() + i);
            /** @type {?} */
            const dobj = { date: d };
            this.dateArr[0].dates.push(dobj);
        }
        i = 0;
        /** @type {?} */
        const arr = [];
        this.sDate = new Date(this.startDate);
        this.eDate = new Date(this.eDate);
        if (this.sDate < this.eDate) {
            do {
                d = new Date(this.sDate.getFullYear(), this.sDate.getMonth(), this.sDate.getDate() + i);
                /** @type {?} */
                const dobj = { date: d, slots: arr };
                dobj.slots = this.setSlots(d);
                this.dateArr1.push(dobj);
                i++;
            } while (d < this.eDate);
        }
        else if (this.sDate === this.eDate) {
            /** @type {?} */
            const arry = [];
            d = new Date(this.sDate.getFullYear(), this.sDate.getMonth(), this.sDate.getDate() + i);
            /** @type {?} */
            const dobj = { date: d, slots: arry };
            dobj.slots = this.setSlots(d);
            this.dateArr1.push(dobj);
        }
        this.initializeTimeArr();
        this.generateTimeArr();
        this.datesArrlen = this.dateArr[0].dates.length;
        /** @type {?} */
        let j;
        for (j = 0; j < this.datesArrlen; j++) {
            this.dateSpanlist.push(j);
        }
        this.generateLegendArr();
        this.generateSlotTimeArr();
    }
    /**
     * @return {?}
     */
    generateSlotTimeArr() {
        /** @type {?} */
        let i = this.startTime;
        while (i <= this.endTime) {
            /** @type {?} */
            let j = 0;
            while (j <= 1) {
                /** @type {?} */
                const d = new Date();
                d.setHours(i);
                if (j === 0) {
                    d.setMinutes(0);
                }
                if (j === 1) {
                    d.setMinutes(30);
                }
                this.newTimeArr.push(d);
                j++;
            }
            i++;
        }
    }
    /**
     * @param {?} d
     * @return {?}
     */
    setSlots(d) {
        /** @type {?} */
        const slot = [];
        /** @type {?} */
        let difference = this.startTime - this.endTime;
        if (difference < 0) {
            difference = difference * (-1);
        }
        /** @type {?} */
        let i = 0;
        while (i <= difference) {
            /** @type {?} */
            let j = 0;
            for (j === 0; j <= 1; j++) {
                /** @type {?} */
                const obj = {};
                /** @type {?} */
                const date1 = new Date(d.getFullYear(), d.getMonth(), d.getDate());
                date1.setHours(this.startTime + i);
                if (j === 0) {
                    date1.setMinutes(0);
                }
                if (j === 1) {
                    date1.setMinutes(30);
                }
                obj['time'] = date1;
                obj['colorflag'] = false;
                slot.push(obj);
            }
            i++;
        }
        return this.chkLabels(d, slot);
    }
    /**
     * @param {?} d
     * @param {?} slotArray
     * @return {?}
     */
    chkLabels(d, slotArray) {
        /** @type {?} */
        let minflag = false;
        /** @type {?} */
        let maxflag = false;
        this.labelData.forEach((/**
         * @param {?} labelelement
         * @return {?}
         */
        (labelelement) => {
            if (labelelement.available) {
                labelelement.available.forEach((/**
                 * @param {?} availableElement
                 * @return {?}
                 */
                (availableElement) => {
                    if (availableElement.date) {
                        /** @type {?} */
                        let minmaxarr = [];
                        /** @type {?} */
                        const dt = new Date(availableElement.date);
                        /** @type {?} */
                        let retflagObj;
                        if (availableElement.time) {
                            retflagObj = this.availableTimeTest(availableElement, slotArray, dt, d, minmaxarr);
                            minflag = retflagObj.minFlag;
                            maxflag = retflagObj.maxFlag;
                            minmaxarr = retflagObj.minmaxArr;
                        }
                        this.setRange(minflag, maxflag, slotArray, minmaxarr, labelelement);
                    }
                }));
            }
        }));
        return slotArray;
    }
    /**
     * @param {?} minflag
     * @param {?} maxflag
     * @param {?} slotArray
     * @param {?} minmaxarr
     * @param {?} labelelement
     * @return {?}
     */
    setRange(minflag, maxflag, slotArray, minmaxarr, labelelement) {
        if (minflag && maxflag) {
            this.setColorRangeTest(slotArray, minmaxarr, labelelement);
        }
    }
    /**
     * @param {?} availableElement
     * @param {?} slotArray
     * @param {?} dt
     * @param {?} d
     * @param {?} minmaxarr
     * @return {?}
     */
    availableTimeTest(availableElement, slotArray, dt, d, minmaxarr) {
        /** @type {?} */
        let minindex = null;
        /** @type {?} */
        let maxindex = null;
        /** @type {?} */
        let minflag = false;
        /** @type {?} */
        let maxflag = false;
        availableElement.time.forEach((/**
         * @param {?} timeElement
         * @return {?}
         */
        (timeElement) => {
            minindex = null;
            maxindex = null;
            minflag = false;
            maxflag = false;
            /** @type {?} */
            const retminmaxObj = this.chkMinMaxIndexTest(slotArray, dt, d, timeElement);
            minflag = retminmaxObj.minFlag;
            maxflag = retminmaxObj.maxFlag;
            minindex = retminmaxObj.minIndex;
            maxindex = retminmaxObj.maxIndex;
            if (minflag && maxflag) {
                /** @type {?} */
                const minmaxobj = { minIndex: minindex, maxIndex: maxindex };
                minmaxarr.push(minmaxobj);
            }
        }));
        return { minFlag: minflag, maxFlag: maxflag, minmaxArr: minmaxarr };
    }
    /**
     * @param {?} slotArray
     * @param {?} minmaxarr
     * @param {?} labelelement
     * @return {?}
     */
    setColorRangeTest(slotArray, minmaxarr, labelelement) {
        slotArray.forEach((/**
         * @param {?} individualSlot
         * @param {?} slotindex
         * @return {?}
         */
        (individualSlot, slotindex) => {
            minmaxarr.forEach((/**
             * @param {?} minmaxrange
             * @return {?}
             */
            (minmaxrange) => {
                if ((slotindex >= minmaxrange.minIndex) && (slotindex <= minmaxrange.maxIndex)) {
                    if (individualSlot.label) {
                        individualSlot.label = labelelement.label;
                        individualSlot['color'] = labelelement.colorcode;
                        individualSlot.colorflag = true;
                    }
                    else {
                        individualSlot['label'] = labelelement.label;
                        individualSlot['color'] = labelelement.colorcode;
                        individualSlot.colorflag = true;
                    }
                }
            }));
        }));
    }
    /**
     * @param {?} slotArray
     * @param {?} dt
     * @param {?} d
     * @param {?} timeElement
     * @return {?}
     */
    chkMinMaxIndexTest(slotArray, dt, d, timeElement) {
        /** @type {?} */
        let minindex = null;
        /** @type {?} */
        let maxindex = null;
        /** @type {?} */
        let minflag = false;
        /** @type {?} */
        let maxflag = false;
        slotArray.forEach((/**
         * @param {?} slotElement
         * @param {?} slotIndex
         * @return {?}
         */
        (slotElement, slotIndex) => {
            if ((dt.getFullYear() === d.getFullYear()) &&
                (dt.getMonth() === d.getMonth()) && (dt.getDate() === d.getDate())) {
                /** @type {?} */
                const obj = this.getHourMinuteFormat(timeElement.starttime);
                if (((obj.hours === slotElement.time.getHours()) && (obj.minutes === slotElement.time.getMinutes()))) {
                    minindex = slotIndex;
                    minflag = true;
                }
            }
            if ((dt.getFullYear() === d.getFullYear()) && (dt.getMonth() === d.getMonth()) &&
                (dt.getDate() === d.getDate())) {
                /** @type {?} */
                const obj = this.getHourMinuteFormat(timeElement.endtime);
                if ((obj.hours === slotElement.time.getHours()) && (obj.minutes === slotElement.time.getMinutes())) {
                    maxindex = slotIndex;
                    maxflag = true;
                }
            }
        }));
        return { minFlag: minflag, maxFlag: maxflag, minIndex: minindex, maxIndex: maxindex };
    }
    /**
     * @param {?} usertime
     * @return {?}
     */
    getHourMinuteFormat(usertime) {
        /** @type {?} */
        let arr = [];
        arr = usertime.toString().split('.');
        return { hours: parseInt((arr[0]), 10), minutes: arr[1] ? (parseInt((arr[1]), 10) * 10) : 0 };
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        /** @type {?} */
        let divHt;
        /** @type {?} */
        let divWt;
        divHt = this.elementView.nativeElement.offsetHeight;
        divWt = this.elementView1.nativeElement.offsetWidth;
        this.dateSpanHt = Math.round(divHt / this.datesArrlen);
        this.dateSpanWt = Math.round((divWt) / this.newTimeArr.length);
    }
    /**
     * @return {?}
     */
    generateLegendArr() {
        this.labelData.forEach((/**
         * @param {?} element
         * @return {?}
         */
        (element) => {
            this.legendObj[element.label] = false;
        }));
        this.labelData.forEach((/**
         * @param {?} element
         * @return {?}
         */
        (element) => {
            /** @type {?} */
            const obj = { label: element.label, colorcode: element.colorcode, textcolor: element.textcolor ? element.textcolor : 'black' };
            this.legendArr.push(obj);
        }));
    }
    /**
     * @return {?}
     */
    initializeTimeArr() {
        this.completeTimeArr = ['12am', '1am', '2am', '3am', '4am', '5am', '6am', '7am', '8am',
            '9am', '10am', '11am', '12pm', '1pm', '2pm', '3pm', '4pm',
            '5pm', '6pm', '7pm', '8pm', '9pm', '10pm', '11pm',
        ];
    }
    /**
     * @return {?}
     */
    generateTimeArr() {
        /** @type {?} */
        let startindex;
        /** @type {?} */
        let endindex;
        this.completeTimeArr.forEach((/**
         * @param {?} element
         * @param {?} index
         * @return {?}
         */
        (element, index) => {
            if (element === this.startTime) {
                startindex = index;
            }
            if (element === this.endTime) {
                endindex = index;
            }
        }));
        this.setTimeArr(startindex, endindex);
    }
    /**
     * @param {?} startindex
     * @param {?} endindex
     * @return {?}
     */
    setTimeArr(startindex, endindex) {
        /** @type {?} */
        const tarr = [];
        this.completeTimeArr.forEach((/**
         * @param {?} element
         * @param {?} index
         * @return {?}
         */
        (element, index) => {
            if ((index >= startindex) && (index <= endindex)) {
                /** @type {?} */
                const tobj = { time: element };
                tarr.push(tobj);
            }
        }));
        this.dateArr[0].timearr = tarr;
    }
    /**
     * @param {?} radioData
     * @return {?}
     */
    onSelection(radioData) {
        this.styleVar = '';
        /** @type {?} */
        const obj = { label: radioData.label, colorcode: radioData.colorcode };
        this.styleVar = obj;
    }
    /**
     * @return {?}
     */
    clearColorFlag() {
        this.dateArr1.forEach((/**
         * @param {?} element
         * @return {?}
         */
        (element) => {
            if (element.slots) {
                element.slots.forEach((/**
                 * @param {?} individualSlot
                 * @return {?}
                 */
                (individualSlot) => {
                    individualSlot.colorflag = false;
                }));
            }
        }));
    }
    /**
     * @param {?} parentiterateitem
     * @param {?} parentindex
     * @param {?} childiterateitem
     * @param {?} childindex
     * @return {?}
     */
    onTimeBlockClick(parentiterateitem, parentindex, childiterateitem, childindex) {
        if (this.radioValue.length > 0) {
            if (this.dateArr1[parentindex].slots[childindex].label) {
                if (this.dateArr1[parentindex].slots[childindex].label === this.styleVar.label) {
                    //  unselect logic
                    /** @type {?} */
                    const newobj = {
                        time: this.dateArr1[parentindex].slots[childindex].time, colorflag: false,
                    };
                    this.dateArr1[parentindex].slots[childindex] = newobj;
                }
                else {
                    this.dateArr1[parentindex].slots[childindex].label = this.styleVar.label;
                    this.dateArr1[parentindex].slots[childindex].color = this.styleVar.colorcode;
                    this.dateArr1[parentindex].slots[childindex].colorflag = true;
                }
            }
            else {
                /** @type {?} */
                const newobj = this.dateArr1[parentindex].slots[childindex];
                newobj['label'] = this.styleVar.label;
                newobj['color'] = this.styleVar.colorcode;
                newobj.colorflag = true;
                this.dateArr1[parentindex].slots[childindex] = newobj;
            }
        }
        this.onClick.emit({
            time: this.dateArr1[parentindex].slots[childindex].time,
            label: this.dateArr1[parentindex].slots[childindex].label,
        });
    }
    /**
     * @return {?}
     */
    onUndoClick() {
        this.generateData();
    }
}
AvailabilityComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-availability',
                template: `
    <!-- third structure starts-->
    <div style="margin-top: 10px;">

        <amexio-row>
            <amexio-column [size]="3">
                <amexio-dropdown [place-holder]="'Select Timezone'" name="timezone" [data]="zoneData"
                    [display-field]="'timezone'" [enable-sort]="true" [sort]="'asc'">
                </amexio-dropdown>
            </amexio-column>
            <amexio-column [size]="7" style="padding-top:15px">
                <span style=" margin-left: 15px; padding: 5px 4px; "
                    [ngStyle]="{'background-color': radio.colorcode}" *ngFor="let radio of legendArr">
                    <span style="padding: 5px 3px 3px; ">

                        <input style="cursor:pointer" type="radio" [(ngModel)]="radioValue" name="{{labelData[0].label}}"
                            (change)="onSelection(radio)" value="{{radio.label}}">
                    </span>

                    <span style="font-size:medium; margin-right: 2%" [style.color]="radio.textcolor"> {{radio.label}}</span>
                </span>
            </amexio-column>
            <amexio-column [size]="2" style="padding-top:14px">
                <span style="float: right">
                    <amexio-button [label]="'Undo'" [size]="'default'" [type]="'theme-color'" (onClick)="onUndoClick()"
                        [icon]="'fa fa-undo'">
                    </amexio-button>
                </span>
            </amexio-column>
        </amexio-row>

    </div>
    <br>
    <div style="width:100%; height:100%; margin:5px; border: 1px solid  darkgrey">
        <div #datesdiv style="width: 100%; height:80%; display: -webkit-box">
            <div #datesfirstdiv style="width:15%; height:100% ; display: grid;">
                <div [style.height.px]="dateSpanHt" class="datespan1">
                    <span class="datespan2">
                    </span>
                </div>
                <div>
                    <!-- dates arr -->
                    <ul style="padding: 5px 0 !important; margin: 0; list-style: none;">
                        <li [style.height.px]="dateSpanHt" style=" padding-left:8%; text-align: left; margin-bottom: 3px; color:black;
                                                                background-color:#DCDCDC"
                            *ngFor="let item of dateArr[0].dates">
                            {{item.date | date:'EEE'}} -
                            {{item.date | date: 'd'}}/{{item.date | date: 'MM'}}/{{item.date | date: 'yy'}}

                        </li>
                    </ul>
                </div>

            </div>
            <div #datesseconddiv style="width:85%">
                <span>
                    <ul style="padding: 5px 0px 2px 0px !important; margin: 0; display:flex;
                                       list-style: none;">
                        <li [style.height.px]="dateSpanHt" [style.width.px]="dateSpanWt" style="text-align: center; display: inline-block; 
    line-height: 20px; margin-bottom: 3px;width:46px;
    background-color:#DCDCDC; 
    border-left:3px solid #F6F6F6" *ngFor="let item of newTimeArr">
                            {{item | date: 'h:mm '}}
                        </li>
                    </ul>
                </span>
                <!-- chk here -->
                <span *ngFor="let iterate of dateArr1; index as parentindex">
                    <ul style="padding: 0px 0px 0px 0px !important; margin: 0; display:flex;
                                           list-style: none;">
                        <li [style.height.px]="dateSpanHt" [style.width.px]="dateSpanWt"
                            (click)="onTimeBlockClick(iterate, parentindex, item, childindex)" style="text-align: center; 
    display: inline-block; width:46px;
    line-height: 20px; margin-bottom: 3px;
    background-color:#DCDCDC; 
    border-left:3px solid #F6F6F6"
                            [ngStyle]="{'background-color': (item.colorflag) ? item.color : '#DCDCDC', 'cursor': (radioValue.length > 0) ?'pointer':''}"
                            *ngFor="let item of iterate.slots; index as childindex">
                        </li>
                    </ul>

                </span>

            </div>
        </div>
    </div>
    <br>
    <br>
  `,
            },] },
];
/** @nocollapse */
AvailabilityComponent.ctorParameters = () => [];
AvailabilityComponent.propDecorators = {
    startDate: [{ type: Input, args: ['start-date',] }],
    endDate: [{ type: Input, args: ['end-date',] }],
    startTime: [{ type: Input, args: ['start-time',] }],
    endTime: [{ type: Input, args: ['end-time',] }],
    zoneData: [{ type: Input, args: ['time-zone-data',] }],
    labelData: [{ type: Input, args: ['label-data',] }],
    elementView: [{ type: ViewChild, args: ['datesdiv',] }],
    elementView1: [{ type: ViewChild, args: ['datesseconddiv',] }],
    elementView2: [{ type: ViewChild, args: ['datesfirstdiv',] }],
    onClick: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @type {?} */
const CALENDAR = {
    ALL_DAY_TEXT: 'all-day',
    YEAR: 'year',
    MONTH: 'month',
    WEEK: 'week',
    DAY: 'day',
    FULL: 'full',
    SHORT: 'short',
    MIN: 'min',
    DAY_NAME: {
        full: ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'],
        short: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'],
        min: ['Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa', 'Su'],
    },
    MONTH_NAME: {
        full: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October',
            'November', 'December'],
        short: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
        min: ['Ja', 'Fe', 'Ma', 'Ap', 'Ma', 'Jun', 'Jul', 'Au', 'Se', 'Oc', 'No', 'De'],
    },
    DAY_TIME_SERIES_WITH_30: [{ hr: 0, min: 0 }, { hr: 0, min: 30 }, { hr: 1, min: 0 }, { hr: 1, min: 30 },
        { hr: 2, min: 0 }, { hr: 2, min: 30 }, { hr: 3, min: 0 }, { hr: 3, min: 30 }, { hr: 4, min: 0 },
        { hr: 4, min: 30 }, { hr: 5, min: 0 }, { hr: 5, min: 30 }, { hr: 6, min: 0 }, { hr: 6, min: 30 },
        { hr: 7, min: 0 }, { hr: 7, min: 30 }, { hr: 8, min: 0 }, { hr: 8, min: 30 }, { hr: 9, min: 0 },
        { hr: 9, min: 30 }, { hr: 10, min: 0 }, { hr: 10, min: 30 }, { hr: 11, min: 0 }, { hr: 11, min: 30 },
        { hr: 12, min: 0 }, { hr: 12, min: 30 }, { hr: 13, min: 0 }, { hr: 13, min: 30 }, { hr: 14, min: 0 },
        { hr: 14, min: 30 }, { hr: 15, min: 0 }, { hr: 15, min: 30 }, { hr: 16, min: 0 }, { hr: 16, min: 30 },
        { hr: 17, min: 0 }, { hr: 17, min: 30 }, { hr: 18, min: 0 }, { hr: 18, min: 30 }, { hr: 19, min: 0 },
        { hr: 19, min: 30 }, { hr: 20, min: 0 }, { hr: 20, min: 30 }, { hr: 21, min: 0 }, { hr: 21, min: 30 },
        { hr: 22, min: 0 }, { hr: 22, min: 30 }, { hr: 23, min: 0 }, { hr: 23, min: 30 }, { hr: 24, min: 0 }],
    DAY_TIME_SERIES: [{ hr: 0, min: 0 }, { hr: 1, min: 0 }, { hr: 2, min: 0 }, { hr: 3, min: 0 },
        { hr: 4, min: 0 }, { hr: 5, min: 0 }, { hr: 6, min: 0 }, { hr: 7, min: 0 }, { hr: 8, min: 0 },
        { hr: 9, min: 0 }, { hr: 10, min: 0 }, { hr: 11, min: 0 }, { hr: 12, min: 0 }, { hr: 13, min: 0 },
        { hr: 14, min: 0 }, { hr: 15, min: 0 }, { hr: 16, min: 0 }, { hr: 17, min: 0 }, { hr: 18, min: 0 },
        { hr: 19, min: 0 }, { hr: 20, min: 0 }, { hr: 21, min: 0 }, { hr: 22, min: 0 }, { hr: 23, min: 0 },
        { hr: 24, min: 0 }],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class CalendarEventModel {
    /**
     * @param {?} isEvent
     * @param {?} details
     * @param {?} title
     * @param {?} hasTimeSlot
     * @param {?} eventDateTime
     * @param {?=} events
     */
    constructor(isEvent, details, title, hasTimeSlot, eventDateTime, events) {
        this.isEvent = isEvent;
        this.details = details;
        this.title = title;
        this.hasTimeSlot = hasTimeSlot;
        this.eventDateTime = eventDateTime;
        this.events = events;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AmexioDateUtils {
    /**
     * @param {?} d1
     * @param {?} d2
     * @return {?}
     */
    isDateEqual(d1, d2) {
        /** @type {?} */
        const date1 = new Date(d1.getTime());
        /** @type {?} */
        const date2 = new Date(d2.getTime());
        if ((date1.getTime() === date2.getTime()) ||
            ((date1.getUTCFullYear() === date2.getUTCFullYear()) && (date1.getMonth() === date2.getMonth())
                && (date1.getDate() === date2.getDate()))) {
            return true;
        }
        return false;
    }
    /**
     * @param {?} d1
     * @param {?} d2
     * @return {?}
     */
    isDateGreaterThenEqualTO(d1, d2) {
        /** @type {?} */
        const date1 = new Date(d1.getTime());
        /** @type {?} */
        const date2 = new Date(d2.getTime());
        if (date1.getTime() >= date2.getTime()) {
            return true;
        }
        return false;
    }
    /**
     * @param {?} selectedPeriod
     * @param {?} currrentDate
     * @return {?}
     */
    createDaysForMonths(selectedPeriod, currrentDate) {
        /** @type {?} */
        const calendaryData = [];
        /** @type {?} */
        const date = new Date(selectedPeriod.getFullYear(), selectedPeriod.getMonth(), 1, 0, 0, 0, 0);
        // Starting at the 1st of the month
        /** @type {?} */
        const extras = (date.getDay() + 6) % 7;
        date.setDate(date.getDate() - extras); // Skip back to the previous monday
        while (calendaryData.length < 6) {
            /** @type {?} */
            const rowDays = [];
            for (let i = 0; i < 7; i++) {
                /** @type {?} */
                const day = {
                    date: null, selected: false, isActivePeriod: null, isDisabled: false,
                    isActive: false, isEvent: false, eventDetails: null,
                };
                day['id'] = window.crypto.getRandomValues(new Uint32Array(1))[0] + '_monthid';
                day.date = new Date(date.getTime());
                day.isActivePeriod = (date.getMonth() === selectedPeriod.getMonth());
                day.isActive = this.isDateEqual(day.date, new Date());
                rowDays.push(day);
                date.setDate(date.getDate() + 1);
            }
            calendaryData.push(rowDays);
        }
        return calendaryData;
    }
    /**
     * @param {?} selectedPeriod
     * @param {?} currrentDate
     * @return {?}
     */
    createDaysForWeek(selectedPeriod, currrentDate) {
        /** @type {?} */
        const calendaryData = [];
        /** @type {?} */
        const date = this.getMonday(selectedPeriod);
        for (let i = 0; i < 7; i++) {
            /** @type {?} */
            const day = {
                date: null, selected: false, isActivePeriod: null, isDisabled: false, isActive: false, isEvent: false, eventDetails: null,
            };
            day.date = new Date(date.getTime());
            day.isActivePeriod = (date.getMonth() === selectedPeriod.getMonth());
            day.isActive = this.isDateEqual(day.date, currrentDate);
            calendaryData.push(day.date);
            date.setDate(date.getDate() + 1);
        }
        return calendaryData;
    }
    /**
     * @param {?} date
     * @return {?}
     */
    getMonday(date) {
        if (date) {
            /** @type {?} */
            const day = date.getDay() || 7;
            if (day !== 1) {
                date.setHours(-24 * (day - 1));
            }
        }
        return date;
    }
    /**
     * @param {?} date
     * @return {?}
     */
    getWeekSunday(date) {
        if (date.getDay() === 0) {
            return date;
        }
        else {
            /** @type {?} */
            const diff = date.getDate() - date.getDay() + (date.getDay() === 0 ? -6 : 1);
            /** @type {?} */
            const monday = new Date(date.setDate(diff));
            return new Date(monday.setDate(monday.getDate() - 1));
        }
    }
    /**
     * @param {?} date
     * @return {?}
     */
    getNextSunday(date) {
        /** @type {?} */
        const currentSunday = this.getWeekSunday(date);
        currentSunday.setDate(currentSunday.getDate() + 7);
        return new Date(currentSunday.getTime());
    }
    /**
     * @param {?} date
     * @return {?}
     */
    getPrevSunday(date) {
        /** @type {?} */
        const currentSunday = this.getWeekSunday(date);
        currentSunday.setDate(currentSunday.getDate() - 7);
        return new Date(currentSunday.getTime());
    }
    /**
     * @param {?} date
     * @param {?} startDate
     * @param {?} endDate
     * @return {?}
     */
    isBetween(date, startDate, endDate) {
        endDate.setSeconds(0);
        startDate.setSeconds(0);
        date.setSeconds(0);
        startDate.setMilliseconds(0);
        endDate.setMilliseconds(0);
        date.setMilliseconds(0);
        if (date.getTime() > startDate.getTime() && date.getTime() < endDate.getTime()) {
            return true;
        }
        return false;
    }
    /**
     * @param {?} longdate
     * @return {?}
     */
    getDateWithSecondsZero(longdate) {
        /** @type {?} */
        const date = new Date(longdate);
        date.setSeconds(0);
        date.setMilliseconds(0);
        return date;
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AmexioCalendarComponent {
    constructor() {
        this.displayHeaders = [];
        this.calendarMonthData = [];
        this.calendarWeekData = [];
        this.prevMonthPressed = false;
        this.nextMonthPressed = false;
        this.dayPressed = false;
        this.weekPressed = false;
        this.monthPressed = false;
        this.yearPressed = false;
        this.onCloseClick = new EventEmitter();
        this.noOfEvents = 2;
        this.onEventClicked = new EventEmitter();
        this.onMoreEventClick = new EventEmitter();
        this.currentState = CALENDAR.MONTH;
        this.headertype = CALENDAR.SHORT;
        this.currrentDate = new Date();
        this.events = [];
        this.adu = new AmexioDateUtils();
        this.weekHeaders = { title: CALENDAR.ALL_DAY_TEXT, daywiseevent: null, time: null };
    }
    /**
     * @param {?} v
     * @return {?}
     */
    set calendardate(v) {
        if (v != null) {
            try {
                this._calenadrDate = v;
                this.currrentDate = new Date(v);
            }
            catch (e) {
                this.currrentDate = new Date();
            }
        }
    }
    /**
     * @return {?}
     */
    get calendardate() {
        return this._calenadrDate;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onMoreEventClicked(event) {
        this.onMoreEventClick.emit(event);
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.initCalendar();
    }
    /**
     * @return {?}
     */
    initCalendar() {
        this.validateEventData();
        this.createData(this.currrentDate);
        this.prevbtnid = window.crypto.getRandomValues(new Uint32Array(1))[0] + '_previd';
        this.nextbtnid = window.crypto.getRandomValues(new Uint32Array(1))[0] + '_nextid';
        this.daybtnid = window.crypto.getRandomValues(new Uint32Array(1))[0] + '_dayid';
        this.weekbtnid = window.crypto.getRandomValues(new Uint32Array(1))[0] + '_weekid';
        this.monthbtnid = window.crypto.getRandomValues(new Uint32Array(1))[0] + '_monthid';
        this.yearbtnid = window.crypto.getRandomValues(new Uint32Array(1))[0] + '_yearid';
    }
    /**
     * @private
     * @return {?}
     */
    validateEventData() {
        /** @type {?} */
        const newEvents = [];
        /** @type {?} */
        let i = 1;
        this.events.forEach((/**
         * @param {?} event
         * @return {?}
         */
        (event) => {
            if ((event.start + '').indexOf('T') !== -1) {
                event.hasTimeSlot = true;
            }
            if (i > 9) {
                i = 1;
            }
            if (this.eventColorGrouping) {
                event['eventclass'] = 'calendar-active-' + i;
            }
            if (event.end) {
                /** @type {?} */
                const events1 = this.generatEventData(new Date(event.start), new Date(event.end));
                events1.forEach((/**
                 * @param {?} event1
                 * @return {?}
                 */
                (event1) => {
                    /** @type {?} */
                    const newobj = Object.assign({}, event);
                    newobj.start = event1;
                    newEvents.push(newobj);
                }));
            }
            i++;
        }));
        newEvents.forEach((/**
         * @param {?} event
         * @return {?}
         */
        (event) => {
            this.events.push(event);
        }));
    }
    /**
     * @private
     * @param {?} startDate
     * @param {?} endDate
     * @return {?}
     */
    generatEventData(startDate, endDate) {
        /** @type {?} */
        const event = [];
        /** @type {?} */
        let flag = false;
        while (startDate.getTime() <= endDate.getTime()) {
            if (flag) {
                event.push(new Date(startDate.getTime()));
            }
            flag = true;
            startDate.setDate(startDate.getDate() + 1);
        }
        return event;
    }
    /**
     * @private
     * @param {?} date
     * @return {?}
     */
    hasEvent(date) {
        /** @type {?} */
        const eventsData = [];
        /** @type {?} */
        const flag = { isEvent: false };
        if (this.events && this.events.length > 0) {
            this.events.forEach((/**
             * @param {?} event
             * @return {?}
             */
            (event) => {
                /** @type {?} */
                const eventStartDate = new Date(event.start);
                /** @type {?} */
                const isEvent = this.adu.isDateEqual(date, eventStartDate);
                if (isEvent) {
                    eventsData.push(new CalendarEventModel(isEvent, event, event.title, event.hasTimeSlot, date, null));
                    flag.isEvent = isEvent;
                }
            }));
        }
        flag['events'] = eventsData;
        return flag;
    }
    /**
     * @private
     * @param {?} selectedPeriod
     * @return {?}
     */
    createData(selectedPeriod) {
        if (this.currentState === CALENDAR.MONTH) {
            this.displayHeaders = CALENDAR.DAY_NAME[this.headertype];
            this.calendarMonthData = this.createDaysForCurrentMonths(selectedPeriod, this.currrentDate);
        }
        else if (this.currentState === CALENDAR.WEEK || this.currentState === CALENDAR.DAY) {
            /** @type {?} */
            let weekDays = [];
            if (this.currentState === CALENDAR.WEEK) {
                weekDays = this.adu.createDaysForWeek(selectedPeriod, this.currrentDate);
            }
            else {
                weekDays = [];
                weekDays.push(new Date(this.currrentDate.getTime()));
            }
            this.displayHeaders = weekDays;
            this.createDaysForCurrentWeek(selectedPeriod);
        }
        else if (this.currentState === CALENDAR.YEAR) {
            this.displayHeaders = CALENDAR.DAY_NAME[CALENDAR.SHORT];
            this.calendarMonthData = this.createYearData();
        }
    }
    /**
     * @private
     * @return {?}
     */
    createYearData() {
        /** @type {?} */
        const yearData = [];
        /** @type {?} */
        const year = this.currrentDate.getUTCFullYear();
        /** @type {?} */
        const months = CALENDAR.MONTH_NAME[CALENDAR.FULL];
        for (let i = 0; i < months.length; i++) {
            /** @type {?} */
            const monthDate = new Date(year, i, 1);
            /** @type {?} */
            const monthData1 = this.createDaysForCurrentMonths(monthDate, new Date());
            yearData.push(Object.assign({}, { month: monthDate, title: months[i], data: monthData1 }));
        }
        return yearData;
    }
    /**
     * @private
     * @param {?} selectedPeriod
     * @param {?} currrentDate
     * @return {?}
     */
    createDaysForCurrentMonths(selectedPeriod, currrentDate) {
        /** @type {?} */
        const calendarMonthData = [];
        /** @type {?} */
        const monthData = this.adu.createDaysForMonths(selectedPeriod, currrentDate);
        monthData.forEach((/**
         * @param {?} week
         * @return {?}
         */
        (week) => {
            /** @type {?} */
            const rowDays = [];
            week.forEach((/**
             * @param {?} day
             * @return {?}
             */
            (day) => {
                /** @type {?} */
                const eventDetails = this.hasEvent(day.date);
                if (eventDetails && eventDetails.isEvent) {
                    day.eventDetails = eventDetails;
                    day.isEvent = eventDetails.isEvent;
                }
                rowDays.push(day);
            }));
            calendarMonthData.push(rowDays);
        }));
        return calendarMonthData;
    }
    /**
     * @private
     * @param {?} selectedPeriod
     * @return {?}
     */
    createDaysForCurrentWeek(selectedPeriod) {
        this.calendarWeekData = [];
        /** @type {?} */
        const allday = Object.assign({}, this.weekHeaders);
        allday.daywiseevent = [];
        this.displayHeaders.forEach((/**
         * @param {?} date
         * @return {?}
         */
        (date) => {
            /** @type {?} */
            const eventDetails1 = this.hasWeekEvent(date, true);
            /** @type {?} */
            const weekobj = Object.assign({}, this.weekobject);
            weekobj.title = eventDetails1.title;
            weekobj.eventDateTime = date;
            weekobj.isEvent = eventDetails1.isEvent;
            weekobj.eventDetails = eventDetails1;
            allday.daywiseevent.push(weekobj);
        }));
        this.calendarWeekData.push(allday);
        CALENDAR.DAY_TIME_SERIES.forEach((/**
         * @param {?} time
         * @return {?}
         */
        (time) => {
            /** @type {?} */
            const dateTime = new Date();
            dateTime.setHours(time.hr, time.min);
            /** @type {?} */
            const daywiseevent = [];
            /** @type {?} */
            const timeDataDayWise = { title: time.hr + ':' + time.min, time: dateTime };
            this.displayHeaders.forEach((/**
             * @param {?} day
             * @return {?}
             */
            (day) => {
                /** @type {?} */
                const dateTime1 = new Date(day.getTime());
                dateTime1.setHours(time.hr, time.min, 0);
                /** @type {?} */
                const eventDetails1 = this.hasWeekEvent(dateTime1, false);
                /** @type {?} */
                const weekobj = {
                    title: eventDetails1.title, eventdatetime: dateTime1,
                    isEvent: eventDetails1.isEvent, eventDetails: eventDetails1,
                };
                daywiseevent.push(weekobj);
            }));
            timeDataDayWise['daywiseevent'] = daywiseevent;
            this.calendarWeekData.push(timeDataDayWise);
        }));
    }
    /**
     * @private
     * @param {?} wsd
     * @param {?} wholeday
     * @return {?}
     */
    hasWeekEvent(wsd, wholeday) {
        /** @type {?} */
        const adu = new AmexioDateUtils();
        /** @type {?} */
        const weekDateSlotStart = adu.getDateWithSecondsZero(wsd.getTime());
        /** @type {?} */
        const weekDateSlotEnd = adu.getDateWithSecondsZero(weekDateSlotStart.getTime());
        weekDateSlotEnd.setHours(weekDateSlotEnd.getHours(), 59);
        /** @type {?} */
        const weekEventObject = Object.assign({}, this.weekobject);
        if (this.events && this.events.length > 0) {
            this.events.forEach((/**
             * @param {?} event
             * @return {?}
             */
            (event) => {
                /** @type {?} */
                const eventStartDate = adu.getDateWithSecondsZero(new Date(event.start).getTime());
                /** @type {?} */
                const isEvent = this.isEventPresent(event, wholeday, eventStartDate, weekDateSlotEnd, weekDateSlotStart);
                if (event.hasTimeSlot && !wholeday && event.end && isEvent) {
                    /** @type {?} */
                    const eventEndDate = adu.getDateWithSecondsZero(new Date(event.end).getTime());
                    weekEventObject.diff = (((eventEndDate.getTime() - eventStartDate.getTime())
                        - (86400000 * Math.floor((eventEndDate - eventStartDate) / 86400000))) / 1000) / 60;
                    weekEventObject.diffwithslot = ((eventStartDate.getTime() - weekDateSlotStart.getTime()) / 1000) / 60;
                }
                if (isEvent && !weekEventObject.isEvent) {
                    weekEventObject.hasTimeSlot = event.hasTimeSlot;
                    weekEventObject.eventDateTime = eventStartDate;
                    weekEventObject.isEvent = isEvent;
                    weekEventObject.details = event;
                    weekEventObject.title = event.title;
                }
            }));
        }
        return weekEventObject;
    }
    /**
     * @private
     * @param {?} event
     * @param {?} wholeday
     * @param {?} eventStartDate
     * @param {?} weekDateSlotEnd
     * @param {?} weekDateSlotStart
     * @return {?}
     */
    isEventPresent(event, wholeday, eventStartDate, weekDateSlotEnd, weekDateSlotStart) {
        /** @type {?} */
        let isEvent = false;
        if (event.hasTimeSlot && !wholeday) {
            if (event.end) {
                isEvent = ((weekDateSlotEnd.getTime() > eventStartDate.getTime())
                    && (eventStartDate.getTime() >= weekDateSlotStart.getTime()));
            }
        }
        else if (wholeday && !event.hasTimeSlot) {
            isEvent = new AmexioDateUtils().isDateEqual(eventStartDate, weekDateSlotStart);
        }
        return isEvent;
    }
    /**
     * @private
     * @param {?} event
     * @param {?} eventDateTime
     * @param {?} isEvent
     * @param {?} diff
     * @param {?} diffwithslot
     * @return {?}
     */
    getWeekObject(event, eventDateTime, isEvent, diff, diffwithslot) {
        /** @type {?} */
        const flag = Object.assign({}, this.weekobject);
        flag.hasTimeSlot = event.hasTimeSlot;
        flag.eventDateTime = eventDateTime;
        flag.isEvent = isEvent;
        flag.details = event;
        flag.title = event.title;
        flag.diff = diff;
        flag.diffwithslot = diff;
        return flag;
    }
    /**
     * @param {?} state
     * @return {?}
     */
    setState(state) {
        this.dayPressed = false;
        this.weekPressed = false;
        this.yearPressed = false;
        this.monthPressed = false;
        if (state === 'day') {
            this.dayPressed = true;
        }
        else if (state === 'week') {
            this.weekPressed = true;
        }
        else if (state === 'month') {
            this.monthPressed = true;
        }
        else if (state === 'year') {
            this.yearPressed = true;
        }
        this.currentState = state;
        this.currrentDate = new Date();
        this.createData(this.currrentDate);
        this.currrentDate = new Date();
    }
    /**
     * @return {?}
     */
    previous() {
        this.prevMonthPressed = true;
        /** @type {?} */
        let newDate = new Date(this.currrentDate.getTime());
        if (this.currentState === CALENDAR.MONTH) {
            newDate.setMonth(newDate.getMonth() - 1);
        }
        else if (this.currentState === CALENDAR.WEEK) {
            newDate = this.adu.getPrevSunday(newDate);
        }
        else if (this.currentState === CALENDAR.DAY) {
            newDate.setDate(newDate.getDate() - 1);
        }
        else if (this.currentState === CALENDAR.YEAR) {
            newDate.setUTCFullYear(newDate.getUTCFullYear() - 1);
        }
        this.currrentDate = new Date(newDate);
        this.createData(this.currrentDate);
    }
    /**
     * @return {?}
     */
    next() {
        this.nextMonthPressed = true;
        /** @type {?} */
        let newDate = new Date(this.currrentDate.getTime());
        if (this.currentState === CALENDAR.MONTH) {
            newDate.setMonth(newDate.getMonth() + 1);
        }
        else if (this.currentState === CALENDAR.WEEK) {
            newDate = this.adu.getNextSunday(newDate);
        }
        else if (this.currentState === CALENDAR.DAY) {
            newDate.setDate(newDate.getDate() + 1);
        }
        else if (this.currentState === CALENDAR.YEAR) {
            newDate.setUTCFullYear(newDate.getUTCFullYear() + 1);
        }
        this.currrentDate = new Date(newDate);
        this.createData(this.currrentDate);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onMonthEvent(event) {
        this.onEventClicked.emit(event);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onDayTimeWiseEvent(event) {
        this.onEventClicked.emit(event);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onYearEvent(event) {
        this.navigateToDayMode(event.this.date);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onDaytimeHeaderClick(event) {
        if (this.currentState === CALENDAR.WEEK) {
            this.navigateToDayMode(event);
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onYearHeaderClicked(event) {
        this.currrentDate = new Date(event.month);
        this.currentState = CALENDAR.MONTH;
        this.createData(this.currrentDate);
    }
    /**
     * @param {?} date
     * @return {?}
     */
    navigateToDayMode(date) {
        this.currentState = CALENDAR.DAY;
        this.currrentDate = new Date(date);
        this.createData(this.currrentDate);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onMoreCloseClick(event) {
        this.onCloseClick.emit(event);
    }
}
AmexioCalendarComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-calendar',
                template: `
      <div class="calendar-header card-header">
          <div style="display: inline-flex;">
              <div *ngIf="(currentState === 'month')"> {{currrentDate | date : 'MMMM, y'}} </div>
              <div *ngIf="(currentState === 'week')"> {{displayHeaders[0] | date : 'd MMM'}} - {{displayHeaders[6] | date : 'd MMM'}} {{displayHeaders[6] | date : 'y'}}
                  </div>
              <div *ngIf="(currentState === 'day')"> {{currrentDate | date : 'd MMMM, y'}} </div>
              <div *ngIf="(currentState === 'year')"> {{currrentDate | date : 'y'}} </div>

              <div class="calendar-navigation">
                  <em id={{prevbtnid}} role="button" [attr.aria-pressed]="prevMonthPressed" (keyup.enter)="previous()" aria-label="previous month"
                      tabindex="1" style="padding-right: 20px;" class="fa fa-chevron-left" aria-hidden="true" (click)="previous()"></em>
                  <em id="{{nextbtnid}}" role="button" [attr.aria-pressed]="nextMonthPressed" (keyup.enter)="next()" aria-label="next month"
                      tabindex="1" style="padding-right: 20px;" class="fa fa-chevron-right" aria-hidden="true" (click)="next()"></em>
              </div>
          </div>
          <div>{{title}}</div>
          <div>
              <button id="{{daybtnid}}" role="button" tabindex="1" [attr.aria-pressed]="dayPressed" (keyup.enter)="setState('day')" (click)="setState('day')">Day</button>
              <button id="{{weekbtnid}}" [attr.aria-pressed]="weekPressed" role="button" aria-label="week" tabindex="1" (keyup.enter)="setState('week')"
                  (click)="setState('week')">Week</button>
              <button id="{{monthbtnid}}" [attr.aria-pressed]="monthPressed" role="button" aria-label="month" tabindex="1" (keyup.enter)="setState('month')"
                  (click)="setState('month')">Month</button>
              <button id="{{yearbtnid}}" [attr.aria-pressed]="yearPressed" role="button" aria-label="year" tabindex="1" (keyup.enter)="setState('year')"
                  (click)="setState('year')">Year</button>
          </div>
      </div>
      <amexio-calendar-month *ngIf="(currentState === 'month')" [no-of-events]="noOfEvents"  [headers]="displayHeaders" [calendar-data]="calendarMonthData"
           (onMoreEventClicked)="onMoreEventClicked($event)" (onCloseClick)="onMoreCloseClick($event)" (onEventClicked)="onMonthEvent($event)">
      </amexio-calendar-month>
      <amexio-calendar-day-timewise *ngIf="(currentState === 'week' || currentState === 'day')" [headers]="displayHeaders" [calendar-data]="calendarWeekData"
          (onHeaderClicked)="onDaytimeHeaderClick($event)" (onEventClicked)="onDayTimeWiseEvent($event)"> </amexio-calendar-day-timewise>
      <amexio-calendar-year *ngIf="(currentState === 'year')" [headers]="displayHeaders" [calendar-data]="calendarMonthData" (onLeftNavigate)="previous()"
          (onRightNavigate)="next()" (onTopNavigate)="previous()" (onBottomNavigate)="next()" (onHeaderClicked)="onYearHeaderClicked($event)"
          (onEventClicked)="onYearEvent($event)"> </amexio-calendar-year>
    `,
                styles: [`
      button,em{cursor:pointer}table{width:100%;height:100%;-webkit-box-sizing:border-box;box-sizing:border-box;table-layout:fixed;border-collapse:collapse;border-spacing:0;position:relative}.EventDetailsContent{position:absolute;z-index:1!important}.fpRightClass .amexio-floating-panel div{right:0}.leftPositionPanel{display:block;position:absolute;left:50px;right:0}.rightPositionPanel{display:block;position:absolute;left:0;right:50px}
    `],
            },] },
];
/** @nocollapse */
AmexioCalendarComponent.ctorParameters = () => [];
AmexioCalendarComponent.propDecorators = {
    headertype: [{ type: Input, args: ['header-type',] }],
    events: [{ type: Input, args: ['events',] }],
    title: [{ type: Input, args: ['title',] }],
    onCloseClick: [{ type: Output, args: ['onCloseClick',] }],
    calendardate: [{ type: Input, args: ['calendar-date',] }],
    eventColorGrouping: [{ type: Input, args: ['event-color-grouping',] }],
    noOfEvents: [{ type: Input, args: ['no-of-events',] }],
    onEventClicked: [{ type: Output, args: ['onEventClicked',] }],
    onMoreEventClick: [{ type: Output, args: ['onMoreEventClick',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AmexioCalendarDayTimeWiseComponent {
    constructor() {
        this.onEventClicked = new EventEmitter();
        this.onHeaderClicked = new EventEmitter();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.width = (this.headerRow.nativeElement.offsetWidth - 50) / 7;
        if ((this.width - 50) > 50) {
            this.width = this.width - 50;
        }
    }
    /**
     * @param {?} event1
     * @param {?} eventData
     * @return {?}
     */
    eventClicked(event1, eventData) {
        /** @type {?} */
        const eventObject = {
            event: event1,
            this: eventData.details,
        };
        this.onEventClicked.emit(eventObject);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onHeaderClick(event) {
        this.onHeaderClicked.emit(event);
    }
    /**
     * @param {?} date
     * @return {?}
     */
    fulldate(date) {
        /** @type {?} */
        const days = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
        /** @type {?} */
        const months = ['january', 'febuary', 'march', 'april', 'may', 'june', 'july', 'august',
            'september', 'october', 'november', 'december'];
        /** @type {?} */
        let ariadate = date.getDate();
        months.forEach((/**
         * @param {?} element
         * @param {?} index
         * @return {?}
         */
        (element, index) => {
            if (date.getMonth() === index) {
                ariadate = ariadate + element;
            }
        }));
        days.forEach((/**
         * @param {?} individualday
         * @param {?} index
         * @return {?}
         */
        (individualday, index) => {
            if (date.getDay() === index) {
                ariadate = ariadate + individualday;
            }
        }));
        return ariadate;
    }
}
AmexioCalendarDayTimeWiseComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-calendar-day-timewise',
                template: `
      <table aria-describedby="table" role="none">

          <thead>
              <tr>
                  <td [attr.colspan]="headers.length">
                      <table aria-describedby="table1" role="none">

                          <tr #headerRow>
                              <td class="calendar-header-items calendar-user-active-timeslot" style="width:50px;"> &nbsp;</td>
                              <td class="calendar-header-items" style="cursor: pointer;" (click)="onHeaderClick(header)" *ngFor="let header of headers">
                                  <span tabindex="1" attr.aria-label="{{header | date : 'EEEE, MMMM d, y'}}">
                                      <span>{{header | date : 'EE'}}</span>
                                      <br />
                                      <strong style="font-size:20px;">{{header | date : 'd'}}</strong>
                                  </span>
                              </td>
                          </tr>
                      </table>
                  </td>
              </tr>
          </thead>

          <tbody>
              <tr>
                  <td class="calendar-mainbox" [attr.colspan]="headers.length">
                      <div class="calendar-scroller">
                          <div style="width: 100%; position: relative;">
                              <div class="calendar-bg">
                                  <table aria-describedby="table2" role="none">
                                      <tr *ngFor="let calendarRow of calendaryData">

                                          <td class="calendar-header-items calendar-week-timeslot" style="width:50px;">
                                              <div style="min-height: 50px;" *ngIf="(calendarRow.time==null)">
                                                  {{calendarRow.title}}
                                              </div>
                                              <div class="calendar-week-timeslotseries-div" *ngIf="(calendarRow.time && calendarRow.time!=null)">
                                                  {{ calendarRow.time | date:'hh:mm a' }}
                                              </div>
                                          </td>

                                          <td style="padding-bottom: 0px;" [ngStyle]="{'padding-top': (day.isEvent && day.eventDetails && day.eventDetails.diffwithslot) ? day.eventDetails.diffwithslot+'px' : '0px'}"
                                              class="calendar-box-items" *ngFor="let day of calendarRow.daywiseevent">

                                              <div (click)="eventClicked($event,day)" [class]="'calendar-week-day-timeslot' + '  '+((day.eventDetails.details && day.eventDetails.details.eventclass) ? day.eventDetails.details.eventclass:'') "
                                                  [ngClass]="{'calendar-week-active-timeslot': day.isEvent}" [ngStyle]="{'height': (day.isEvent && day.eventDetails && day.eventDetails.diff) ? day.eventDetails.diff+'px' : null}">

                                                  <span [attr.tabindex]="(day.isEvent ? 1 : -1)" (keyup.enter)="eventClicked($event,day)" attr.aria-label="{{day.eventdatetime | date : 'EEEE, MMMM d, y'}} {{day.eventDetails.details.title}} {{day.eventDetails.details.start |  date: 'shortTime'}} to {{day.eventDetails.details.end |  date: 'shortTime'}}"
                                                      *ngIf="day.isEvent" class="calendar-user-active">
                                                      {{day.eventDetails.details.title}}
                                                      <br />
                                                      <span class="calendar-user-active-timeslot" *ngIf="(day.eventDetails.details && day.eventDetails.details.hasTimeSlot)">
                                                          {{day.eventDetails.details.start | date: "shortTime"}}
                                                          <ng-container *ngIf="(day.eventDetails.details && day.eventDetails.details.end)">
                                                              - {{day.eventDetails.details.end | date: "shortTime"}}
                                                          </ng-container>
                                                      </span>
                                                  </span>

                                              </div>
                                          </td>

                                      </tr>
                                  </table>
                              </div>
                          </div>
                      </div>
                  </td>
              </tr>
          </tbody>
      </table>
    `,
                styles: [`
      table{width:100%;height:100%;-webkit-box-sizing:border-box;box-sizing:border-box;table-layout:fixed;border-collapse:collapse;border-spacing:0;position:relative}.EventDetailsContent{position:absolute;z-index:1!important}.fpRightClass .amexio-floating-panel div{right:0}.leftPositionPanel{display:block;position:absolute;left:50px;right:0}.rightPositionPanel{display:block;position:absolute;left:0;right:50px}
    `],
            },] },
];
/** @nocollapse */
AmexioCalendarDayTimeWiseComponent.ctorParameters = () => [];
AmexioCalendarDayTimeWiseComponent.propDecorators = {
    headers: [{ type: Input, args: ['headers',] }],
    calendaryData: [{ type: Input, args: ['calendar-data',] }],
    headerRow: [{ type: ViewChild, args: ['headerRow',] }],
    onEventClicked: [{ type: Output, args: ['onEventClicked',] }],
    onHeaderClicked: [{ type: Output, args: ['onHeaderClicked',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AmexioCalendarMonthComponent {
    /**
     * @param {?} componentFactoryResolver
     * @param {?} renderer
     */
    constructor(componentFactoryResolver, renderer) {
        this.componentFactoryResolver = componentFactoryResolver;
        this.renderer = renderer;
        this.onEventClicked = new EventEmitter();
        this.onCloseClicked = new EventEmitter();
        this.onMoreEventClicked = new EventEmitter();
        this.openFloatingPanel = false;
        this.leftPositionPanel = 'leftPositionPanel';
        this.rightPositionPanel = 'rightPositionPanel';
    }
    /**
     * @param {?} data
     * @param {?} dayData
     * @return {?}
     */
    onMoreClicked(data, dayData) {
        if (this.calendaryData) {
            this.calendaryData.forEach((/**
             * @param {?} calendarRow
             * @return {?}
             */
            (calendarRow) => {
                calendarRow.forEach((/**
                 * @param {?} day
                 * @return {?}
                 */
                (day) => {
                    if (day.eventDetails) {
                        day.eventDetails.events.fpFlag = false;
                    }
                }));
            }));
        }
        dayData['fpFlag'] = true;
        this.openFloatingPanel = true;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onCloseClick(event) {
        event.data.fpFlag = false;
        this.onCloseClicked.emit(event);
    }
    /**
     * @param {?} event
     * @param {?} item
     * @param {?} runtimeDiv
     * @return {?}
     */
    onChipClick(event, item, runtimeDiv) {
        /** @type {?} */
        const emitEvent = {};
        emitEvent['event'] = event;
        emitEvent['item'] = item;
        emitEvent['this'] = this;
        emitEvent['runtimeDiv'] = runtimeDiv;
        this.xValue = event.pageX;
        this.onMoreEventClicked.emit(emitEvent);
    }
    /**
     * @param {?} amexioComponent
     * @param {?} event
     * @return {?}
     */
    addComponent(amexioComponent, event) {
        if (this.runTimeInstance) {
            this.runTimeInstance.destroy();
        }
        event.runtimeDiv.innerHTML = '';
        /** @type {?} */
        const id = event.runtimeDiv.id;
        /** @type {?} */
        const runTimeDivs = this.runtimeDiv.toArray();
        for (let i = 0; i <= runTimeDivs.length; i++) {
            if (runTimeDivs[i].element.nativeElement.id === id) {
                /** @type {?} */
                const tpCF = this.componentFactoryResolver.resolveComponentFactory(amexioComponent);
                this.runTimeInstance = runTimeDivs[i].createComponent(tpCF);
                this.nativeRuntimeDiv = runTimeDivs[i];
                this.renderer.setStyle(this.nativeRuntimeDiv.element.nativeElement.nextElementSibling, 'visibility', 'hidden');
                setTimeout((/**
                 * @return {?}
                 */
                () => {
                    if (455 > (screen.width - this.xValue)) {
                        this.calculatedWidth = (screen.width - event.event.clientX);
                        this.widthPosition = this.calculatedWidth + 'px';
                        this.heightPosition = event.event.clientX + 'px';
                        this.renderer.addClass(this.nativeRuntimeDiv.element.nativeElement.nextElementSibling, 'leftPositionPanel');
                        this.renderer.setStyle(this.nativeRuntimeDiv.element.nativeElement.nextElementSibling, 'right', this.widthPosition);
                        this.renderer.setStyle(this.nativeRuntimeDiv.element.nativeElement.nextElementSibling, 'visibility', 'visible');
                    }
                    else {
                        this.calculatedWidth = event.event.clientX - (event.event.layerX + event.event.offsetX);
                        this.widthPosition = this.calculatedWidth + 'px';
                        this.renderer.addClass(this.nativeRuntimeDiv.element.nativeElement.nextElementSibling, 'rightPositionPanel');
                        this.renderer.setStyle(this.nativeRuntimeDiv.element.nativeElement.nextElementSibling, 'left', this.widthPosition);
                        this.renderer.setStyle(this.nativeRuntimeDiv.element.nativeElement.nextElementSibling, 'visibility', 'visible');
                    }
                }), 200);
                return this.runTimeInstance;
            }
        }
    }
    /**
     * @param {?} calculatedWidth
     * @param {?} nextSiblingElement
     * @param {?} cssClass
     * @return {?}
     */
    addDynamicClass(calculatedWidth, nextSiblingElement, cssClass) {
        this.widthPosition = calculatedWidth + 'px';
        this.renderer.addClass(nextSiblingElement, cssClass);
        this.renderer.setStyle(nextSiblingElement, 'left', this.widthPosition);
        this.renderer.setStyle(this.nativeRuntimeDiv.element.nativeElement.nextElementSibling, 'visibility', 'visible');
    }
    /**
     * @param {?} amexioComponent
     * @param {?} event
     * @return {?}
     */
    addEventDetails(amexioComponent, event) {
        if (this.runTimeInstance) {
            this.runTimeInstance.destroy();
        }
        event.runtimeDiv.innerHTML = '';
        /** @type {?} */
        const id = event.runtimeDiv.id;
        /** @type {?} */
        const runTimeDivs = this.runtimeDiv1.toArray();
        for (let i = 0; i <= runTimeDivs.length; i++) {
            if (runTimeDivs[i].element.nativeElement.id === id) {
                /** @type {?} */
                const tpCF = this.componentFactoryResolver.resolveComponentFactory(amexioComponent);
                this.runTimeInstance = runTimeDivs[i].createComponent(tpCF);
                this.nativeRuntimeDiv = runTimeDivs[i];
                this.renderer.setStyle(this.nativeRuntimeDiv.element.nativeElement.nextElementSibling, 'visibility', 'hidden');
                setTimeout((/**
                 * @return {?}
                 */
                () => {
                    if (455 > (screen.width - event.event.pageX)) {
                        this.calculatedWidth = (event.event.screenX - event.event.layerX);
                        this.addDynamicClass(this.calculatedWidth, this.nativeRuntimeDiv.element.nativeElement.nextElementSibling, this.leftPositionPanel);
                    }
                    else {
                        this.calculatedWidth = (event.event.layerX + event.event.offsetX - 50);
                        this.addDynamicClass(this.calculatedWidth, this.nativeRuntimeDiv.element.nativeElement.nextElementSibling, this.rightPositionPanel);
                    }
                }), 200);
                return this.runTimeInstance;
            }
        }
    }
    /**
     * @param {?} event1
     * @param {?} eventData
     * @param {?} runTimeDiv
     * @return {?}
     */
    eventClicked(event1, eventData, runTimeDiv) {
        /** @type {?} */
        const eventObject = {};
        eventObject['event'] = event1;
        eventObject['item'] = eventData;
        eventObject['this'] = this;
        eventObject['runtimeDiv'] = runTimeDiv;
        this.onEventClicked.emit(eventObject);
    }
    /**
     * @param {?} day
     * @return {?}
     */
    nextrightday(day) {
        /** @type {?} */
        let focusrowindex;
        /** @type {?} */
        let focusinnerindex;
        this.calendaryData.forEach((/**
         * @param {?} calendarrow
         * @param {?} rowindex
         * @return {?}
         */
        (calendarrow, rowindex) => {
            calendarrow.forEach((/**
             * @param {?} calendardata
             * @param {?} innerindex
             * @return {?}
             */
            (calendardata, innerindex) => {
                if (day.id === calendardata.id) {
                    if ((calendarrow.length - 1) === innerindex) {
                        focusinnerindex = 0;
                        focusrowindex = rowindex + 1;
                    }
                    else {
                        focusinnerindex = innerindex + 1;
                        focusrowindex = rowindex;
                    }
                }
            }));
        }));
        /** @type {?} */
        const itemid = this.calendaryData[focusrowindex][focusinnerindex];
        document.getElementById(itemid['id']).focus();
    }
    /**
     * @param {?} day
     * @return {?}
     */
    nextleftday(day) {
        this.calendaryData.forEach((/**
         * @param {?} calendarrow
         * @param {?} rowindex
         * @return {?}
         */
        (calendarrow, rowindex) => {
            calendarrow.forEach((/**
             * @param {?} individualday
             * @param {?} innerindex
             * @return {?}
             */
            (individualday, innerindex) => {
                if (day.id === individualday.id) {
                    this.refactoredleftday(rowindex, innerindex, calendarrow);
                }
            }));
        }));
        /** @type {?} */
        const itemid = this.calendaryData[this.focusrindex][this.focusiindex];
        document.getElementById(itemid['id']).focus();
    }
    /**
     * @param {?} rowindex
     * @param {?} innerindex
     * @param {?} calendarrow
     * @return {?}
     */
    refactoredleftday(rowindex, innerindex, calendarrow) {
        if (rowindex === 0) {
            if (innerindex > 0) {
                this.focusrindex = rowindex;
                this.focusiindex = innerindex - 1;
            }
            else {
                this.focusrindex = rowindex;
                this.focusiindex = innerindex;
            }
        }
        else {
            if (innerindex === 0) {
                this.focusrindex = rowindex - 1;
                this.focusiindex = calendarrow.length - 1;
            }
            else {
                this.focusrindex = rowindex;
                this.focusiindex = innerindex - 1;
            }
        }
    }
    /**
     * @param {?} day
     * @return {?}
     */
    nexttopday(day) {
        /** @type {?} */
        let focusrowindex;
        /** @type {?} */
        let focusinnerindex;
        this.calendaryData.forEach((/**
         * @param {?} calrow
         * @param {?} calrowindex
         * @return {?}
         */
        (calrow, calrowindex) => {
            calrow.forEach((/**
             * @param {?} calday
             * @param {?} calinnerindex
             * @return {?}
             */
            (calday, calinnerindex) => {
                if (day.id === calday.id) {
                    if (calrowindex > 0) {
                        focusrowindex = calrowindex - 1;
                        focusinnerindex = calinnerindex;
                    }
                    else {
                        focusrowindex = calrowindex;
                        focusinnerindex = calinnerindex;
                    }
                }
            }));
        }));
        /** @type {?} */
        const itemid = this.calendaryData[focusrowindex][focusinnerindex];
        document.getElementById(itemid['id']).focus();
    }
    /**
     * @param {?} day
     * @return {?}
     */
    nextbottomday(day) {
        /** @type {?} */
        let focusrowindex;
        /** @type {?} */
        let focusinnerindex;
        this.calendaryData.forEach((/**
         * @param {?} calrow
         * @param {?} calindex
         * @return {?}
         */
        (calrow, calindex) => {
            calrow.forEach((/**
             * @param {?} calday
             * @param {?} innerindex
             * @return {?}
             */
            (calday, innerindex) => {
                if (day.id === calday.id) {
                    if ((calindex < (calrow.length - 1))) {
                        focusrowindex = calindex + 1;
                        focusinnerindex = innerindex;
                    }
                    else {
                        focusrowindex = calindex;
                        focusinnerindex = innerindex;
                    }
                }
            }));
        }));
        /** @type {?} */
        const itemid = this.calendaryData[focusrowindex][focusinnerindex];
        document.getElementById(itemid['id']).focus();
    }
    /**
     * @param {?} day
     * @return {?}
     */
    ondatefocus(day) {
        this.ariadatalabel = '';
        if (day.eventDetails && day.eventDetails !== null) {
            day.eventDetails.events.forEach((/**
             * @param {?} scheduledevent
             * @param {?} index
             * @return {?}
             */
            (scheduledevent, index) => {
                if (index === 0) {
                    this.ariadatalabel = this.receiveDateFormat(day.date);
                }
                this.ariadatalabel = this.ariadatalabel + scheduledevent.details.title +
                    ' event scheduled ' +
                    this.formatAMPM(new Date(scheduledevent.details.start)) +
                    ' to ' +
                    this.formatAMPM(new Date(scheduledevent.details.end));
            }));
        }
        else {
            this.ariadatalabel = this.receiveDateFormat(day.date) + ' no events scheduled';
        }
    }
    /**
     * @param {?} date
     * @return {?}
     */
    formatAMPM(date) {
        /** @type {?} */
        let hours = date.getHours();
        /** @type {?} */
        const minutes = date.getMinutes();
        /** @type {?} */
        let lmins;
        /** @type {?} */
        const ampm = hours >= 12 ? 'pm' : 'am';
        hours = hours % 12;
        hours = hours ? hours : 12; // the hour '0' should be '12'
        lmins = minutes < 10 ? '0' + minutes : minutes;
        return (hours + ':' + lmins + ' ' + ampm);
    }
    /**
     * @param {?} day
     * @return {?}
     */
    receiveDateFormat(day) {
        /** @type {?} */
        let datestring = '';
        datestring = (day).getDate() + this.getFullMonthName(new Date(day)) +
            this.getFullDayName(new Date(day));
        return datestring;
    }
    /**
     * @param {?} recevieddate
     * @return {?}
     */
    getFullMonthName(recevieddate) {
        /** @type {?} */
        const months = ['January', 'Febuary', 'March', 'April', 'May', 'June',
            'July', 'August', 'September', 'October', 'November', 'December'];
        /** @type {?} */
        const datemonth = recevieddate.getMonth();
        /** @type {?} */
        let monthString = '';
        months.forEach((/**
         * @param {?} element
         * @param {?} index
         * @return {?}
         */
        (element, index) => {
            if (datemonth === index) {
                monthString = element;
            }
        }));
        return monthString;
    }
    /**
     * @param {?} receiveddate
     * @return {?}
     */
    getFullDayName(receiveddate) {
        /** @type {?} */
        const weekdays = ['Sunday', 'Monday', 'Tuesday', 'Wednesday',
            'Thursday', 'Friday', 'Saturday'];
        /** @type {?} */
        const day = receiveddate.getDay();
        /** @type {?} */
        let dayname = '';
        weekdays.forEach((/**
         * @param {?} element
         * @param {?} index
         * @return {?}
         */
        (element, index) => {
            if (day === index) {
                dayname = element;
            }
        }));
        return dayname;
    }
}
AmexioCalendarMonthComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-calendar-month',
                template: `
      <table aria-describedby="table" role="none">
          <thead>
              <tr>
                  <td [attr.colspan]="headers.length">
                      <table aria-describedby="table" role="none">
                          <tr>
                              <td class="calendar-header-items" *ngFor="let header of headers">
                                  <strong>{{header}}</strong>
                              </td>
                          </tr>
                      </table>
                  </td>
              </tr>
          </thead>
          <tbody>
              <tr>
                  <td class="calendar-mainbox" [attr.colspan]="headers.length">
                      <div class="calendar-scroller">
                          <div style="width: 100%; position: relative;">
                              <div style="min-height: 150px; position: relative;" *ngFor="let calendarRow of calendaryData;index as rowIndex;">
                                  <div class="calendar-bg">
                                      <table aria-describedby="table" role="none">
                                          <tr>
                                              <!-- here down -->
                                              <td attr.aria-label="{{ariadatalabel}}" tabindex="1" (focus)="ondatefocus(day)" (keyup.arrowright)="nextrightday(day)" (keyup.arrowleft)="nextleftday(day)"
                                                  (keyup.arrowdown)="nextbottomday(day)" (keyup.arrowup)="nexttopday(day)" attr.id="{{day.id}}"
                                                  [ngClass]="{'calendar-active-box': day.isActive}" class="calendar-box-items" *ngFor="let day of calendarRow">
                                                  <span [ngClass]="{'calendar-inactive': !day.isActivePeriod}">
                                                      {{ day.date | date:'d' }}
                                                  </span>
                                              </td>
                                          </tr>
                                      </table>
                                  </div>
                                  <div class="calendar-user-content">
                                      <table aria-describedby="table" role="none">
                                          <tr>
                                              <td [ngClass]="{'calendar-user-active': (day.eventDetails && day.eventDetails.isEvent)}" *ngFor="let day of calendarRow; last as isLast">
                                                  <ng-container *ngIf="(day.eventDetails && day.eventDetails.events)">
                                                      <ul class="calendar-ul">
                                                          <div *ngFor="let dayevent of day.eventDetails.events; let i = index">
                                                              <div class="EventDetailsContent" #runtimeDiv1 id="{{day.date + i}}"></div>
                                                              <li (click)="eventClicked($event,dayevent, runtimeDiv1)">
                                                                  <ng-container *ngIf="i + 1 <= noOfEvents">
                                                                      <div style="padding:5px" class="calendar-li " [attr.class]="'calendar-li '+' '+dayevent.details.eventclass">
                                                                          <span tabindex="1" (keyup.enter)="eventClicked($event,dayevent, runtimeDiv1)" attr.aria-label="{{day.date | date : 'EEEE, MMMM d, y'}} {{dayevent.details.title}} {{dayevent.details.start |  date: 'shortTime'}} {{dayevent.details.end |  date: 'shortTime'}}"
                                                                              class="calendar-user-active" *ngIf="dayevent.isEvent">

                                                                              {{dayevent.details.title}}

                                                                              <br/>
                                                                              <span class="calendar-user-active-timeslot" *ngIf="(dayevent.details && dayevent.details.hasTimeSlot)">
                                                                                  {{dayevent.details.start | date: "shortTime"}}
                                                                                  <ng-container *ngIf="(dayevent.details && dayevent.details.end)">
                                                                                      - {{dayevent.details.end | date: "shortTime"}}
                                                                                  </ng-container>
                                                                              </span>
                                                                          </span>
                                                                      </div>
                                                                  </ng-container>

                                                              </li>
                                                              <ng-container *ngIf="i + 1 == noOfEvents && (day.eventDetails.events.length - noOfEvents != 0) ">
                                                                  <div (click)="onMoreClicked($event, day.eventDetails.events)" class="calendar-li ">
                                                                      <span tabindex="1" (keyup.enter)="eventClicked($event,dayevent, runtimeDiv)" class="calendar-user-active">
                                                                          {{day.eventDetails.events.length - noOfEvents}} More 
                                                                          <br/>
                                                                      </span>
                                                                  </div>


                                                                  <div [ngClass]="{fpClass: !isLast, fpRightClass: isLast}">
                                                                      <div class="EventDetailsContent" #runtimeDiv [attr.id]="day.date"></div>
                                                                      <div class="floatingPanelIndex">
                                                                          <amexio-floating-panel class="amexio-floating-panel" [(show-panel)]="day.eventDetails.events.fpFlag" [relative]="true" [closeable]="true"
                                                                              [width]="'200'" [title]="day.eventDetails.events[0].eventDateTime|date :'mediumDate'"
                                                                              (onClose)="onCloseClick({event: $event, data: day.eventDetails.events})">


                                                                              <amexio-layout-columns [orientation]="'horizontal'" [border]="false">
                                                                                  <amexio-layout-item [fit]="true">

                                                                                      <amexio-layout-columns [fit]="true" [border]="false" [orientation]="'vertical'" [alignment]="'start'">
                                                                                          <amexio-layout-item *ngFor="let item of day.eventDetails.events">
                                                                                              <div style="cursor:pointer" (click)="onChipClick($event,item, runtimeDiv)">
                                                                                              {{item.details.start | date: "shortTime"}} - {{item.title}}
                                                                                              </div>
                                                                                              <br>

                                                                                          </amexio-layout-item>
                                                                                      </amexio-layout-columns>
                                                                                  </amexio-layout-item>
                                                                              </amexio-layout-columns>
                                                                          </amexio-floating-panel>
                                                                      </div>
                                                                  </div>

                                                              </ng-container>

                                                          </div>

                                                      </ul>
                                                  </ng-container>
                                              </td>
                                          </tr>
                                      </table>
                                  </div>
                              </div>
                          </div>
                      </div>
                  </td>
              </tr>
          </tbody>
      </table>
    `,
                styles: [`
      table{width:100%;height:100%;-webkit-box-sizing:border-box;box-sizing:border-box;table-layout:fixed;border-collapse:collapse;border-spacing:0;position:relative}.EventDetailsContent{position:absolute;z-index:1!important}.fpRightClass .amexio-floating-panel div{right:0}.leftPositionPanel{display:block;position:absolute;left:50px;right:0}.rightPositionPanel{display:block;position:absolute;left:0;right:50px}
    `],
            },] },
];
/** @nocollapse */
AmexioCalendarMonthComponent.ctorParameters = () => [
    { type: ComponentFactoryResolver },
    { type: Renderer2 }
];
AmexioCalendarMonthComponent.propDecorators = {
    headers: [{ type: Input, args: ['headers',] }],
    calendaryData: [{ type: Input, args: ['calendar-data',] }],
    calendarRow: [{ type: Input, args: ['calendar-row',] }],
    noOfEvents: [{ type: Input, args: ['no-of-events',] }],
    onEventClicked: [{ type: Output, args: ['onEventClicked',] }],
    onCloseClicked: [{ type: Output, args: ['onCloseClick',] }],
    onMoreEventClicked: [{ type: Output, args: ['onMoreEventClicked',] }],
    runtimeDiv: [{ type: ViewChildren, args: ['runtimeDiv', { read: ViewContainerRef },] }],
    runtimeDiv1: [{ type: ViewChildren, args: ['runtimeDiv1', { read: ViewContainerRef },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AmexioCalendarYearComponent {
    constructor() {
        this.isextremeright = false;
        this.isextremeleft = false;
        this.onEventClicked = new EventEmitter();
        this.onHeaderClicked = new EventEmitter();
        this.onleftnavigate = new EventEmitter();
        this.onrightnavigate = new EventEmitter();
        this.ontopnavigate = new EventEmitter();
        this.onbottomnavigate = new EventEmitter();
        this.isdaypressed = false;
    }
    /**
     * @param {?} event1
     * @param {?} eventData
     * @return {?}
     */
    eventClicked(event1, eventData) {
        this.isdaypressed = true;
        /** @type {?} */
        const eventObject = {
            event: event1,
            this: eventData,
        };
        this.onEventClicked.emit(eventObject);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    monthClicked(event) {
        this.onHeaderClicked.emit(event);
    }
    /**
     * @param {?} day
     * @return {?}
     */
    navigateright(day) {
        this.calendaryData.forEach((/**
         * @param {?} calendarrow
         * @param {?} rowindex
         * @return {?}
         */
        (calendarrow, rowindex) => {
            calendarrow.data.forEach((/**
             * @param {?} calendardata
             * @param {?} innerindex
             * @return {?}
             */
            (calendardata, innerindex) => {
                calendardata.forEach((/**
                 * @param {?} calelement
                 * @param {?} calindex
                 * @return {?}
                 */
                (calelement, calindex) => {
                    if (day.id === calelement.id) {
                        this.refactorednavigateright(calindex, calendardata, innerindex, calendarrow, rowindex);
                    }
                }));
            }));
        }));
        if (!this.isextremeright) {
            /** @type {?} */
            const itemid = this.calendaryData[this.rightfocusrowindex].data[this.rightfocusinnerindex][this.rightfocuscalindex];
            document.getElementById(itemid['id']).focus();
        }
    }
    /**
     * @param {?} calindex
     * @param {?} calendardata
     * @param {?} innerindex
     * @param {?} calendarrow
     * @param {?} rowindex
     * @return {?}
     */
    refactorednavigateright(calindex, calendardata, innerindex, calendarrow, rowindex) {
        if (calindex === (calendardata.length - 1) &&
            innerindex === (calendarrow.data.length - 1) &&
            rowindex === (this.calendaryData.length - 1)) {
            this.onrightnavigate.emit();
            this.isextremeright = true;
            this.setExtremeFocus();
        }
        else if (calindex === (calendardata.length - 1)) {
            // chk condn for last row
            if ((calendarrow.data.length - 1) === innerindex) {
                this.rightfocusrowindex = rowindex + 1; // by inc:-> next month
                this.rightfocusinnerindex = 0; // by inc:-> next row in same month
                this.rightfocuscalindex = 0; // by inc:-> next day
            }
            else {
                this.rightfocusrowindex = rowindex; // by inc:-> next month
                this.rightfocusinnerindex = innerindex + 1; // by inc:-> next row in same month
                this.rightfocuscalindex = 0; // by inc:-> next day
            }
        }
        else {
            this.rightfocusrowindex = rowindex; // by inc:-> next month
            this.rightfocusinnerindex = innerindex; // by inc:-> next row in same month
            this.rightfocuscalindex = calindex + 1; // by inc:-> next day
        }
    }
    /**
     * @param {?} day
     * @return {?}
     */
    navigateleft(day) {
        this.calendaryData.forEach((/**
         * @param {?} calendarrow
         * @param {?} rowindex
         * @return {?}
         */
        (calendarrow, rowindex) => {
            calendarrow.data.forEach((/**
             * @param {?} calendardata
             * @param {?} innerindex
             * @return {?}
             */
            (calendardata, innerindex) => {
                calendardata.forEach((/**
                 * @param {?} calelement
                 * @param {?} calindex
                 * @return {?}
                 */
                (calelement, calindex) => {
                    if (day.id === calelement.id) {
                        this.refactoredleftnavigate(rowindex, innerindex, calindex, calendarrow, calendardata);
                    }
                }));
            }));
        }));
        if (!this.isextremeleft) {
            /** @type {?} */
            const itemid = this.calendaryData[this.leftfocusrowindex].data[this.leftfocusinnerindex][this.leftfocuscalindex];
            document.getElementById(itemid['id']).focus();
        }
    }
    /**
     * @param {?} rowindex
     * @param {?} innerindex
     * @param {?} calindex
     * @param {?} calendarrow
     * @param {?} calendardata
     * @return {?}
     */
    refactoredleftnavigate(rowindex, innerindex, calindex, calendarrow, calendardata) {
        if (rowindex === 0 && innerindex === 0 && calindex === 0) {
            this.onleftnavigate.emit();
            this.isextremeleft = true;
            this.setExtremeFocus();
        }
        else if (calindex === 0) {
            // chk for first row
            if (innerindex === 0) {
                this.leftfocusrowindex = rowindex - 1;
                this.leftfocusinnerindex = calendarrow.data.length - 1; // row change
                this.leftfocuscalindex = calendardata.length - 1; // last ele of month
            }
            else {
                this.leftfocusrowindex = rowindex;
                this.leftfocusinnerindex = innerindex - 1;
                this.leftfocuscalindex = calendardata.length - 1;
            }
        }
        else {
            this.leftfocusrowindex = rowindex;
            this.leftfocusinnerindex = innerindex;
            this.leftfocuscalindex = calindex - 1;
        }
    }
    /**
     * @param {?} day
     * @return {?}
     */
    navigatedown(day) {
        /** @type {?} */
        let focusrowindex;
        /** @type {?} */
        let focusinnerindex;
        /** @type {?} */
        let focuscalindex;
        /** @type {?} */
        let isextremedown = false;
        this.calendaryData.forEach((/**
         * @param {?} calendarrow
         * @param {?} rowindex
         * @return {?}
         */
        (calendarrow, rowindex) => {
            calendarrow.data.forEach((/**
             * @param {?} calendardata
             * @param {?} innerindex
             * @return {?}
             */
            (calendardata, innerindex) => {
                calendardata.forEach((/**
                 * @param {?} calelement
                 * @param {?} calindex
                 * @return {?}
                 */
                (calelement, calindex) => {
                    if (day.id === calelement.id) {
                        if (rowindex === (this.calendaryData.length - 1) &&
                            innerindex === (calendarrow.data.length - 1)) {
                            this.onbottomnavigate.emit();
                            isextremedown = true;
                            this.setExtremeFocus();
                        }
                        else if (innerindex === (calendarrow.data.length - 1)) {
                            focusrowindex = rowindex + 1;
                            focusinnerindex = 0;
                            focuscalindex = 0;
                        }
                        else {
                            focusrowindex = rowindex;
                            focusinnerindex = innerindex + 1;
                            focuscalindex = calindex;
                        }
                    }
                }));
            }));
        }));
        if (!isextremedown) {
            /** @type {?} */
            const itemid = this.calendaryData[focusrowindex].data[focusinnerindex][focuscalindex];
            document.getElementById(itemid['id']).focus();
        }
    }
    /**
     * @param {?} day
     * @return {?}
     */
    navigateup(day) {
        /** @type {?} */
        let focusrowindex;
        /** @type {?} */
        let focusinnerindex;
        /** @type {?} */
        let focuscalindex;
        /** @type {?} */
        let isextremetop = false;
        this.calendaryData.forEach((/**
         * @param {?} calendarrow
         * @param {?} rowindex
         * @return {?}
         */
        (calendarrow, rowindex) => {
            calendarrow.data.forEach((/**
             * @param {?} calendardata
             * @param {?} innerindex
             * @return {?}
             */
            (calendardata, innerindex) => {
                calendardata.forEach((/**
                 * @param {?} calelement
                 * @param {?} calindex
                 * @return {?}
                 */
                (calelement, calindex) => {
                    if (day.id === calelement.id) {
                        if (rowindex === 0 && innerindex === 0) {
                            this.ontopnavigate.emit();
                            isextremetop = true;
                            this.setExtremeFocus();
                        }
                        else if (innerindex === 0) {
                            focusrowindex = rowindex - 1;
                            focusinnerindex = calendarrow.data.length - 1;
                            focuscalindex = calendardata.length - 1;
                        }
                        else {
                            focusrowindex = rowindex;
                            focusinnerindex = innerindex - 1;
                            focuscalindex = calindex;
                        }
                    }
                }));
            }));
        }));
        if (!isextremetop) {
            /** @type {?} */
            const itemid = this.calendaryData[focusrowindex].data[focusinnerindex][focuscalindex];
            document.getElementById(itemid['id']).focus();
        }
    }
    /**
     * @return {?}
     */
    setExtremeFocus() {
        setTimeout((/**
         * @return {?}
         */
        () => {
            /** @type {?} */
            let itemid;
            this.calendaryData.forEach((/**
             * @param {?} calendarrow
             * @param {?} rowindex
             * @return {?}
             */
            (calendarrow, rowindex) => {
                calendarrow.data.forEach((/**
                 * @param {?} calendardata
                 * @param {?} innerindex
                 * @return {?}
                 */
                (calendardata, innerindex) => {
                    calendardata.forEach((/**
                     * @param {?} calelement
                     * @param {?} calindex
                     * @return {?}
                     */
                    (calelement, calindex) => {
                        if (rowindex === 0 && innerindex === 0 && calindex === 0) {
                            itemid = this.calendaryData[0].data[0][0];
                            document.getElementById(itemid['id']).focus();
                        }
                    }));
                }));
            }));
        }), 0);
    }
}
AmexioCalendarYearComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-calendar-year',
                template: `
      <div class="calendar-year">
          <div class="calendar-year-box" *ngFor="let month of calendaryData">
              <div class="calendar-year-month">
                  <div style="cursor: pointer;" (click)="monthClicked(month)">
                      <strong>{{month.title}}</strong>
                  </div>
                  <table aria-describedby="table1" role="none">
                      <thead>
                          <tr>
                              <td *ngFor="let header of headers" style="text-align: center;">
                                  {{header}}
                              </td>
                          </tr>
                      </thead>
                      <tbody>
                          <tr *ngFor="let week of month.data" class="calendar-week-timeslot">
                              <td class="focuscls" attr.id="{{day.id}}" tabindex="1" role="button" [attr.aria-pressed]="isdaypressed" (keyup.arrowright)="navigateright(day)"
                                  (keyup.arrowleft)="navigateleft(day)" (keyup.arrowdown)="navigatedown(day)" (keyup.arrowup)="navigateup(day)"
                                  attr.aria-label="{{day.date | date : 'EEEE, MMMM d, y'}} " [ngClass]="{'calendar-inactive': (!day.isActivePeriod),                                         
                                              'calendar-year-month-hasevent': (day.isActivePeriod && day.isEvent)}" (click)="eventClicked($event, day)"
                                  (keyup.enter)="eventClicked($event, day)" *ngFor="let day of week" style="text-align: center;">
                                  <div  [ngClass]="{'calendar-active-box calendar-year-month-today': (day.isActivePeriod && day.isActive)}" style="height:30px; width: 30px;"
                                      style="text-align: center; cursor: pointer;">
                                      {{day.date | date :'dd'}}
                                  </div>
                              </td>
                          </tr>
                          <tr></tr>
                      </tbody>
                  </table>
              </div>

          </div>
      </div>
    `,
                styles: [`
      table{width:100%;height:100%;-webkit-box-sizing:border-box;box-sizing:border-box;table-layout:fixed;border-collapse:collapse;border-spacing:0;position:relative}.EventDetailsContent{position:absolute;z-index:1!important}.fpRightClass .amexio-floating-panel div{right:0}.leftPositionPanel{display:block;position:absolute;left:50px;right:0}.rightPositionPanel{display:block;position:absolute;left:0;right:50px}
    `],
            },] },
];
/** @nocollapse */
AmexioCalendarYearComponent.ctorParameters = () => [];
AmexioCalendarYearComponent.propDecorators = {
    headers: [{ type: Input, args: ['headers',] }],
    calendaryData: [{ type: Input, args: ['calendar-data',] }],
    onEventClicked: [{ type: Output, args: ['onEventClicked',] }],
    onHeaderClicked: [{ type: Output, args: ['onHeaderClicked',] }],
    onleftnavigate: [{ type: Output, args: ['onLeftNavigate',] }],
    onrightnavigate: [{ type: Output, args: ['onRightNavigate',] }],
    ontopnavigate: [{ type: Output, args: ['onTopNavigate',] }],
    onbottomnavigate: [{ type: Output, args: ['onBottomNavigate',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class StepWizardItemComponent {
    /**
     * @param {?} formBuilder
     * @param {?} iconService
     */
    constructor(formBuilder, iconService) {
        this.formBuilder = formBuilder;
        this.iconService = iconService;
        this.active = false;
        this.footerAlign = 'space-between';
        this.onNextStep = new EventEmitter();
        this.onPreviousStep = new EventEmitter();
        this.index = 0;
        this.showPreviousButton = true;
        this.showNextButton = true;
        this.nextLabel = 'Next';
        this.previousIcon = 'fa fa-chevron-left';
        this.nextIcon = 'fa fa-chevron-right';
        if (this.iconService.iconToUse !== 'fa') {
            this.previousIcon = 'keyboard_arrow_left';
            this.nextIcon = 'keyboard_arrow_right';
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onPreviousClick(event) {
        this.onPreviousStep.emit({ title: this.title,
            index: this.index, data: this.form.value, emitData: { currentdata: this.form.value, event } });
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onNextClick(event) {
        this.onNextStep.emit({ title: this.title, index: this.index, data: this.form.value, emitData: { currentdata: this.form.value, event } });
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.registerFormComponent();
        this.validateForm();
    }
    /**
     * @return {?}
     */
    ngAfterContentChecked() {
        this.validateForm();
    }
    /**
     * @return {?}
     */
    validateForm() {
        if (this.form && this.form.status === 'INVALID') {
            this.isNextButtonDisable = true;
        }
        else {
            this.isNextButtonDisable = false;
        }
    }
    /**
     * @return {?}
     */
    registerFormComponent() {
        /** @type {?} */
        const ngContentModels = this.models.toArray();
        /** @type {?} */
        const innerModelArray = [];
        ngContentModels.forEach((/**
         * @param {?} model
         * @return {?}
         */
        (model) => {
            if (!this.isFieldPresentInParentAndChildBoth(innerModelArray, model.name)) {
                if (!model.name || model.name === null) {
                    model.name = model.valueAccessor['name'];
                }
                this.form.control.registerControl(model.name, model.control);
            }
        }));
    }
    /**
     * @param {?} innerModelArray
     * @param {?} name
     * @return {?}
     */
    isFieldPresentInParentAndChildBoth(innerModelArray, name) {
        /** @type {?} */
        let isPresent = false;
        innerModelArray.forEach((/**
         * @param {?} innerModel
         * @return {?}
         */
        (innerModel) => {
            if (name === innerModel.name) {
                isPresent = true;
            }
        }));
        return isPresent;
    }
}
StepWizardItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-step-wizard-item',
                template: `
   <form [ngStyle]="{'display':active ? 'block':'none'}" class="form-container form-group">
       <div class="form-body formbody" tabindex="1">
           <ng-content></ng-content>
       </div>
       <footer #formFooter class="form-footer" [ngStyle]="{'justify-content': footerAlign}">
           <amexio-button *ngIf="showPreviousButton" [icon]="previousIcon" [label]="'Previous'" [type]="'theme-color'"
               [tooltip]="'Previous'" (onClick)="onPreviousClick($event)">
           </amexio-button>
           <span *ngIf="!showPreviousButton"></span>
           <amexio-button *ngIf="showNextButton" [disabled]="isNextButtonDisable" [icon]="nextIcon" [label]="nextLabel"
               [form-bind]="'validateForm'" [type]="'theme-color'" [tooltip]="'Next'" (onClick)="onNextClick($event)">
           </amexio-button>
       </footer>
   </form>
 `,
            },] },
];
/** @nocollapse */
StepWizardItemComponent.ctorParameters = () => [
    { type: FormBuilder },
    { type: IconLoaderService }
];
StepWizardItemComponent.propDecorators = {
    title: [{ type: Input, args: ['title',] }],
    icon: [{ type: Input, args: ['icon',] }],
    active: [{ type: Input, args: ['active',] }],
    footerAlign: [{ type: Input, args: ['footer-align',] }],
    onNextStep: [{ type: Output }],
    onPreviousStep: [{ type: Output }],
    form: [{ type: ViewChild, args: [NgForm,] }],
    models: [{ type: ContentChildren, args: [NgModel, { descendants: true },] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class StepWizardComponent {
    /**
     * @param {?} matchMediaService
     */
    constructor(matchMediaService) {
        this.matchMediaService = matchMediaService;
        this.showStepNumber = true;
        this.footerAlign = 'space-between';
        this.finalStage = new EventEmitter();
        this.onNextStepClick = new EventEmitter();
        this.onPreviousStepClick = new EventEmitter();
        this.data = {};
        this.isPhone = false;
        if (this.matchMediaService.IsTablet() || this.matchMediaService.IsPhone()) {
            this.isPhone = true;
        }
    }
    /**
     * @return {?}
     */
    ngAfterContentInit() {
        /** @type {?} */
        const time = new Date().getTime();
        this.stepItemList = this.stepItemQueryList.toArray();
        if (this.stepItemList && this.stepItemList.length > 0) {
            this.stepItemList[0].active = true;
        }
        this.stepItemList.forEach((/**
         * @param {?} node
         * @param {?} index
         * @return {?}
         */
        (node, index) => {
            try {
                this.stepItemList[index].index = time + index;
                node.onNextStep.subscribe((/**
                 * @param {?} eventdata
                 * @return {?}
                 */
                (eventdata) => this.onNextStep(eventdata)));
                node.onPreviousStep.subscribe((/**
                 * @param {?} eventdata
                 * @return {?}
                 */
                (eventdata) => this.onPreviousStep(eventdata)));
                this.stepItemList[index].footerAlign = this.footerAlign;
            }
            catch (Error) {
            }
        }));
        this.stepItemList[0].showPreviousButton = false;
        this.stepItemList[0].activeClass = 'active';
        this.stepItemList[this.stepItemList.length - 1].nextLabel = 'Done';
        this.stepItemList[this.stepItemList.length - 1].nextIcon = '';
        this.title = this.stepItemList[0].title;
    }
    // ON NEXT STEP CLICK
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    onNextStep(event) {
        /** @type {?} */
        let activeIndex = 0;
        /** @type {?} */
        const updatedTitle = event.title.replace(/\s/g, '').toLowerCase();
        this.data[updatedTitle] = event.data;
        this.stepItemList.forEach((/**
         * @param {?} stepItem
         * @param {?} index
         * @return {?}
         */
        (stepItem, index) => {
            if (stepItem.index === event.index) {
                activeIndex = index + 1;
                if (this.stepItemList[activeIndex]) {
                    this.stepItemList[activeIndex].activeClass = 'active';
                    this.stepItemList[activeIndex].active = true;
                    this.title = this.stepItemList[activeIndex].title;
                }
            }
        }));
        if (activeIndex !== this.stepItemList.length) {
            if (event && event.emitData && event.emitData.currentdata) {
                this.onNextStepClick.emit({ title: event.title,
                    currentdata: event.emitData.currentdata,
                    data: this.data, event: event.emitData.event });
            }
        }
        this.stepItemList.forEach((/**
         * @param {?} stepItem
         * @param {?} index
         * @return {?}
         */
        (stepItem, index) => {
            /** @type {?} */
            const ind = index + 1;
            if (ind <= activeIndex) {
                this.stepItemList[ind - 1].activeClass = 'completed';
                this.stepItemList[ind - 1].active = false;
            }
            if (activeIndex === this.stepItemList.length) {
                this.stepItemList[activeIndex - 1].active = true;
            }
        }));
        if (activeIndex === this.stepItemList.length) {
            this.finalStage.emit(this.data);
        }
    }
    // ON PREVIOUS STEP CLICK
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    onPreviousStep(event) {
        if (event && event.emitData && event.emitData.currentdata) {
            // tslint:disable-next-line:max-line-length
            this.onPreviousStepClick.emit({ title: event.title, currentdata: event.emitData.currentdata, data: this.data, event: event.emitData.event });
        }
        /** @type {?} */
        let activeIndex = 0;
        this.stepItemList.forEach((/**
         * @param {?} stepItem
         * @param {?} index
         * @return {?}
         */
        (stepItem, index) => {
            if (stepItem.index === event.index) {
                activeIndex = index;
            }
        }));
        this.stepItemList.forEach((/**
         * @param {?} stepItem
         * @param {?} index
         * @return {?}
         */
        (stepItem, index) => {
            if (activeIndex === index) {
                this.stepItemList[index - 1].activeClass = 'active';
                this.stepItemList[index - 1].active = true;
                this.title = this.stepItemList[index - 1].title;
            }
            else if (activeIndex > index) {
                this.stepItemList[index + 1].activeClass = '';
                this.stepItemList[index].activeClass = 'completed';
                this.stepItemList[index + 1].active = false;
            }
        }));
        this.stepItemList[0].showPreviousButton = false;
    }
}
StepWizardComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-step-wizard',
                template: `
    <amexio-card-ce>
        <amexio-header-ce [background]="headerBackground">
            {{title}}
        </amexio-header-ce>
        <ul class="step-wizard step-wizard-horizontal">
            <li [attr.tabindex]="(item.activeClass === 'active') ? 1: -1" *ngFor="let item of stepItemList; let i = index"
                [ngClass]="item.activeClass">
                <a>
                    <span class="circle ">
                        <ng-container *ngIf="item.icon ">
                            <amexio-image [icon-class]="item.icon "></amexio-image>
                        </ng-container>
                        <ng-container *ngIf="!item.icon && showStepNumber ">{{i+1}}</ng-container>
                    </span>
                    <ng-container *ngIf="item.title ">
                        <ng-container *ngIf="item.icon && showStepNumber ">
                            {{i+1}}
                        </ng-container>
                        <ng-container *ngIf="!isPhone">
                            <span class="stepTitleColor">
                                    {{item.title}}
                            </span>
                        </ng-container>

                    </ng-container>
                </a>
            </li>
        </ul>
        <amexio-body-ce>
            <ng-content select="amexio-step-wizard-item">
            </ng-content>
        </amexio-body-ce>
    </amexio-card-ce>
  `,
            },] },
];
/** @nocollapse */
StepWizardComponent.ctorParameters = () => [
    { type: DeviceQueryService }
];
StepWizardComponent.propDecorators = {
    showStepNumber: [{ type: Input, args: ['show-step-number',] }],
    headerBackground: [{ type: Input, args: ['header-background',] }],
    footerAlign: [{ type: Input, args: ['footer-align',] }],
    finalStage: [{ type: Output }],
    onNextStepClick: [{ type: Output }],
    onPreviousStepClick: [{ type: Output }],
    stepItemQueryList: [{ type: ContentChildren, args: [StepWizardItemComponent,] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AmexioThemeSwitcherService {
    /**
     * @param {?} _http
     */
    constructor(_http) {
        this._http = _http;
        // themeData: Observable<any>;
        this.themeData = new BehaviorSubject(null);
    }
    /**
     * @param {?} url
     * @return {?}
     */
    loadThemes(url) {
        return this._http.get(url);
    }
    /**
     * @param {?} theme
     * @return {?}
     */
    switchTheme(theme) {
        /** @type {?} */
        let response;
        this._http.get('https://api.amexio.org/api/mda/' + theme.themeJSONFile).subscribe((/**
         * @param {?} data
         * @return {?}
         */
        (data) => {
            response = data;
        }), (/**
         * @param {?} error
         * @return {?}
         */
        (error) => {
        }), (/**
         * @return {?}
         */
        () => {
            this.themeData.next(response);
            /** @type {?} */
            const themeColor = response.themeColor;
            /** @type {?} */
            const appColor = response.appColor;
            /** @type {?} */
            const compColor = response.compColor;
            themeColor.forEach((/**
             * @param {?} style
             * @return {?}
             */
            (style) => {
                /** @type {?} */
                const value = style.value.replace(';', '');
                document.documentElement.style.setProperty(style.key, value);
            }));
            appColor.forEach((/**
             * @param {?} style
             * @return {?}
             */
            (style) => {
                /** @type {?} */
                const value = style.value.replace(';', '');
                document.documentElement.style.setProperty(style.key, value);
            }));
            compColor.forEach((/**
             * @param {?} style
             * @return {?}
             */
            (style) => {
                document.documentElement.style.setProperty(style.key, style.value);
            }));
        }));
    }
}
AmexioThemeSwitcherService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
AmexioThemeSwitcherService.ctorParameters = () => [
    { type: HttpClient }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AmexioThemeSwitcherComponent {
    /**
     * @param {?} service
     */
    constructor(service) {
        this.service = service;
        this.testmode = true;
        this.isMDA = true;
        this.colsize = 3;
        this.relative = false;
        this.buttonType = 'floatingbutton';
        this.horizontalPosition = 'right';
        this.verticalPosition = 'bottom';
        this.onclose = new EventEmitter();
        this.onThemeClick = new EventEmitter();
        this.respo = [];
        this.isFloatingButton = false;
        this.isSimpleButton = false;
        this.positionMapData = [];
        this.positionMapData['hpos-right'] = { position: 'right', value: '10px' };
        this.positionMapData['hpos-left'] = { position: 'left', value: '10px' };
        this.positionMapData['vpos-bottom'] = { position: 'bottom', value: '25px' };
        this.positionMapData['vpos-top'] = { position: 'top', value: '55px' };
        this.closeable = true;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.buttonType === 'floatingbutton') {
            this.isFloatingButton = true;
        }
        else if (this.buttonType === 'button') {
            this.isSimpleButton = true;
        }
        if (this.relative && !this.closeable) {
            this.show = true;
        }
        this.loadMDAThemes();
        this.service.themeData.subscribe((/**
         * @param {?} theme
         * @return {?}
         */
        (theme) => {
            if (theme != null) {
                this.onThemeClick.emit(theme);
            }
        }));
    }
    /**
     * @return {?}
     */
    loadMDAThemes() {
        if (this.isMDA) {
            /** @type {?} */
            let responseData;
            this.service.loadThemes('assets/amexiomdathemes/json/amexio-mda.json')
                .subscribe((/**
             * @param {?} data
             * @return {?}
             */
            (data) => {
                responseData = data;
            }), (/**
             * @param {?} error
             * @return {?}
             */
            (error) => {
            }), (/**
             * @return {?}
             */
            () => {
                this.data = responseData;
            }));
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes['show']) {
            this.show = changes.show.currentValue;
        }
    }
    /**
     * @param {?} theme
     * @return {?}
     */
    themeChange(theme) {
        this.service.switchTheme(theme);
    }
    /**
     * @param {?} value
     * @return {?}
     */
    onChange(value) {
        this.isMoreDetails = value;
    }
    /**
     * @return {?}
     */
    togglePanel() {
        this.show = !this.show;
        this.onclose.emit(this);
    }
    /**
     * @return {?}
     */
    themeStyle() {
        /** @type {?} */
        const windowWidth = window.innerWidth;
        /** @type {?} */
        const perBlockWidth = ((windowWidth / 100) * 35) / 3;
        /** @type {?} */
        const style1 = {};
        /** @type {?} */
        const style = this.getPostion(style1);
        style['display'] = 'block';
        if (this.closeable === true) {
            style['z-index'] = '600';
        }
        else {
            style['z-index'] = '0';
        }
        if (this.colsize <= 3) {
            style['min-width'] = '250px';
        }
        else {
            style['min-width'] = '200px';
        }
        if (!this.relative) {
            /** @type {?} */
            const hpos = this.positionMapData['hpos-' + this.horizontalPosition];
            /** @type {?} */
            const vpos = this.positionMapData['vpos-' + this.verticalPosition];
            if (hpos) {
                style[hpos.position] = hpos.value;
            }
            if (vpos) {
                style[vpos.position] = vpos.value;
            }
        }
        else {
            style['margin-top'] = '10px';
        }
        if (this.closeable) {
            style['width'] = (perBlockWidth * this.colsize) + 'px';
        }
        else {
            style['width'] = '100%';
        }
        return style;
    }
    /**
     * @param {?} style
     * @return {?}
     */
    getPostion(style) {
        if (!this.closeable) {
            style['position'] = 'relative';
        }
        else if (this.closeable && this.relative) {
            style['position'] = 'absolute';
            style['right'] = '0';
        }
        else {
            style['position'] = 'fixed';
        }
        return style;
    }
}
AmexioThemeSwitcherComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-theme-switcher',
                template: `
      <ng-container *ngIf="isFloatingButton">
          <amexio-floating-button *ngIf="!relative" style="position: fixed; right: 10px; bottom: 25px;" (onClick)="togglePanel()" [relative]="true"
              [icon]="'fa fa-ellipsis-v'" [type]="'red'">
          </amexio-floating-button>
      </ng-container>
      <div style="display: block; position: relative; width: 100%;">
          <ng-container *ngIf="isSimpleButton">
              <amexio-button *ngIf="closeable" [label]="'Theme Selector'" [type]="'theme-color'" [tooltip]="'Theme Selector'" (onClick)="togglePanel()">
              </amexio-button>
          </ng-container>


          <amexio-card-ce *ngIf="show" [ngStyle]="themeStyle()">
              <amexio-header-ce [align]="'space-between'" [border-bottom]="true">
                  <div style="width:100%;">
                      <div class="flex-inline flex-spacebetween">
                          <amexio-label [word-wrap]="false" style="width:90%" [size]="'medium-bold'">
                              Material Design Themes
                          </amexio-label>

                          <amexio-image *ngIf="closeable" style="display: block; cursor: pointer;" [icon-class]="'fa fa-times ng-star-inserted'" (onClick)="togglePanel()">
                          </amexio-image>

                      </div>
                      <br />
                      <div style="display: inline-flex;">
                          <amexio-label [size]="'small'">
                              More Details: &nbsp;
                          </amexio-label>
                          <amexio-toggle (onChange)="onChange($event)" [size]="'small'" [type]="1" shape="square">
                          </amexio-toggle>
                      </div>
                  </div>
              </amexio-header-ce>
              <amexio-body-ce style="overflow: auto;display: block;" [ngStyle]="{'height': (closeable)?'400px' : '100%'}">
                  <div class="flex-row">
                      <ng-container *ngFor="let row of data">
                          <div [class]="'flex-col'" [class]="'flex-col-'+(12/colsize)" *ngFor="let col of row">
                              <div class="card-container" style="margin: 5px;">
                                  <header class="card-header flex-inline flex-spacebetween" style="padding: 10px;" [ngStyle]="{'background-color':col.navBarBGColor, 'color':col.navBarFontColor}">
                                      <label role="text" style="width:90%;outline: none; cursor: text; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;"
                                          class="label-content medium-bold">
                                          {{col.themeName}}
                                      </label>
                                      <span *ngIf="testmode" style="cursor: pointer;" (click)="themeChange(col)">
                                          <em class="fa fa-check"></em>
                                      </span>
                                  </header>
                                  <div *ngIf="isMoreDetails" class="card-body cardbody">
                                      <img [attr.alt]="col.themeName" alt="" [attr.src]="'assets/amexiomdathemes/images/'+col.themeImageFile"
                                          class="img-fluid" />
                                      <br />
                                      <label role="text" style="outline: none; cursor: text;" class="label-content small-bold">
                                          Version: {{col.version}}
                                      </label>
                                      <br />
                                      <label *ngIf="col.algorithmName" role="text" style="outline: none; cursor: text;" class="label-content small-bold">
                                          Algorithm: {{col.algorithmName}}
                                          <br />
                                      </label>

                                      <label *ngIf="col.releaseDate" role="text" style="outline: none; cursor: text;" class="label-content small-bold">
                                          Release: {{col.releaseDate}}
                                      </label>

                                  </div>
                                  <footer class="card-footer flex-center" [ngStyle]="{ 'height': (closeable) ? '25px':'unset'}">
                                      <div *ngFor="let color of col.themes" class="themecolorpalette" [ngStyle]="{'background-color': color,'height': (!closeable) ? '50px':'unset','margin': (!closeable) ? ' 0px 5px':'0px 2px'}">
                                      </div>
                                  </footer>
                              </div>
                          </div>
                      </ng-container>
                  </div>
              </amexio-body-ce>
          </amexio-card-ce>
      </div>
    `,
            },] },
];
/** @nocollapse */
AmexioThemeSwitcherComponent.ctorParameters = () => [
    { type: AmexioThemeSwitcherService }
];
AmexioThemeSwitcherComponent.propDecorators = {
    data: [{ type: Input, args: ['data',] }],
    isMoreDetails: [{ type: Input, args: ['more-details',] }],
    testmode: [{ type: Input, args: ['test-mode',] }],
    isMDA: [{ type: Input, args: ['mda',] }],
    colsize: [{ type: Input, args: ['col-size',] }],
    relative: [{ type: Input, args: ['relative',] }],
    buttonType: [{ type: Input, args: ['button-type',] }],
    horizontalPosition: [{ type: Input, args: ['horizontal-position',] }],
    verticalPosition: [{ type: Input, args: ['vertical-position',] }],
    onclose: [{ type: Output, args: ['onClose',] }],
    show: [{ type: Input, args: ['show',] }],
    closeable: [{ type: Input, args: ['closeable',] }],
    onThemeClick: [{ type: Output, args: ['onThemeClick',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class TreeTabComponent {
    constructor() {
        this.nodeClick = new EventEmitter();
        this.onLoad = new EventEmitter();
        this.width = '200px';
        this.emitData = {};
    }
    /**
     * @return {?}
     */
    ngOnInit() {
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        setTimeout((/**
         * @return {?}
         */
        () => {
            this.onLoad.emit(this.tab);
        }), 500);
    }
    /**
     * @param {?} event
     * @return {?}
     */
    addtab(event) {
        this.emitData['data'] = event;
        this.emitData['tabData'] = this.tab;
        this.nodeClick.emit(this.emitData);
    }
}
TreeTabComponent.decorators = [
    { type: Component, args: [{
                selector: 'amexio-tree-tab',
                template: `

          <amexio-side-nav class="sideNavBorder" [data]="data" [data-reader]="dataReader" [width]="width" [position]="'relative'"
              (nodeClick)='addtab($event)'>
          </amexio-side-nav>
                         <amexio-tab-view class="amexio-tab-view" style="padding-left:10px" #tab [closable]="false" [tab-position]="'top'" [header-align]="'left'">
                      </amexio-tab-view>   
    `,
                styles: [`
      :host{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row}.amexio-tab-view{padding-left:10px;display:block;width:100%;overflow:hidden}
    `],
            },] },
];
/** @nocollapse */
TreeTabComponent.ctorParameters = () => [];
TreeTabComponent.propDecorators = {
    data: [{ type: Input, args: ['data',] }],
    dataReader: [{ type: Input, args: ['data-reader',] }],
    tab: [{ type: ViewChild, args: ['tab',] }],
    nodeClick: [{ type: Output, args: ['nodeClick',] }],
    onLoad: [{ type: Output, args: ['onLoad',] }],
    width: [{ type: Input, args: ['width',] }],
    httpUrl: [{ type: Input, args: ['http-url',] }],
    httpMethod: [{ type: Input, args: ['http-method',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Created by pratik on 27/11/17.
 */
/** @type {?} */
const ENTERPRISE_COMPONENTS = [
    MultiMediaCarouselComponent,
    ContentComponent,
    AmexioYoutubePlayerComponent,
    AmexioWeekDayAvailiblityComponent,
    AmexioCalendarComponent,
    AmexioCalendarDayTimeWiseComponent,
    AmexioCalendarMonthComponent,
    AmexioCalendarYearComponent,
    AmexioThemeSwitcherComponent,
    StepWizardComponent,
    StepWizardItemComponent,
    TreeTabComponent,
    AvailabilityComponent,
];
class AmexioEnterpriseModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: AmexioEnterpriseModule,
            providers: [CommonDataService, DeviceQueryService, AmexioThemeSwitcherService],
        };
    }
}
AmexioEnterpriseModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    FormsModule,
                    AmexioFormsModule,
                    AmexioPaneModule,
                    AmexioMediaModule,
                    AmexioCreativeModule,
                    AmexioCommonModule,
                    HttpClientModule,
                    AmexioNavModule,
                    AmexioLayoutModule,
                ],
                exports: ENTERPRISE_COMPONENTS,
                declarations: ENTERPRISE_COMPONENTS,
                providers: [CommonDataService, DeviceQueryService, AmexioThemeSwitcherService],
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Generated bundle index. Do not edit.
 */

export { AmexioWidgetModule, CommonDataService, DeviceQueryService, IconLoaderService, AmexioCreditCardModel, GridConfig, GridConstants, GoogleMapOverlays, AvailableSlotsModel, DayModel, TimeModel, TimeUtil, PropertyGridModel, RoutedirDirective, RouterService, AmexioFormsModule, LoadRecaptchaService, COMPONENT_CLASS_MAP, AmexioButtonComponent, AmexioButtonGroupComponent, ScriptLoadService, AmexioNavModule, AmexioSideNavComponent, SideNavNodeComponent, AmexioNavBarComponent, KEY_CODE_notify, AmexioNotificationComponent, AmexioTaskbarItemComponent, AmexioTaskbarComponent, AmexioLayoutModule, AmexioAccordionHeaderComponent, AmexioAccordionTabComponent, AmexioAccordionComponent, AccordionService, AmexioBorderLayoutItemComponent, AmexioBorderLayoutComponent, AmexioBoxComponent, AmexioCardComponent, AmexioColumnComponent, AmexioGridComponent, AmexioGridItemComponent, AmexioRowComponent, AmexioGridLayoutService, AmexioDataModule, GoogleMapScriptService, AmexioListBoxComponent, AmexioTreeViewComponent, AmexioPaginatorComponent, TreeDataTableComponent, AmexioGoogleMapComponent, AmexioDashBoardModule, DashboardLoaderService, DashBoardTitleComponent, DataPointCenterComponent, DataPointsComponent, DataPointEastComponent, DataPointNorthComponent, DataPointSouthComponent, DataPointWestComponent, GaugeChartComponent, AmexioChartsModule, AreaChartComponent, BarChartComponent, BubbleChartComponent, CandlestickChartComponent, CandlestickWaterfallChartComponent, ChartAreaComponent, ChartLegendComponent, ChartTitleComponent, ColumnChartComponent, ComboChartComponent, DonutChartComponent, GanttChartComponent, HistogramChartComponent, HorizontalAxisComponent, LineChartComponent, PieChartComponent, ScatterChartComponent, TimeLineChartComponent, VerticalAxisComponent, ChartLoaderService, AmexioMapModule, MapPropertiesComponent, GeoChartComponent, TreeMapComponent, MapTitleComponent, MapLoaderService, AmexioPaneModule, AmexioFooterComponent, AmexioBodyComponent, AmexioCarouselComponent, AmexioTemplateDirective, AmexioTemplateWrapperDirective, AmexiodialoguePaneComponent, AmexioFieldSetComponent, AmexioFormActionComponent, AmexioFormBodyComponent, AmexioFormComponent, AmexioFormHeaderComponent, AmexioHeaderComponent, AmexioPanelHeaderComponent, StackableItemComponent, StackablePanelComponent, AmexioStepsComponent, StepBlockComponent, AmexioRightVerticalTabComponent, AmexioTabActionComponent, TOP_COMPONENT_CLASS_MAP, BOTTOM_COMPONENT_CLASS_MAP, AmexioTabComponent, AmexioTabPillComponent, AmexioVerticalTabComponent, AmexiotimelineComponent, AmexiotimelineeventComponent, AmexioWindowPaneComponent, AmexioWindowHeaderComponent, MinimizeWindowComponent, OverlayContainerComponent, AmexioFormGroupDirective, AmexioEnterpriseModule, MultiMediaCarouselComponent, ContentComponent, AmexioYoutubePlayerComponent, AmexioWeekDayAvailiblityComponent, AmexioCalendarComponent, AmexioCalendarDayTimeWiseComponent, AmexioCalendarMonthComponent, AmexioCalendarYearComponent, AmexioThemeSwitcherService, AmexioThemeSwitcherComponent, AvailabilityComponent, AmexioMediaModule, AmexioVideoPlayerComponent, DisplayFieldService, AmexioRuntimeModule as ɵew, AmexioRuntimeComponent as ɵex, AmexioCommonModule as ɵc, AmexioContextMenuComponent as ɵb, AmexioBaseContextMenuModule as ɵa, BaseInput as ɵu, BaseInputEventComponent as ɵm, BaseFormValidator as ɵbd, CommonIconComponent as ɵg, DisplayFieldComponent as ɵd, DropDownListComponent as ɵe, EventBaseComponent as ɵr, AmexioInputHelperComponent as ɵv, LifeCycleBaseComponent as ɵi, ListBaseComponent as ɵt, ListBaseDatepickerComponent as ɵbm, ValueAccessorBaseComponent as ɵn, AmexioCreativeModule as ɵdy, AmexioCardCEComponent as ɵeb, AmexioCarouselCEComponent as ɵeu, ColorPaletteComponent as ɵeo, ColorPickerComponent as ɵen, ColorsliderComponent as ɵep, AmexioCardCEActionComponent as ɵdz, AmexioCardCEBodyComponent as ɵea, AmexioCardCEHeaderComponent as ɵec, AmexioFormCEComponent as ɵee, AmexioFormActionCEComponent as ɵed, AmexioHomePageCenterPanelComponent as ɵef, AmexioHomePageComponent as ɵej, AmexioHomePageEastPanelComponent as ɵeg, AmexioHomePageNorthPanelComponent as ɵeh, AmexioHomePageWestPanelComponent as ɵei, AmexioMenuCEComponent as ɵev, AmexioProgressCEComponent as ɵel, ViewportBackgroundComponent as ɵes, ViewportContentBodyComponent as ɵet, ViewportContentComponent as ɵer, ViewportComponent as ɵeq, AmexioWindowCEComponent as ɵek, CeMinimizeWindowComponent as ɵem, AmexioGridColumnComponent as ɵdn, AmexioDatagridComponent as ɵdl, DataGridFilterComponent as ɵdm, AmexioDataGridHeaderComponent as ɵdo, AmexioItemSelectorComponent as ɵdw, AmexioProgressMultiBarComponent as ɵdr, AmexioProgressBarComponent as ɵds, PropertyGridComponent as ɵdp, SpeechBubbleComponent as ɵdq, AmexioFilterTreeComponent as ɵdv, HorizontalTreeViewNodeComponent as ɵdt, HorizontalTreeViewComponent as ɵdu, AmexioVirtualScrollerComponent as ɵdx, ColorPaletteDirective as ɵh, DynamicTextDirective as ɵfa, AmexioFullScreenDirective as ɵez, AmexioInputPatternDirective as ɵco, RoundEdgesDirective as ɵey, StepWizardComponent as ɵfb, StepWizardItemComponent as ɵfc, TreeTabComponent as ɵfd, AmexioSearchAdvanceComponent as ɵbx, SearchboxtoolComponent as ɵbw, AmexioBadgeComponent as ɵcj, AmexioButtonDropdownComponent as ɵbc, AmexioButtonDropDownItemComponent as ɵbe, AmexioSpiltButtonDropdownComponent as ɵbf, CheckboxComponent as ɵbh, AmexioCheckBoxGroupComponent as ɵbg, AmexioCheckBoxComponent as ɵo, AmexioChipComponent as ɵcb, AmexioChipsComponent as ɵcc, AmexioCreditcardComponent as ɵca, DarkmodeComponent as ɵck, AmexioDateTimePickerComponent as ɵbl, AmexioDialpadComponent as ɵcp, AmexioDropDownMenuComponent as ɵbs, AmexioDropDownitemsComponent as ɵbr, AmexioDropDownComponent as ɵq, AmexioEmailInputComponent as ɵw, AmexioFileUploadComponent as ɵbn, AmexioFloatingButtonComponent as ɵbp, AmexioFloatingGroupButtonComponent as ɵbq, AmexioFormValidator as ɵp, GeolocComponent as ɵcn, AmexioLabelComponent as ɵbo, AmexioMultipleDatePickerComponent as ɵcm, AmexioMultiRangePickerComponent as ɵcq, AmexioNumberInputComponent as ɵx, AmexioPasswordComponent as ɵy, AmexioRadioGroupComponent as ɵcv, AmexioRangeSliderComponent as ɵcl, AmexioRatingComponent as ɵbb, RecaptchaComponent as ɵby, AmexioSliderComponent as ɵbi, DomHandler as ɵbj, FacebookAuthComponent as ɵch, GithubAuthComponent as ɵcd, GoogleAuthComponent as ɵcf, LinkedInAuthComponent as ɵcg, SocialBaseComponent as ɵce, AmexioSocialComponent as ɵci, AmexioSpinnerComponent as ɵbz, AmexioTagsInputComponent as ɵbk, AmexioTextAreaComponent as ɵz, AmexioTextInputComponent as ɵl, AmexioToggleComponent as ɵba, ToolbarComponent as ɵbt, ToolBarActionComponent as ɵbv, ToolbaroneComponent as ɵbu, AmexioTypeAheadComponent as ɵs, AmexioLayoutComponent as ɵj, AmexioLayoutItemComponent as ɵk, AmexioImageComponent as ɵcr, AmexioBreadcrumbComponent as ɵdj, DockbarComponent as ɵdg, DockedBarToolComponent as ɵdh, AmexioMenuBarComponent as ɵdi, AmexioBannerComponent as ɵdb, AmexioNavActionComponent as ɵdc, AmexioNavDesktopMenuComponent as ɵde, AmexioNavItemComponent as ɵcz, AmexioNavMenuComponent as ɵda, AmexioNavMobileMenuComponent as ɵdf, AmexioNavTextFieldComponent as ɵdd, AmexioSideNavInnerNodeComponent as ɵdk, AmexioFloatingPanelComponent as ɵct, AmexioPanelComponent as ɵcw, PanelItemComponent as ɵcx, SlidingPanelComponent as ɵcy, BaseTabComponent as ɵcu, MinimizeService as ɵcs, FilterPipe as ɵf };
